<!DOCTYPE html>
<html lang="zh-cmn-Hans" class="han-init">
<head>
  <meta charset="utf-8">
  
  <title>理解TCP（五）：可靠性交付的实现 | BlueSun</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="tcp," />
  

  <meta name="description" content="更好阅读体验：《理解 TCP 和 UDP》— By Gitbook    

TCP 是一种提供可靠性交付的协议。也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。但是在网络中相连两端之间的介质，是复杂的，并不确保数据的可靠性交付，那么 TCP 是怎么样解决问题的？这就需要了解 TCP 的几种技术：    

滑动窗口    
超时重传    
流量控制    
拥塞">
<meta property="og:type" content="article">
<meta property="og:title" content="理解TCP（五）：可靠性交付的实现">
<meta property="og:url" content="http://huang-jerryc.com/2017/03/02/understand-tcp-5/index.html">
<meta property="og:site_name" content="BlueSun">
<meta property="og:description" content="更好阅读体验：《理解 TCP 和 UDP》— By Gitbook    

TCP 是一种提供可靠性交付的协议。也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。但是在网络中相连两端之间的介质，是复杂的，并不确保数据的可靠性交付，那么 TCP 是怎么样解决问题的？这就需要了解 TCP 的几种技术：    

滑动窗口    
超时重传    
流量控制    
拥塞">
<meta property="og:image" content="http://om6ayrafu.bkt.clouddn.com/post/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png">
<meta property="og:image" content="http://om6ayrafu.bkt.clouddn.com/post/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png">
<meta property="og:image" content="http://om6ayrafu.bkt.clouddn.com/post/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png">
<meta property="og:image" content="http://om6ayrafu.bkt.clouddn.com/post/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png">
<meta property="og:image" content="http://om6ayrafu.bkt.clouddn.com/post/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png">
<meta property="og:updated_time" content="2018-05-01T16:16:02.086Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="理解TCP（五）：可靠性交付的实现">
<meta name="twitter:description" content="更好阅读体验：《理解 TCP 和 UDP》— By Gitbook    

TCP 是一种提供可靠性交付的协议。也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。但是在网络中相连两端之间的介质，是复杂的，并不确保数据的可靠性交付，那么 TCP 是怎么样解决问题的？这就需要了解 TCP 的几种技术：    

滑动窗口    
超时重传    
流量控制    
拥塞">
<meta name="twitter:image" content="http://om6ayrafu.bkt.clouddn.com/post/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png">

  

  
    <link rel="icon" href="/images/favicon.ico">
  

  <link rel="stylesheet" href="/css/styles.css">

  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83430919-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?b65b3ffc3fd0d14c968e1036793e631b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <link rel="stylesheet" media="all" href="//cdnjs.cloudflare.com/ajax/libs/Han/3.2.7/han.min.css">

</head>

<body>
  <div class="post-header CENTER">
   
  <div class="toolbox">
    <div class="toolbox-entry">盒子</div>
    <ul class="list-toolbox">
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/archives/">博客</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/category/">分类</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/tag/">标签</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/link/">友链</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/about/">关于</a>
          </li>
        
      
        
          <li class="item-toolbox">
            <a class="CIRCLE" href="/atom.xml">RSS</a>
          </li>
        
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#超时重传"><span class="toc-text">超时重传</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重传时机"><span class="toc-text">重传时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重传算法"><span class="toc-text">重传算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#先认识两个概念"><span class="toc-text">先认识两个概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RTO-Retransmission-Time-Out-重传超时时间"><span class="toc-text">RTO ( Retransmission Time-Out ) 重传超时时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RTT-Round-Trip-Time-连接往返时间"><span class="toc-text">RTT ( Round Trip Time ) 连接往返时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jacobson-Karels-算法"><span class="toc-text">Jacobson / Karels 算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#拥塞控制"><span class="toc-text">拥塞控制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#滑动窗口-Sliding-Window"><span class="toc-text">滑动窗口 Sliding Window</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#发送窗口"><span class="toc-text">发送窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接收窗口"><span class="toc-text">接收窗口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
  </div>


<div class="content-post CENTER">
   <article id="post-understand-tcp-5" class="article article-type-post" itemscope itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">理解TCP（五）：可靠性交付的实现</h1>

    <div class="article-meta">
      <span>2017-03-02</span>

      <span> | </span>

      <span class="article-author">JerryC</span>

      <span> | </span>

      
  <span class="article-category">
    <a class="article-category-link" href="/categories/搬砖码农/">搬砖码农</a>
  </span>


    </div>
  </header>

  <div class="article-content">
    
      <blockquote>
<p>更好阅读体验：<a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/" target="_blank" rel="external">《理解 TCP 和 UDP》— By Gitbook</a>    </p>
</blockquote>
<p>TCP 是一种提供可靠性交付的协议。<br>也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。<br>但是在网络中相连两端之间的介质，是复杂的，并不确保数据的可靠性交付，那么 TCP 是怎么样解决问题的？<br>这就需要了解 TCP 的几种技术：    </p>
<ol>
<li>滑动窗口    </li>
<li>超时重传    </li>
<li>流量控制    </li>
<li>拥塞控制    </li>
</ol>
<p>下面来分别讲一下这几种技术的实现原理。    </p>
<h1 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h1><h2 id="重传时机"><a href="#重传时机" class="headerlink" title="重传时机"></a>重传时机</h2><p>TCP 报文段在传输的过程中，下面的情况都是有可能发生的：</p>
<ol>
<li>数据包中途丢失；</li>
<li>数据包顺利到达，但对方发送的 ACK 报文中途丢失；</li>
<li>数据包顺利到达，但对方异常未响应 ACK 或被对方丢弃；</li>
</ol>
<p>当出现这些异常情况时，TCP 就会超时重传。<br>TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到了，但还没有收到确认，就重传这一报文段，这个就叫做「超时重传」。    </p>
<h2 id="重传算法"><a href="#重传算法" class="headerlink" title="重传算法"></a>重传算法</h2><h3 id="先认识两个概念"><a href="#先认识两个概念" class="headerlink" title="先认识两个概念"></a>先认识两个概念</h3><h4 id="RTO-Retransmission-Time-Out-重传超时时间"><a href="#RTO-Retransmission-Time-Out-重传超时时间" class="headerlink" title="RTO ( Retransmission Time-Out ) 重传超时时间"></a>RTO ( Retransmission Time-Out ) 重传超时时间</h4><p>指发送端发送数据后、重传数据前等待接收方收到该数据 ACK 报文的时间。<br>大白话就是，需要等待多长时间还没收到确认，就重新传一次。    </p>
<p>RTO 的设置对于重传非常重要：    </p>
<ol>
<li>设长了，重发就慢，没有效率，性能差；</li>
<li>设短了，重发得就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ol>
<h4 id="RTT-Round-Trip-Time-连接往返时间"><a href="#RTT-Round-Trip-Time-连接往返时间" class="headerlink" title="RTT ( Round Trip Time ) 连接往返时间"></a>RTT ( Round Trip Time ) 连接往返时间</h4><p>指发送端从发送 TCP 包开始到接收它的 ACK 报文之间所耗费的时间。<br>而在实际的网络传输中，RTT 的值每次都是随机的，无法事先预预知。<br>TCP 通过测量来获得连接当前 RTT 的一个估计值，并以该 RTT 估计值为基准来设置当前的 RTO。<br>这就引入了一类算法的称呼：自适应重传算法（Adaptive Restransmission Algorithm）<br>这类算法的关键就在于对当前 RTT 的准确估计，以便适时调整 RTO。    </p>
<p>关于自适应重传算法，经历过多次的迭代和修正。<br>从 1981 年的 <a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="external">RFC793</a> 提及的经典算法，到 1987 年 Karn 提出的 Karn/Partridge 算法，再到后来的 1988 年的 Jacobson / Karels 算法。<br>最后的这个算法在被用在今天的 TCP 协议中（Linux的源代码在：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609" target="_blank" rel="external"><code>tcp_rtt_estimator</code></a>）。    </p>
<p>自适应重传算法的发展读者有兴趣可以参考其他资料，在这里我拎一个现在在用的算法出来讲讲，随意感受一下。    </p>
<h3 id="Jacobson-Karels-算法"><a href="#Jacobson-Karels-算法" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h3><p>1988年，有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看<a href="https://tools.ietf.org/html/rfc2988" target="_blank" rel="external">RFC6298</a>）。<br>其计算公式：</p>
<blockquote>
<p>SRTT = SRTT + α ( RTT – SRTT )  —— 计算平滑 RTT</p>
<p>DevRTT = ( 1-β ) <em> DevRTT + β </em> ( | RTT - SRTT | ) ——计算平滑 RTT 和真实的差距（加权移动平均）</p>
<p>RTO= µ <em> SRTT + ∂ </em> DevRTT </p>
</blockquote>
<p>其中：</p>
<ul>
<li><p><code>α</code>、<code>β</code>、<code>μ</code>、<code>∂</code> 是可以调整的参数，在 RFC6298 中给出了对应的参考值，而在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4；</p>
</li>
<li><p>SRTT 是 Smoothed RTT 的意思，是 RTT 的平滑计算值，即根据每次测量的 RTT 和旧的 RTT 进行运算，得出新的 RTT。SRTT 的值，会在每一次测量到 RTT 之后进行更新；</p>
</li>
<li><p>DevRTT 是 Deviation RTT 的意思，根据每次测量的 RTT 和旧的 SRTT 值进行运算，得出新的 DevRTT；</p>
</li>
</ul>
<p>由算法可以知道 RTO 的值会根据每次测量的 RTT 值变化而变化，基本要点是 TCP 监视每个连接的性能，由每一个 TCP 的连接情况推算出合适的 RTO 值，根据不同的网络情况，自动修改 RTO 值，以适应负责的网络变化。</p>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h1 id="滑动窗口-Sliding-Window"><a href="#滑动窗口-Sliding-Window" class="headerlink" title="滑动窗口 Sliding Window"></a>滑动窗口 Sliding Window</h1><p>滑动窗口协议比较复杂，也是 TCP 协议的精髓所在。    </p>
<p>TCP 头里有一个字段叫 Window，叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。    </p>
<p>滑动窗口分为「接收窗口」和「发送窗口」<br>因为 TCP 协议是全双工的，会话的双方都可以同时接收和发送，那么就需要各自维护一个「发送窗口」和「接收窗口」。    </p>
<h2 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h2><p>大小取决于对端通告的接受窗口。<br>只有收到对端对于本端发送窗口内字节的 ACK 确认，才会移动发送窗口的左边界。    </p>
<p>下图是发送窗口的示意图：</p>
<p><img src="http://om6ayrafu.bkt.clouddn.com/post/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png" alt="tcps-send-wwindows.png"></p>
<p>对于发送窗口，在缓存内的数据有四种状态：</p>
<ul>
<li>#1 已发送，并得到接收方 ACK 确认；</li>
<li>#2 已发送，但还未收到接收方 ACK；</li>
<li>#3 未发送，但接收方允许发送，接收方还有空间</li>
<li>#4 未发送，且接收方不允许发送，接收方没有空间</li>
</ul>
<p>如果下一刻，收到了接收方对于 32-36 字节序的数据包的 ACK 确认，那么发送方的窗口就会发生「滑动」。<br>并且发送下一个 46-51 字节序的数据包。    </p>
<p><img src="http://om6ayrafu.bkt.clouddn.com/post/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png" alt="tcps-send-wslide.png"></p>
<p>滑动窗口的概念，描述了 TCP 的数据是怎么发送，以及怎么接收的。<br>TCP 的滑动窗口是动态的，我们可以想象成小学常见的一个数学题，一个水池，体积 V，每小时进水量 V1, 出水量 V2。<br>当水池满了就不允许再注入了，如果有个液压系统控制水池大小，那么就可以控制水的注入速率和量了。<br>应用程序可以根据自身的处理能力变化，通过 API 来控制本端 TCP 接收窗口的大小，来进行流量控制。    </p>
<h2 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h2><p>大小取决于应用、系统、硬件的限制。    </p>
<p>下图是接收窗口的示意图（找不到图，唯有自己画了）：    </p>
<p><img src="http://om6ayrafu.bkt.clouddn.com/post/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png" alt="tcps-receive-wwindows.png"></p>
<p>相对于发送窗口，接受窗口在缓存内的数据只有三种状态：</p>
<ul>
<li>已接收已确认；</li>
<li>未接收，准备接收；</li>
<li>未接收，并未准备接收；</li>
</ul>
<p>下一刻接收到来自发送端的 32-36 数据包，然后回送 ACK 确认报，并且移动接收窗口。    </p>
<p><img src="http://om6ayrafu.bkt.clouddn.com/post/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png" alt="tcps-receive-wslide.png"></p>
<p>另外接收端相对于发送端还有不同的一点，只有前面所有的段都确认的情况下才会移动左边界，<br>在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认，以此确保对端会对这些数据重传。<br>假如 32-36 字节不是一个报文段的，而是每个字节一个报文段的话，那么就会分成了 5 个报文段。<br>在实际的网络环境中，不能确保是按序收到的，其中会有一些早达到，一些迟到达。    </p>
<p><img src="http://om6ayrafu.bkt.clouddn.com/post/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png" alt="tcps-receive-disorder.png"></p>
<p>如图中的 34、35 字节序，先收到了，接收窗口也不会移动。<br>因为有可能 32、33 字节序会出现丢包或者超时，这时就需要发送端重发报文段了。    </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo.htm" target="_blank" rel="external">The TCP/IP Guide</a><br><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP 的那些事儿（下）</a><br><a href="https://book.douban.com/subject/26850616/" target="_blank" rel="external">《后台开发 核心技术与应用实践》</a><br><a href="https://book.douban.com/subject/2970300/" target="_blank" rel="external">《计算机网络》</a>    </p>

    
  </div>
</article>



<section class="disqus-comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>




</div>

  
<script>
  var disqus_shortname = 'bluesun-jerryc';
  
  var disqus_url = 'http://huang-jerryc.com/2017/03/02/understand-tcp-5/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  

</body>
  <script src="//cdnjs.cloudflare.com/ajax/libs/Han/3.2.7/han.min.js"></script>
</html>
