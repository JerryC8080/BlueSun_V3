{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"themes/fexo/source/sw.js","path":"sw.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/sass/styles.scss","path":"sass/styles.scss","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/zenscroll.js","path":"js/zenscroll.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/util.js","path":"js/util.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/sw-register.js","path":"js/sw-register.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/scroll-spy.js","path":"js/scroll-spy.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/fastclick.js","path":"js/fastclick.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/bundle.js","path":"js/bundle.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/images/qr-wechat.jpg","path":"images/qr-wechat.jpg","modified":0,"renderable":1},{"_id":"themes/fexo/source/images/qr-alipay.png","path":"images/qr-alipay.png","modified":0,"renderable":1},{"_id":"themes/fexo/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/fexo/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff2","path":"fonts/fontello.woff2","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff","path":"fonts/fontello.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.ttf","path":"fonts/fontello.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.svg","path":"fonts/fontello.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.eot","path":"fonts/fontello.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","path":"fonts/calligraffitti-regular-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","path":"fonts/calligraffitti-regular-webfont.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","path":"fonts/calligraffitti-regular-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","path":"fonts/calligraffitti-regular-webfont.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","path":"fonts/calligraffitti-regular-webfont.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","path":"fonts/PoiretOne-Regular.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","path":"fonts/PoiretOne-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","path":"fonts/PoiretOne-Regular.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","path":"fonts/PoiretOne-Regular.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","path":"fonts/Lobster-Regular.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","path":"fonts/Lobster-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","path":"fonts/Lobster-Regular.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","path":"fonts/Lobster-Regular.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/css/styles.css.map","path":"css/styles.css.map","modified":0,"renderable":1},{"_id":"themes/fexo/source/css/styles.css","path":"css/styles.css","modified":0,"renderable":1},{"_id":"source/image/blog/whatisAST/表达式语法树比较.png","path":"image/blog/whatisAST/表达式语法树比较.png","modified":0,"renderable":0},{"_id":"source/image/blog/whatisAST/javascript语法树.png","path":"image/blog/whatisAST/javascript语法树.png","modified":0,"renderable":0},{"_id":"source/image/blog/whatisAST/Python语法树.png","path":"image/blog/whatisAST/Python语法树.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png","path":"image/blog/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png","path":"image/blog/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/DB900F916ECD267746706FEA8DF682CD.png","path":"image/blog/understand-tcp-udp/DB900F916ECD267746706FEA8DF682CD.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/CFC6314E4B2FD039C450821D946E93E2.png","path":"image/blog/understand-tcp-udp/CFC6314E4B2FD039C450821D946E93E2.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png","path":"image/blog/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/6FCC9F4EDE80F784BD11ED9FA76FA375.png","path":"image/blog/understand-tcp-udp/6FCC9F4EDE80F784BD11ED9FA76FA375.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png","path":"image/blog/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/5DADDF7480F81837145468E2ADA6839F.png","path":"image/blog/understand-tcp-udp/5DADDF7480F81837145468E2ADA6839F.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png","path":"image/blog/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/46872611EB6C0874FE9E4C290E8F3FE9.png","path":"image/blog/understand-tcp-udp/46872611EB6C0874FE9E4C290E8F3FE9.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/3D9C291187835C3571A111952201B4FF.png","path":"image/blog/understand-tcp-udp/3D9C291187835C3571A111952201B4FF.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/3A60080FBC8767DB575C2D2919097613.png","path":"image/blog/understand-tcp-udp/3A60080FBC8767DB575C2D2919097613.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/08EAF7F3E7FFCEF3E781385BF62BA2BC.png","path":"image/blog/understand-tcp-udp/08EAF7F3E7FFCEF3E781385BF62BA2BC.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png","path":"image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png","path":"image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png","path":"image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png","path":"image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png","path":"image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png","modified":0,"renderable":0},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png","path":"image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png","modified":0,"renderable":0},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png","path":"image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png","modified":0,"renderable":0},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png","path":"image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png","modified":0,"renderable":0},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg","path":"image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/memory-in-nodejs/V8的堆示意图.png","path":"image/blog/memory-in-nodejs/V8的堆示意图.png","modified":0,"renderable":0},{"_id":"source/image/blog/memory-in-nodejs/V8的堆内存示意图.png","path":"image/blog/memory-in-nodejs/V8的堆内存示意图.png","modified":0,"renderable":0},{"_id":"source/image/blog/memory-in-nodejs/V8的分代示意图.png","path":"image/blog/memory-in-nodejs/V8的分代示意图.png","modified":0,"renderable":0},{"_id":"source/image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png","path":"image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png","modified":0,"renderable":0},{"_id":"source/image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png","path":"image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png","modified":0,"renderable":0},{"_id":"source/image/blog/memory-in-nodejs/Chrome Profile.jpg","path":"image/blog/memory-in-nodejs/Chrome Profile.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg","path":"image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif","path":"image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg","path":"image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif","path":"image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif","path":"image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg","path":"image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif","path":"image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif","path":"image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg","path":"image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg","path":"image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412172732788.jpg","path":"image/blog/imgFile1412172732788.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412172691061.jpeg","path":"image/blog/imgFile1412172691061.jpeg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412172676130.jpg","path":"image/blog/imgFile1412172676130.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168908105.jpg","path":"image/blog/imgFile1412168908105.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168871884.jpg","path":"image/blog/imgFile1412168871884.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168834596.jpg","path":"image/blog/imgFile1412168834596.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168755327.jpg","path":"image/blog/imgFile1412168755327.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168728769.jpg","path":"image/blog/imgFile1412168728769.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168608341.jpg","path":"image/blog/imgFile1412168608341.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168592404.jpg","path":"image/blog/imgFile1412168592404.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168553899.jpg","path":"image/blog/imgFile1412168553899.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168511771.jpg","path":"image/blog/imgFile1412168511771.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168471850.jpg","path":"image/blog/imgFile1412168471850.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168441331.jpg","path":"image/blog/imgFile1412168441331.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168419938.jpg","path":"image/blog/imgFile1412168419938.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168354773.jpg","path":"image/blog/imgFile1412168354773.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B531CE953267440FAA32A1DA644BFD68.png","path":"image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B531CE953267440FAA32A1DA644BFD68.png","modified":0,"renderable":0},{"_id":"source/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B415AA74BF5438CCEB2FEAEDD002B1BD.jpg","path":"image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B415AA74BF5438CCEB2FEAEDD002B1BD.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif","path":"image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif","modified":0,"renderable":0},{"_id":"source/image/blog/about-communicate/DraggedImage.png","path":"image/blog/about-communicate/DraggedImage.png","modified":0,"renderable":0},{"_id":"source/image/blog/about-communicate/DraggedImage-1.png","path":"image/blog/about-communicate/DraggedImage-1.png","modified":0,"renderable":0},{"_id":"source/image/blog/79702-e7cf075365536286.jpeg","path":"image/blog/79702-e7cf075365536286.jpeg","modified":0,"renderable":0},{"_id":"source/image/blog/79702-d66ee9d1fd912b33.jpg","path":"image/blog/79702-d66ee9d1fd912b33.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/79702-8afbd2a4f48118bd.jpeg","path":"image/blog/79702-8afbd2a4f48118bd.jpeg","modified":0,"renderable":0},{"_id":"source/image/blog/79702-5d2b1c9e8970c3ea.jpeg","path":"image/blog/79702-5d2b1c9e8970c3ea.jpeg","modified":0,"renderable":0},{"_id":"source/image/blog/79702-5660ac4cb51f6257.jpg","path":"image/blog/79702-5660ac4cb51f6257.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/HTML-CSS-JS打造Windows桌面版《2048》.md","shasum":"dee94acebd930cc55b7b2924df0b4fe5c6fb18b6","modified":1486047205000,"hash":"dee94acebd930cc55b7b2924df0b4fe5c6fb18b6"},{"_id":"source/_posts/JavaScript原型中的哲学思想.md","shasum":"d3528c810e4334f70902f9750bfa80ff7c31462d","modified":1486047205000,"hash":"d3528c810e4334f70902f9750bfa80ff7c31462d"},{"_id":"source/_posts/Javascript那些书籍.md","shasum":"873d4b34f8b7a7f895ed7010a5d376a68704b94e","modified":1486047205000,"hash":"873d4b34f8b7a7f895ed7010a5d376a68704b94e"},{"_id":"source/_posts/Kissy-WaterFall-实现手动加载数据.md","shasum":"14f9833a7baaae37ba7934ab4bde63355e21077f","modified":1486047205000,"hash":"14f9833a7baaae37ba7934ab4bde63355e21077f"},{"_id":"source/_posts/Kissy-WaterFall-静态调用.md","shasum":"ac3a9e0e3d0e0fa6d0d7df5581ce7445c228a3db","modified":1486047205000,"hash":"ac3a9e0e3d0e0fa6d0d7df5581ce7445c228a3db"},{"_id":"source/_posts/My-Nodejs-Tool-Kit.md","shasum":"5730dbb1095736679fa5509b4fb2d02551e9d04f","modified":1486047205000,"hash":"5730dbb1095736679fa5509b4fb2d02551e9d04f"},{"_id":"source/_posts/NodeJS中被忽略的内存.md","shasum":"9ef3835c397ba0d8a9e8c87cd0bcae59cd5d93a3","modified":1486047205000,"hash":"9ef3835c397ba0d8a9e8c87cd0bcae59cd5d93a3"},{"_id":"source/_posts/SOAP-Web-Service的枢纽.md","shasum":"d4a842ef9cb82cdb6304cc3c42428f4bdad3627a","modified":1486047205000,"hash":"d4a842ef9cb82cdb6304cc3c42428f4bdad3627a"},{"_id":"source/_posts/Session原理.md","shasum":"a9df8f55cb4158cd31d3af0bfef240bc9a49540c","modified":1486047205000,"hash":"a9df8f55cb4158cd31d3af0bfef240bc9a49540c"},{"_id":"source/_posts/a-thinking-on-insomnia-night.md","shasum":"fe4ae1bb852e313bfdbc2499f66725a43cd8266f","modified":1650426199489,"hash":"e6e169e6683536a3acbf6ac75f8ac161546df0d0"},{"_id":"source/_posts/about-communicate.md","shasum":"931ce2c423b6ddf1ae177d7c6823a86ff5eb8618","modified":1555148745626,"hash":"931ce2c423b6ddf1ae177d7c6823a86ff5eb8618"},{"_id":"source/_posts/about-okr.md","shasum":"a49c99ecb181d9af14b189251f1784e334f55820","modified":1562425830994,"hash":"a49c99ecb181d9af14b189251f1784e334f55820"},{"_id":"source/_posts/beautywe-intro.md","shasum":"e401caf748f181e48fb3c332332cb5906ec898c6","modified":1563371475075,"hash":"e401caf748f181e48fb3c332332cb5906ec898c6"},{"_id":"source/_posts/build-a-extensible-reliable-controllable-PWA-app.md","shasum":"8dbb6708542f0f04ade4de2dd7dccd9299621017","modified":1650423987393},{"_id":"source/_posts/do-you-konw-the-different-between-compiler-and-interpreter.md","shasum":"5bd7712306a12045d959de1374b2980b92fbcde5","modified":1486047205000,"hash":"5bd7712306a12045d959de1374b2980b92fbcde5"},{"_id":"source/_posts/change-and-its-detection-in-javascript-frameworks.md","shasum":"50cc9ec097d180b0ba2f1cefa939fede10325fc8","modified":1607867235662,"hash":"50cc9ec097d180b0ba2f1cefa939fede10325fc8"},{"_id":"source/_posts/github-workflow.md","shasum":"b035283e9af5f0b1ce33ef5b03b1f69c4410b61c","modified":1611827556379},{"_id":"source/_posts/gulp-base.md","shasum":"5e2277106f77db2864251902ffe56a24938d68d3","modified":1488260997000,"hash":"5e2277106f77db2864251902ffe56a24938d68d3"},{"_id":"source/_posts/iframe-在IE下透明背景.md","shasum":"82c291f41aea36f74c3955461b232a073b200461","modified":1486047205000,"hash":"82c291f41aea36f74c3955461b232a073b200461"},{"_id":"source/_posts/jQuery动画反方向延伸.md","shasum":"942e88d9e83c0b31ef096fbf8306ea7f4caba38e","modified":1486047205000,"hash":"942e88d9e83c0b31ef096fbf8306ea7f4caba38e"},{"_id":"source/_posts/keep-focus-and-efficiency.md","shasum":"ce14907f8194a96cf1f8c7b2b07686e3efc4aa22","modified":1486047205000,"hash":"ce14907f8194a96cf1f8c7b2b07686e3efc4aa22"},{"_id":"source/_posts/management-of-common-sense-1.md","shasum":"744e5a42530021c2e1823b030f7d1984d5e01280","modified":1555147838771,"hash":"744e5a42530021c2e1823b030f7d1984d5e01280"},{"_id":"source/_posts/method-fuse.md","shasum":"a0a5de7c1adcf666cc5a6723956ab5330eeab6e7","modified":1611826567795},{"_id":"source/_posts/talk-about-pixel-and-rpx.md","shasum":"1a791c2b5649e1757d107dc10f6897b8a4f13419","modified":1607867235663,"hash":"1a791c2b5649e1757d107dc10f6897b8a4f13419"},{"_id":"source/_posts/reconsidering-for-2017-Q1.md","shasum":"0368ea1f3836dc813c13c56645fd31e28977bd8c","modified":1525191362081,"hash":"0368ea1f3836dc813c13c56645fd31e28977bd8c"},{"_id":"source/_posts/the-memeye.md","shasum":"55e5a41bf03427e0dfbe12aa8c233313a2566fb0","modified":1563371569737,"hash":"55e5a41bf03427e0dfbe12aa8c233313a2566fb0"},{"_id":"source/_posts/the-v8-what-javascripter-should-konw-of-v8-in-nodejs.md","shasum":"26473dcc1fd98186636f38adb1f97e63b2da83f4","modified":1486047205000,"hash":"26473dcc1fd98186636f38adb1f97e63b2da83f4"},{"_id":"source/_posts/the-winter-and-summer-of-Meizu.md","shasum":"f95e6035227f1a6b66b9de4d8b928551ea781cf4","modified":1486216978000,"hash":"f95e6035227f1a6b66b9de4d8b928551ea781cf4"},{"_id":"source/_posts/understand-tcp-1.md","shasum":"214f2f185402ee47877d36c6a734455a6c307574","modified":1525191362082,"hash":"214f2f185402ee47877d36c6a734455a6c307574"},{"_id":"source/_posts/understand-tcp-2.md","shasum":"56ab4cc4eb160cb60928a162f1026b2279d4c9fb","modified":1607867235663,"hash":"56ab4cc4eb160cb60928a162f1026b2279d4c9fb"},{"_id":"source/_posts/understand-tcp-3.md","shasum":"cfb3853cff36dc17b004e36e19688bab0c0b5cb9","modified":1607867235664,"hash":"cfb3853cff36dc17b004e36e19688bab0c0b5cb9"},{"_id":"source/_posts/understand-tcp-4.md","shasum":"9f4c3c6d1ab9490b1978bef73376413646fb80ce","modified":1607867235664,"hash":"9f4c3c6d1ab9490b1978bef73376413646fb80ce"},{"_id":"source/_posts/understand-tcp-6.md","shasum":"6c4e52e9127f07b6cf9cda4eb6792526ed36ccc4","modified":1607867235665,"hash":"6c4e52e9127f07b6cf9cda4eb6792526ed36ccc4"},{"_id":"source/_posts/understand-tcp-5.md","shasum":"46b09c41354d3fc47fa12a4af0e3bb4918017b1d","modified":1607867235665,"hash":"46b09c41354d3fc47fa12a4af0e3bb4918017b1d"},{"_id":"source/_posts/understand-this-of-javascript.md","shasum":"b6a95109320f9678f8c1b0e686e30fde425f07d5","modified":1500177269000,"hash":"b6a95109320f9678f8c1b0e686e30fde425f07d5"},{"_id":"source/_posts/understand-udp.md","shasum":"cb75c3703ed9bea096988e48bf3b17cad3956741","modified":1607867235666,"hash":"cb75c3703ed9bea096988e48bf3b17cad3956741"},{"_id":"source/_posts/use-npm-in-weapp.md","shasum":"3733dbce58d26de590e7f729d611a68de06a5b57","modified":1562495325723,"hash":"3733dbce58d26de590e7f729d611a68de06a5b57"},{"_id":"source/_posts/wxapp-login-design.md","shasum":"72be5a503ceff5fa4ee18d609e16712ab8b1b252","modified":1603074282620},{"_id":"source/_posts/wxapp-router-experience.md","shasum":"ae47fb6aee3c150622ee5511524a34330a393e16","modified":1637027962376},{"_id":"source/_posts/yz-share-about-wxapp--cencept.md","shasum":"b3c5464e7f1f859d3e55483dd19d365eb5d61912","modified":1607867235668,"hash":"b3c5464e7f1f859d3e55483dd19d365eb5d61912"},{"_id":"source/_posts/「ES6笔记」 Babel.md","shasum":"559e28d711d1245c68084ce696a5d6a303a6d605","modified":1486047205000,"hash":"559e28d711d1245c68084ce696a5d6a303a6d605"},{"_id":"source/_posts/「理解HTTP」之常见的状态码.md","shasum":"21e3c06da58fa2e100c37bb0f305847a5c2b54d7","modified":1486047205000,"hash":"21e3c06da58fa2e100c37bb0f305847a5c2b54d7"},{"_id":"source/_posts/下雨天的夜晚，特别容易失眠.md","shasum":"f67460423c9b2ab5d74502a8fa6ebbdac52b8deb","modified":1486215376000,"hash":"f67460423c9b2ab5d74502a8fa6ebbdac52b8deb"},{"_id":"source/_posts/为什么使用Sails.md","shasum":"f528e60f666322cc0df2db15fc8de105e4ff7a13","modified":1486047205000,"hash":"f528e60f666322cc0df2db15fc8de105e4ff7a13"},{"_id":"source/_posts/了解 Nginx 的基本概念.md","shasum":"76355eb4e9ab3cc7a4bd768d74d3e3550e665483","modified":1486047205000,"hash":"76355eb4e9ab3cc7a4bd768d74d3e3550e665483"},{"_id":"source/_posts/二零一六年一月二十八日，于珠海.md","shasum":"d6588ecae7b7cb865f56fcb191cb67fd527fc813","modified":1486047205000,"hash":"d6588ecae7b7cb865f56fcb191cb67fd527fc813"},{"_id":"source/_posts/何为技术人的核心竞争力.md","shasum":"f3292781c0f6e3e196f778fbefec87aac2a22a72","modified":1486047205000,"hash":"f3292781c0f6e3e196f778fbefec87aac2a22a72"},{"_id":"source/_posts/何为语法树.md","shasum":"b629f74fca54635d67352b77d5ea0948fbbedd22","modified":1486047205000,"hash":"b629f74fca54635d67352b77d5ea0948fbbedd22"},{"_id":"source/_posts/单点登录的三种实现方式.md","shasum":"cf91ec216c688294b8da653ebb32d77dd08c44d9","modified":1607867235669,"hash":"cf91ec216c688294b8da653ebb32d77dd08c44d9"},{"_id":"source/_posts/在Nodejs中贯彻单元测试.md","shasum":"d5ce2bbf935060c8d199b349a3a6b0e84e2c97c4","modified":1486047205000,"hash":"d5ce2bbf935060c8d199b349a3a6b0e84e2c97c4"},{"_id":"source/_posts/原生JavaScript实现拖拽效果.md","shasum":"9be01fa3f5a736201a0eeacb074263cb13406848","modified":1486047205000,"hash":"9be01fa3f5a736201a0eeacb074263cb13406848"},{"_id":"source/_posts/基于jQuery的2048游戏.md","shasum":"17e4815abc52971f657237742e428bf60feecc3e","modified":1486047205000,"hash":"17e4815abc52971f657237742e428bf60feecc3e"},{"_id":"source/_posts/如果你用GitHub，可以这样提高效率.md","shasum":"0a024ee9e898c30063f3a8ca612bd94b6e83624a","modified":1486047205000,"hash":"0a024ee9e898c30063f3a8ca612bd94b6e83624a"},{"_id":"source/_posts/基于RESTful-API-怎么设计用户权限控制.md","shasum":"7a4120ab1eebe44dbc3c691fbef3b6d61a2ae321","modified":1486047205000,"hash":"7a4120ab1eebe44dbc3c691fbef3b6d61a2ae321"},{"_id":"source/_posts/打造高效个性Terminal（二）之 zsh.md","shasum":"556065f6b5b36c9275bf521c9a0456755dfb05e2","modified":1486047205000,"hash":"556065f6b5b36c9275bf521c9a0456755dfb05e2"},{"_id":"source/_posts/消息系统设计与实现「上篇」.md","shasum":"c4d68767dd267b4bab39fc33ae2caf2389328a7f","modified":1486047205000,"hash":"c4d68767dd267b4bab39fc33ae2caf2389328a7f"},{"_id":"source/_posts/打造高效个性Terminal（一）之 iTerm.md","shasum":"92c787c476397ff0795d7945100dbb70d5476d5d","modified":1486047205000,"hash":"92c787c476397ff0795d7945100dbb70d5476d5d"},{"_id":"source/_posts/消息系统设计与实现「下篇」.md","shasum":"e4837d02d38c22615890d7949091ddfb294aa309","modified":1486047205000,"hash":"e4837d02d38c22615890d7949091ddfb294aa309"},{"_id":"source/_posts/理解 CORS (Cross-Origin Resource Sharing).md","shasum":"1e0b978b71aef822fcbc383e29bb3a0a135d0fed","modified":1486047205000,"hash":"1e0b978b71aef822fcbc383e29bb3a0a135d0fed"},{"_id":"source/_posts/登录那些事儿.md","shasum":"d87aa0e310c4369db8a1f51f586b37a2bd4196fe","modified":1486047205000,"hash":"d87aa0e310c4369db8a1f51f586b37a2bd4196fe"},{"_id":"source/_posts/盘点国内的那些ROM.md","shasum":"827e13996011e664e5a33b94e15e29227753704d","modified":1486047205000,"hash":"827e13996011e664e5a33b94e15e29227753704d"},{"_id":"source/_posts/读《重来》.md","shasum":"899517e30f6b1728765618c3d0b5cae0d367d972","modified":1486047205000,"hash":"899517e30f6b1728765618c3d0b5cae0d367d972"},{"_id":"source/about/index.md","shasum":"507996d1aad09278bc94a499deecb92db633801e","modified":1486047205000,"hash":"507996d1aad09278bc94a499deecb92db633801e"},{"_id":"source/_posts/那一夜独处.md","shasum":"871f04ce82d32dafc6985e52aa232be4e87af245","modified":1486047205000,"hash":"871f04ce82d32dafc6985e52aa232be4e87af245"},{"_id":"source/category/index.md","shasum":"838a0ba6b58f4def2b6b3c0d5841288f801bdb85","modified":1486047205000,"hash":"838a0ba6b58f4def2b6b3c0d5841288f801bdb85"},{"_id":"source/css/personal-style.css","shasum":"5dca9ce8d8d1f710c3c0cbeb3d9129061cae28d8","modified":1562491033422,"hash":"5dca9ce8d8d1f710c3c0cbeb3d9129061cae28d8"},{"_id":"source/image/blog/79702-5d2b1c9e8970c3ea.jpeg","shasum":"7a32620c73edcce6e9c3163b7b0a9e27659701b4","modified":1486047205000,"hash":"7a32620c73edcce6e9c3163b7b0a9e27659701b4"},{"_id":"source/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif","shasum":"868e2fd30051c693bebd9dd91d3ceede24a2e863","modified":1486047205000,"hash":"868e2fd30051c693bebd9dd91d3ceede24a2e863"},{"_id":"source/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B531CE953267440FAA32A1DA644BFD68.png","shasum":"64055a621546c70e5fde53aae72e3bb7ca590dad","modified":1486047205000,"hash":"64055a621546c70e5fde53aae72e3bb7ca590dad"},{"_id":"source/image/blog/imgFile1412168728769.jpg","shasum":"2b3e55629a2d38db708b2e2e26d085918738af95","modified":1486047205000,"hash":"2b3e55629a2d38db708b2e2e26d085918738af95"},{"_id":"source/image/blog/imgFile1412168834596.jpg","shasum":"b65d6af4f2310c741a424f7944f6cf473d74f2e1","modified":1486047205000,"hash":"b65d6af4f2310c741a424f7944f6cf473d74f2e1"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg","shasum":"ede513572ec495a8e0c8ad4fa79e208b45f5d418","modified":1486047205000,"hash":"ede513572ec495a8e0c8ad4fa79e208b45f5d418"},{"_id":"source/image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png","shasum":"4e9b1da90be242224b1bce0e8a65cc685635c437","modified":1486047205000,"hash":"4e9b1da90be242224b1bce0e8a65cc685635c437"},{"_id":"source/image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png","shasum":"79a362733e7e457c848b2a8b71bac8087f0e3c26","modified":1486047205000,"hash":"79a362733e7e457c848b2a8b71bac8087f0e3c26"},{"_id":"source/image/blog/memory-in-nodejs/V8的分代示意图.png","shasum":"52cc0c583bb3ea4211743f05d2dca50ab7424159","modified":1486047205000,"hash":"52cc0c583bb3ea4211743f05d2dca50ab7424159"},{"_id":"source/image/blog/memory-in-nodejs/V8的堆内存示意图.png","shasum":"1018a600ec1dcd69a9db256c7f00ec2c129a2a3e","modified":1486047205000,"hash":"1018a600ec1dcd69a9db256c7f00ec2c129a2a3e"},{"_id":"source/image/blog/memory-in-nodejs/V8的堆示意图.png","shasum":"8df2d5ba5621249d2a0b8ab4bc682a7e204f7ff2","modified":1486047205000,"hash":"8df2d5ba5621249d2a0b8ab4bc682a7e204f7ff2"},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png","shasum":"5e539fd4304d709ee7fce494b858c9f5ac1d5f2d","modified":1486047205000,"hash":"5e539fd4304d709ee7fce494b858c9f5ac1d5f2d"},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png","shasum":"26ab9b4670e1214b412d2e322f9fc7bba017acfd","modified":1486047205000,"hash":"26ab9b4670e1214b412d2e322f9fc7bba017acfd"},{"_id":"source/image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png","shasum":"17abe246eb6ae6523c0e9291fd5f2457f2230876","modified":1486047205000,"hash":"17abe246eb6ae6523c0e9291fd5f2457f2230876"},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png","shasum":"4d9c4ab5fedcf04052fb584c0794743d70883e3e","modified":1486047205000,"hash":"4d9c4ab5fedcf04052fb584c0794743d70883e3e"},{"_id":"source/image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png","shasum":"cc7d13236f9e12f09bf6a0f242def476eb3358fd","modified":1486047205000,"hash":"cc7d13236f9e12f09bf6a0f242def476eb3358fd"},{"_id":"source/image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png","shasum":"994b09ceb5f0561f8dcdcdf9d384ed723a193168","modified":1486047205000,"hash":"994b09ceb5f0561f8dcdcdf9d384ed723a193168"},{"_id":"source/image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png","shasum":"189efea61c3757dc42472b02ba6527757368d343","modified":1486047205000,"hash":"189efea61c3757dc42472b02ba6527757368d343"},{"_id":"source/image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png","shasum":"d6d5140d0d6c9449062ad0d13a17d8dc001adfe2","modified":1486047205000,"hash":"d6d5140d0d6c9449062ad0d13a17d8dc001adfe2"},{"_id":"source/image/blog/understand-tcp-udp/3A60080FBC8767DB575C2D2919097613.png","shasum":"4942e3b30f753701c5aca54af249cb686602547c","modified":1488435073000,"hash":"4942e3b30f753701c5aca54af249cb686602547c"},{"_id":"source/image/blog/understand-tcp-udp/46872611EB6C0874FE9E4C290E8F3FE9.png","shasum":"db440a0bc227c77ecf57e954ff5c6c1994720939","modified":1488435073000,"hash":"db440a0bc227c77ecf57e954ff5c6c1994720939"},{"_id":"source/image/blog/understand-tcp-udp/3D9C291187835C3571A111952201B4FF.png","shasum":"761afeaf9764913a4b253ff0876377824d72727e","modified":1488435073000,"hash":"761afeaf9764913a4b253ff0876377824d72727e"},{"_id":"source/image/blog/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png","shasum":"a10efa9e588a291542fef0c5a6b28e662ddd2d67","modified":1488435073000,"hash":"a10efa9e588a291542fef0c5a6b28e662ddd2d67"},{"_id":"source/image/blog/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png","shasum":"82c360ada66472252f9cfcabea6e3cdb626e7340","modified":1488435073000,"hash":"82c360ada66472252f9cfcabea6e3cdb626e7340"},{"_id":"source/image/blog/understand-tcp-udp/5DADDF7480F81837145468E2ADA6839F.png","shasum":"4f27ac7e3cf0d7dbf41c92fdd94dd6a22456be3f","modified":1488435073000,"hash":"4f27ac7e3cf0d7dbf41c92fdd94dd6a22456be3f"},{"_id":"source/image/blog/understand-tcp-udp/6FCC9F4EDE80F784BD11ED9FA76FA375.png","shasum":"ba9b0df516e6fe14ccf9a78d983f50a4e164f2d0","modified":1488435073000,"hash":"ba9b0df516e6fe14ccf9a78d983f50a4e164f2d0"},{"_id":"source/image/blog/understand-tcp-udp/CFC6314E4B2FD039C450821D946E93E2.png","shasum":"5c4171641dbbc785ece72a98cd83a19d6fdb31fd","modified":1488435073000,"hash":"5c4171641dbbc785ece72a98cd83a19d6fdb31fd"},{"_id":"source/image/blog/understand-tcp-udp/DB900F916ECD267746706FEA8DF682CD.png","shasum":"8d6e1b2004225d2bcb849a272921f5925ff8716b","modified":1488435073000,"hash":"8d6e1b2004225d2bcb849a272921f5925ff8716b"},{"_id":"source/image/blog/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png","shasum":"b487ebb98540d92ef33c9dab2a21d512ab003ca8","modified":1488435073000,"hash":"b487ebb98540d92ef33c9dab2a21d512ab003ca8"},{"_id":"source/image/blog/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png","shasum":"6f8aeee9e1e2f15bd0c2b5a9595ad39f0752da42","modified":1488435073000,"hash":"6f8aeee9e1e2f15bd0c2b5a9595ad39f0752da42"},{"_id":"source/image/blog/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png","shasum":"5bc7f4d044710583461481c6dc216b1ee972ce6d","modified":1488435073000,"hash":"5bc7f4d044710583461481c6dc216b1ee972ce6d"},{"_id":"source/image/blog/whatisAST/Python语法树.png","shasum":"6a5d39718236537dd906ef57b361ce03828742c6","modified":1486047205000,"hash":"6a5d39718236537dd906ef57b361ce03828742c6"},{"_id":"source/image/blog/whatisAST/javascript语法树.png","shasum":"b07f6f8231fc8aaedf41af1c89764d4b345eec65","modified":1486047205000,"hash":"b07f6f8231fc8aaedf41af1c89764d4b345eec65"},{"_id":"source/link/index.md","shasum":"70bd0de52901bac812f76d5510925361a7921d99","modified":1486047205000,"hash":"70bd0de52901bac812f76d5510925361a7921d99"},{"_id":"themes/fexo/source/sass/pages/_tag.scss","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562465924911,"hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"source/tag/index.md","shasum":"bee4c19d66746750628e1e0ba397e6623a31d70a","modified":1486047205000,"hash":"bee4c19d66746750628e1e0ba397e6623a31d70a"},{"_id":"source/image/blog/79702-5660ac4cb51f6257.jpg","shasum":"ed6b1882f3dc96eeee24342ef49988ebf77c1260","modified":1486047205000,"hash":"ed6b1882f3dc96eeee24342ef49988ebf77c1260"},{"_id":"source/image/blog/79702-8afbd2a4f48118bd.jpeg","shasum":"c41894ff92fb004f06fb064c8cdfa19d6bb1058a","modified":1486047205000,"hash":"c41894ff92fb004f06fb064c8cdfa19d6bb1058a"},{"_id":"source/image/blog/79702-e7cf075365536286.jpeg","shasum":"0c9cb904120a6bed2e675da14db01331438bdea6","modified":1486047205000,"hash":"0c9cb904120a6bed2e675da14db01331438bdea6"},{"_id":"source/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B415AA74BF5438CCEB2FEAEDD002B1BD.jpg","shasum":"4a7b1bfe9c43fe6686c63c1c3ec564e5f35bc93a","modified":1486047205000,"hash":"4a7b1bfe9c43fe6686c63c1c3ec564e5f35bc93a"},{"_id":"source/image/blog/imgFile1412168354773.jpg","shasum":"615642e03176c66248336defa5cc735059fa63f2","modified":1486047205000,"hash":"615642e03176c66248336defa5cc735059fa63f2"},{"_id":"source/image/blog/imgFile1412168511771.jpg","shasum":"3d7c8ce758c2f4452485dd1d757f29b8e0afdaf8","modified":1486047205000,"hash":"3d7c8ce758c2f4452485dd1d757f29b8e0afdaf8"},{"_id":"source/image/blog/imgFile1412168608341.jpg","shasum":"b7d21357f7f906d363ac5009baaa8748bc9c0c15","modified":1486047205000,"hash":"b7d21357f7f906d363ac5009baaa8748bc9c0c15"},{"_id":"source/image/blog/imgFile1412168755327.jpg","shasum":"b7d21357f7f906d363ac5009baaa8748bc9c0c15","modified":1486047205000,"hash":"b7d21357f7f906d363ac5009baaa8748bc9c0c15"},{"_id":"source/image/blog/imgFile1412168908105.jpg","shasum":"b3a7e2d223bab42c1e9892b15bb1cd2ca528fc62","modified":1486047205000,"hash":"b3a7e2d223bab42c1e9892b15bb1cd2ca528fc62"},{"_id":"source/image/blog/imgFile1412172676130.jpg","shasum":"340d6fbadcc15852645f0770f8379d6c8e500bdc","modified":1486047205000,"hash":"340d6fbadcc15852645f0770f8379d6c8e500bdc"},{"_id":"source/image/blog/understand-tcp-udp/08EAF7F3E7FFCEF3E781385BF62BA2BC.png","shasum":"d73b8bac756532c4df7ed9d7083e4ac1cd50a378","modified":1488435073000,"hash":"d73b8bac756532c4df7ed9d7083e4ac1cd50a378"},{"_id":"source/image/blog/whatisAST/表达式语法树比较.png","shasum":"b1bb37c84d0f5f4973f69462280ef5f445b84df6","modified":1486047205000,"hash":"b1bb37c84d0f5f4973f69462280ef5f445b84df6"},{"_id":"themes/fexo/LICENSE","shasum":"db4cb5aef6072a96721b5428fdd999647c049d55","modified":1562465924826,"hash":"db4cb5aef6072a96721b5428fdd999647c049d55"},{"_id":"themes/fexo/README.md","shasum":"35cd346c229e17ed83609ee94b5d6493c4ab9982","modified":1562465924826,"hash":"35cd346c229e17ed83609ee94b5d6493c4ab9982"},{"_id":"themes/fexo/_config.yml","shasum":"1c9537f5497f6c2b3e7606085824f9eb7babeccc","modified":1562491508974,"hash":"1c9537f5497f6c2b3e7606085824f9eb7babeccc"},{"_id":"themes/fexo/languages/default.yml","shasum":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1562465924827,"hash":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b"},{"_id":"themes/fexo/gulpfile.js","shasum":"dc8e67be9205210ca5d5776cc54ab8d76ead96a0","modified":1562465924827,"hash":"dc8e67be9205210ca5d5776cc54ab8d76ead96a0"},{"_id":"themes/fexo/languages/zh-CN.yml","shasum":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1562465924828,"hash":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b"},{"_id":"themes/fexo/languages/en.yml","shasum":"b58364c7dfac61eddd64510f74ca7516da48f0cf","modified":1562465924827,"hash":"b58364c7dfac61eddd64510f74ca7516da48f0cf"},{"_id":"themes/fexo/languages/no.yml","shasum":"bf11017d77f64fbafb9c99ac219d076b20d53afc","modified":1562465924827,"hash":"bf11017d77f64fbafb9c99ac219d076b20d53afc"},{"_id":"themes/fexo/languages/zh-TW.yml","shasum":"6141b4c7a094c74bd9df7c08908d92b561c1a0c0","modified":1562465924828,"hash":"6141b4c7a094c74bd9df7c08908d92b561c1a0c0"},{"_id":"themes/fexo/layout/_partial/article.ejs","shasum":"78c95b932b2f6d80e1765907b70df918fd00d694","modified":1562465924828,"hash":"78c95b932b2f6d80e1765907b70df918fd00d694"},{"_id":"themes/fexo/layout/_partial/baidu-analytics.ejs","shasum":"c19e4abec19c23840fff7f8a51f4aefbb2b7e8ca","modified":1562465924829,"hash":"c19e4abec19c23840fff7f8a51f4aefbb2b7e8ca"},{"_id":"themes/fexo/layout/_partial/component/back-top.ejs","shasum":"47f2b8306b901f0fffc6aa0cfa40db697a0c5aff","modified":1562465924829,"hash":"47f2b8306b901f0fffc6aa0cfa40db697a0c5aff"},{"_id":"themes/fexo/layout/_partial/baidu-push.ejs","shasum":"6950255d74efac8811d5b05d0d7a263c3c96486d","modified":1562465924829,"hash":"6950255d74efac8811d5b05d0d7a263c3c96486d"},{"_id":"themes/fexo/layout/_partial/component/category-box.ejs","shasum":"f18e08e5c8718d5cd6672fc01e25ba457db0a385","modified":1562465924829,"hash":"f18e08e5c8718d5cd6672fc01e25ba457db0a385"},{"_id":"themes/fexo/layout/_partial/component/category.ejs","shasum":"2429158ff177b8876de765498b54d0c91b3fc551","modified":1562465924830,"hash":"2429158ff177b8876de765498b54d0c91b3fc551"},{"_id":"themes/fexo/layout/_partial/component/changyan.ejs","shasum":"e87c5fa6db61713b63264e467e11d7fde229e1c0","modified":1562465924830,"hash":"e87c5fa6db61713b63264e467e11d7fde229e1c0"},{"_id":"themes/fexo/layout/_partial/component/comments.ejs","shasum":"db8c87adcf9426984b959a014cae149f4c872cb1","modified":1562465924830,"hash":"db8c87adcf9426984b959a014cae149f4c872cb1"},{"_id":"themes/fexo/layout/_partial/component/date.ejs","shasum":"163fbd874481cb9e2b6da5282701a3fbaa4e367a","modified":1562465924830,"hash":"163fbd874481cb9e2b6da5282701a3fbaa4e367a"},{"_id":"themes/fexo/layout/_partial/component/disqus.ejs","shasum":"283f8e2b5406c46edc3c062a5103c3fd8c075c73","modified":1607867235670,"hash":"283f8e2b5406c46edc3c062a5103c3fd8c075c73"},{"_id":"themes/fexo/layout/_partial/component/donation.ejs","shasum":"b81e911bca334074fb4b504673a14f2f184b8536","modified":1562465924831,"hash":"b81e911bca334074fb4b504673a14f2f184b8536"},{"_id":"themes/fexo/layout/_partial/component/gentie.ejs","shasum":"9b78a138fb93a71b481ab25c8dea2e082e5e9d6c","modified":1562465924831,"hash":"9b78a138fb93a71b481ab25c8dea2e082e5e9d6c"},{"_id":"themes/fexo/layout/_partial/component/gitalk.ejs","shasum":"8bd0101b6673550fe1bf161cc005fb591ee8496c","modified":1562465924831,"hash":"8bd0101b6673550fe1bf161cc005fb591ee8496c"},{"_id":"themes/fexo/layout/_partial/component/gitment.ejs","shasum":"dda26e46ff84c896a96207ad33bb85a8f233f435","modified":1562465924832,"hash":"dda26e46ff84c896a96207ad33bb85a8f233f435"},{"_id":"themes/fexo/layout/_partial/component/hypercomments.ejs","shasum":"321339582edb1dd9c4e4ca13108fe494d08494fc","modified":1562465924832,"hash":"321339582edb1dd9c4e4ca13108fe494d08494fc"},{"_id":"themes/fexo/layout/_partial/component/item-post.ejs","shasum":"722e5dbde2d4683eea08f2af922358db45b253b1","modified":1562465924832,"hash":"722e5dbde2d4683eea08f2af922358db45b253b1"},{"_id":"themes/fexo/layout/_partial/component/item-category-name.ejs","shasum":"8ab52c9b5d5db1d3c1d343ecb405c4e15cd144ac","modified":1562465924832,"hash":"8ab52c9b5d5db1d3c1d343ecb405c4e15cd144ac"},{"_id":"themes/fexo/layout/_partial/component/item-tag.ejs","shasum":"1b4c4e090c33ccfd44b531a5de9af16eec266512","modified":1562465924833,"hash":"1b4c4e090c33ccfd44b531a5de9af16eec266512"},{"_id":"themes/fexo/layout/_partial/component/modal.ejs","shasum":"8edceb2fd6c770691bd5cf4a35236c1def8410fe","modified":1562465924833,"hash":"8edceb2fd6c770691bd5cf4a35236c1def8410fe"},{"_id":"themes/fexo/layout/_partial/component/page-header.ejs","shasum":"14bad32082d87d7eeb45c0e9079e72f0ae65dbf4","modified":1562465924834,"hash":"14bad32082d87d7eeb45c0e9079e72f0ae65dbf4"},{"_id":"themes/fexo/layout/_partial/component/item-year.ejs","shasum":"7df23ac13ae06c173701122e67cbf53940478da9","modified":1562491420820,"hash":"7df23ac13ae06c173701122e67cbf53940478da9"},{"_id":"themes/fexo/layout/_partial/component/tag-box.ejs","shasum":"d648ea91ec9dc72bca80d70fbb66f7655bd0ea12","modified":1562465924835,"hash":"d648ea91ec9dc72bca80d70fbb66f7655bd0ea12"},{"_id":"themes/fexo/layout/_partial/component/prev-net.ejs","shasum":"d1cb2e61814bcbd25ccb1628f99b18316e029892","modified":1562465924835,"hash":"d1cb2e61814bcbd25ccb1628f99b18316e029892"},{"_id":"themes/fexo/layout/_partial/component/pagination.ejs","shasum":"ffbb548aee6e15cae924ee7f922f28b2403e8e45","modified":1562465924834,"hash":"ffbb548aee6e15cae924ee7f922f28b2403e8e45"},{"_id":"themes/fexo/layout/_partial/component/title.ejs","shasum":"e2fcdd904123186648513cfca4c7ad04921d2d57","modified":1562465924836,"hash":"e2fcdd904123186648513cfca4c7ad04921d2d57"},{"_id":"themes/fexo/layout/_partial/component/toc.ejs","shasum":"000be428e925f5595af29eeba37ba6111f7f6511","modified":1562465924836,"hash":"000be428e925f5595af29eeba37ba6111f7f6511"},{"_id":"themes/fexo/layout/_partial/component/uyan.ejs","shasum":"afe757c6f45d24640b22d90db6f2799000c6f994","modified":1562465924837,"hash":"afe757c6f45d24640b22d90db6f2799000c6f994"},{"_id":"themes/fexo/layout/_partial/component/toolbox.ejs","shasum":"fcfcccc5b231c4050f1a665b70f7738f9d070541","modified":1562465924836,"hash":"fcfcccc5b231c4050f1a665b70f7738f9d070541"},{"_id":"themes/fexo/layout/_partial/component/valine.ejs","shasum":"28d537af94571dd962ca37358c86d529eb4efa5e","modified":1562465924837,"hash":"28d537af94571dd962ca37358c86d529eb4efa5e"},{"_id":"themes/fexo/layout/_partial/component/tag-list.ejs","shasum":"8535c40b573744ced738b051383c0feca80eb0e9","modified":1562465924835,"hash":"8535c40b573744ced738b051383c0feca80eb0e9"},{"_id":"themes/fexo/layout/_partial/head.ejs","shasum":"c711336c4f4f970b276a244f121fed6eb02ee804","modified":1562465924838,"hash":"c711336c4f4f970b276a244f121fed6eb02ee804"},{"_id":"themes/fexo/layout/_partial/home.ejs","shasum":"225b8a001c7aace46f2b39676e968e7cba9a4277","modified":1562465924838,"hash":"225b8a001c7aace46f2b39676e968e7cba9a4277"},{"_id":"themes/fexo/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1562465924837,"hash":"f921e7f9223d7c95165e0f835f353b2938e40c45"},{"_id":"themes/fexo/layout/_partial/load-script.ejs","shasum":"7ce6b4c901a012d0eaeb034ad0c1115a3be7d011","modified":1650419447802,"hash":"7ce6b4c901a012d0eaeb034ad0c1115a3be7d011"},{"_id":"themes/fexo/layout/_partial/style.ejs","shasum":"b3a5bbed9dbdba4934e9805a6d98fb7ff3ed040c","modified":1562465924838,"hash":"b3a5bbed9dbdba4934e9805a6d98fb7ff3ed040c"},{"_id":"themes/fexo/layout/about.ejs","shasum":"f1f06842f3fac2c7dd74811722431c5720e6cf8d","modified":1562465924839,"hash":"f1f06842f3fac2c7dd74811722431c5720e6cf8d"},{"_id":"themes/fexo/layout/index.ejs","shasum":"9d33cd03e7a8adf8bbc124c248def36c15e681d0","modified":1562465924840,"hash":"9d33cd03e7a8adf8bbc124c248def36c15e681d0"},{"_id":"themes/fexo/layout/category.ejs","shasum":"e8c8209f74ac0c96c29dbdff38d0f43664417342","modified":1562465924839,"hash":"e8c8209f74ac0c96c29dbdff38d0f43664417342"},{"_id":"themes/fexo/layout/archive.ejs","shasum":"9c22251c328e937c444a9f5d4b324f97a78d324f","modified":1562465924839,"hash":"9c22251c328e937c444a9f5d4b324f97a78d324f"},{"_id":"themes/fexo/layout/layout.ejs","shasum":"ae485be0f6c0c431245e0cac21dc109c9d0125e8","modified":1562465924840,"hash":"ae485be0f6c0c431245e0cac21dc109c9d0125e8"},{"_id":"themes/fexo/layout/link.ejs","shasum":"0144bdb1bc5f19763535b79b3302bf85bc0afbff","modified":1562465924840,"hash":"0144bdb1bc5f19763535b79b3302bf85bc0afbff"},{"_id":"themes/fexo/layout/post.ejs","shasum":"8cf15be489f8f3c11ac0215c16cbce36c854555f","modified":1562465924841,"hash":"8cf15be489f8f3c11ac0215c16cbce36c854555f"},{"_id":"themes/fexo/layout/project.ejs","shasum":"ea63f5ffda0d260b5dc2c2e852caddd082e37efa","modified":1562465924841,"hash":"ea63f5ffda0d260b5dc2c2e852caddd082e37efa"},{"_id":"themes/fexo/layout/search.ejs","shasum":"8c6fc59bed1facf14dd6a48bdf8dd44452583f4d","modified":1562465924841,"hash":"8c6fc59bed1facf14dd6a48bdf8dd44452583f4d"},{"_id":"themes/fexo/layout/tag.ejs","shasum":"ea8f39f11e6f8750edbf4130abf26168a403b1b4","modified":1562465924841,"hash":"ea8f39f11e6f8750edbf4130abf26168a403b1b4"},{"_id":"themes/fexo/package.json","shasum":"7e0642c0349ee1368304918d68c0a6a4f52aa435","modified":1562465924842,"hash":"7e0642c0349ee1368304918d68c0a6a4f52aa435"},{"_id":"themes/fexo/source/css/styles.css","shasum":"1c1062a8115827ce4b8ecd4e166abacf93e1e558","modified":1562465924843,"hash":"1c1062a8115827ce4b8ecd4e166abacf93e1e558"},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","shasum":"1cebcedde2c52261591bc322b176638798336a24","modified":1562465924866,"hash":"1cebcedde2c52261591bc322b176638798336a24"},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","shasum":"2b186ce205301f7f3abd441f0372b72adcd2aee3","modified":1562465924865,"hash":"2b186ce205301f7f3abd441f0372b72adcd2aee3"},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","shasum":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f","modified":1562465924862,"hash":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f"},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","shasum":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1562465924866,"hash":"4c7bcece73621f648fa71d58fa13c28670fed8ca"},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","shasum":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1562465924870,"hash":"ba50c427166090361b0dab4c72136c7b451e86d4"},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","shasum":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1562465924870,"hash":"1364845a3815740c572e29c83fd8d54f1c1ef5de"},{"_id":"themes/fexo/source/fonts/fontello.svg","shasum":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1","modified":1562465924871,"hash":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1"},{"_id":"themes/fexo/source/fonts/fontello.woff","shasum":"45737fea847f3942ef405f00ea4df940fbb6bbd9","modified":1562465924872,"hash":"45737fea847f3942ef405f00ea4df940fbb6bbd9"},{"_id":"themes/fexo/source/fonts/fontello.woff2","shasum":"1dfbc23328582f7cd9bcbe538224f6c762023e43","modified":1562465924873,"hash":"1dfbc23328582f7cd9bcbe538224f6c762023e43"},{"_id":"themes/fexo/source/images/avatar.jpg","shasum":"b7b97c6861cc09185eb148c096c61a1b3da68e5a","modified":1562467811322,"hash":"b7b97c6861cc09185eb148c096c61a1b3da68e5a"},{"_id":"themes/fexo/source/images/favicon.ico","shasum":"1bc51dc506b463f57ce91d15e28eb09bc23d374f","modified":1562467796751,"hash":"1bc51dc506b463f57ce91d15e28eb09bc23d374f"},{"_id":"themes/fexo/source/js/bundle.js","shasum":"8b64dd44eec4521f554323fc0a1dbb07f61dc678","modified":1562465924894,"hash":"8b64dd44eec4521f554323fc0a1dbb07f61dc678"},{"_id":"themes/fexo/source/js/app.js","shasum":"dca6a478f1ebfa27ea4bc36c0ab0692908705403","modified":1562465924894,"hash":"dca6a478f1ebfa27ea4bc36c0ab0692908705403"},{"_id":"themes/fexo/source/js/fastclick.js","shasum":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1562465924895,"hash":"06cef196733a710e77ad7e386ced6963f092dc55"},{"_id":"themes/fexo/source/js/sw-register.js","shasum":"c38ec52fe213cd819002c5ea8723b1abf54d15b7","modified":1650419447802,"hash":"c38ec52fe213cd819002c5ea8723b1abf54d15b7"},{"_id":"themes/fexo/source/js/scroll-spy.js","shasum":"cd7ba3d2982bc418d9eced6ef28bdcff83d4cb35","modified":1562465924895,"hash":"cd7ba3d2982bc418d9eced6ef28bdcff83d4cb35"},{"_id":"themes/fexo/source/js/util.js","shasum":"8136da2bec1faf5fe3e14fa436f501292fca8c07","modified":1562465924896,"hash":"8136da2bec1faf5fe3e14fa436f501292fca8c07"},{"_id":"themes/fexo/source/js/zenscroll.js","shasum":"bea2a3571555fdae64e8fc56f161f9a4f427b335","modified":1562465924896,"hash":"bea2a3571555fdae64e8fc56f161f9a4f427b335"},{"_id":"themes/fexo/source/sass/_animate.scss","shasum":"8de97c948cb4b9c9b7a87c0f7332ed534c378e26","modified":1562465924896,"hash":"8de97c948cb4b9c9b7a87c0f7332ed534c378e26"},{"_id":"themes/fexo/source/fonts/fontello.eot","shasum":"7732065eeaec4614e9548955d9bd30ccd7b149c1","modified":1562465924871,"hash":"7732065eeaec4614e9548955d9bd30ccd7b149c1"},{"_id":"themes/fexo/source/sass/_base.scss","shasum":"83f01dbe82e47ce781c6e7eb8a793d95d97e168b","modified":1562465924897,"hash":"83f01dbe82e47ce781c6e7eb8a793d95d97e168b"},{"_id":"themes/fexo/source/sass/_fontello.scss","shasum":"f2d6b86bb63459884cf63e8c045fd10c827396eb","modified":1562465924898,"hash":"f2d6b86bb63459884cf63e8c045fd10c827396eb"},{"_id":"themes/fexo/source/sass/_common.scss","shasum":"f1ad269b3c2902411dcae94a04cd27e710783de3","modified":1562465924897,"hash":"f1ad269b3c2902411dcae94a04cd27e710783de3"},{"_id":"themes/fexo/source/sass/_fonts.scss","shasum":"10e188d379782ae2ee10427544919557036d0137","modified":1562465924898,"hash":"10e188d379782ae2ee10427544919557036d0137"},{"_id":"themes/fexo/source/sass/_highlight-js.scss","shasum":"38a5c4d9f3a2943aff9bde1d624d710587e3bc05","modified":1562465924898,"hash":"38a5c4d9f3a2943aff9bde1d624d710587e3bc05"},{"_id":"themes/fexo/source/sass/_variable.scss","shasum":"7b05581ef035a88bd1191914ff992103c7812bdf","modified":1562465924900,"hash":"7b05581ef035a88bd1191914ff992103c7812bdf"},{"_id":"themes/fexo/source/sass/_normalize.scss","shasum":"e58275a588bb631a37a2988145eea231ed23176b","modified":1562465924899,"hash":"e58275a588bb631a37a2988145eea231ed23176b"},{"_id":"themes/fexo/source/sass/_type.scss","shasum":"cc7a25654593030f5214d5adf85f12a954c373c5","modified":1562465924899,"hash":"cc7a25654593030f5214d5adf85f12a954c373c5"},{"_id":"themes/fexo/source/sass/component/_back-top.scss","shasum":"1c67da7007f4b9d8c65deea3d82c0f579e65f2c2","modified":1562465924900,"hash":"1c67da7007f4b9d8c65deea3d82c0f579e65f2c2"},{"_id":"themes/fexo/source/sass/component/_category-box.scss","shasum":"a807145b74d1b98270ea19ae35edd25b4c448bfa","modified":1562465924901,"hash":"a807145b74d1b98270ea19ae35edd25b4c448bfa"},{"_id":"themes/fexo/source/sass/component/_comments.scss","shasum":"3e9b61bc08f38f947f54e942986a19a7f95ce723","modified":1562465924901,"hash":"3e9b61bc08f38f947f54e942986a19a7f95ce723"},{"_id":"themes/fexo/source/sass/component/_donation.scss","shasum":"d4d2d05e470978a38abf883be34ea2095132057a","modified":1562465924902,"hash":"d4d2d05e470978a38abf883be34ea2095132057a"},{"_id":"themes/fexo/source/sass/component/_hint.scss","shasum":"2812b4e10313168f2e082b740c60d64a151d94c8","modified":1562465924902,"hash":"2812b4e10313168f2e082b740c60d64a151d94c8"},{"_id":"themes/fexo/source/fonts/fontello.ttf","shasum":"e255d37ca14348e9a8532667a757ab552e58caff","modified":1562465924872,"hash":"e255d37ca14348e9a8532667a757ab552e58caff"},{"_id":"themes/fexo/source/sass/component/_index.scss","shasum":"a741a0bfb47d0acdef12cdeb968c104bb002f86d","modified":1562465924903,"hash":"a741a0bfb47d0acdef12cdeb968c104bb002f86d"},{"_id":"themes/fexo/source/sass/component/_item-category-name.scss","shasum":"119840d160cd263b57e79e2099a81079d7eeee3d","modified":1562465924903,"hash":"119840d160cd263b57e79e2099a81079d7eeee3d"},{"_id":"themes/fexo/source/sass/component/_item-post.scss","shasum":"1fb2e9be2d2edbb538cfbce7c80d5847f88e2f05","modified":1562465924904,"hash":"1fb2e9be2d2edbb538cfbce7c80d5847f88e2f05"},{"_id":"themes/fexo/source/sass/component/_item-title.scss","shasum":"cdaca2858abc9428ef01103a7fbea8f095d856aa","modified":1562465924905,"hash":"cdaca2858abc9428ef01103a7fbea8f095d856aa"},{"_id":"themes/fexo/source/sass/component/_list-post.scss","shasum":"43564f6443385bf34e15672d1477d1c7560f5563","modified":1562465924905,"hash":"43564f6443385bf34e15672d1477d1c7560f5563"},{"_id":"themes/fexo/source/sass/component/_item-year.scss","shasum":"12c147dd4ab9587cd622083c86c2f6cf07d8e26a","modified":1562465924905,"hash":"12c147dd4ab9587cd622083c86c2f6cf07d8e26a"},{"_id":"themes/fexo/source/sass/component/_page-header.scss","shasum":"893d0595ef48323dce449ef0d17308ce02b36087","modified":1562465924906,"hash":"893d0595ef48323dce449ef0d17308ce02b36087"},{"_id":"themes/fexo/source/sass/component/_pagination.scss","shasum":"12c1880c518aee2e3ccf59661d01c308639f8a9e","modified":1562465924906,"hash":"12c1880c518aee2e3ccf59661d01c308639f8a9e"},{"_id":"themes/fexo/source/sass/component/_table.scss","shasum":"4899fb31d1be8d5c9c397fcbcfc2ff0c5b2e7f7f","modified":1562465924907,"hash":"4899fb31d1be8d5c9c397fcbcfc2ff0c5b2e7f7f"},{"_id":"themes/fexo/source/sass/component/_modal.scss","shasum":"2f0ed96df388ec28445b1ce5c6a61a0a697f9a68","modified":1562465924906,"hash":"2f0ed96df388ec28445b1ce5c6a61a0a697f9a68"},{"_id":"themes/fexo/source/sass/component/_prev-net.scss","shasum":"634ef68823dda03bf9d42c740590581663c17351","modified":1562465924906,"hash":"634ef68823dda03bf9d42c740590581663c17351"},{"_id":"themes/fexo/source/sass/component/_tag-box.scss","shasum":"7601951d09a75a7c39493bfa1b1da5ac989d9cda","modified":1562465924907,"hash":"7601951d09a75a7c39493bfa1b1da5ac989d9cda"},{"_id":"themes/fexo/source/sass/component/_toolbox-mobile.scss","shasum":"f15b215b9bb103ee1773a01d8badd81bb7643710","modified":1562465924908,"hash":"f15b215b9bb103ee1773a01d8badd81bb7643710"},{"_id":"themes/fexo/source/sass/pages/_about.scss","shasum":"7d61e627ea5376390081e0b93db426ffc6c4dee8","modified":1562465924908,"hash":"7d61e627ea5376390081e0b93db426ffc6c4dee8"},{"_id":"themes/fexo/source/sass/component/_toc.scss","shasum":"3b4c083cb2ba4a88ca35b6d8259ee991c83b3406","modified":1562465924907,"hash":"3b4c083cb2ba4a88ca35b6d8259ee991c83b3406"},{"_id":"themes/fexo/source/sass/component/_toolbox.scss","shasum":"964a480d4e7fad100463195cde2a3f67f9765c23","modified":1562465924908,"hash":"964a480d4e7fad100463195cde2a3f67f9765c23"},{"_id":"themes/fexo/source/sass/pages/_archive.scss","shasum":"fefd54282a42ebb68b711f1cfefa1f67abbde05b","modified":1562465924909,"hash":"fefd54282a42ebb68b711f1cfefa1f67abbde05b"},{"_id":"themes/fexo/source/sass/pages/_category.scss","shasum":"713242d10c0c8687c9e2f287f1beeb38de6cdbad","modified":1562465924909,"hash":"713242d10c0c8687c9e2f287f1beeb38de6cdbad"},{"_id":"themes/fexo/source/sass/pages/_home.scss","shasum":"b65bb069ed28fbf223c5bb7e760882f79d20fa46","modified":1562465924909,"hash":"b65bb069ed28fbf223c5bb7e760882f79d20fa46"},{"_id":"themes/fexo/source/sass/pages/_index.scss","shasum":"d9fe73a87585abad06a7dd77b67ec7ce6c24402c","modified":1562465924910,"hash":"d9fe73a87585abad06a7dd77b67ec7ce6c24402c"},{"_id":"themes/fexo/source/sass/pages/_post.scss","shasum":"c6f694568af362f9fe1e7e2b9909e47303178116","modified":1562465924911,"hash":"c6f694568af362f9fe1e7e2b9909e47303178116"},{"_id":"themes/fexo/source/sass/pages/_link.scss","shasum":"d3a249423c7ee88d1cb3a12e03f6c42a0a4d45a1","modified":1562465924910,"hash":"d3a249423c7ee88d1cb3a12e03f6c42a0a4d45a1"},{"_id":"themes/fexo/source/sass/pages/_project.scss","shasum":"cab0947fc9d7926a07badaa567803cc7a0968f10","modified":1562465924911,"hash":"cab0947fc9d7926a07badaa567803cc7a0968f10"},{"_id":"themes/fexo/source/sass/pages/_search.scss","shasum":"fd28f01829628c9d21f9391d5067ddcd836dad13","modified":1562465924911,"hash":"fd28f01829628c9d21f9391d5067ddcd836dad13"},{"_id":"themes/fexo/source/sass/styles.scss","shasum":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be","modified":1562465924912,"hash":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be"},{"_id":"themes/fexo/source/sw.js","shasum":"590bc1e2076ce80613c1797771aa962500cc0b6b","modified":1650419447802,"hash":"590bc1e2076ce80613c1797771aa962500cc0b6b"},{"_id":"source/image/blog/79702-d66ee9d1fd912b33.jpg","shasum":"327ef3be9eaa9d570b2e279d6e2fb9f25106a82e","modified":1486047205000,"hash":"327ef3be9eaa9d570b2e279d6e2fb9f25106a82e"},{"_id":"source/image/blog/imgFile1412168419938.jpg","shasum":"b53e4c388cad1d47e9563e4e94132e5185a97057","modified":1486047205000,"hash":"b53e4c388cad1d47e9563e4e94132e5185a97057"},{"_id":"source/image/blog/imgFile1412168441331.jpg","shasum":"a102efc197f5f290516316323d00f760fb5bda21","modified":1486047205000,"hash":"a102efc197f5f290516316323d00f760fb5bda21"},{"_id":"source/image/blog/imgFile1412168553899.jpg","shasum":"ecbc7f8cd2d4fd5458ed7a66572f8cc249c09334","modified":1486047205000,"hash":"ecbc7f8cd2d4fd5458ed7a66572f8cc249c09334"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg","shasum":"c066d3bf30b582c088ec0ff5c39d9d1b0c8ef520","modified":1486047205000,"hash":"c066d3bf30b582c088ec0ff5c39d9d1b0c8ef520"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg","shasum":"6a258996a300f1da8215fc59445d10ed22243843","modified":1486047205000,"hash":"6a258996a300f1da8215fc59445d10ed22243843"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg","shasum":"e808f11256c83a5f56aafa2b6dd8866aa39fd29f","modified":1486047205000,"hash":"e808f11256c83a5f56aafa2b6dd8866aa39fd29f"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg","shasum":"aaf5f88a18f3dc9554fd69ff3ecda8c277799c1c","modified":1486047205000,"hash":"aaf5f88a18f3dc9554fd69ff3ecda8c277799c1c"},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg","shasum":"5d7f7f6e62f9a832af44afc4b89ae97775992a3f","modified":1486215415000,"hash":"5d7f7f6e62f9a832af44afc4b89ae97775992a3f"},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg","shasum":"78dbefd05cce7898df2da0b179d3535e185adee8","modified":1486215415000,"hash":"78dbefd05cce7898df2da0b179d3535e185adee8"},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg","shasum":"ec96ec66b1c84e658e245be91110320f19555b5b","modified":1486215415000,"hash":"ec96ec66b1c84e658e245be91110320f19555b5b"},{"_id":"themes/fexo/source/css/styles.css.map","shasum":"9672a4e5f8c6e9742095c1ca33f1c68b3145a7e3","modified":1562465924845,"hash":"9672a4e5f8c6e9742095c1ca33f1c68b3145a7e3"},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","shasum":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1562465924869,"hash":"4688935c427ae40dcbf16523bc11d9fc10e359b5"},{"_id":"source/image/blog/imgFile1412168471850.jpg","shasum":"3e80fe9317e3ffb83cacb0cb221997239b3e266b","modified":1486047205000,"hash":"3e80fe9317e3ffb83cacb0cb221997239b3e266b"},{"_id":"source/image/blog/imgFile1412168592404.jpg","shasum":"42332077b117269f80c6b67956f3be5fbae7381a","modified":1486047205000,"hash":"42332077b117269f80c6b67956f3be5fbae7381a"},{"_id":"source/image/blog/imgFile1412168871884.jpg","shasum":"99f1bca6f95282e7d3c8b5207b9abe56c3dc0df9","modified":1486047205000,"hash":"99f1bca6f95282e7d3c8b5207b9abe56c3dc0df9"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg","shasum":"ffb8ddfb41ea9a89b391c70a98fcf24883ef7d25","modified":1486047205000,"hash":"ffb8ddfb41ea9a89b391c70a98fcf24883ef7d25"},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg","shasum":"6ad1dd6ae6893416076b8577d5dfb1699a754905","modified":1486215415000,"hash":"6ad1dd6ae6893416076b8577d5dfb1699a754905"},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","shasum":"e21109783f218cb7849b12e867e0b775ce3fadda","modified":1562465924864,"hash":"e21109783f218cb7849b12e867e0b775ce3fadda"},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","shasum":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67","modified":1562465924868,"hash":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67"},{"_id":"themes/fexo/yarn.lock","shasum":"4c334209995c83f4c60032fc3ecb2a395ba38be3","modified":1562465924913,"hash":"4c334209995c83f4c60032fc3ecb2a395ba38be3"},{"_id":"source/image/blog/about-communicate/DraggedImage-1.png","shasum":"9c75c6404b843f40e6de9a02d221e951613530ce","modified":1555148383463,"hash":"9c75c6404b843f40e6de9a02d221e951613530ce"},{"_id":"source/image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg","shasum":"815f173caef5df64955e7bc5eb06da1a0f5cdd34","modified":1486047205000,"hash":"815f173caef5df64955e7bc5eb06da1a0f5cdd34"},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg","shasum":"a3ceddd956d7fcc0734608c2c07231b228f7b15b","modified":1486215415000,"hash":"a3ceddd956d7fcc0734608c2c07231b228f7b15b"},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg","shasum":"4936bfbdf0d1e969f0c71de032b89d5df8439cd6","modified":1486215415000,"hash":"4936bfbdf0d1e969f0c71de032b89d5df8439cd6"},{"_id":"source/image/blog/memory-in-nodejs/Chrome Profile.jpg","shasum":"8b40dcb35047089cfefc0e6df2f4d0486d7057e0","modified":1486047205000,"hash":"8b40dcb35047089cfefc0e6df2f4d0486d7057e0"},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg","shasum":"d55dbe18ade80c0bba080f7aab3e1be07b36af43","modified":1486215415000,"hash":"d55dbe18ade80c0bba080f7aab3e1be07b36af43"},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg","shasum":"cf15edd89c2d929a515b3ff0005a2515493ca79d","modified":1486215415000,"hash":"cf15edd89c2d929a515b3ff0005a2515493ca79d"},{"_id":"themes/fexo/source/images/qr-alipay.png","shasum":"e136ec9000cc6f9a219abaef7877bc0a46206b1f","modified":1562490326917,"hash":"e136ec9000cc6f9a219abaef7877bc0a46206b1f"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg","shasum":"f723e8e46b7d01983901afe6cf925b152a1ca18c","modified":1486047205000,"hash":"f723e8e46b7d01983901afe6cf925b152a1ca18c"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg","shasum":"7101047022342969f633dbadd4f6fe796e36add8","modified":1486047205000,"hash":"7101047022342969f633dbadd4f6fe796e36add8"},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg","shasum":"c03cfd4a333e24ebc1ff86fd313c711d7e92d963","modified":1486047205000,"hash":"c03cfd4a333e24ebc1ff86fd313c711d7e92d963"},{"_id":"themes/fexo/source/images/qr-wechat.jpg","shasum":"f405abc209e214d2c3c521ac3987959c65870b15","modified":1562490403879,"hash":"f405abc209e214d2c3c521ac3987959c65870b15"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg","shasum":"498768a0462d7d20bcf2e9849b97c7e01c665151","modified":1486047205000,"hash":"498768a0462d7d20bcf2e9849b97c7e01c665151"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg","shasum":"d5181add5da735b87267fc1269a2b6dce5cae619","modified":1486047205000,"hash":"d5181add5da735b87267fc1269a2b6dce5cae619"},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg","shasum":"c241a425cf59f461b33f6cca7d99c13528d9f7a2","modified":1486215415000,"hash":"c241a425cf59f461b33f6cca7d99c13528d9f7a2"},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg","shasum":"4f4565e650b1ae3485c514a17cc3368a25bbfbdd","modified":1486215415000,"hash":"4f4565e650b1ae3485c514a17cc3368a25bbfbdd"},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","shasum":"4f0c85f63beb0d95610317e16f1d4acdd2962eee","modified":1562465924849,"hash":"4f0c85f63beb0d95610317e16f1d4acdd2962eee"},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","shasum":"298b80b1c9f694e1a055d62a5d809863c89baf50","modified":1562465924861,"hash":"298b80b1c9f694e1a055d62a5d809863c89baf50"},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","shasum":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f","modified":1562465924858,"hash":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f"},{"_id":"source/image/blog/imgFile1412172691061.jpeg","shasum":"2cc9735fef8ed5fc27ea1348cdf4be3e6bb9e5b9","modified":1486047205000,"hash":"2cc9735fef8ed5fc27ea1348cdf4be3e6bb9e5b9"},{"_id":"source/image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg","shasum":"7e9f7eef4724b0497d522262e396360caad17234","modified":1486047205000,"hash":"7e9f7eef4724b0497d522262e396360caad17234"},{"_id":"source/image/blog/imgFile1412172732788.jpg","shasum":"c9000526a5451475b95f060de359dfba87c7ff22","modified":1486047205000,"hash":"c9000526a5451475b95f060de359dfba87c7ff22"},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","shasum":"be1cab622c673942fb4d11a23c012227938b4792","modified":1562465924854,"hash":"be1cab622c673942fb4d11a23c012227938b4792"},{"_id":"source/image/blog/about-communicate/DraggedImage.png","shasum":"dffa4b7a37f73555a5889767dae512363f587cde","modified":1555148383573,"hash":"dffa4b7a37f73555a5889767dae512363f587cde"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif","shasum":"add32ba300895037b01b0906932ca7546897b954","modified":1486047205000,"hash":"add32ba300895037b01b0906932ca7546897b954"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif","shasum":"6968b32dc2c717a05db2102b10516fc3075c06ae","modified":1486047205000,"hash":"6968b32dc2c717a05db2102b10516fc3075c06ae"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif","shasum":"3d2463493d7ba19f6222bce70c7f094e5e6fd319","modified":1486047205000,"hash":"3d2463493d7ba19f6222bce70c7f094e5e6fd319"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif","shasum":"8e86ad70d0af226cd59667b7d0c419cf2a40d483","modified":1486047205000,"hash":"8e86ad70d0af226cd59667b7d0c419cf2a40d483"},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif","shasum":"9c7256ff02cb93df14db78ce7a091b2c564a6261","modified":1486047205000,"hash":"9c7256ff02cb93df14db78ce7a091b2c564a6261"},{"_id":"public/tag/index.html","hash":"415823d23f1d839d3f829f18a2e63804757114a4","modified":1694667417935},{"_id":"public/link/index.html","hash":"85d6c5803da6a7b7945443fd9c68df3e8a85de5f","modified":1692588607932},{"_id":"public/css/personal-style.css","hash":"5dca9ce8d8d1f710c3c0cbeb3d9129061cae28d8","modified":1650426512070},{"_id":"public/category/index.html","hash":"a2bdba218eff8fe259b049ade35614dec41f88de","modified":1694667417935},{"_id":"public/about/index.html","hash":"9d319c0c549a9e991ebf41544bba924496a527aa","modified":1692588607932},{"_id":"public/2022/04/20/build-a-extensible-reliable-controllable-PWA-app/index.html","modified":1650426006116,"shasum":"b54715a34c815b2f1f96f08e1742c7f484f1fc20"},{"_id":"public/2022/03/30/a-thinking-on-insomnia-night/index.html","modified":1650426006120,"shasum":"a887d3aeec4b5beaffce8241d83bfb55b6754fab"},{"_id":"public/2021/03/21/wxapp-router-experience/index.html","modified":1650426006147,"shasum":"a28e487b40b680f3b0c13d475ddf31d8fd6c3917"},{"_id":"public/2021/01/28/github-workflow/index.html","modified":1650426006155,"shasum":"92d337539683866171712f20435ec7462aeb4837"},{"_id":"public/2021/01/28/method-fuse/index.html","modified":1650426006164,"shasum":"fed6d29cae80a68bedae994f8b996e209a19e46a"},{"_id":"public/2020/10/16/wxapp-login-design/index.html","modified":1650426006208,"shasum":"69b4f03082302475cf99382f3610feb883dfd6e7"},{"_id":"public/2019/07/06/about-okr/index.html","hash":"e18f2b22e7028d8c1599b74d7089ae55d63d5f75","modified":1692588607932},{"_id":"public/2019/06/11/beautywe-intro/index.html","hash":"672d60c30da3780ace2a60d6f599a8e91364be66","modified":1692588607932},{"_id":"public/2019/04/13/about-communicate/index.html","hash":"bc6c4f112a70b64f3a8857db33d01bfab0b45b29","modified":1692588607932},{"_id":"public/2019/03/21/management-of-common-sense-1/index.html","hash":"16e7a5c272e6ba2ed0c55141c36b33ec947e28cd","modified":1692588607932},{"_id":"public/2018/05/02/use-npm-in-weapp/index.html","hash":"04ac3eefc89426ba4c8b58aa7629b60a9b287bdc","modified":1692588607932},{"_id":"public/2017/11/01/change-and-its-detection-in-javascript-frameworks/index.html","hash":"29500a938275262ab950ed3658940961807a0fcb","modified":1692588607932},{"_id":"public/2017/08/31/yz-share-about-wxapp--cencept/index.html","hash":"cf1223ac63fd8b143c152fdd989b6ca730429ad8","modified":1692588607932},{"_id":"public/2017/07/15/understand-this-of-javascript/index.html","hash":"34aff087767e5b1a7bcd723ec2d340837208b3b7","modified":1692588607932},{"_id":"public/2017/05/21/talk-about-pixel-and-rpx/index.html","hash":"b9116e4b5ff93bccf4126bdec0272171247a2e52","modified":1692588607932},{"_id":"public/2017/05/04/reconsidering-for-2017-Q1/index.html","hash":"385183ddecc943ff02824eee9ada256bda2fc34e","modified":1692588607932},{"_id":"public/2017/03/17/the-memeye/index.html","hash":"df14ec5294c7487f3f760095d60b239932e6f8f8","modified":1692588607932},{"_id":"public/2017/03/02/understand-udp/index.html","hash":"4551fbe9e3bed1391b719e69a60f3f46d8a951f8","modified":1692588607932},{"_id":"public/2017/03/02/understand-tcp-6/index.html","hash":"56f8ebc3b4ea30f2b457917d82c8b1c8aaca2261","modified":1692588607932},{"_id":"public/2017/03/02/understand-tcp-5/index.html","hash":"ef9527f512d6f62f8ccb7682db843ef995e50160","modified":1692588607932},{"_id":"public/2017/03/02/understand-tcp-4/index.html","hash":"d05d12fdc38d021237dae6366080eac8d36dd10a","modified":1692588607932},{"_id":"public/2017/03/02/understand-tcp-3/index.html","hash":"a34566edeac1e35624a4163ff0fb01241fd575e9","modified":1692588607932},{"_id":"public/2017/03/02/understand-tcp-2/index.html","hash":"e3ee69c8eb5c12c0258401bdb99e77353044dcb7","modified":1692588607932},{"_id":"public/2017/03/02/understand-tcp-1/index.html","hash":"1f4efbaaa5d51ac14be1003cfc98423f01841bdc","modified":1692588607932},{"_id":"public/2017/02/28/gulp-base/index.html","hash":"88d60c9b30fcd96c509619dfe19deba32a304e6f","modified":1692588607932},{"_id":"public/2017/01/25/the-winter-and-summer-of-Meizu/index.html","hash":"ff3a24bf1cbcb890d9696d9f80bb1d8fe2859e67","modified":1692588607932},{"_id":"public/2016/11/27/keep-focus-and-efficiency/index.html","hash":"b709390616fccd588afb014572975c28b70630bf","modified":1692588607932},{"_id":"public/2016/11/20/do-you-konw-the-different-between-compiler-and-interpreter/index.html","hash":"6ff2a046d85911706ddd262806b6217aa2074a67","modified":1692588607932},{"_id":"public/2016/11/08/the-v8-what-javascripter-should-konw-of-v8-in-nodejs/index.html","hash":"70cd8404dc95aa3b947b5534f9f3846cf0c76c48","modified":1692588607932},{"_id":"public/2016/10/14/了解 Nginx 的基本概念/index.html","hash":"ec1b26ac18cdc5b0d83224ad7391946a7c277d67","modified":1692588607932},{"_id":"public/2016/08/30/何为技术人的核心竞争力/index.html","hash":"3ed2427bda37006f917470ecce54e3a64163b923","modified":1692588607932},{"_id":"public/2016/08/11/打造高效个性Terminal（二）之 zsh/index.html","hash":"331145e2e26ede3c6a607b165899948b03df70d4","modified":1692588607932},{"_id":"public/2016/08/11/打造高效个性Terminal（一）之 iTerm/index.html","hash":"cee139a4a72a45a4ce9a6378ff6146e0592239c3","modified":1692588607932},{"_id":"public/2016/07/07/读《重来》/index.html","hash":"9dfd4a811cd71e82674f750b9d45f233d6f03b77","modified":1692588607932},{"_id":"public/2016/06/28/JavaScript原型中的哲学思想/index.html","hash":"05b8c8f7bda8a6371a61f170b859619031b867d6","modified":1692588607932},{"_id":"public/2016/06/19/「ES6笔记」 Babel/index.html","hash":"88fafeb9d6810ef2bffe650a41e6ac76b23149b9","modified":1692588607932},{"_id":"public/2016/05/28/下雨天的夜晚，特别容易失眠/index.html","hash":"1eb8c6f2185e05bb8decbd5d55c5b1f7c3d063a4","modified":1692588607932},{"_id":"public/2016/05/22/「理解HTTP」之常见的状态码/index.html","hash":"fba1c27ed3653a91325cd8bdcc7378f9e9cb650a","modified":1692588607932},{"_id":"public/2016/05/15/理解 CORS (Cross-Origin Resource Sharing)/index.html","hash":"95d46b3a92da31ac9d98e23e3977ca3e4e9405b5","modified":1692588607932},{"_id":"public/2016/04/14/NodeJS中被忽略的内存/index.html","hash":"662c5deec97b90c58c8b7fcd23fccff6b448fa6f","modified":1692588607932},{"_id":"public/2016/03/15/何为语法树/index.html","hash":"336c71bc4b8e49f9bc4753e955fe47ff2a2ce040","modified":1692588607932},{"_id":"public/2016/01/28/二零一六年一月二十八日，于珠海/index.html","hash":"0119b53a35358b492165367beabf545ee96f8351","modified":1692588607932},{"_id":"public/2016/01/15/如果你用GitHub，可以这样提高效率/index.html","hash":"d44bb767b1203564323bc0f83065ff12f3cf5277","modified":1692588607932},{"_id":"public/2015/12/30/那一夜独处/index.html","hash":"9cf2f3797de375154325d852f5aafc05f74b40e4","modified":1692588607932},{"_id":"public/2015/12/14/登录那些事儿/index.html","hash":"5d19d8efdaf1bc6adcf802c9a28f1304fd496d7b","modified":1692588607932},{"_id":"public/2015/11/15/消息系统设计与实现「下篇」/index.html","hash":"fc1d9609ce122d75223d5a3ca127754e2da0b31f","modified":1692588607932},{"_id":"public/2015/10/14/消息系统设计与实现「上篇」/index.html","hash":"e674064961cc58e63869083f4e63cc12b8681740","modified":1692588607932},{"_id":"public/2015/09/14/单点登录的三种实现方式/index.html","hash":"1bb60954fb1e29881ec75b965287ce4dc7ac0488","modified":1692588607932},{"_id":"public/2015/07/30/在Nodejs中贯彻单元测试/index.html","hash":"d0d82c958112e4adce0abd16813d18baaaa7b6b4","modified":1692588607932},{"_id":"public/2015/07/14/Session原理/index.html","hash":"429591a88211afc85a2e47cb4b152737f58940b1","modified":1692588607932},{"_id":"public/2015/04/25/为什么使用Sails/index.html","hash":"c6db3876790fdc8c5ea28cdae29256ac94a76ecc","modified":1692588607932},{"_id":"public/2015/03/29/基于RESTful-API-怎么设计用户权限控制/index.html","hash":"221d8e1c893bf7d8cd86d586031b29df7504136f","modified":1692588607932},{"_id":"public/2015/03/03/盘点国内的那些ROM/index.html","hash":"32eea47e6e982f48e43c8bfc8d6026b42616b5a3","modified":1692588607932},{"_id":"public/2015/01/29/My-Nodejs-Tool-Kit/index.html","hash":"e7d650653a4fa1c4a3f28776d5160d5535011eaa","modified":1692588607932},{"_id":"public/2015/01/12/SOAP-Web-Service的枢纽/index.html","hash":"b1b8929a90363ed87e0570127e2b6670984e99d1","modified":1692588607932},{"_id":"public/2014/07/19/HTML-CSS-JS打造Windows桌面版《2048》/index.html","hash":"8bdbc6fa6c99d2aa8b107179f324ab31b10cdfe4","modified":1692588607932},{"_id":"public/2014/07/12/基于jQuery的2048游戏/index.html","hash":"4d9c67b83f5502c710f0be159c185be9661e5109","modified":1692588607932},{"_id":"public/2014/07/12/原生JavaScript实现拖拽效果/index.html","hash":"9dd7eed4f5bb780b9e7da0020d167c3665697dfc","modified":1692588607932},{"_id":"public/2014/07/08/Javascript那些书籍/index.html","hash":"3f5f3bca5bef6ff0be79b1ffc1d52940b72208c6","modified":1692588607932},{"_id":"public/2013/08/07/iframe-在IE下透明背景/index.html","hash":"aad4bd1f6d245545c6b5fc0e5346436e2f94c1ab","modified":1692588607932},{"_id":"public/2013/07/21/jQuery动画反方向延伸/index.html","hash":"f5dd748c5f3ee5695217e9563ebccd2585a6fd9f","modified":1692588607932},{"_id":"public/2013/07/21/Kissy-WaterFall-实现手动加载数据/index.html","hash":"4af0e22c7de08c2c26f9b26ca36266f34df59887","modified":1692588607932},{"_id":"public/2013/03/07/Kissy-WaterFall-静态调用/index.html","hash":"629ff7aa065d1587a68d00a14fc8bf472eedfb2a","modified":1692588607932},{"_id":"public/categories/搬砖码农/index.html","hash":"4188d75cfe1c5270e831c59d244c235fef4e9da6","modified":1694667417935},{"_id":"public/categories/三省吾身/index.html","hash":"b34a418b91b4fddaa21065bba836327062f9b483","modified":1694667417935},{"_id":"public/categories/人丑就要多读书/index.html","hash":"1477bca716310a253e17523471d8c396a22700cf","modified":1694667417935},{"_id":"public/archives/index.html","hash":"aa1096d76695d167a1f71014d0a3bc775ffd170b","modified":1694667417935},{"_id":"public/archives/2013/index.html","hash":"2378332b199eef53713183ca1124ed7057c3ad9f","modified":1692588607932},{"_id":"public/archives/2013/03/index.html","hash":"8d2c7a98cdde654f1434976e500886bb4e92652e","modified":1692588607932},{"_id":"public/archives/2013/07/index.html","hash":"79eab3aa39080126d4ad1c2b6079681e4518cd89","modified":1692588607932},{"_id":"public/archives/2013/08/index.html","hash":"8f2b0cb144c18ee45edb8514f4f4fcde940d190b","modified":1692588607932},{"_id":"public/archives/2014/index.html","hash":"c2de755349771d1cf8c30fb6b53b245b35f5ba5f","modified":1692588607932},{"_id":"public/archives/2014/07/index.html","hash":"10e8813dfb4839cfc596bcb9677b62a8d652d0c9","modified":1692588607932},{"_id":"public/archives/2015/index.html","hash":"f17c0be9ed4e3f0f3c4903fb65bb24d10df8ae5d","modified":1692588607932},{"_id":"public/archives/2015/01/index.html","hash":"eebc9cdddf516caeddb50393bfba174a606891e0","modified":1692588607932},{"_id":"public/archives/2015/03/index.html","hash":"b3752f85488a16c585ad32e731f6d481b7564692","modified":1692588607932},{"_id":"public/archives/2015/04/index.html","hash":"fbd0115a9eb96f00941550fabe61944381475e5b","modified":1692588607932},{"_id":"public/archives/2015/07/index.html","hash":"8153f20433a8cb5b4320fa6e89f3246d1a7104a7","modified":1692588607932},{"_id":"public/archives/2015/09/index.html","hash":"d9fce037874d529342fffac15eb83711ae203af4","modified":1692588607932},{"_id":"public/archives/2015/10/index.html","hash":"53c37ea424d7968be446fe743690c806392b5975","modified":1692588607932},{"_id":"public/archives/2015/11/index.html","hash":"cb25ea73ff5e14194c84acdf8ed8a6cb91254558","modified":1692588607932},{"_id":"public/archives/2015/12/index.html","hash":"cf938af308ffde218ebefbc27cbcfccaeb0895db","modified":1692588607932},{"_id":"public/archives/2016/index.html","hash":"1791a04d9b49e3477a67444b11b799df1559d69b","modified":1692588607932},{"_id":"public/archives/2016/01/index.html","hash":"6fe8d053328ef94cad636c290d4923e909a835f2","modified":1692588607932},{"_id":"public/archives/2016/03/index.html","hash":"b8aeb97592545d6997abcbc293fa97bde48d9e44","modified":1692588607932},{"_id":"public/archives/2016/04/index.html","hash":"8631c2aa0f36a17c795686723b4608c67ac4ffd0","modified":1692588607932},{"_id":"public/archives/2016/05/index.html","hash":"8aed2d78994b75d544d9a073ef8fc235f5c7b9c5","modified":1692588607932},{"_id":"public/archives/2016/06/index.html","hash":"44b3cd1669329df7efc32a018e401ef91cc07729","modified":1692588607932},{"_id":"public/archives/2016/07/index.html","hash":"fc25c54bdd033385dbf8f184569f24114bc940d1","modified":1692588607932},{"_id":"public/archives/2016/08/index.html","hash":"a17fa0fbecb61a64f5b659a887e812a0442b992d","modified":1692588607932},{"_id":"public/archives/2016/10/index.html","hash":"1f174cb2f176a62eedf5b2c8bc4ac662f11ca60d","modified":1692588607932},{"_id":"public/archives/2016/11/index.html","hash":"debb50cf0cc77a46ad70d683ab557cddeb658c9c","modified":1692588607932},{"_id":"public/archives/2017/index.html","hash":"3365a4bf637a7a6aa8b95e1bc4aada22c476aa14","modified":1692588607932},{"_id":"public/archives/2017/01/index.html","hash":"3d06bf857195a59fb69687b87040a13a617aaaa9","modified":1692588607932},{"_id":"public/archives/2017/02/index.html","hash":"2551c672c48d404fa9f009a23f39905330465a60","modified":1692588607932},{"_id":"public/archives/2017/03/index.html","hash":"837083e73a4e3d3be443585a59f2bbe2ad5dd721","modified":1692588607932},{"_id":"public/archives/2017/05/index.html","hash":"a259c9cad494b5a476a9c0a2d14487098757398b","modified":1692588607932},{"_id":"public/archives/2017/07/index.html","hash":"52dfc6ac43b81851de865b48cdc235bd01dc87a4","modified":1692588607932},{"_id":"public/archives/2017/08/index.html","hash":"c092e2b8a70715a63fb2b064f13d9186fd9ebde8","modified":1692588607932},{"_id":"public/archives/2017/11/index.html","hash":"c5513b3cc2779f322bdfc517e36232a9ed4669a2","modified":1692588607932},{"_id":"public/archives/2018/index.html","hash":"bb48bb422f2c788589cecb9ffe3088dc21fea9a2","modified":1692588607932},{"_id":"public/archives/2018/05/index.html","hash":"d0a5cdfa6152b3d0b61ce7ce99f49f1cc4e8a6fd","modified":1692588607932},{"_id":"public/archives/2019/index.html","hash":"2feaa4bb1221aeea0535559544b717e8de931e4a","modified":1692588607932},{"_id":"public/archives/2019/03/index.html","hash":"ebaf94a841d38684ea7677708e4833cd1019880a","modified":1692588607932},{"_id":"public/archives/2019/04/index.html","hash":"85b11c6881a8c0a2a4340e2e7c7c6b0ffb2840dd","modified":1692588607932},{"_id":"public/archives/2019/06/index.html","hash":"7c16772a6ef62c90ff4e8fa55839ef7a768ec10c","modified":1692588607932},{"_id":"public/archives/2019/07/index.html","hash":"922b624a7f0a2939248ed2e45c90d949aeced634","modified":1692588607932},{"_id":"public/archives/2020/index.html","hash":"c7d4a7106aa454e2b33539ac65c859d10100195c","modified":1692588607932},{"_id":"public/archives/2020/10/index.html","hash":"852a676e5a336e7ddcbc2d380b6961feb87264a6","modified":1692588607932},{"_id":"public/archives/2021/index.html","hash":"055489d627c74a586fecff79412ef229429995b6","modified":1692588607932},{"_id":"public/archives/2021/01/index.html","hash":"d02fb047234ab10470ba323722a2cb15d24ec009","modified":1692588607932},{"_id":"public/archives/2021/03/index.html","hash":"e91a5a6e0946a741057360107e37107cfeb5dd60","modified":1692588607932},{"_id":"public/archives/2022/index.html","hash":"4660371eb0c4b357a6bdd631e5e59296d21373aa","modified":1692588607932},{"_id":"public/archives/2022/03/index.html","modified":1650426006889,"shasum":"62eaef827878a43f760f52eb76741c78b3efdbe7"},{"_id":"public/archives/2022/04/index.html","hash":"93b8f41eb9937fe3fda6ef52d0b843055591e867","modified":1692588607932},{"_id":"public/atom.xml","hash":"3202e582ef29f2bf0c0f4172b6ecb86f8e214f22","modified":1694667417935},{"_id":"public/tags/HTML/index.html","hash":"174b7a4ac1a49a25b54b146a977b4b5b34fa3eea","modified":1694667417935},{"_id":"public/tags/CSS/index.html","hash":"d868a8035568c59f4f441a92167a4f0f3ae13f87","modified":1694667417935},{"_id":"public/tags/Javascript/index.html","hash":"236b1c9b1f8bd79859da83619c8f6bbbd20e63e9","modified":1694667417935},{"_id":"public/tags/node-webkit/index.html","hash":"364ef909fba24715cecd1e055f030d02859722a7","modified":1694667417935},{"_id":"public/tags/读书笔记/index.html","hash":"db7c2d3d79b3b2eda149073a3654725783c33b4e","modified":1694667417935},{"_id":"public/tags/ROM/index.html","hash":"9b6b4056bd998b055cf3c36b14c1f423fc90825c","modified":1694667417935},{"_id":"public/tags/单点登录/index.html","hash":"fbf411f9a829744fdee42407867f9cafaa980d30","modified":1694667417935},{"_id":"public/tags/cookie/index.html","hash":"95d6cc6a5e384f9e61378b54bafd3481fba73a97","modified":1694667417935},{"_id":"public/tags/session/index.html","hash":"8fb4c6f4126afa0f88e1ed0726229ec34af64dcb","modified":1694667417935},{"_id":"public/tags/Nodejs/index.html","hash":"2ea51a7a6011ae8c3c3da35123edb8c254cb1557","modified":1694667417935},{"_id":"public/tags/http/index.html","hash":"f20526672506448961dc6fdbf21096a70368c433","modified":1694667417935},{"_id":"public/tags/cors/index.html","hash":"52cc140118507e40ad96c41811debc0acdb28548","modified":1694667417935},{"_id":"public/tags/架构/index.html","hash":"e38749c109fa584844728c20163ebede9941919b","modified":1694667417935},{"_id":"public/tags/消息系统/index.html","hash":"8ea943a20633edb4439d5e4988fc6476abffaa0f","modified":1694667417935},{"_id":"public/tags/Tool-Kit/index.html","hash":"1046d229780b82e554242be8a9abe862f5f89870","modified":1694667417935},{"_id":"public/tags/RESTful/index.html","hash":"31b94fbc57d0f2691c00bcc90d6c1bc71d887751","modified":1694667417935},{"_id":"public/tags/权限系统/index.html","hash":"ddefa34e3594790febc4fa5baeb7a56f6b7ad48b","modified":1694667417935},{"_id":"public/tags/mocha/index.html","hash":"ec7665081314cd20b6387eaf42ca119da89db816","modified":1694667417935},{"_id":"public/tags/unit-test/index.html","hash":"f5948ae6da48dbb2ae749896480b1dece79ab3da","modified":1694667417935},{"_id":"public/tags/语法树/index.html","hash":"98e270fb75d6c896e74cbe77ea9ffe482085b4ab","modified":1694667417935},{"_id":"public/tags/Nginx/index.html","hash":"047e45410d021bafb74ae85b8d14c47e517ff830","modified":1694667417935},{"_id":"public/tags/SailsJS/index.html","hash":"fefdb0816a778bf2cf38de08e434c9aa1faf5fff","modified":1694667417935},{"_id":"public/tags/babel/index.html","hash":"892e8a1355ddc66df1dbf3534c3dbdf80d209226","modified":1694667417935},{"_id":"public/tags/ES6/index.html","hash":"640c81a8c798dcf2459fd759536b0fd9271964d1","modified":1694667417935},{"_id":"public/tags/小程序/index.html","hash":"60588d3b09a6cfc5e711614f60a5fd123982a04e","modified":1694667417935},{"_id":"public/tags/微信小程序/index.html","hash":"a060dcec21579720336f4fbbde1498ce6bf585b8","modified":1694667417935},{"_id":"public/tags/登录-微信小程序/index.html","hash":"189c45fc52b4f17306203d7181d9ce046a997e9b","modified":1694667417935},{"_id":"public/tags/udp/index.html","hash":"0a452e8deffc50699d55a0a2a0a7928aa4ccd41b","modified":1694667417935},{"_id":"public/tags/javascript/index.html","hash":"373b1339ae1f2b6fa304ea2bae3ac41ff4aadff1","modified":1694667417935},{"_id":"public/tags/tcp/index.html","hash":"49a68745c8e85cc41504a7d65a018332bbea9e3f","modified":1694667417935},{"_id":"public/tags/v8/index.html","hash":"b7a5ac7ffc02038bc654a85587fd4c7e417b1d4a","modified":1694667417935},{"_id":"public/tags/NodeJS/index.html","hash":"62aff27b7d7329fb9b39aaed11a499393fbcc249","modified":1694667417935},{"_id":"public/tags/SOAP/index.html","hash":"69c27e7e042ce421aa165c49f1812c28a85d731a","modified":1694667417935},{"_id":"public/tags/前端/index.html","hash":"e96f807662b55ef638c446ee72c09e9d325d7762","modified":1694667417935},{"_id":"public/tags/效率/index.html","hash":"6c585600d88eb1e2ff3cce1055110ae1e06fe3ab","modified":1694667417935},{"_id":"public/tags/专注/index.html","hash":"c55fef4cba02116d0547d0136d65a387778c9399","modified":1694667417935},{"_id":"public/tags/前端构建/index.html","hash":"b86ec6024c366eaebbdadf1e7ae66ffa8c73b12a","modified":1694667417935},{"_id":"public/tags/编译/index.html","hash":"784f87442ffe0590bb494592b44df73dbdbdffc7","modified":1694667417935},{"_id":"public/tags/解释/index.html","hash":"9b618ccfa05ad9c05937f3a09b2185892e344940","modified":1694667417935},{"_id":"public/tags/PWA/index.html","hash":"13a03357712a94fe66469fff9ba298c9a2358f86","modified":1694667417935},{"_id":"public/tags/内存/index.html","hash":"45181f39abf5476530ac2c4a3431830afd42b588","modified":1694667417935},{"_id":"public/tags/书籍/index.html","hash":"8872a560d7f2d1e798ea39a0b7cf48463eaedfb6","modified":1694667417935},{"_id":"public/index.html","hash":"e6312cb329bf8d84698da604c668a228edf22c4e","modified":1692588607932},{"_id":"source/.DS_Store","hash":"928227b0c1b00be1cfe659b8f4b047085fa5adca","modified":1637629826111},{"_id":"source/image/.DS_Store","hash":"39b4a7b49141f8f6204871460e2eb413890c4924","modified":1555149533000},{"_id":"themes/fexo/.csscomb.json","hash":"0bff596879c2556634b9a92abe5b1606dc77fd1c","modified":1562465924000},{"_id":"source/image/blog/.DS_Store","hash":"e2284d1c7a057523858c0706cbb05f5666eccbe2","modified":1488435517000},{"_id":"themes/fexo/.gitignore","hash":"cb475326f4d34c639c3dc1abddc03a2539dafbc9","modified":1562465924000},{"_id":"source/_posts/2022/build-a-extensible-reliable-controllable-PWA-app.md","hash":"d3022ede66ab1bbcd7158ed61e4df19b25bec076","modified":1650426387769},{"_id":"source/_posts/2021/method-fuse.md","hash":"a0a5de7c1adcf666cc5a6723956ab5330eeab6e7","modified":1611826567795},{"_id":"source/_posts/2021/github-workflow.md","hash":"b035283e9af5f0b1ce33ef5b03b1f69c4410b61c","modified":1611827556379},{"_id":"source/_posts/2021/wxapp-login-design.md","hash":"72be5a503ceff5fa4ee18d609e16712ab8b1b252","modified":1603074282620},{"_id":"source/_posts/2020/wxapp-login-design.md","hash":"72be5a503ceff5fa4ee18d609e16712ab8b1b252","modified":1603074282620},{"_id":"source/_posts/2021/wxapp-router-experience.md","hash":"ae47fb6aee3c150622ee5511524a34330a393e16","modified":1637027962376},{"_id":"public/2019/08/17/a-thinking-on-insomnia-night/index.html","hash":"79487f0f7e4210e176e242d1f52a1589d3bf8a55","modified":1692588607932},{"_id":"public/archives/2019/08/index.html","hash":"6e74471585cc44e2c4c15a7ba662b0dbadd9ceae","modified":1692588607932},{"_id":"public/2022/04/20/2022/build-a-extensible-reliable-controllable-PWA-app/index.html","hash":"9614e37db0ddf4e2236fa1b6222a40d95a2b88d5","modified":1692588607932},{"_id":"public/2021/03/21/2021/wxapp-router-experience/index.html","hash":"5e0587c2a08f6e84c1e62b60221c4b8899080503","modified":1692588607932},{"_id":"public/2021/01/28/2021/github-workflow/index.html","hash":"396f8e0998d6d790f2afb9682df353dc192d6343","modified":1692588607932},{"_id":"public/2021/01/28/2021/method-fuse/index.html","hash":"bdc22a33aa7262de09717ba0273114e844e0a8f1","modified":1692588607932},{"_id":"public/2020/10/16/2020/wxapp-login-design/index.html","hash":"0a35fc01f03f9e7650dec4edf378ff19ade6b688","modified":1692588607932},{"_id":"themes/fexo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1562465924822},{"_id":"themes/fexo/.git/config","hash":"a04997723156ad92acd37b6b1249f76028b9aa2d","modified":1562465924824},{"_id":"themes/fexo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1562465918759},{"_id":"themes/fexo/.git/packed-refs","hash":"077850fec71c840ea9449390ab9f70474a6733d0","modified":1562465924818},{"_id":"themes/fexo/.git/index","hash":"e9a9781ab2835ab9abcc203fe34310648fde8c70","modified":1562465924913},{"_id":"source/_posts/2022/http-cache-vs-service-worker-cache.md","hash":"1d77d3a8d916a7c41dfea52ba49097b4c2601c36","modified":1650477123960},{"_id":"themes/fexo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1562465918765},{"_id":"themes/fexo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1562465918769},{"_id":"themes/fexo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1562465918760},{"_id":"themes/fexo/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1562465918761},{"_id":"themes/fexo/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1562465918763},{"_id":"themes/fexo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1562465918770},{"_id":"themes/fexo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1562465918758},{"_id":"themes/fexo/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1562465918768},{"_id":"themes/fexo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1562465918767},{"_id":"themes/fexo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1562465918768},{"_id":"themes/fexo/.git/logs/HEAD","hash":"b75ab4202d081a3641abefd22e68b28265700898","modified":1562465924823},{"_id":"themes/fexo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1562465918770},{"_id":"themes/fexo/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1562465918766},{"_id":"themes/fexo/.git/refs/heads/master","hash":"7793d7bc482725f206010c0ffcb8cc30faf51eaa","modified":1562465924822},{"_id":"themes/fexo/.git/objects/pack/pack-db3c73e874113bb7724518ccacf5fc5f0e8907f0.idx","hash":"7ff28ac894f356c5c95bc7cc2b15862d4175e7cf","modified":1562465924809},{"_id":"themes/fexo/.git/logs/refs/heads/master","hash":"b75ab4202d081a3641abefd22e68b28265700898","modified":1562465924823},{"_id":"themes/fexo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1562465924821},{"_id":"themes/fexo/.git/logs/refs/remotes/origin/HEAD","hash":"b75ab4202d081a3641abefd22e68b28265700898","modified":1562465924821},{"_id":"themes/fexo/.git/objects/pack/pack-db3c73e874113bb7724518ccacf5fc5f0e8907f0.pack","hash":"37a9f489c893644eaf2c8aa002beb763720ddb08","modified":1562465924807},{"_id":"public/2022/04/21/2022/http-cache-vs-service-worker-cache/index.html","hash":"a53019932a4f410f3843aadcef1f319981d71c59","modified":1694667417935},{"_id":"source/_posts/2023/tencent-docs-drive-buildings.md","hash":"9bdc3d03e2a0ad85b6b5f2903445d3002a31da3d","modified":1692588590431},{"_id":"public/archives/2023/08/index.html","hash":"34bb86099f468e123de4d674247c183a397940fb","modified":1692588607932},{"_id":"public/archives/2023/index.html","hash":"7226cc1a86aa0e9b42f96f4427a07fbc2f9b2029","modified":1692588607932},{"_id":"public/2023/08/19/2023/tencent-docs-drive-buildings/index.html","hash":"ba4fe2e2bdbb70ec65e7cbf5f1bc3d0521f15917","modified":1692588607932}],"Category":[{"name":"搬砖码农","_id":"cl270y8qi0001xwrlbh4miv5j"},{"name":"三省吾身","_id":"cl270y8qz000hxwrlv4qejupf"},{"name":"人丑就要多读书","_id":"cl270y8r1000kxwrlj33vodet"}],"Data":[],"Page":[{"title":"tag","layout":"tag","comments":0,"_content":"","source":"tag/index.md","raw":"---\ntitle: tag\nlayout: tag\ncomments: false\n---","date":"2017-02-02T14:53:25.000Z","updated":"2017-02-02T14:53:25.000Z","path":"tag/index.html","_id":"cl270y8ql000bxwrlsic3ywyd","content":"","excerpt":"","more":""},{"title":"link","layout":"link","comments":0,"_content":"","source":"link/index.md","raw":"---\ntitle: link\nlayout: link\ncomments: false\n---","date":"2017-02-02T14:53:25.000Z","updated":"2017-02-02T14:53:25.000Z","path":"link/index.html","_id":"cl270y8qm000cxwrld79ee9et","content":"","excerpt":"","more":""},{"_content":".article-content img {\n    transform: translate(-50%);\n    position: relative;\n    left: 50%;\n}","source":"css/personal-style.css","raw":".article-content img {\n    transform: translate(-50%);\n    position: relative;\n    left: 50%;\n}","date":"2019-07-07T09:17:13.422Z","updated":"2019-07-07T09:17:13.422Z","path":"css/personal-style.css","layout":"false","_id":"cl270y8qw000dxwrl1u6yv9am","title":"","comments":1,"content":".article-content img {\n    transform: translate(-50%);\n    position: relative;\n    left: 50%;\n}","excerpt":"","more":".article-content img {\n    transform: translate(-50%);\n    position: relative;\n    left: 50%;\n}"},{"title":"category","layout":"category","comments":0,"_content":"","source":"category/index.md","raw":"---\ntitle: category\nlayout: category\ncomments: false\n---","date":"2017-02-02T14:53:25.000Z","updated":"2017-02-02T14:53:25.000Z","path":"category/index.html","_id":"cl270y8qx000exwrl2vis1h0y","content":"","excerpt":"","more":""},{"title":"about","layout":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ncomments: false\n---","date":"2017-02-02T14:53:25.000Z","updated":"2017-02-02T14:53:25.000Z","path":"about/index.html","_id":"cl270y8qx000fxwrlwib3bqhk","content":"","excerpt":"","more":""}],"Post":[{"title":"HTML-CSS-JS打造Windows桌面版《2048》","date":"2014-07-19T08:10:49.000Z","_content":"\n![头图](/image/blog/imgFile1412168354773.jpg)\n\n# 前言    \n\n受益于Node的问世，Javascript终于能够挣脱浏览器这个条条框框的盒子。于是，Javascript能够开发服务器应用了。既然Javascript能够运行在操作系统中，那是否也能使用Javascript像C/C++开发那些个桌面应用呢。\n在Google一番之后，果然已经有高人实现了这个想法了。\n\nNode-WebKit，把浏览器的布局引擎WebKit和Node.js结合了在一起。WebKit负责处理HTML5 UI相关的部分，而Node.js负责本地的API接口，比如文件系统，网络，设备等等。\n一个需要特别提醒的，Node-WebKit的开发维护者正是国内的王文睿大大，中国人啊，很自豪有木有！！但是项目文档好想没有中文版的，只是英文版的，这也许是要和国际接轨的原因吧。\n\n项目地址：[https://github.com/rogerwang/node-webkit](https://github.com/rogerwang/node-webkit)\n\n话不多说，我们撸起袖子，开始尝试一下使用前端技术开发桌面应用的乐趣吧。\n\n\n\n# Windows桌面版《2048》\n\n## Step 1 ：准备材料\n\n1、node-webkit(本文使用v0.8.6-win版本):\n[node-webkit-v0.8.6-win-ia32.zip](http://dl.node-webkit.org/v0.8.6/node-webkit-v0.8.6-win-ia32.zip)\n\n2、基于jQuery实现的2048游戏：\nhttp://huang-jerryc/（原文地址）\nhttps://github.com/JerryC8080/My2048（下载地址）\n\nnode-webkit的其他版本，在项目地址（https://github.com/rogerwang/node-webkit）可以下载得到，不同操作系统是不同版本的。\n基于jQuery实现的2048游戏，是我之前做的一个小玩意，而这一次就完美移植到Windows桌面，哇嘎嘎嘎。\n\nnode-webkit下载并解压之后，如下：\n![解压后](/image/blog/imgFile1412168419938.jpg)\n\n```\n文件说明：\nnw.pak           --核心Javascript库\nincudt.dll       --网络库\nffmpegsumo.dll   --媒体库，为<video>、<audio>或者其他媒体功能提供支持\nlibEGL.dll、\nlibGLESv2.dll、\nD3DCompiler_43.dll、\nd3dx9_43.dll     --该四个dll，为WebGL、GPU、DirectX提供支持\n```\n\n基于jQuery实现的2048游戏下载并解压之后，如下：\n![解压后](/image/blog/imgFile1412168441331.jpg)\n\n## Step 2  ： 编写package.json文件\n\n在《2048》游戏的目录，新建一个package.json文件，输入内容：\nHTML 代码片段\n\n\n```json\n{\n  \"name\": \"MyDemo\",\n  \"main\": \"index.html\",\n  \"window\": {\n    \"toolbar\": false,\n    \"resizable\": false,\n    \"width\": 660,\n    \"height\": 800\n  }\n}\n```\n![](/image/blog/imgFile1412168471850.jpg)\n\n\n复制代码保存代码提示：\n1. 编写代码可使用Emmet语法，即Zen coding语法 \n2. 当代码框处于激活状态下按 CTRL+F11 键可全屏!\n\n\n## Step 3  ：压缩源程序\n\n我们使用压缩工具，把已经编写好的../My2048-master目录里面的内容压缩。\n压缩需要注意的两点：\n1. 压缩格式要为zip；\n2. 文件后缀名要为.nw；\n\n如图：\n![enter image description here](/image/blog/imgFile1412168511771.jpg)\n\n压缩完成\n![enter image description here](/image/blog/imgFile1412168553899.jpg)\n\n## Step 4  ：预览\n\n把压缩好的 My2048-master.nw 文件复制到node-webkit目录：\n![enter image description here](/image/blog/imgFile1412168592404.jpg)\n\n运行cmd，\n移动到node-webkit所在的目录： cd + node-webkit所在的路径\n运行命令：nw My2048-master.nw\n![enter image description here](/image/blog/imgFile1412168834596.jpg)\n\n便能看到预览效果了\n![enter image description here](/image/blog/imgFile1412168728769.jpg)\n\n## Step 5   ：生成exe执行文件\n\n依然在node-webkit的目录下\n运行命令：\n`copy /b nw.exe+My2048-master.nw My2048.exe`\n![enter image description here](/image/blog/imgFile1412168755327.jpg)\n\nOK，我们可以看到node-webkit目录下多了一个My2048.exe的执行文件，我们点解它运行看看效果：\n![enter image description here](/image/blog/imgFile1412168871884.jpg)\n\n![enter image description here](/image/blog/imgFile1412168728769.jpg)\n\n\n## Step 6  ： 打包程序\n\n如果想把这个程序发给朋友，除了.exe文件之外，还需要包括另外两个必要的文件:\n- **icudt.dll**(必要网络库)\n- **nw.pak**(核心javascript库)\n\n这两个是最基本的文件，如果程序还包含了其他功能，还需要包含相对应的dll文件，各个文件功能说明文章开始已经说明了。\n\n所以，我们得到了最基本的发布版了：\n![enter image description here](/image/blog/imgFile1412168908105.jpg)\n","source":"_posts/HTML-CSS-JS打造Windows桌面版《2048》.md","raw":"---\ntitle: HTML-CSS-JS打造Windows桌面版《2048》\ncategory: 搬砖码农\ndate: 2014-07-19 16:10:49\ntags:\n- HTML\n- CSS\n- Javascript\n- node webkit\n---\n\n![头图](/image/blog/imgFile1412168354773.jpg)\n\n# 前言    \n\n受益于Node的问世，Javascript终于能够挣脱浏览器这个条条框框的盒子。于是，Javascript能够开发服务器应用了。既然Javascript能够运行在操作系统中，那是否也能使用Javascript像C/C++开发那些个桌面应用呢。\n在Google一番之后，果然已经有高人实现了这个想法了。\n\nNode-WebKit，把浏览器的布局引擎WebKit和Node.js结合了在一起。WebKit负责处理HTML5 UI相关的部分，而Node.js负责本地的API接口，比如文件系统，网络，设备等等。\n一个需要特别提醒的，Node-WebKit的开发维护者正是国内的王文睿大大，中国人啊，很自豪有木有！！但是项目文档好想没有中文版的，只是英文版的，这也许是要和国际接轨的原因吧。\n\n项目地址：[https://github.com/rogerwang/node-webkit](https://github.com/rogerwang/node-webkit)\n\n话不多说，我们撸起袖子，开始尝试一下使用前端技术开发桌面应用的乐趣吧。\n\n\n\n# Windows桌面版《2048》\n\n## Step 1 ：准备材料\n\n1、node-webkit(本文使用v0.8.6-win版本):\n[node-webkit-v0.8.6-win-ia32.zip](http://dl.node-webkit.org/v0.8.6/node-webkit-v0.8.6-win-ia32.zip)\n\n2、基于jQuery实现的2048游戏：\nhttp://huang-jerryc/（原文地址）\nhttps://github.com/JerryC8080/My2048（下载地址）\n\nnode-webkit的其他版本，在项目地址（https://github.com/rogerwang/node-webkit）可以下载得到，不同操作系统是不同版本的。\n基于jQuery实现的2048游戏，是我之前做的一个小玩意，而这一次就完美移植到Windows桌面，哇嘎嘎嘎。\n\nnode-webkit下载并解压之后，如下：\n![解压后](/image/blog/imgFile1412168419938.jpg)\n\n```\n文件说明：\nnw.pak           --核心Javascript库\nincudt.dll       --网络库\nffmpegsumo.dll   --媒体库，为<video>、<audio>或者其他媒体功能提供支持\nlibEGL.dll、\nlibGLESv2.dll、\nD3DCompiler_43.dll、\nd3dx9_43.dll     --该四个dll，为WebGL、GPU、DirectX提供支持\n```\n\n基于jQuery实现的2048游戏下载并解压之后，如下：\n![解压后](/image/blog/imgFile1412168441331.jpg)\n\n## Step 2  ： 编写package.json文件\n\n在《2048》游戏的目录，新建一个package.json文件，输入内容：\nHTML 代码片段\n\n\n```json\n{\n  \"name\": \"MyDemo\",\n  \"main\": \"index.html\",\n  \"window\": {\n    \"toolbar\": false,\n    \"resizable\": false,\n    \"width\": 660,\n    \"height\": 800\n  }\n}\n```\n![](/image/blog/imgFile1412168471850.jpg)\n\n\n复制代码保存代码提示：\n1. 编写代码可使用Emmet语法，即Zen coding语法 \n2. 当代码框处于激活状态下按 CTRL+F11 键可全屏!\n\n\n## Step 3  ：压缩源程序\n\n我们使用压缩工具，把已经编写好的../My2048-master目录里面的内容压缩。\n压缩需要注意的两点：\n1. 压缩格式要为zip；\n2. 文件后缀名要为.nw；\n\n如图：\n![enter image description here](/image/blog/imgFile1412168511771.jpg)\n\n压缩完成\n![enter image description here](/image/blog/imgFile1412168553899.jpg)\n\n## Step 4  ：预览\n\n把压缩好的 My2048-master.nw 文件复制到node-webkit目录：\n![enter image description here](/image/blog/imgFile1412168592404.jpg)\n\n运行cmd，\n移动到node-webkit所在的目录： cd + node-webkit所在的路径\n运行命令：nw My2048-master.nw\n![enter image description here](/image/blog/imgFile1412168834596.jpg)\n\n便能看到预览效果了\n![enter image description here](/image/blog/imgFile1412168728769.jpg)\n\n## Step 5   ：生成exe执行文件\n\n依然在node-webkit的目录下\n运行命令：\n`copy /b nw.exe+My2048-master.nw My2048.exe`\n![enter image description here](/image/blog/imgFile1412168755327.jpg)\n\nOK，我们可以看到node-webkit目录下多了一个My2048.exe的执行文件，我们点解它运行看看效果：\n![enter image description here](/image/blog/imgFile1412168871884.jpg)\n\n![enter image description here](/image/blog/imgFile1412168728769.jpg)\n\n\n## Step 6  ： 打包程序\n\n如果想把这个程序发给朋友，除了.exe文件之外，还需要包括另外两个必要的文件:\n- **icudt.dll**(必要网络库)\n- **nw.pak**(核心javascript库)\n\n这两个是最基本的文件，如果程序还包含了其他功能，还需要包含相对应的dll文件，各个文件功能说明文章开始已经说明了。\n\n所以，我们得到了最基本的发布版了：\n![enter image description here](/image/blog/imgFile1412168908105.jpg)\n","slug":"HTML-CSS-JS打造Windows桌面版《2048》","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8qf0000xwrlo43rom6u","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/image/blog/imgFile1412168354773.jpg\" alt=\"头图\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>受益于Node的问世，Javascript终于能够挣脱浏览器这个条条框框的盒子。于是，Javascript能够开发服务器应用了。既然Javascript能够运行在操作系统中，那是否也能使用Javascript像C/C++开发那些个桌面应用呢。<br>在Google一番之后，果然已经有高人实现了这个想法了。</p>\n<p>Node-WebKit，把浏览器的布局引擎WebKit和Node.js结合了在一起。WebKit负责处理HTML5 UI相关的部分，而Node.js负责本地的API接口，比如文件系统，网络，设备等等。<br>一个需要特别提醒的，Node-WebKit的开发维护者正是国内的王文睿大大，中国人啊，很自豪有木有！！但是项目文档好想没有中文版的，只是英文版的，这也许是要和国际接轨的原因吧。</p>\n<p>项目地址：<a href=\"https://github.com/rogerwang/node-webkit\" target=\"_blank\" rel=\"external\">https://github.com/rogerwang/node-webkit</a></p>\n<p>话不多说，我们撸起袖子，开始尝试一下使用前端技术开发桌面应用的乐趣吧。</p>\n<h1 id=\"Windows桌面版《2048》\"><a href=\"#Windows桌面版《2048》\" class=\"headerlink\" title=\"Windows桌面版《2048》\"></a>Windows桌面版《2048》</h1><h2 id=\"Step-1-：准备材料\"><a href=\"#Step-1-：准备材料\" class=\"headerlink\" title=\"Step 1 ：准备材料\"></a>Step 1 ：准备材料</h2><p>1、node-webkit(本文使用v0.8.6-win版本):<br><a href=\"http://dl.node-webkit.org/v0.8.6/node-webkit-v0.8.6-win-ia32.zip\" target=\"_blank\" rel=\"external\">node-webkit-v0.8.6-win-ia32.zip</a></p>\n<p>2、基于jQuery实现的2048游戏：<br><a href=\"http://huang-jerryc/（原文地址）\" target=\"_blank\" rel=\"external\">http://huang-jerryc/（原文地址）</a><br><a href=\"https://github.com/JerryC8080/My2048（下载地址）\" target=\"_blank\" rel=\"external\">https://github.com/JerryC8080/My2048（下载地址）</a></p>\n<p>node-webkit的其他版本，在项目地址（<a href=\"https://github.com/rogerwang/node-webkit）可以下载得到，不同操作系统是不同版本的。\" target=\"_blank\" rel=\"external\">https://github.com/rogerwang/node-webkit）可以下载得到，不同操作系统是不同版本的。</a><br>基于jQuery实现的2048游戏，是我之前做的一个小玩意，而这一次就完美移植到Windows桌面，哇嘎嘎嘎。</p>\n<p>node-webkit下载并解压之后，如下：<br><img src=\"/image/blog/imgFile1412168419938.jpg\" alt=\"解压后\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件说明：</span><br><span class=\"line\">nw.pak           --核心Javascript库</span><br><span class=\"line\">incudt.dll       --网络库</span><br><span class=\"line\">ffmpegsumo.dll   --媒体库，为&lt;video&gt;、&lt;audio&gt;或者其他媒体功能提供支持</span><br><span class=\"line\">libEGL.dll、</span><br><span class=\"line\">libGLESv2.dll、</span><br><span class=\"line\">D3DCompiler_43.dll、</span><br><span class=\"line\">d3dx9_43.dll     --该四个dll，为WebGL、GPU、DirectX提供支持</span><br></pre></td></tr></table></figure>\n<p>基于jQuery实现的2048游戏下载并解压之后，如下：<br><img src=\"/image/blog/imgFile1412168441331.jpg\" alt=\"解压后\"></p>\n<h2 id=\"Step-2-：-编写package-json文件\"><a href=\"#Step-2-：-编写package-json文件\" class=\"headerlink\" title=\"Step 2  ： 编写package.json文件\"></a>Step 2  ： 编写package.json文件</h2><p>在《2048》游戏的目录，新建一个package.json文件，输入内容：<br>HTML 代码片段</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"MyDemo\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"main\"</span>: <span class=\"string\">\"index.html\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"window\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"toolbar\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"resizable\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"width\"</span>: <span class=\"number\">660</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"height\"</span>: <span class=\"number\">800</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/image/blog/imgFile1412168471850.jpg\" alt></p>\n<p>复制代码保存代码提示：</p>\n<ol>\n<li>编写代码可使用Emmet语法，即Zen coding语法 </li>\n<li>当代码框处于激活状态下按 CTRL+F11 键可全屏!</li>\n</ol>\n<h2 id=\"Step-3-：压缩源程序\"><a href=\"#Step-3-：压缩源程序\" class=\"headerlink\" title=\"Step 3  ：压缩源程序\"></a>Step 3  ：压缩源程序</h2><p>我们使用压缩工具，把已经编写好的../My2048-master目录里面的内容压缩。<br>压缩需要注意的两点：</p>\n<ol>\n<li>压缩格式要为zip；</li>\n<li>文件后缀名要为.nw；</li>\n</ol>\n<p>如图：<br><img src=\"/image/blog/imgFile1412168511771.jpg\" alt=\"enter image description here\"></p>\n<p>压缩完成<br><img src=\"/image/blog/imgFile1412168553899.jpg\" alt=\"enter image description here\"></p>\n<h2 id=\"Step-4-：预览\"><a href=\"#Step-4-：预览\" class=\"headerlink\" title=\"Step 4  ：预览\"></a>Step 4  ：预览</h2><p>把压缩好的 My2048-master.nw 文件复制到node-webkit目录：<br><img src=\"/image/blog/imgFile1412168592404.jpg\" alt=\"enter image description here\"></p>\n<p>运行cmd，<br>移动到node-webkit所在的目录： cd + node-webkit所在的路径<br>运行命令：nw My2048-master.nw<br><img src=\"/image/blog/imgFile1412168834596.jpg\" alt=\"enter image description here\"></p>\n<p>便能看到预览效果了<br><img src=\"/image/blog/imgFile1412168728769.jpg\" alt=\"enter image description here\"></p>\n<h2 id=\"Step-5-：生成exe执行文件\"><a href=\"#Step-5-：生成exe执行文件\" class=\"headerlink\" title=\"Step 5   ：生成exe执行文件\"></a>Step 5   ：生成exe执行文件</h2><p>依然在node-webkit的目录下<br>运行命令：<br><code>copy /b nw.exe+My2048-master.nw My2048.exe</code><br><img src=\"/image/blog/imgFile1412168755327.jpg\" alt=\"enter image description here\"></p>\n<p>OK，我们可以看到node-webkit目录下多了一个My2048.exe的执行文件，我们点解它运行看看效果：<br><img src=\"/image/blog/imgFile1412168871884.jpg\" alt=\"enter image description here\"></p>\n<p><img src=\"/image/blog/imgFile1412168728769.jpg\" alt=\"enter image description here\"></p>\n<h2 id=\"Step-6-：-打包程序\"><a href=\"#Step-6-：-打包程序\" class=\"headerlink\" title=\"Step 6  ： 打包程序\"></a>Step 6  ： 打包程序</h2><p>如果想把这个程序发给朋友，除了.exe文件之外，还需要包括另外两个必要的文件:</p>\n<ul>\n<li><strong>icudt.dll</strong>(必要网络库)</li>\n<li><strong>nw.pak</strong>(核心javascript库)</li>\n</ul>\n<p>这两个是最基本的文件，如果程序还包含了其他功能，还需要包含相对应的dll文件，各个文件功能说明文章开始已经说明了。</p>\n<p>所以，我们得到了最基本的发布版了：<br><img src=\"/image/blog/imgFile1412168908105.jpg\" alt=\"enter image description here\"></p>\n","excerpt":"","more":"<p><img src=\"/image/blog/imgFile1412168354773.jpg\" alt=\"头图\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>受益于Node的问世，Javascript终于能够挣脱浏览器这个条条框框的盒子。于是，Javascript能够开发服务器应用了。既然Javascript能够运行在操作系统中，那是否也能使用Javascript像C/C++开发那些个桌面应用呢。<br>在Google一番之后，果然已经有高人实现了这个想法了。</p>\n<p>Node-WebKit，把浏览器的布局引擎WebKit和Node.js结合了在一起。WebKit负责处理HTML5 UI相关的部分，而Node.js负责本地的API接口，比如文件系统，网络，设备等等。<br>一个需要特别提醒的，Node-WebKit的开发维护者正是国内的王文睿大大，中国人啊，很自豪有木有！！但是项目文档好想没有中文版的，只是英文版的，这也许是要和国际接轨的原因吧。</p>\n<p>项目地址：<a href=\"https://github.com/rogerwang/node-webkit\">https://github.com/rogerwang/node-webkit</a></p>\n<p>话不多说，我们撸起袖子，开始尝试一下使用前端技术开发桌面应用的乐趣吧。</p>\n<h1 id=\"Windows桌面版《2048》\"><a href=\"#Windows桌面版《2048》\" class=\"headerlink\" title=\"Windows桌面版《2048》\"></a>Windows桌面版《2048》</h1><h2 id=\"Step-1-：准备材料\"><a href=\"#Step-1-：准备材料\" class=\"headerlink\" title=\"Step 1 ：准备材料\"></a>Step 1 ：准备材料</h2><p>1、node-webkit(本文使用v0.8.6-win版本):<br><a href=\"http://dl.node-webkit.org/v0.8.6/node-webkit-v0.8.6-win-ia32.zip\">node-webkit-v0.8.6-win-ia32.zip</a></p>\n<p>2、基于jQuery实现的2048游戏：<br><a href=\"http://huang-jerryc/（原文地址）\">http://huang-jerryc/（原文地址）</a><br><a href=\"https://github.com/JerryC8080/My2048（下载地址）\">https://github.com/JerryC8080/My2048（下载地址）</a></p>\n<p>node-webkit的其他版本，在项目地址（<a href=\"https://github.com/rogerwang/node-webkit）可以下载得到，不同操作系统是不同版本的。\">https://github.com/rogerwang/node-webkit）可以下载得到，不同操作系统是不同版本的。</a><br>基于jQuery实现的2048游戏，是我之前做的一个小玩意，而这一次就完美移植到Windows桌面，哇嘎嘎嘎。</p>\n<p>node-webkit下载并解压之后，如下：<br><img src=\"/image/blog/imgFile1412168419938.jpg\" alt=\"解压后\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件说明：</span><br><span class=\"line\">nw.pak           --核心Javascript库</span><br><span class=\"line\">incudt.dll       --网络库</span><br><span class=\"line\">ffmpegsumo.dll   --媒体库，为&lt;video&gt;、&lt;audio&gt;或者其他媒体功能提供支持</span><br><span class=\"line\">libEGL.dll、</span><br><span class=\"line\">libGLESv2.dll、</span><br><span class=\"line\">D3DCompiler_43.dll、</span><br><span class=\"line\">d3dx9_43.dll     --该四个dll，为WebGL、GPU、DirectX提供支持</span><br></pre></td></tr></table></figure>\n<p>基于jQuery实现的2048游戏下载并解压之后，如下：<br><img src=\"/image/blog/imgFile1412168441331.jpg\" alt=\"解压后\"></p>\n<h2 id=\"Step-2-：-编写package-json文件\"><a href=\"#Step-2-：-编写package-json文件\" class=\"headerlink\" title=\"Step 2  ： 编写package.json文件\"></a>Step 2  ： 编写package.json文件</h2><p>在《2048》游戏的目录，新建一个package.json文件，输入内容：<br>HTML 代码片段</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"MyDemo\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"main\"</span>: <span class=\"string\">\"index.html\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"window\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"toolbar\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"resizable\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"width\"</span>: <span class=\"number\">660</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"height\"</span>: <span class=\"number\">800</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/image/blog/imgFile1412168471850.jpg\" alt=\"\"></p>\n<p>复制代码保存代码提示：</p>\n<ol>\n<li>编写代码可使用Emmet语法，即Zen coding语法 </li>\n<li>当代码框处于激活状态下按 CTRL+F11 键可全屏!</li>\n</ol>\n<h2 id=\"Step-3-：压缩源程序\"><a href=\"#Step-3-：压缩源程序\" class=\"headerlink\" title=\"Step 3  ：压缩源程序\"></a>Step 3  ：压缩源程序</h2><p>我们使用压缩工具，把已经编写好的../My2048-master目录里面的内容压缩。<br>压缩需要注意的两点：</p>\n<ol>\n<li>压缩格式要为zip；</li>\n<li>文件后缀名要为.nw；</li>\n</ol>\n<p>如图：<br><img src=\"/image/blog/imgFile1412168511771.jpg\" alt=\"enter image description here\"></p>\n<p>压缩完成<br><img src=\"/image/blog/imgFile1412168553899.jpg\" alt=\"enter image description here\"></p>\n<h2 id=\"Step-4-：预览\"><a href=\"#Step-4-：预览\" class=\"headerlink\" title=\"Step 4  ：预览\"></a>Step 4  ：预览</h2><p>把压缩好的 My2048-master.nw 文件复制到node-webkit目录：<br><img src=\"/image/blog/imgFile1412168592404.jpg\" alt=\"enter image description here\"></p>\n<p>运行cmd，<br>移动到node-webkit所在的目录： cd + node-webkit所在的路径<br>运行命令：nw My2048-master.nw<br><img src=\"/image/blog/imgFile1412168834596.jpg\" alt=\"enter image description here\"></p>\n<p>便能看到预览效果了<br><img src=\"/image/blog/imgFile1412168728769.jpg\" alt=\"enter image description here\"></p>\n<h2 id=\"Step-5-：生成exe执行文件\"><a href=\"#Step-5-：生成exe执行文件\" class=\"headerlink\" title=\"Step 5   ：生成exe执行文件\"></a>Step 5   ：生成exe执行文件</h2><p>依然在node-webkit的目录下<br>运行命令：<br><code>copy /b nw.exe+My2048-master.nw My2048.exe</code><br><img src=\"/image/blog/imgFile1412168755327.jpg\" alt=\"enter image description here\"></p>\n<p>OK，我们可以看到node-webkit目录下多了一个My2048.exe的执行文件，我们点解它运行看看效果：<br><img src=\"/image/blog/imgFile1412168871884.jpg\" alt=\"enter image description here\"></p>\n<p><img src=\"/image/blog/imgFile1412168728769.jpg\" alt=\"enter image description here\"></p>\n<h2 id=\"Step-6-：-打包程序\"><a href=\"#Step-6-：-打包程序\" class=\"headerlink\" title=\"Step 6  ： 打包程序\"></a>Step 6  ： 打包程序</h2><p>如果想把这个程序发给朋友，除了.exe文件之外，还需要包括另外两个必要的文件:</p>\n<ul>\n<li><strong>icudt.dll</strong>(必要网络库)</li>\n<li><strong>nw.pak</strong>(核心javascript库)</li>\n</ul>\n<p>这两个是最基本的文件，如果程序还包含了其他功能，还需要包含相对应的dll文件，各个文件功能说明文章开始已经说明了。</p>\n<p>所以，我们得到了最基本的发布版了：<br><img src=\"/image/blog/imgFile1412168908105.jpg\" alt=\"enter image description here\"></p>\n"},{"title":"那一夜独处","date":"2015-12-30T15:49:07.000Z","_content":"\n![](/image/blog/79702-d66ee9d1fd912b33.jpg)\n\n异地恋的开始，让我渐渐的开始再次......\n学会一个人的生活，\n学会享受独处的时间，\n学会享受一个人的红茶，\n学会享受周末午后那属于一个人的阳光，\n学会享受一个人安静的在暖黄色的灯光下细细品味书架上久久未动过的书。\n\n独处的时间让我重新有了思考的时间，这段时间，会想到以前没有想过的问题，会想到已经忘了的曾经的决心。\n\n黑夜中，独自一人在充满柔和暖光的房间中，闭上眼睛，发动身上的每一个细胞，去感受着周围。\n\n那是多么的安静，安静的让我忘却了我依然身处这个世界，完全沉浸在自我世界中，\n\n很久，很久，很久.....\n\n忽然，那一刻，恍然大悟，心旷神怡。\n\n清楚了自己想要的是什么，\n想走的是什么样的路，\n\n但是，\n\n我还不知道怎么去走，怎么去达到目标，\n\n这是接下来要做的。","source":"_posts/那一夜独处.md","raw":"---\ntitle: 那一夜独处\ncategory: 三省吾身\ndate: 2015-12-30 23:49:07\ntags:\n---\n\n![](/image/blog/79702-d66ee9d1fd912b33.jpg)\n\n异地恋的开始，让我渐渐的开始再次......\n学会一个人的生活，\n学会享受独处的时间，\n学会享受一个人的红茶，\n学会享受周末午后那属于一个人的阳光，\n学会享受一个人安静的在暖黄色的灯光下细细品味书架上久久未动过的书。\n\n独处的时间让我重新有了思考的时间，这段时间，会想到以前没有想过的问题，会想到已经忘了的曾经的决心。\n\n黑夜中，独自一人在充满柔和暖光的房间中，闭上眼睛，发动身上的每一个细胞，去感受着周围。\n\n那是多么的安静，安静的让我忘却了我依然身处这个世界，完全沉浸在自我世界中，\n\n很久，很久，很久.....\n\n忽然，那一刻，恍然大悟，心旷神怡。\n\n清楚了自己想要的是什么，\n想走的是什么样的路，\n\n但是，\n\n我还不知道怎么去走，怎么去达到目标，\n\n这是接下来要做的。","slug":"那一夜独处","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8qy000gxwrl2g3c87v1","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/image/blog/79702-d66ee9d1fd912b33.jpg\" alt></p>\n<p>异地恋的开始，让我渐渐的开始再次……<br>学会一个人的生活，<br>学会享受独处的时间，<br>学会享受一个人的红茶，<br>学会享受周末午后那属于一个人的阳光，<br>学会享受一个人安静的在暖黄色的灯光下细细品味书架上久久未动过的书。</p>\n<p>独处的时间让我重新有了思考的时间，这段时间，会想到以前没有想过的问题，会想到已经忘了的曾经的决心。</p>\n<p>黑夜中，独自一人在充满柔和暖光的房间中，闭上眼睛，发动身上的每一个细胞，去感受着周围。</p>\n<p>那是多么的安静，安静的让我忘却了我依然身处这个世界，完全沉浸在自我世界中，</p>\n<p>很久，很久，很久…..</p>\n<p>忽然，那一刻，恍然大悟，心旷神怡。</p>\n<p>清楚了自己想要的是什么，<br>想走的是什么样的路，</p>\n<p>但是，</p>\n<p>我还不知道怎么去走，怎么去达到目标，</p>\n<p>这是接下来要做的。</p>\n","excerpt":"","more":"<p><img src=\"/image/blog/79702-d66ee9d1fd912b33.jpg\" alt=\"\"></p>\n<p>异地恋的开始，让我渐渐的开始再次……<br>学会一个人的生活，<br>学会享受独处的时间，<br>学会享受一个人的红茶，<br>学会享受周末午后那属于一个人的阳光，<br>学会享受一个人安静的在暖黄色的灯光下细细品味书架上久久未动过的书。</p>\n<p>独处的时间让我重新有了思考的时间，这段时间，会想到以前没有想过的问题，会想到已经忘了的曾经的决心。</p>\n<p>黑夜中，独自一人在充满柔和暖光的房间中，闭上眼睛，发动身上的每一个细胞，去感受着周围。</p>\n<p>那是多么的安静，安静的让我忘却了我依然身处这个世界，完全沉浸在自我世界中，</p>\n<p>很久，很久，很久…..</p>\n<p>忽然，那一刻，恍然大悟，心旷神怡。</p>\n<p>清楚了自己想要的是什么，<br>想走的是什么样的路，</p>\n<p>但是，</p>\n<p>我还不知道怎么去走，怎么去达到目标，</p>\n<p>这是接下来要做的。</p>\n"},{"title":"读《重来》","date":"2016-07-06T16:14:25.000Z","_content":"\n之前我们团队一直在用Coding来作为代码仓库，以及团队协作的工具。大半年下来，攒了不少「码币」，正好碰上Coding的码市搞活动，用码币换取一些Coding的周边，我翻到码市页面的最底下，正好有《重来》这本书可以兑换。对于码农来说，书是一个廉价却特别有价值的东西，于是毫不犹豫就兑换了这本书。\n\n《重来》，也叫《Rework》，作者是37signals的两位创始人：Json Fried, David Heinemeier Hansson。\n这本书的主题是「创业」，书中蕴含了90条作者在创业过程中的商业思维，把它们分篇到12个章节中。\n读这本书的过程中，我会在每一条有所体会，有所思的「思维」中，用铅笔在空白处写下自己的思考。\n读这本书的感觉很像以前读的一本《人性的弱点》，都是教条式的写作。\n其中的每一条，描述的篇幅都很小，但是每一条都需要思思品味，好好感悟。\n很多「思维」中，虽然描述中明显的指向到「创业」思维中，但是我认为很多跟平时我们做人做事的原则很相符。\n读书的过程虽慢，但是我却很认真，对一本好的书，多认真都不显得过分。\n故以此文记录这些笔记。\n\n## 卸负篇\n\n### 哪来的从错误中学习 <small>Learning from mistakes is overrated</small>\n> \n在广义上，成功时并不需要知道失败所遇到的事情\n若放在小事上，例如编程，有一些不折腾过，并不知道以后出错时如何解决\n但也可以延伸另外一个观点：寻找前往成功的直径，绕开不必要的弯路。\n\n### 计划既瞎猜 <small>Planning is guessing</small>\n> \n这篇的说法很符合「说走就走的旅行」的观念。\n计划有用，是对未来的憧憬，但行动更重要，做自己想做的。\n\n### 何必壮大 <small>Why grow?</small>\n> \n在这一篇中，我想起了海贼王中「草帽路飞」海贼团。\n团队中每个人都能独当一面，且有一个统一的向心点。\n\n### 工作狂 <small>Workaholism</small>\n> \n这篇虽说加班，但更深层是效率的问题。\n追求在对的方向，以对的方式快速完成事情。\n\n## 行动篇\n\n### 挠自己的痒处 <small>Scratch your own itch</small> \n> \n为自己服务，解决自己的痛点，顺便造福一下人类。\n让我想起了我那几个搁浅的开源项目-_-!\n\n### 着手做点什么 <small>Start making something</small>\n> \n价值并不在创意，而在于执行力。\n\n### 画沙为界，立场明确 <small>Draw a line in the sand</small>\n> \n让自己更加主见，并且为你的主见提供足够让人信服的论证，如果没有，就去创造这样的论证。\n这一篇有点「乔布斯」的味道，特立独行，打造自身的个性品牌，并无刻意迎合大众。\n这又让我想起了魅族改变路线，迎合消费者，冲销量的做法。\n但是，毕竟它身处一个苛刻的战场。\n\n### 万不得已不筹资 <small>Outside money is Plan 2</small>\n> \n这篇文章是站在创始人视角看待问题。\n从另外一个角度来说，要看待投资方是谁。\n如果是一些基金会，它们需要的是急切的盈利，想到的是如何套现。\n而如果是看中你所做的事情，想一起合作的，或者合并你的公司的投资方就不一样了。他会把你所做的事情当做自己的事情来做。\n\n## 进阶篇\n\n### 条件受限是好事 <small>Embrace constaints</small>\n> \n本篇强调「灵活」与「限制」。\n提出了一个让我所有共鸣，以往能感觉到却没能形容的观点：\n以艰苦的条件来激发人的创造力。\n\n### 与其做个半成品，不如做好半个产品 <small>Build half a product. Not a half-assed product</small>\n> \n不要大而全，只要简而美。\n兴趣与学习也是一个道理，选一件最需要做好的事情投入。\n\n### 从核心出发 <small>Start at the epicenter</small>\n> \n选择能做的，想做的，必须做的。\n\n### 不要过早关注细节 <small>Ignore the details early on</small>\n> \n从整体到局部的思想，做设计、做架构，都是先有个轮廓，然后一点点细化。\n\n### 作出决定就是取得进展 <small>Making the call is making progress</small>\n> \n规划总是要有个度，太近的不够全面，太远的变数太多，不切实际。\n当有了想法，尽早做个决定，先尝试走几步吧。\n\n### 当好博物馆长 <small>Be a curator</small>\n> \n精简，小而美。\n不必追求大而全，东西要发挥它的作用。\n\n### 关注不变因素 <small>Focus on what won't change</small>\n> \n英语、经济学、写作、音乐，\n这一些都是性价比颇高的素质，都十分有助于一个人的内在修养。\n\n### 音乐就在你的指尖流淌 <small>Tone is in your fingers</small>\n> \n抛开工具，关注事物的内在。\n工具，是在你了解了其内部原理之后用来提升效率的。\n\n### 卖掉副产品 <small>Sell your by-products</small>\n> \n对于我的工作来说，把学习的过程，工作上遇到的问题给写下来，发表到博客，这就是我的副产品。\n\n### 立马就上线 <small>Launch now</small>\n> \n第一个版本：一个能用的版本\n\n## 效率篇\n\n### 赞同的错觉 <small>Illusions of agreement</small>\n> \n很多时候多希望有一个idea出现的时候，立马可以动手来做，而不用太在意后来的事情。\n但我认为，需要谨慎的事情需要适度的设计和考虑。\n\n### 打岔是效率的敌人 <small>Interruption is the enemy of productivity</small>\n> \n这一点让我深有体会，并且一直在挣扎的事情。\n尝试过番茄工作法，并且尝试让同事理解我这样的做法。\n并不接受直接过来打扰的沟通方式。\n\n### 刚刚好就是真的好 <small>Good enough is fine</small>\n> \n以小博大，遵循简单，首要目的是把事情做好，做出来。\n后面可以随时改善以及改进。\n\n### 速战速决 <small>Quick Wins</small>\n> \n在这一章中，作者多次提出一个概念，或者是思维：不要等，马上行动!\n在我眼中，这里还有一个思维：积跬步以至千里。\n这跟我的座右铭很相似：厚积薄发。\n\n### 不要逞英雄 <small>Don't be a hero</small>\n> \n把你的时间花在最值得花的地方，并且要量力而行，学会放弃\n\n### 该睡觉时就睡觉 <small>Go to sleep</small>\n> \n学会休息，并且是高效的休息。\n因为疲倦会带来懒惰思考、缺乏创意、士气低落、情绪失控。\n\n### 预估的都是垃圾 <small>Your estimates suck</small>\n> \n对于自己的学习计划也是如此，很多东西想学，却不知从哪个开始，怎么开始。\n那么就把它们排个序，然后逐个评估时间，然后马上执行。\n\n### 罗列问题，不得解决 <small>Long lists don't get done</small>\n> \n把大任务分成小任务，并从小任务中获得成就感。\n\n## 对手篇\n\n### 拒绝照搬 <small>Don't copy</small>\n> \n在学习的方向上，需要模仿，这是一种有效的学习方式。\nCopy-Paste的过程中，尽量知其所以然。\n不需要盲从，掌握主动。\n\n### 向对手挑战 <small>Pick a fight</small>\n> \n调侃对手这种做法，更偏向于一种营销手段，需要玩出自己的特色。\n在国内，这种案例也很多，被网友戏称「碰瓷营销」。\n\n### 给竞争力做减法 <small>Underdo your competition</small>\n> \n一款简约的产品，只需要集中解决用户的一个主要的痛点，而且如果以低成本随手可得的话，更加容易成为流行品。\n\n## 进化篇\n\n### 头脑发热不等于当务之急 <small>Don't confuse enthusiasm with priority</small>\n> \n避免头脑发热，有些事情或决定，可以先放着，过几天再回来看看。\n在《人性的弱点》中，也有类似的观点，那是这样的一个说法：一封愤怒的信，先放几天再决定是否要寄出。\n\n### 家用便利就是好 <small>Be at home good</small>\n> \n弄清哪个是本，哪个是辅\n\n### 甘于低微 <small>Welcome obscurity</small>\n> \n之所以说籍籍无名值得庆幸。\n是因为在这个阶段犯的错误，并没有放大效应，试错成本低。\n对于「甘于低微」，我还有另外一种理解。\n每个人都有他的优点，有胜于你的地方。甘于低微，可以让你保持低调，以及一颗愿意接纳新想法的心。\n\n### 培养自己的拥趸 <small>Build an audience</small>\n> \n通过提供有价值的内容，来培养自己的粉丝。\n\n### 普及知识，赢得竞争 <small>Out-teach your competition</small>\n> \n国内的很多技术团队，都有各自的技术博客，都会有分享的习惯。\n如果他们的内容强劲，他们所做的产品和项目也会备受关注。\n\n### 效仿大厨 <small>Emulate chefs</small>\n> \n分享知识，是我一直所推崇的。\n能帮助别人，记录进步，好处是不少的。\n\n### 没人喜欢塑料花 <small>Nobody likes plostic flowers</small>\n> \n不完美才真实，这一篇有很多优美的句子，尽管是翻译的句子。这让我好奇原版是怎么样的句子了。\n这些句子，都谈论了一个道理：直面弱点，做真实的自己，把真实的自己展示给别人。\n摘抄：\n1. 不完美才真实，真实才能激起人们的共鸣。\n2. 繁华落尽见真淳。\n3. \"保留原有的韵致\"是一种美丽的行事方法。\n4. 过度的雕琢会使事物失去灵魂，变得机械乏味。\n\n### 一夜成名只是传说 <small>The myth of the overnight sensation</small>\n> \n文章中谈论到的几点，也是对个人来说很有启发性。\n你要拥有足够牢固的基础来支撑你以后的名声。\n现在就需要开始一点一滴的培养基础，和你的观众。\n\n## 招聘篇\n\n### 受不了时再招人 <small>Hire when it hurts</small>\n> \n这也是对于创业团队，或者小团队而言。\n在大公司的团队中，往往所分配的名额是固定的。\n申请名额不容易，所以会导致很多一些部门都是招人进来先占个坑。\n\n### 放弃牛人 <small>Pass on greate people</small>\n> \n这个也是大公司毛病，很多都是储备员工，也是没事找事干。\n站在牛人的角度来想问题的话，在一个方向牛起来，总会有需要你的地方。\n\n### 鸡尾酒会上的陌生人 <small>Strangers at a cocktail party</small>\n> \n招人，要给予足够的时间来交谈，得到充分的相互了解。\n应聘，同样对你所应聘的公司给予足够的关注和充分的沟通。\n\n### 可笑的求职简历 <small>Resumes are ridiculous</small>\n> \n要充分的了解你所应聘的公司，这是未来很长一段时间共同奋斗的团队。\n这考验了你的信息收集能力，和社交能力。\n\n### 多年的无关经验 <small>Years of irrelevance</small>\n> \n熟悉、掌握一门技术活，只需要半年到一年的时间。\n而在这之后，真正要看的是个人的努力程度、性格差异、智力水平以及工作态度。\n当然，还有基础知识的积累。\n例如你说有两年的NodeJS工作经验，但是基础的JavaScript都吃不通的话，让别人怎么相信你过去的努力程度。\n\n## 救灾篇\n\n### 主动掌控负面新闻 <small>Own your bad news</small>\n> \n自己的糗事由自己来说比别人来说，结果会好得多。\n本篇说的，我总结三个字：责任心。\n愿意承担起责任的人，总是受人尊重。\n\n## 文化篇\n\n### 文化不是由谁创造的 <small>You don't create a culture</small>\n> \n但是对于小团队来说，企业文化往往取决于创始人的个人魅力。\n\n### 决策都是临时性的 <small>Decisions are temporary</small>\n> \n在平时工作中，考虑功能实现的时候也是如此。\n考虑得多是好事，但要参考特定环境的符合程度。\n渐渐地感觉到了，担心的事情大多不会真的发生，当它真的发生了，再考虑对策吧。\n\n### 跳过摇滚明星 <small>Skip the rock starts</small>\n> \n巨星环境的生成源于信任、自律以及责任感，是给予员工充分的隐私权、空间以及必备工具的结果。\n所以BAT的技术团队才那么多人趋之若鹜。\n\n### 员工不知13岁 <small>They're not children</small>\n> \n当你像小孩一样行事，别人也会把你当小孩子。\n如何获得信任？\n让你的工作在领导不用操心的情况下完成，在遇到问题和不懂的地方，先尝试自己解决。\n\n### 发出你的心声 <small>Sound like you</small>\n> \n悲惨的是国内的应试语文教育，只会扼杀大部分人的写作能力。\n真正的写作是一种自由、个性、观点的表述过程。\n而不是那些为作文题目，为分数而写的非自愿的文章。\n\n### 需要避开的词汇 <small>Four-letters words</small>\n> \n避开那种「非黑即白」的词语，真相往往不是非黑即白。\n\n## 总结篇\n\n### 灵感稍纵即逝\n> \n有些灵感也会因为当前能力的局限而难以实现。\n但如果仅因为这样而放弃或者耽误你的灵感，是十分浪费的。\n所以，在灵感还没来的时候就要「厚积」，而当灵感来敲门了，不管是否有足够的执行力，先开始了再说。\n\n","source":"_posts/读《重来》.md","raw":"---\ntitle: 读《重来》\ncategory: 人丑就要多读书\ndate: 2016-07-07 00:14:25\ntags: \n- 读书笔记\n---\n\n之前我们团队一直在用Coding来作为代码仓库，以及团队协作的工具。大半年下来，攒了不少「码币」，正好碰上Coding的码市搞活动，用码币换取一些Coding的周边，我翻到码市页面的最底下，正好有《重来》这本书可以兑换。对于码农来说，书是一个廉价却特别有价值的东西，于是毫不犹豫就兑换了这本书。\n\n《重来》，也叫《Rework》，作者是37signals的两位创始人：Json Fried, David Heinemeier Hansson。\n这本书的主题是「创业」，书中蕴含了90条作者在创业过程中的商业思维，把它们分篇到12个章节中。\n读这本书的过程中，我会在每一条有所体会，有所思的「思维」中，用铅笔在空白处写下自己的思考。\n读这本书的感觉很像以前读的一本《人性的弱点》，都是教条式的写作。\n其中的每一条，描述的篇幅都很小，但是每一条都需要思思品味，好好感悟。\n很多「思维」中，虽然描述中明显的指向到「创业」思维中，但是我认为很多跟平时我们做人做事的原则很相符。\n读书的过程虽慢，但是我却很认真，对一本好的书，多认真都不显得过分。\n故以此文记录这些笔记。\n\n## 卸负篇\n\n### 哪来的从错误中学习 <small>Learning from mistakes is overrated</small>\n> \n在广义上，成功时并不需要知道失败所遇到的事情\n若放在小事上，例如编程，有一些不折腾过，并不知道以后出错时如何解决\n但也可以延伸另外一个观点：寻找前往成功的直径，绕开不必要的弯路。\n\n### 计划既瞎猜 <small>Planning is guessing</small>\n> \n这篇的说法很符合「说走就走的旅行」的观念。\n计划有用，是对未来的憧憬，但行动更重要，做自己想做的。\n\n### 何必壮大 <small>Why grow?</small>\n> \n在这一篇中，我想起了海贼王中「草帽路飞」海贼团。\n团队中每个人都能独当一面，且有一个统一的向心点。\n\n### 工作狂 <small>Workaholism</small>\n> \n这篇虽说加班，但更深层是效率的问题。\n追求在对的方向，以对的方式快速完成事情。\n\n## 行动篇\n\n### 挠自己的痒处 <small>Scratch your own itch</small> \n> \n为自己服务，解决自己的痛点，顺便造福一下人类。\n让我想起了我那几个搁浅的开源项目-_-!\n\n### 着手做点什么 <small>Start making something</small>\n> \n价值并不在创意，而在于执行力。\n\n### 画沙为界，立场明确 <small>Draw a line in the sand</small>\n> \n让自己更加主见，并且为你的主见提供足够让人信服的论证，如果没有，就去创造这样的论证。\n这一篇有点「乔布斯」的味道，特立独行，打造自身的个性品牌，并无刻意迎合大众。\n这又让我想起了魅族改变路线，迎合消费者，冲销量的做法。\n但是，毕竟它身处一个苛刻的战场。\n\n### 万不得已不筹资 <small>Outside money is Plan 2</small>\n> \n这篇文章是站在创始人视角看待问题。\n从另外一个角度来说，要看待投资方是谁。\n如果是一些基金会，它们需要的是急切的盈利，想到的是如何套现。\n而如果是看中你所做的事情，想一起合作的，或者合并你的公司的投资方就不一样了。他会把你所做的事情当做自己的事情来做。\n\n## 进阶篇\n\n### 条件受限是好事 <small>Embrace constaints</small>\n> \n本篇强调「灵活」与「限制」。\n提出了一个让我所有共鸣，以往能感觉到却没能形容的观点：\n以艰苦的条件来激发人的创造力。\n\n### 与其做个半成品，不如做好半个产品 <small>Build half a product. Not a half-assed product</small>\n> \n不要大而全，只要简而美。\n兴趣与学习也是一个道理，选一件最需要做好的事情投入。\n\n### 从核心出发 <small>Start at the epicenter</small>\n> \n选择能做的，想做的，必须做的。\n\n### 不要过早关注细节 <small>Ignore the details early on</small>\n> \n从整体到局部的思想，做设计、做架构，都是先有个轮廓，然后一点点细化。\n\n### 作出决定就是取得进展 <small>Making the call is making progress</small>\n> \n规划总是要有个度，太近的不够全面，太远的变数太多，不切实际。\n当有了想法，尽早做个决定，先尝试走几步吧。\n\n### 当好博物馆长 <small>Be a curator</small>\n> \n精简，小而美。\n不必追求大而全，东西要发挥它的作用。\n\n### 关注不变因素 <small>Focus on what won't change</small>\n> \n英语、经济学、写作、音乐，\n这一些都是性价比颇高的素质，都十分有助于一个人的内在修养。\n\n### 音乐就在你的指尖流淌 <small>Tone is in your fingers</small>\n> \n抛开工具，关注事物的内在。\n工具，是在你了解了其内部原理之后用来提升效率的。\n\n### 卖掉副产品 <small>Sell your by-products</small>\n> \n对于我的工作来说，把学习的过程，工作上遇到的问题给写下来，发表到博客，这就是我的副产品。\n\n### 立马就上线 <small>Launch now</small>\n> \n第一个版本：一个能用的版本\n\n## 效率篇\n\n### 赞同的错觉 <small>Illusions of agreement</small>\n> \n很多时候多希望有一个idea出现的时候，立马可以动手来做，而不用太在意后来的事情。\n但我认为，需要谨慎的事情需要适度的设计和考虑。\n\n### 打岔是效率的敌人 <small>Interruption is the enemy of productivity</small>\n> \n这一点让我深有体会，并且一直在挣扎的事情。\n尝试过番茄工作法，并且尝试让同事理解我这样的做法。\n并不接受直接过来打扰的沟通方式。\n\n### 刚刚好就是真的好 <small>Good enough is fine</small>\n> \n以小博大，遵循简单，首要目的是把事情做好，做出来。\n后面可以随时改善以及改进。\n\n### 速战速决 <small>Quick Wins</small>\n> \n在这一章中，作者多次提出一个概念，或者是思维：不要等，马上行动!\n在我眼中，这里还有一个思维：积跬步以至千里。\n这跟我的座右铭很相似：厚积薄发。\n\n### 不要逞英雄 <small>Don't be a hero</small>\n> \n把你的时间花在最值得花的地方，并且要量力而行，学会放弃\n\n### 该睡觉时就睡觉 <small>Go to sleep</small>\n> \n学会休息，并且是高效的休息。\n因为疲倦会带来懒惰思考、缺乏创意、士气低落、情绪失控。\n\n### 预估的都是垃圾 <small>Your estimates suck</small>\n> \n对于自己的学习计划也是如此，很多东西想学，却不知从哪个开始，怎么开始。\n那么就把它们排个序，然后逐个评估时间，然后马上执行。\n\n### 罗列问题，不得解决 <small>Long lists don't get done</small>\n> \n把大任务分成小任务，并从小任务中获得成就感。\n\n## 对手篇\n\n### 拒绝照搬 <small>Don't copy</small>\n> \n在学习的方向上，需要模仿，这是一种有效的学习方式。\nCopy-Paste的过程中，尽量知其所以然。\n不需要盲从，掌握主动。\n\n### 向对手挑战 <small>Pick a fight</small>\n> \n调侃对手这种做法，更偏向于一种营销手段，需要玩出自己的特色。\n在国内，这种案例也很多，被网友戏称「碰瓷营销」。\n\n### 给竞争力做减法 <small>Underdo your competition</small>\n> \n一款简约的产品，只需要集中解决用户的一个主要的痛点，而且如果以低成本随手可得的话，更加容易成为流行品。\n\n## 进化篇\n\n### 头脑发热不等于当务之急 <small>Don't confuse enthusiasm with priority</small>\n> \n避免头脑发热，有些事情或决定，可以先放着，过几天再回来看看。\n在《人性的弱点》中，也有类似的观点，那是这样的一个说法：一封愤怒的信，先放几天再决定是否要寄出。\n\n### 家用便利就是好 <small>Be at home good</small>\n> \n弄清哪个是本，哪个是辅\n\n### 甘于低微 <small>Welcome obscurity</small>\n> \n之所以说籍籍无名值得庆幸。\n是因为在这个阶段犯的错误，并没有放大效应，试错成本低。\n对于「甘于低微」，我还有另外一种理解。\n每个人都有他的优点，有胜于你的地方。甘于低微，可以让你保持低调，以及一颗愿意接纳新想法的心。\n\n### 培养自己的拥趸 <small>Build an audience</small>\n> \n通过提供有价值的内容，来培养自己的粉丝。\n\n### 普及知识，赢得竞争 <small>Out-teach your competition</small>\n> \n国内的很多技术团队，都有各自的技术博客，都会有分享的习惯。\n如果他们的内容强劲，他们所做的产品和项目也会备受关注。\n\n### 效仿大厨 <small>Emulate chefs</small>\n> \n分享知识，是我一直所推崇的。\n能帮助别人，记录进步，好处是不少的。\n\n### 没人喜欢塑料花 <small>Nobody likes plostic flowers</small>\n> \n不完美才真实，这一篇有很多优美的句子，尽管是翻译的句子。这让我好奇原版是怎么样的句子了。\n这些句子，都谈论了一个道理：直面弱点，做真实的自己，把真实的自己展示给别人。\n摘抄：\n1. 不完美才真实，真实才能激起人们的共鸣。\n2. 繁华落尽见真淳。\n3. \"保留原有的韵致\"是一种美丽的行事方法。\n4. 过度的雕琢会使事物失去灵魂，变得机械乏味。\n\n### 一夜成名只是传说 <small>The myth of the overnight sensation</small>\n> \n文章中谈论到的几点，也是对个人来说很有启发性。\n你要拥有足够牢固的基础来支撑你以后的名声。\n现在就需要开始一点一滴的培养基础，和你的观众。\n\n## 招聘篇\n\n### 受不了时再招人 <small>Hire when it hurts</small>\n> \n这也是对于创业团队，或者小团队而言。\n在大公司的团队中，往往所分配的名额是固定的。\n申请名额不容易，所以会导致很多一些部门都是招人进来先占个坑。\n\n### 放弃牛人 <small>Pass on greate people</small>\n> \n这个也是大公司毛病，很多都是储备员工，也是没事找事干。\n站在牛人的角度来想问题的话，在一个方向牛起来，总会有需要你的地方。\n\n### 鸡尾酒会上的陌生人 <small>Strangers at a cocktail party</small>\n> \n招人，要给予足够的时间来交谈，得到充分的相互了解。\n应聘，同样对你所应聘的公司给予足够的关注和充分的沟通。\n\n### 可笑的求职简历 <small>Resumes are ridiculous</small>\n> \n要充分的了解你所应聘的公司，这是未来很长一段时间共同奋斗的团队。\n这考验了你的信息收集能力，和社交能力。\n\n### 多年的无关经验 <small>Years of irrelevance</small>\n> \n熟悉、掌握一门技术活，只需要半年到一年的时间。\n而在这之后，真正要看的是个人的努力程度、性格差异、智力水平以及工作态度。\n当然，还有基础知识的积累。\n例如你说有两年的NodeJS工作经验，但是基础的JavaScript都吃不通的话，让别人怎么相信你过去的努力程度。\n\n## 救灾篇\n\n### 主动掌控负面新闻 <small>Own your bad news</small>\n> \n自己的糗事由自己来说比别人来说，结果会好得多。\n本篇说的，我总结三个字：责任心。\n愿意承担起责任的人，总是受人尊重。\n\n## 文化篇\n\n### 文化不是由谁创造的 <small>You don't create a culture</small>\n> \n但是对于小团队来说，企业文化往往取决于创始人的个人魅力。\n\n### 决策都是临时性的 <small>Decisions are temporary</small>\n> \n在平时工作中，考虑功能实现的时候也是如此。\n考虑得多是好事，但要参考特定环境的符合程度。\n渐渐地感觉到了，担心的事情大多不会真的发生，当它真的发生了，再考虑对策吧。\n\n### 跳过摇滚明星 <small>Skip the rock starts</small>\n> \n巨星环境的生成源于信任、自律以及责任感，是给予员工充分的隐私权、空间以及必备工具的结果。\n所以BAT的技术团队才那么多人趋之若鹜。\n\n### 员工不知13岁 <small>They're not children</small>\n> \n当你像小孩一样行事，别人也会把你当小孩子。\n如何获得信任？\n让你的工作在领导不用操心的情况下完成，在遇到问题和不懂的地方，先尝试自己解决。\n\n### 发出你的心声 <small>Sound like you</small>\n> \n悲惨的是国内的应试语文教育，只会扼杀大部分人的写作能力。\n真正的写作是一种自由、个性、观点的表述过程。\n而不是那些为作文题目，为分数而写的非自愿的文章。\n\n### 需要避开的词汇 <small>Four-letters words</small>\n> \n避开那种「非黑即白」的词语，真相往往不是非黑即白。\n\n## 总结篇\n\n### 灵感稍纵即逝\n> \n有些灵感也会因为当前能力的局限而难以实现。\n但如果仅因为这样而放弃或者耽误你的灵感，是十分浪费的。\n所以，在灵感还没来的时候就要「厚积」，而当灵感来敲门了，不管是否有足够的执行力，先开始了再说。\n\n","slug":"读《重来》","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8r0000jxwrlk8wefpgk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>之前我们团队一直在用Coding来作为代码仓库，以及团队协作的工具。大半年下来，攒了不少「码币」，正好碰上Coding的码市搞活动，用码币换取一些Coding的周边，我翻到码市页面的最底下，正好有《重来》这本书可以兑换。对于码农来说，书是一个廉价却特别有价值的东西，于是毫不犹豫就兑换了这本书。</p>\n<p>《重来》，也叫《Rework》，作者是37signals的两位创始人：Json Fried, David Heinemeier Hansson。<br>这本书的主题是「创业」，书中蕴含了90条作者在创业过程中的商业思维，把它们分篇到12个章节中。<br>读这本书的过程中，我会在每一条有所体会，有所思的「思维」中，用铅笔在空白处写下自己的思考。<br>读这本书的感觉很像以前读的一本《人性的弱点》，都是教条式的写作。<br>其中的每一条，描述的篇幅都很小，但是每一条都需要思思品味，好好感悟。<br>很多「思维」中，虽然描述中明显的指向到「创业」思维中，但是我认为很多跟平时我们做人做事的原则很相符。<br>读书的过程虽慢，但是我却很认真，对一本好的书，多认真都不显得过分。<br>故以此文记录这些笔记。</p>\n<h2 id=\"卸负篇\"><a href=\"#卸负篇\" class=\"headerlink\" title=\"卸负篇\"></a>卸负篇</h2><h3 id=\"哪来的从错误中学习-Learning-from-mistakes-is-overrated\"><a href=\"#哪来的从错误中学习-Learning-from-mistakes-is-overrated\" class=\"headerlink\" title=\"哪来的从错误中学习 Learning from mistakes is overrated\"></a>哪来的从错误中学习 <small>Learning from mistakes is overrated</small></h3><blockquote>\n</blockquote>\n<p>在广义上，成功时并不需要知道失败所遇到的事情<br>若放在小事上，例如编程，有一些不折腾过，并不知道以后出错时如何解决<br>但也可以延伸另外一个观点：寻找前往成功的直径，绕开不必要的弯路。</p>\n<h3 id=\"计划既瞎猜-Planning-is-guessing\"><a href=\"#计划既瞎猜-Planning-is-guessing\" class=\"headerlink\" title=\"计划既瞎猜 Planning is guessing\"></a>计划既瞎猜 <small>Planning is guessing</small></h3><blockquote>\n</blockquote>\n<p>这篇的说法很符合「说走就走的旅行」的观念。<br>计划有用，是对未来的憧憬，但行动更重要，做自己想做的。</p>\n<h3 id=\"何必壮大-Why-grow\"><a href=\"#何必壮大-Why-grow\" class=\"headerlink\" title=\"何必壮大 Why grow?\"></a>何必壮大 <small>Why grow?</small></h3><blockquote>\n</blockquote>\n<p>在这一篇中，我想起了海贼王中「草帽路飞」海贼团。<br>团队中每个人都能独当一面，且有一个统一的向心点。</p>\n<h3 id=\"工作狂-Workaholism\"><a href=\"#工作狂-Workaholism\" class=\"headerlink\" title=\"工作狂 Workaholism\"></a>工作狂 <small>Workaholism</small></h3><blockquote>\n</blockquote>\n<p>这篇虽说加班，但更深层是效率的问题。<br>追求在对的方向，以对的方式快速完成事情。</p>\n<h2 id=\"行动篇\"><a href=\"#行动篇\" class=\"headerlink\" title=\"行动篇\"></a>行动篇</h2><h3 id=\"挠自己的痒处-Scratch-your-own-itch\"><a href=\"#挠自己的痒处-Scratch-your-own-itch\" class=\"headerlink\" title=\"挠自己的痒处 Scratch your own itch\"></a>挠自己的痒处 <small>Scratch your own itch</small></h3><blockquote>\n</blockquote>\n<p>为自己服务，解决自己的痛点，顺便造福一下人类。<br>让我想起了我那几个搁浅的开源项目-_-!</p>\n<h3 id=\"着手做点什么-Start-making-something\"><a href=\"#着手做点什么-Start-making-something\" class=\"headerlink\" title=\"着手做点什么 Start making something\"></a>着手做点什么 <small>Start making something</small></h3><blockquote>\n</blockquote>\n<p>价值并不在创意，而在于执行力。</p>\n<h3 id=\"画沙为界，立场明确-Draw-a-line-in-the-sand\"><a href=\"#画沙为界，立场明确-Draw-a-line-in-the-sand\" class=\"headerlink\" title=\"画沙为界，立场明确 Draw a line in the sand\"></a>画沙为界，立场明确 <small>Draw a line in the sand</small></h3><blockquote>\n</blockquote>\n<p>让自己更加主见，并且为你的主见提供足够让人信服的论证，如果没有，就去创造这样的论证。<br>这一篇有点「乔布斯」的味道，特立独行，打造自身的个性品牌，并无刻意迎合大众。<br>这又让我想起了魅族改变路线，迎合消费者，冲销量的做法。<br>但是，毕竟它身处一个苛刻的战场。</p>\n<h3 id=\"万不得已不筹资-Outside-money-is-Plan-2\"><a href=\"#万不得已不筹资-Outside-money-is-Plan-2\" class=\"headerlink\" title=\"万不得已不筹资 Outside money is Plan 2\"></a>万不得已不筹资 <small>Outside money is Plan 2</small></h3><blockquote>\n</blockquote>\n<p>这篇文章是站在创始人视角看待问题。<br>从另外一个角度来说，要看待投资方是谁。<br>如果是一些基金会，它们需要的是急切的盈利，想到的是如何套现。<br>而如果是看中你所做的事情，想一起合作的，或者合并你的公司的投资方就不一样了。他会把你所做的事情当做自己的事情来做。</p>\n<h2 id=\"进阶篇\"><a href=\"#进阶篇\" class=\"headerlink\" title=\"进阶篇\"></a>进阶篇</h2><h3 id=\"条件受限是好事-Embrace-constaints\"><a href=\"#条件受限是好事-Embrace-constaints\" class=\"headerlink\" title=\"条件受限是好事 Embrace constaints\"></a>条件受限是好事 <small>Embrace constaints</small></h3><blockquote>\n</blockquote>\n<p>本篇强调「灵活」与「限制」。<br>提出了一个让我所有共鸣，以往能感觉到却没能形容的观点：<br>以艰苦的条件来激发人的创造力。</p>\n<h3 id=\"与其做个半成品，不如做好半个产品-Build-half-a-product-Not-a-half-assed-product\"><a href=\"#与其做个半成品，不如做好半个产品-Build-half-a-product-Not-a-half-assed-product\" class=\"headerlink\" title=\"与其做个半成品，不如做好半个产品 Build half a product. Not a half-assed product\"></a>与其做个半成品，不如做好半个产品 <small>Build half a product. Not a half-assed product</small></h3><blockquote>\n</blockquote>\n<p>不要大而全，只要简而美。<br>兴趣与学习也是一个道理，选一件最需要做好的事情投入。</p>\n<h3 id=\"从核心出发-Start-at-the-epicenter\"><a href=\"#从核心出发-Start-at-the-epicenter\" class=\"headerlink\" title=\"从核心出发 Start at the epicenter\"></a>从核心出发 <small>Start at the epicenter</small></h3><blockquote>\n</blockquote>\n<p>选择能做的，想做的，必须做的。</p>\n<h3 id=\"不要过早关注细节-Ignore-the-details-early-on\"><a href=\"#不要过早关注细节-Ignore-the-details-early-on\" class=\"headerlink\" title=\"不要过早关注细节 Ignore the details early on\"></a>不要过早关注细节 <small>Ignore the details early on</small></h3><blockquote>\n</blockquote>\n<p>从整体到局部的思想，做设计、做架构，都是先有个轮廓，然后一点点细化。</p>\n<h3 id=\"作出决定就是取得进展-Making-the-call-is-making-progress\"><a href=\"#作出决定就是取得进展-Making-the-call-is-making-progress\" class=\"headerlink\" title=\"作出决定就是取得进展 Making the call is making progress\"></a>作出决定就是取得进展 <small>Making the call is making progress</small></h3><blockquote>\n</blockquote>\n<p>规划总是要有个度，太近的不够全面，太远的变数太多，不切实际。<br>当有了想法，尽早做个决定，先尝试走几步吧。</p>\n<h3 id=\"当好博物馆长-Be-a-curator\"><a href=\"#当好博物馆长-Be-a-curator\" class=\"headerlink\" title=\"当好博物馆长 Be a curator\"></a>当好博物馆长 <small>Be a curator</small></h3><blockquote>\n</blockquote>\n<p>精简，小而美。<br>不必追求大而全，东西要发挥它的作用。</p>\n<h3 id=\"关注不变因素-Focus-on-what-won’t-change\"><a href=\"#关注不变因素-Focus-on-what-won’t-change\" class=\"headerlink\" title=\"关注不变因素 Focus on what won’t change\"></a>关注不变因素 <small>Focus on what won’t change</small></h3><blockquote>\n</blockquote>\n<p>英语、经济学、写作、音乐，<br>这一些都是性价比颇高的素质，都十分有助于一个人的内在修养。</p>\n<h3 id=\"音乐就在你的指尖流淌-Tone-is-in-your-fingers\"><a href=\"#音乐就在你的指尖流淌-Tone-is-in-your-fingers\" class=\"headerlink\" title=\"音乐就在你的指尖流淌 Tone is in your fingers\"></a>音乐就在你的指尖流淌 <small>Tone is in your fingers</small></h3><blockquote>\n</blockquote>\n<p>抛开工具，关注事物的内在。<br>工具，是在你了解了其内部原理之后用来提升效率的。</p>\n<h3 id=\"卖掉副产品-Sell-your-by-products\"><a href=\"#卖掉副产品-Sell-your-by-products\" class=\"headerlink\" title=\"卖掉副产品 Sell your by-products\"></a>卖掉副产品 <small>Sell your by-products</small></h3><blockquote>\n</blockquote>\n<p>对于我的工作来说，把学习的过程，工作上遇到的问题给写下来，发表到博客，这就是我的副产品。</p>\n<h3 id=\"立马就上线-Launch-now\"><a href=\"#立马就上线-Launch-now\" class=\"headerlink\" title=\"立马就上线 Launch now\"></a>立马就上线 <small>Launch now</small></h3><blockquote>\n</blockquote>\n<p>第一个版本：一个能用的版本</p>\n<h2 id=\"效率篇\"><a href=\"#效率篇\" class=\"headerlink\" title=\"效率篇\"></a>效率篇</h2><h3 id=\"赞同的错觉-Illusions-of-agreement\"><a href=\"#赞同的错觉-Illusions-of-agreement\" class=\"headerlink\" title=\"赞同的错觉 Illusions of agreement\"></a>赞同的错觉 <small>Illusions of agreement</small></h3><blockquote>\n</blockquote>\n<p>很多时候多希望有一个idea出现的时候，立马可以动手来做，而不用太在意后来的事情。<br>但我认为，需要谨慎的事情需要适度的设计和考虑。</p>\n<h3 id=\"打岔是效率的敌人-Interruption-is-the-enemy-of-productivity\"><a href=\"#打岔是效率的敌人-Interruption-is-the-enemy-of-productivity\" class=\"headerlink\" title=\"打岔是效率的敌人 Interruption is the enemy of productivity\"></a>打岔是效率的敌人 <small>Interruption is the enemy of productivity</small></h3><blockquote>\n</blockquote>\n<p>这一点让我深有体会，并且一直在挣扎的事情。<br>尝试过番茄工作法，并且尝试让同事理解我这样的做法。<br>并不接受直接过来打扰的沟通方式。</p>\n<h3 id=\"刚刚好就是真的好-Good-enough-is-fine\"><a href=\"#刚刚好就是真的好-Good-enough-is-fine\" class=\"headerlink\" title=\"刚刚好就是真的好 Good enough is fine\"></a>刚刚好就是真的好 <small>Good enough is fine</small></h3><blockquote>\n</blockquote>\n<p>以小博大，遵循简单，首要目的是把事情做好，做出来。<br>后面可以随时改善以及改进。</p>\n<h3 id=\"速战速决-Quick-Wins\"><a href=\"#速战速决-Quick-Wins\" class=\"headerlink\" title=\"速战速决 Quick Wins\"></a>速战速决 <small>Quick Wins</small></h3><blockquote>\n</blockquote>\n<p>在这一章中，作者多次提出一个概念，或者是思维：不要等，马上行动!<br>在我眼中，这里还有一个思维：积跬步以至千里。<br>这跟我的座右铭很相似：厚积薄发。</p>\n<h3 id=\"不要逞英雄-Don’t-be-a-hero\"><a href=\"#不要逞英雄-Don’t-be-a-hero\" class=\"headerlink\" title=\"不要逞英雄 Don’t be a hero\"></a>不要逞英雄 <small>Don’t be a hero</small></h3><blockquote>\n</blockquote>\n<p>把你的时间花在最值得花的地方，并且要量力而行，学会放弃</p>\n<h3 id=\"该睡觉时就睡觉-Go-to-sleep\"><a href=\"#该睡觉时就睡觉-Go-to-sleep\" class=\"headerlink\" title=\"该睡觉时就睡觉 Go to sleep\"></a>该睡觉时就睡觉 <small>Go to sleep</small></h3><blockquote>\n</blockquote>\n<p>学会休息，并且是高效的休息。<br>因为疲倦会带来懒惰思考、缺乏创意、士气低落、情绪失控。</p>\n<h3 id=\"预估的都是垃圾-Your-estimates-suck\"><a href=\"#预估的都是垃圾-Your-estimates-suck\" class=\"headerlink\" title=\"预估的都是垃圾 Your estimates suck\"></a>预估的都是垃圾 <small>Your estimates suck</small></h3><blockquote>\n</blockquote>\n<p>对于自己的学习计划也是如此，很多东西想学，却不知从哪个开始，怎么开始。<br>那么就把它们排个序，然后逐个评估时间，然后马上执行。</p>\n<h3 id=\"罗列问题，不得解决-Long-lists-don’t-get-done\"><a href=\"#罗列问题，不得解决-Long-lists-don’t-get-done\" class=\"headerlink\" title=\"罗列问题，不得解决 Long lists don’t get done\"></a>罗列问题，不得解决 <small>Long lists don’t get done</small></h3><blockquote>\n</blockquote>\n<p>把大任务分成小任务，并从小任务中获得成就感。</p>\n<h2 id=\"对手篇\"><a href=\"#对手篇\" class=\"headerlink\" title=\"对手篇\"></a>对手篇</h2><h3 id=\"拒绝照搬-Don’t-copy\"><a href=\"#拒绝照搬-Don’t-copy\" class=\"headerlink\" title=\"拒绝照搬 Don’t copy\"></a>拒绝照搬 <small>Don’t copy</small></h3><blockquote>\n</blockquote>\n<p>在学习的方向上，需要模仿，这是一种有效的学习方式。<br>Copy-Paste的过程中，尽量知其所以然。<br>不需要盲从，掌握主动。</p>\n<h3 id=\"向对手挑战-Pick-a-fight\"><a href=\"#向对手挑战-Pick-a-fight\" class=\"headerlink\" title=\"向对手挑战 Pick a fight\"></a>向对手挑战 <small>Pick a fight</small></h3><blockquote>\n</blockquote>\n<p>调侃对手这种做法，更偏向于一种营销手段，需要玩出自己的特色。<br>在国内，这种案例也很多，被网友戏称「碰瓷营销」。</p>\n<h3 id=\"给竞争力做减法-Underdo-your-competition\"><a href=\"#给竞争力做减法-Underdo-your-competition\" class=\"headerlink\" title=\"给竞争力做减法 Underdo your competition\"></a>给竞争力做减法 <small>Underdo your competition</small></h3><blockquote>\n</blockquote>\n<p>一款简约的产品，只需要集中解决用户的一个主要的痛点，而且如果以低成本随手可得的话，更加容易成为流行品。</p>\n<h2 id=\"进化篇\"><a href=\"#进化篇\" class=\"headerlink\" title=\"进化篇\"></a>进化篇</h2><h3 id=\"头脑发热不等于当务之急-Don’t-confuse-enthusiasm-with-priority\"><a href=\"#头脑发热不等于当务之急-Don’t-confuse-enthusiasm-with-priority\" class=\"headerlink\" title=\"头脑发热不等于当务之急 Don’t confuse enthusiasm with priority\"></a>头脑发热不等于当务之急 <small>Don’t confuse enthusiasm with priority</small></h3><blockquote>\n</blockquote>\n<p>避免头脑发热，有些事情或决定，可以先放着，过几天再回来看看。<br>在《人性的弱点》中，也有类似的观点，那是这样的一个说法：一封愤怒的信，先放几天再决定是否要寄出。</p>\n<h3 id=\"家用便利就是好-Be-at-home-good\"><a href=\"#家用便利就是好-Be-at-home-good\" class=\"headerlink\" title=\"家用便利就是好 Be at home good\"></a>家用便利就是好 <small>Be at home good</small></h3><blockquote>\n</blockquote>\n<p>弄清哪个是本，哪个是辅</p>\n<h3 id=\"甘于低微-Welcome-obscurity\"><a href=\"#甘于低微-Welcome-obscurity\" class=\"headerlink\" title=\"甘于低微 Welcome obscurity\"></a>甘于低微 <small>Welcome obscurity</small></h3><blockquote>\n</blockquote>\n<p>之所以说籍籍无名值得庆幸。<br>是因为在这个阶段犯的错误，并没有放大效应，试错成本低。<br>对于「甘于低微」，我还有另外一种理解。<br>每个人都有他的优点，有胜于你的地方。甘于低微，可以让你保持低调，以及一颗愿意接纳新想法的心。</p>\n<h3 id=\"培养自己的拥趸-Build-an-audience\"><a href=\"#培养自己的拥趸-Build-an-audience\" class=\"headerlink\" title=\"培养自己的拥趸 Build an audience\"></a>培养自己的拥趸 <small>Build an audience</small></h3><blockquote>\n</blockquote>\n<p>通过提供有价值的内容，来培养自己的粉丝。</p>\n<h3 id=\"普及知识，赢得竞争-Out-teach-your-competition\"><a href=\"#普及知识，赢得竞争-Out-teach-your-competition\" class=\"headerlink\" title=\"普及知识，赢得竞争 Out-teach your competition\"></a>普及知识，赢得竞争 <small>Out-teach your competition</small></h3><blockquote>\n</blockquote>\n<p>国内的很多技术团队，都有各自的技术博客，都会有分享的习惯。<br>如果他们的内容强劲，他们所做的产品和项目也会备受关注。</p>\n<h3 id=\"效仿大厨-Emulate-chefs\"><a href=\"#效仿大厨-Emulate-chefs\" class=\"headerlink\" title=\"效仿大厨 Emulate chefs\"></a>效仿大厨 <small>Emulate chefs</small></h3><blockquote>\n</blockquote>\n<p>分享知识，是我一直所推崇的。<br>能帮助别人，记录进步，好处是不少的。</p>\n<h3 id=\"没人喜欢塑料花-Nobody-likes-plostic-flowers\"><a href=\"#没人喜欢塑料花-Nobody-likes-plostic-flowers\" class=\"headerlink\" title=\"没人喜欢塑料花 Nobody likes plostic flowers\"></a>没人喜欢塑料花 <small>Nobody likes plostic flowers</small></h3><blockquote>\n</blockquote>\n<p>不完美才真实，这一篇有很多优美的句子，尽管是翻译的句子。这让我好奇原版是怎么样的句子了。<br>这些句子，都谈论了一个道理：直面弱点，做真实的自己，把真实的自己展示给别人。<br>摘抄：</p>\n<ol>\n<li>不完美才真实，真实才能激起人们的共鸣。</li>\n<li>繁华落尽见真淳。</li>\n<li>“保留原有的韵致”是一种美丽的行事方法。</li>\n<li>过度的雕琢会使事物失去灵魂，变得机械乏味。</li>\n</ol>\n<h3 id=\"一夜成名只是传说-The-myth-of-the-overnight-sensation\"><a href=\"#一夜成名只是传说-The-myth-of-the-overnight-sensation\" class=\"headerlink\" title=\"一夜成名只是传说 The myth of the overnight sensation\"></a>一夜成名只是传说 <small>The myth of the overnight sensation</small></h3><blockquote>\n</blockquote>\n<p>文章中谈论到的几点，也是对个人来说很有启发性。<br>你要拥有足够牢固的基础来支撑你以后的名声。<br>现在就需要开始一点一滴的培养基础，和你的观众。</p>\n<h2 id=\"招聘篇\"><a href=\"#招聘篇\" class=\"headerlink\" title=\"招聘篇\"></a>招聘篇</h2><h3 id=\"受不了时再招人-Hire-when-it-hurts\"><a href=\"#受不了时再招人-Hire-when-it-hurts\" class=\"headerlink\" title=\"受不了时再招人 Hire when it hurts\"></a>受不了时再招人 <small>Hire when it hurts</small></h3><blockquote>\n</blockquote>\n<p>这也是对于创业团队，或者小团队而言。<br>在大公司的团队中，往往所分配的名额是固定的。<br>申请名额不容易，所以会导致很多一些部门都是招人进来先占个坑。</p>\n<h3 id=\"放弃牛人-Pass-on-greate-people\"><a href=\"#放弃牛人-Pass-on-greate-people\" class=\"headerlink\" title=\"放弃牛人 Pass on greate people\"></a>放弃牛人 <small>Pass on greate people</small></h3><blockquote>\n</blockquote>\n<p>这个也是大公司毛病，很多都是储备员工，也是没事找事干。<br>站在牛人的角度来想问题的话，在一个方向牛起来，总会有需要你的地方。</p>\n<h3 id=\"鸡尾酒会上的陌生人-Strangers-at-a-cocktail-party\"><a href=\"#鸡尾酒会上的陌生人-Strangers-at-a-cocktail-party\" class=\"headerlink\" title=\"鸡尾酒会上的陌生人 Strangers at a cocktail party\"></a>鸡尾酒会上的陌生人 <small>Strangers at a cocktail party</small></h3><blockquote>\n</blockquote>\n<p>招人，要给予足够的时间来交谈，得到充分的相互了解。<br>应聘，同样对你所应聘的公司给予足够的关注和充分的沟通。</p>\n<h3 id=\"可笑的求职简历-Resumes-are-ridiculous\"><a href=\"#可笑的求职简历-Resumes-are-ridiculous\" class=\"headerlink\" title=\"可笑的求职简历 Resumes are ridiculous\"></a>可笑的求职简历 <small>Resumes are ridiculous</small></h3><blockquote>\n</blockquote>\n<p>要充分的了解你所应聘的公司，这是未来很长一段时间共同奋斗的团队。<br>这考验了你的信息收集能力，和社交能力。</p>\n<h3 id=\"多年的无关经验-Years-of-irrelevance\"><a href=\"#多年的无关经验-Years-of-irrelevance\" class=\"headerlink\" title=\"多年的无关经验 Years of irrelevance\"></a>多年的无关经验 <small>Years of irrelevance</small></h3><blockquote>\n</blockquote>\n<p>熟悉、掌握一门技术活，只需要半年到一年的时间。<br>而在这之后，真正要看的是个人的努力程度、性格差异、智力水平以及工作态度。<br>当然，还有基础知识的积累。<br>例如你说有两年的NodeJS工作经验，但是基础的JavaScript都吃不通的话，让别人怎么相信你过去的努力程度。</p>\n<h2 id=\"救灾篇\"><a href=\"#救灾篇\" class=\"headerlink\" title=\"救灾篇\"></a>救灾篇</h2><h3 id=\"主动掌控负面新闻-Own-your-bad-news\"><a href=\"#主动掌控负面新闻-Own-your-bad-news\" class=\"headerlink\" title=\"主动掌控负面新闻 Own your bad news\"></a>主动掌控负面新闻 <small>Own your bad news</small></h3><blockquote>\n</blockquote>\n<p>自己的糗事由自己来说比别人来说，结果会好得多。<br>本篇说的，我总结三个字：责任心。<br>愿意承担起责任的人，总是受人尊重。</p>\n<h2 id=\"文化篇\"><a href=\"#文化篇\" class=\"headerlink\" title=\"文化篇\"></a>文化篇</h2><h3 id=\"文化不是由谁创造的-You-don’t-create-a-culture\"><a href=\"#文化不是由谁创造的-You-don’t-create-a-culture\" class=\"headerlink\" title=\"文化不是由谁创造的 You don’t create a culture\"></a>文化不是由谁创造的 <small>You don’t create a culture</small></h3><blockquote>\n</blockquote>\n<p>但是对于小团队来说，企业文化往往取决于创始人的个人魅力。</p>\n<h3 id=\"决策都是临时性的-Decisions-are-temporary\"><a href=\"#决策都是临时性的-Decisions-are-temporary\" class=\"headerlink\" title=\"决策都是临时性的 Decisions are temporary\"></a>决策都是临时性的 <small>Decisions are temporary</small></h3><blockquote>\n</blockquote>\n<p>在平时工作中，考虑功能实现的时候也是如此。<br>考虑得多是好事，但要参考特定环境的符合程度。<br>渐渐地感觉到了，担心的事情大多不会真的发生，当它真的发生了，再考虑对策吧。</p>\n<h3 id=\"跳过摇滚明星-Skip-the-rock-starts\"><a href=\"#跳过摇滚明星-Skip-the-rock-starts\" class=\"headerlink\" title=\"跳过摇滚明星 Skip the rock starts\"></a>跳过摇滚明星 <small>Skip the rock starts</small></h3><blockquote>\n</blockquote>\n<p>巨星环境的生成源于信任、自律以及责任感，是给予员工充分的隐私权、空间以及必备工具的结果。<br>所以BAT的技术团队才那么多人趋之若鹜。</p>\n<h3 id=\"员工不知13岁-They’re-not-children\"><a href=\"#员工不知13岁-They’re-not-children\" class=\"headerlink\" title=\"员工不知13岁 They’re not children\"></a>员工不知13岁 <small>They’re not children</small></h3><blockquote>\n</blockquote>\n<p>当你像小孩一样行事，别人也会把你当小孩子。<br>如何获得信任？<br>让你的工作在领导不用操心的情况下完成，在遇到问题和不懂的地方，先尝试自己解决。</p>\n<h3 id=\"发出你的心声-Sound-like-you\"><a href=\"#发出你的心声-Sound-like-you\" class=\"headerlink\" title=\"发出你的心声 Sound like you\"></a>发出你的心声 <small>Sound like you</small></h3><blockquote>\n</blockquote>\n<p>悲惨的是国内的应试语文教育，只会扼杀大部分人的写作能力。<br>真正的写作是一种自由、个性、观点的表述过程。<br>而不是那些为作文题目，为分数而写的非自愿的文章。</p>\n<h3 id=\"需要避开的词汇-Four-letters-words\"><a href=\"#需要避开的词汇-Four-letters-words\" class=\"headerlink\" title=\"需要避开的词汇 Four-letters words\"></a>需要避开的词汇 <small>Four-letters words</small></h3><blockquote>\n</blockquote>\n<p>避开那种「非黑即白」的词语，真相往往不是非黑即白。</p>\n<h2 id=\"总结篇\"><a href=\"#总结篇\" class=\"headerlink\" title=\"总结篇\"></a>总结篇</h2><h3 id=\"灵感稍纵即逝\"><a href=\"#灵感稍纵即逝\" class=\"headerlink\" title=\"灵感稍纵即逝\"></a>灵感稍纵即逝</h3><blockquote>\n</blockquote>\n<p>有些灵感也会因为当前能力的局限而难以实现。<br>但如果仅因为这样而放弃或者耽误你的灵感，是十分浪费的。<br>所以，在灵感还没来的时候就要「厚积」，而当灵感来敲门了，不管是否有足够的执行力，先开始了再说。</p>\n","excerpt":"","more":"<p>之前我们团队一直在用Coding来作为代码仓库，以及团队协作的工具。大半年下来，攒了不少「码币」，正好碰上Coding的码市搞活动，用码币换取一些Coding的周边，我翻到码市页面的最底下，正好有《重来》这本书可以兑换。对于码农来说，书是一个廉价却特别有价值的东西，于是毫不犹豫就兑换了这本书。</p>\n<p>《重来》，也叫《Rework》，作者是37signals的两位创始人：Json Fried, David Heinemeier Hansson。<br>这本书的主题是「创业」，书中蕴含了90条作者在创业过程中的商业思维，把它们分篇到12个章节中。<br>读这本书的过程中，我会在每一条有所体会，有所思的「思维」中，用铅笔在空白处写下自己的思考。<br>读这本书的感觉很像以前读的一本《人性的弱点》，都是教条式的写作。<br>其中的每一条，描述的篇幅都很小，但是每一条都需要思思品味，好好感悟。<br>很多「思维」中，虽然描述中明显的指向到「创业」思维中，但是我认为很多跟平时我们做人做事的原则很相符。<br>读书的过程虽慢，但是我却很认真，对一本好的书，多认真都不显得过分。<br>故以此文记录这些笔记。</p>\n<h2 id=\"卸负篇\"><a href=\"#卸负篇\" class=\"headerlink\" title=\"卸负篇\"></a>卸负篇</h2><h3 id=\"哪来的从错误中学习-Learning-from-mistakes-is-overrated\"><a href=\"#哪来的从错误中学习-Learning-from-mistakes-is-overrated\" class=\"headerlink\" title=\"哪来的从错误中学习 Learning from mistakes is overrated\"></a>哪来的从错误中学习 <small>Learning from mistakes is overrated</small></h3><blockquote>\n</blockquote>\n<p>在广义上，成功时并不需要知道失败所遇到的事情<br>若放在小事上，例如编程，有一些不折腾过，并不知道以后出错时如何解决<br>但也可以延伸另外一个观点：寻找前往成功的直径，绕开不必要的弯路。</p>\n<h3 id=\"计划既瞎猜-Planning-is-guessing\"><a href=\"#计划既瞎猜-Planning-is-guessing\" class=\"headerlink\" title=\"计划既瞎猜 Planning is guessing\"></a>计划既瞎猜 <small>Planning is guessing</small></h3><blockquote>\n</blockquote>\n<p>这篇的说法很符合「说走就走的旅行」的观念。<br>计划有用，是对未来的憧憬，但行动更重要，做自己想做的。</p>\n<h3 id=\"何必壮大-Why-grow\"><a href=\"#何必壮大-Why-grow\" class=\"headerlink\" title=\"何必壮大 Why grow?\"></a>何必壮大 <small>Why grow?</small></h3><blockquote>\n</blockquote>\n<p>在这一篇中，我想起了海贼王中「草帽路飞」海贼团。<br>团队中每个人都能独当一面，且有一个统一的向心点。</p>\n<h3 id=\"工作狂-Workaholism\"><a href=\"#工作狂-Workaholism\" class=\"headerlink\" title=\"工作狂 Workaholism\"></a>工作狂 <small>Workaholism</small></h3><blockquote>\n</blockquote>\n<p>这篇虽说加班，但更深层是效率的问题。<br>追求在对的方向，以对的方式快速完成事情。</p>\n<h2 id=\"行动篇\"><a href=\"#行动篇\" class=\"headerlink\" title=\"行动篇\"></a>行动篇</h2><h3 id=\"挠自己的痒处-Scratch-your-own-itch\"><a href=\"#挠自己的痒处-Scratch-your-own-itch\" class=\"headerlink\" title=\"挠自己的痒处 Scratch your own itch\"></a>挠自己的痒处 <small>Scratch your own itch</small></h3><blockquote>\n</blockquote>\n<p>为自己服务，解决自己的痛点，顺便造福一下人类。<br>让我想起了我那几个搁浅的开源项目-_-!</p>\n<h3 id=\"着手做点什么-Start-making-something\"><a href=\"#着手做点什么-Start-making-something\" class=\"headerlink\" title=\"着手做点什么 Start making something\"></a>着手做点什么 <small>Start making something</small></h3><blockquote>\n</blockquote>\n<p>价值并不在创意，而在于执行力。</p>\n<h3 id=\"画沙为界，立场明确-Draw-a-line-in-the-sand\"><a href=\"#画沙为界，立场明确-Draw-a-line-in-the-sand\" class=\"headerlink\" title=\"画沙为界，立场明确 Draw a line in the sand\"></a>画沙为界，立场明确 <small>Draw a line in the sand</small></h3><blockquote>\n</blockquote>\n<p>让自己更加主见，并且为你的主见提供足够让人信服的论证，如果没有，就去创造这样的论证。<br>这一篇有点「乔布斯」的味道，特立独行，打造自身的个性品牌，并无刻意迎合大众。<br>这又让我想起了魅族改变路线，迎合消费者，冲销量的做法。<br>但是，毕竟它身处一个苛刻的战场。</p>\n<h3 id=\"万不得已不筹资-Outside-money-is-Plan-2\"><a href=\"#万不得已不筹资-Outside-money-is-Plan-2\" class=\"headerlink\" title=\"万不得已不筹资 Outside money is Plan 2\"></a>万不得已不筹资 <small>Outside money is Plan 2</small></h3><blockquote>\n</blockquote>\n<p>这篇文章是站在创始人视角看待问题。<br>从另外一个角度来说，要看待投资方是谁。<br>如果是一些基金会，它们需要的是急切的盈利，想到的是如何套现。<br>而如果是看中你所做的事情，想一起合作的，或者合并你的公司的投资方就不一样了。他会把你所做的事情当做自己的事情来做。</p>\n<h2 id=\"进阶篇\"><a href=\"#进阶篇\" class=\"headerlink\" title=\"进阶篇\"></a>进阶篇</h2><h3 id=\"条件受限是好事-Embrace-constaints\"><a href=\"#条件受限是好事-Embrace-constaints\" class=\"headerlink\" title=\"条件受限是好事 Embrace constaints\"></a>条件受限是好事 <small>Embrace constaints</small></h3><blockquote>\n</blockquote>\n<p>本篇强调「灵活」与「限制」。<br>提出了一个让我所有共鸣，以往能感觉到却没能形容的观点：<br>以艰苦的条件来激发人的创造力。</p>\n<h3 id=\"与其做个半成品，不如做好半个产品-Build-half-a-product-Not-a-half-assed-product\"><a href=\"#与其做个半成品，不如做好半个产品-Build-half-a-product-Not-a-half-assed-product\" class=\"headerlink\" title=\"与其做个半成品，不如做好半个产品 Build half a product. Not a half-assed product\"></a>与其做个半成品，不如做好半个产品 <small>Build half a product. Not a half-assed product</small></h3><blockquote>\n</blockquote>\n<p>不要大而全，只要简而美。<br>兴趣与学习也是一个道理，选一件最需要做好的事情投入。</p>\n<h3 id=\"从核心出发-Start-at-the-epicenter\"><a href=\"#从核心出发-Start-at-the-epicenter\" class=\"headerlink\" title=\"从核心出发 Start at the epicenter\"></a>从核心出发 <small>Start at the epicenter</small></h3><blockquote>\n</blockquote>\n<p>选择能做的，想做的，必须做的。</p>\n<h3 id=\"不要过早关注细节-Ignore-the-details-early-on\"><a href=\"#不要过早关注细节-Ignore-the-details-early-on\" class=\"headerlink\" title=\"不要过早关注细节 Ignore the details early on\"></a>不要过早关注细节 <small>Ignore the details early on</small></h3><blockquote>\n</blockquote>\n<p>从整体到局部的思想，做设计、做架构，都是先有个轮廓，然后一点点细化。</p>\n<h3 id=\"作出决定就是取得进展-Making-the-call-is-making-progress\"><a href=\"#作出决定就是取得进展-Making-the-call-is-making-progress\" class=\"headerlink\" title=\"作出决定就是取得进展 Making the call is making progress\"></a>作出决定就是取得进展 <small>Making the call is making progress</small></h3><blockquote>\n</blockquote>\n<p>规划总是要有个度，太近的不够全面，太远的变数太多，不切实际。<br>当有了想法，尽早做个决定，先尝试走几步吧。</p>\n<h3 id=\"当好博物馆长-Be-a-curator\"><a href=\"#当好博物馆长-Be-a-curator\" class=\"headerlink\" title=\"当好博物馆长 Be a curator\"></a>当好博物馆长 <small>Be a curator</small></h3><blockquote>\n</blockquote>\n<p>精简，小而美。<br>不必追求大而全，东西要发挥它的作用。</p>\n<h3 id=\"关注不变因素-Focus-on-what-won’t-change\"><a href=\"#关注不变因素-Focus-on-what-won’t-change\" class=\"headerlink\" title=\"关注不变因素 Focus on what won’t change\"></a>关注不变因素 <small>Focus on what won’t change</small></h3><blockquote>\n</blockquote>\n<p>英语、经济学、写作、音乐，<br>这一些都是性价比颇高的素质，都十分有助于一个人的内在修养。</p>\n<h3 id=\"音乐就在你的指尖流淌-Tone-is-in-your-fingers\"><a href=\"#音乐就在你的指尖流淌-Tone-is-in-your-fingers\" class=\"headerlink\" title=\"音乐就在你的指尖流淌 Tone is in your fingers\"></a>音乐就在你的指尖流淌 <small>Tone is in your fingers</small></h3><blockquote>\n</blockquote>\n<p>抛开工具，关注事物的内在。<br>工具，是在你了解了其内部原理之后用来提升效率的。</p>\n<h3 id=\"卖掉副产品-Sell-your-by-products\"><a href=\"#卖掉副产品-Sell-your-by-products\" class=\"headerlink\" title=\"卖掉副产品 Sell your by-products\"></a>卖掉副产品 <small>Sell your by-products</small></h3><blockquote>\n</blockquote>\n<p>对于我的工作来说，把学习的过程，工作上遇到的问题给写下来，发表到博客，这就是我的副产品。</p>\n<h3 id=\"立马就上线-Launch-now\"><a href=\"#立马就上线-Launch-now\" class=\"headerlink\" title=\"立马就上线 Launch now\"></a>立马就上线 <small>Launch now</small></h3><blockquote>\n</blockquote>\n<p>第一个版本：一个能用的版本</p>\n<h2 id=\"效率篇\"><a href=\"#效率篇\" class=\"headerlink\" title=\"效率篇\"></a>效率篇</h2><h3 id=\"赞同的错觉-Illusions-of-agreement\"><a href=\"#赞同的错觉-Illusions-of-agreement\" class=\"headerlink\" title=\"赞同的错觉 Illusions of agreement\"></a>赞同的错觉 <small>Illusions of agreement</small></h3><blockquote>\n</blockquote>\n<p>很多时候多希望有一个idea出现的时候，立马可以动手来做，而不用太在意后来的事情。<br>但我认为，需要谨慎的事情需要适度的设计和考虑。</p>\n<h3 id=\"打岔是效率的敌人-Interruption-is-the-enemy-of-productivity\"><a href=\"#打岔是效率的敌人-Interruption-is-the-enemy-of-productivity\" class=\"headerlink\" title=\"打岔是效率的敌人 Interruption is the enemy of productivity\"></a>打岔是效率的敌人 <small>Interruption is the enemy of productivity</small></h3><blockquote>\n</blockquote>\n<p>这一点让我深有体会，并且一直在挣扎的事情。<br>尝试过番茄工作法，并且尝试让同事理解我这样的做法。<br>并不接受直接过来打扰的沟通方式。</p>\n<h3 id=\"刚刚好就是真的好-Good-enough-is-fine\"><a href=\"#刚刚好就是真的好-Good-enough-is-fine\" class=\"headerlink\" title=\"刚刚好就是真的好 Good enough is fine\"></a>刚刚好就是真的好 <small>Good enough is fine</small></h3><blockquote>\n</blockquote>\n<p>以小博大，遵循简单，首要目的是把事情做好，做出来。<br>后面可以随时改善以及改进。</p>\n<h3 id=\"速战速决-Quick-Wins\"><a href=\"#速战速决-Quick-Wins\" class=\"headerlink\" title=\"速战速决 Quick Wins\"></a>速战速决 <small>Quick Wins</small></h3><blockquote>\n</blockquote>\n<p>在这一章中，作者多次提出一个概念，或者是思维：不要等，马上行动!<br>在我眼中，这里还有一个思维：积跬步以至千里。<br>这跟我的座右铭很相似：厚积薄发。</p>\n<h3 id=\"不要逞英雄-Don’t-be-a-hero\"><a href=\"#不要逞英雄-Don’t-be-a-hero\" class=\"headerlink\" title=\"不要逞英雄 Don’t be a hero\"></a>不要逞英雄 <small>Don’t be a hero</small></h3><blockquote>\n</blockquote>\n<p>把你的时间花在最值得花的地方，并且要量力而行，学会放弃</p>\n<h3 id=\"该睡觉时就睡觉-Go-to-sleep\"><a href=\"#该睡觉时就睡觉-Go-to-sleep\" class=\"headerlink\" title=\"该睡觉时就睡觉 Go to sleep\"></a>该睡觉时就睡觉 <small>Go to sleep</small></h3><blockquote>\n</blockquote>\n<p>学会休息，并且是高效的休息。<br>因为疲倦会带来懒惰思考、缺乏创意、士气低落、情绪失控。</p>\n<h3 id=\"预估的都是垃圾-Your-estimates-suck\"><a href=\"#预估的都是垃圾-Your-estimates-suck\" class=\"headerlink\" title=\"预估的都是垃圾 Your estimates suck\"></a>预估的都是垃圾 <small>Your estimates suck</small></h3><blockquote>\n</blockquote>\n<p>对于自己的学习计划也是如此，很多东西想学，却不知从哪个开始，怎么开始。<br>那么就把它们排个序，然后逐个评估时间，然后马上执行。</p>\n<h3 id=\"罗列问题，不得解决-Long-lists-don’t-get-done\"><a href=\"#罗列问题，不得解决-Long-lists-don’t-get-done\" class=\"headerlink\" title=\"罗列问题，不得解决 Long lists don’t get done\"></a>罗列问题，不得解决 <small>Long lists don’t get done</small></h3><blockquote>\n</blockquote>\n<p>把大任务分成小任务，并从小任务中获得成就感。</p>\n<h2 id=\"对手篇\"><a href=\"#对手篇\" class=\"headerlink\" title=\"对手篇\"></a>对手篇</h2><h3 id=\"拒绝照搬-Don’t-copy\"><a href=\"#拒绝照搬-Don’t-copy\" class=\"headerlink\" title=\"拒绝照搬 Don’t copy\"></a>拒绝照搬 <small>Don’t copy</small></h3><blockquote>\n</blockquote>\n<p>在学习的方向上，需要模仿，这是一种有效的学习方式。<br>Copy-Paste的过程中，尽量知其所以然。<br>不需要盲从，掌握主动。</p>\n<h3 id=\"向对手挑战-Pick-a-fight\"><a href=\"#向对手挑战-Pick-a-fight\" class=\"headerlink\" title=\"向对手挑战 Pick a fight\"></a>向对手挑战 <small>Pick a fight</small></h3><blockquote>\n</blockquote>\n<p>调侃对手这种做法，更偏向于一种营销手段，需要玩出自己的特色。<br>在国内，这种案例也很多，被网友戏称「碰瓷营销」。</p>\n<h3 id=\"给竞争力做减法-Underdo-your-competition\"><a href=\"#给竞争力做减法-Underdo-your-competition\" class=\"headerlink\" title=\"给竞争力做减法 Underdo your competition\"></a>给竞争力做减法 <small>Underdo your competition</small></h3><blockquote>\n</blockquote>\n<p>一款简约的产品，只需要集中解决用户的一个主要的痛点，而且如果以低成本随手可得的话，更加容易成为流行品。</p>\n<h2 id=\"进化篇\"><a href=\"#进化篇\" class=\"headerlink\" title=\"进化篇\"></a>进化篇</h2><h3 id=\"头脑发热不等于当务之急-Don’t-confuse-enthusiasm-with-priority\"><a href=\"#头脑发热不等于当务之急-Don’t-confuse-enthusiasm-with-priority\" class=\"headerlink\" title=\"头脑发热不等于当务之急 Don’t confuse enthusiasm with priority\"></a>头脑发热不等于当务之急 <small>Don’t confuse enthusiasm with priority</small></h3><blockquote>\n</blockquote>\n<p>避免头脑发热，有些事情或决定，可以先放着，过几天再回来看看。<br>在《人性的弱点》中，也有类似的观点，那是这样的一个说法：一封愤怒的信，先放几天再决定是否要寄出。</p>\n<h3 id=\"家用便利就是好-Be-at-home-good\"><a href=\"#家用便利就是好-Be-at-home-good\" class=\"headerlink\" title=\"家用便利就是好 Be at home good\"></a>家用便利就是好 <small>Be at home good</small></h3><blockquote>\n</blockquote>\n<p>弄清哪个是本，哪个是辅</p>\n<h3 id=\"甘于低微-Welcome-obscurity\"><a href=\"#甘于低微-Welcome-obscurity\" class=\"headerlink\" title=\"甘于低微 Welcome obscurity\"></a>甘于低微 <small>Welcome obscurity</small></h3><blockquote>\n</blockquote>\n<p>之所以说籍籍无名值得庆幸。<br>是因为在这个阶段犯的错误，并没有放大效应，试错成本低。<br>对于「甘于低微」，我还有另外一种理解。<br>每个人都有他的优点，有胜于你的地方。甘于低微，可以让你保持低调，以及一颗愿意接纳新想法的心。</p>\n<h3 id=\"培养自己的拥趸-Build-an-audience\"><a href=\"#培养自己的拥趸-Build-an-audience\" class=\"headerlink\" title=\"培养自己的拥趸 Build an audience\"></a>培养自己的拥趸 <small>Build an audience</small></h3><blockquote>\n</blockquote>\n<p>通过提供有价值的内容，来培养自己的粉丝。</p>\n<h3 id=\"普及知识，赢得竞争-Out-teach-your-competition\"><a href=\"#普及知识，赢得竞争-Out-teach-your-competition\" class=\"headerlink\" title=\"普及知识，赢得竞争 Out-teach your competition\"></a>普及知识，赢得竞争 <small>Out-teach your competition</small></h3><blockquote>\n</blockquote>\n<p>国内的很多技术团队，都有各自的技术博客，都会有分享的习惯。<br>如果他们的内容强劲，他们所做的产品和项目也会备受关注。</p>\n<h3 id=\"效仿大厨-Emulate-chefs\"><a href=\"#效仿大厨-Emulate-chefs\" class=\"headerlink\" title=\"效仿大厨 Emulate chefs\"></a>效仿大厨 <small>Emulate chefs</small></h3><blockquote>\n</blockquote>\n<p>分享知识，是我一直所推崇的。<br>能帮助别人，记录进步，好处是不少的。</p>\n<h3 id=\"没人喜欢塑料花-Nobody-likes-plostic-flowers\"><a href=\"#没人喜欢塑料花-Nobody-likes-plostic-flowers\" class=\"headerlink\" title=\"没人喜欢塑料花 Nobody likes plostic flowers\"></a>没人喜欢塑料花 <small>Nobody likes plostic flowers</small></h3><blockquote>\n</blockquote>\n<p>不完美才真实，这一篇有很多优美的句子，尽管是翻译的句子。这让我好奇原版是怎么样的句子了。<br>这些句子，都谈论了一个道理：直面弱点，做真实的自己，把真实的自己展示给别人。<br>摘抄：</p>\n<ol>\n<li>不完美才真实，真实才能激起人们的共鸣。</li>\n<li>繁华落尽见真淳。</li>\n<li>“保留原有的韵致”是一种美丽的行事方法。</li>\n<li>过度的雕琢会使事物失去灵魂，变得机械乏味。</li>\n</ol>\n<h3 id=\"一夜成名只是传说-The-myth-of-the-overnight-sensation\"><a href=\"#一夜成名只是传说-The-myth-of-the-overnight-sensation\" class=\"headerlink\" title=\"一夜成名只是传说 The myth of the overnight sensation\"></a>一夜成名只是传说 <small>The myth of the overnight sensation</small></h3><blockquote>\n</blockquote>\n<p>文章中谈论到的几点，也是对个人来说很有启发性。<br>你要拥有足够牢固的基础来支撑你以后的名声。<br>现在就需要开始一点一滴的培养基础，和你的观众。</p>\n<h2 id=\"招聘篇\"><a href=\"#招聘篇\" class=\"headerlink\" title=\"招聘篇\"></a>招聘篇</h2><h3 id=\"受不了时再招人-Hire-when-it-hurts\"><a href=\"#受不了时再招人-Hire-when-it-hurts\" class=\"headerlink\" title=\"受不了时再招人 Hire when it hurts\"></a>受不了时再招人 <small>Hire when it hurts</small></h3><blockquote>\n</blockquote>\n<p>这也是对于创业团队，或者小团队而言。<br>在大公司的团队中，往往所分配的名额是固定的。<br>申请名额不容易，所以会导致很多一些部门都是招人进来先占个坑。</p>\n<h3 id=\"放弃牛人-Pass-on-greate-people\"><a href=\"#放弃牛人-Pass-on-greate-people\" class=\"headerlink\" title=\"放弃牛人 Pass on greate people\"></a>放弃牛人 <small>Pass on greate people</small></h3><blockquote>\n</blockquote>\n<p>这个也是大公司毛病，很多都是储备员工，也是没事找事干。<br>站在牛人的角度来想问题的话，在一个方向牛起来，总会有需要你的地方。</p>\n<h3 id=\"鸡尾酒会上的陌生人-Strangers-at-a-cocktail-party\"><a href=\"#鸡尾酒会上的陌生人-Strangers-at-a-cocktail-party\" class=\"headerlink\" title=\"鸡尾酒会上的陌生人 Strangers at a cocktail party\"></a>鸡尾酒会上的陌生人 <small>Strangers at a cocktail party</small></h3><blockquote>\n</blockquote>\n<p>招人，要给予足够的时间来交谈，得到充分的相互了解。<br>应聘，同样对你所应聘的公司给予足够的关注和充分的沟通。</p>\n<h3 id=\"可笑的求职简历-Resumes-are-ridiculous\"><a href=\"#可笑的求职简历-Resumes-are-ridiculous\" class=\"headerlink\" title=\"可笑的求职简历 Resumes are ridiculous\"></a>可笑的求职简历 <small>Resumes are ridiculous</small></h3><blockquote>\n</blockquote>\n<p>要充分的了解你所应聘的公司，这是未来很长一段时间共同奋斗的团队。<br>这考验了你的信息收集能力，和社交能力。</p>\n<h3 id=\"多年的无关经验-Years-of-irrelevance\"><a href=\"#多年的无关经验-Years-of-irrelevance\" class=\"headerlink\" title=\"多年的无关经验 Years of irrelevance\"></a>多年的无关经验 <small>Years of irrelevance</small></h3><blockquote>\n</blockquote>\n<p>熟悉、掌握一门技术活，只需要半年到一年的时间。<br>而在这之后，真正要看的是个人的努力程度、性格差异、智力水平以及工作态度。<br>当然，还有基础知识的积累。<br>例如你说有两年的NodeJS工作经验，但是基础的JavaScript都吃不通的话，让别人怎么相信你过去的努力程度。</p>\n<h2 id=\"救灾篇\"><a href=\"#救灾篇\" class=\"headerlink\" title=\"救灾篇\"></a>救灾篇</h2><h3 id=\"主动掌控负面新闻-Own-your-bad-news\"><a href=\"#主动掌控负面新闻-Own-your-bad-news\" class=\"headerlink\" title=\"主动掌控负面新闻 Own your bad news\"></a>主动掌控负面新闻 <small>Own your bad news</small></h3><blockquote>\n</blockquote>\n<p>自己的糗事由自己来说比别人来说，结果会好得多。<br>本篇说的，我总结三个字：责任心。<br>愿意承担起责任的人，总是受人尊重。</p>\n<h2 id=\"文化篇\"><a href=\"#文化篇\" class=\"headerlink\" title=\"文化篇\"></a>文化篇</h2><h3 id=\"文化不是由谁创造的-You-don’t-create-a-culture\"><a href=\"#文化不是由谁创造的-You-don’t-create-a-culture\" class=\"headerlink\" title=\"文化不是由谁创造的 You don’t create a culture\"></a>文化不是由谁创造的 <small>You don’t create a culture</small></h3><blockquote>\n</blockquote>\n<p>但是对于小团队来说，企业文化往往取决于创始人的个人魅力。</p>\n<h3 id=\"决策都是临时性的-Decisions-are-temporary\"><a href=\"#决策都是临时性的-Decisions-are-temporary\" class=\"headerlink\" title=\"决策都是临时性的 Decisions are temporary\"></a>决策都是临时性的 <small>Decisions are temporary</small></h3><blockquote>\n</blockquote>\n<p>在平时工作中，考虑功能实现的时候也是如此。<br>考虑得多是好事，但要参考特定环境的符合程度。<br>渐渐地感觉到了，担心的事情大多不会真的发生，当它真的发生了，再考虑对策吧。</p>\n<h3 id=\"跳过摇滚明星-Skip-the-rock-starts\"><a href=\"#跳过摇滚明星-Skip-the-rock-starts\" class=\"headerlink\" title=\"跳过摇滚明星 Skip the rock starts\"></a>跳过摇滚明星 <small>Skip the rock starts</small></h3><blockquote>\n</blockquote>\n<p>巨星环境的生成源于信任、自律以及责任感，是给予员工充分的隐私权、空间以及必备工具的结果。<br>所以BAT的技术团队才那么多人趋之若鹜。</p>\n<h3 id=\"员工不知13岁-They’re-not-children\"><a href=\"#员工不知13岁-They’re-not-children\" class=\"headerlink\" title=\"员工不知13岁 They’re not children\"></a>员工不知13岁 <small>They’re not children</small></h3><blockquote>\n</blockquote>\n<p>当你像小孩一样行事，别人也会把你当小孩子。<br>如何获得信任？<br>让你的工作在领导不用操心的情况下完成，在遇到问题和不懂的地方，先尝试自己解决。</p>\n<h3 id=\"发出你的心声-Sound-like-you\"><a href=\"#发出你的心声-Sound-like-you\" class=\"headerlink\" title=\"发出你的心声 Sound like you\"></a>发出你的心声 <small>Sound like you</small></h3><blockquote>\n</blockquote>\n<p>悲惨的是国内的应试语文教育，只会扼杀大部分人的写作能力。<br>真正的写作是一种自由、个性、观点的表述过程。<br>而不是那些为作文题目，为分数而写的非自愿的文章。</p>\n<h3 id=\"需要避开的词汇-Four-letters-words\"><a href=\"#需要避开的词汇-Four-letters-words\" class=\"headerlink\" title=\"需要避开的词汇 Four-letters words\"></a>需要避开的词汇 <small>Four-letters words</small></h3><blockquote>\n</blockquote>\n<p>避开那种「非黑即白」的词语，真相往往不是非黑即白。</p>\n<h2 id=\"总结篇\"><a href=\"#总结篇\" class=\"headerlink\" title=\"总结篇\"></a>总结篇</h2><h3 id=\"灵感稍纵即逝\"><a href=\"#灵感稍纵即逝\" class=\"headerlink\" title=\"灵感稍纵即逝\"></a>灵感稍纵即逝</h3><blockquote>\n</blockquote>\n<p>有些灵感也会因为当前能力的局限而难以实现。<br>但如果仅因为这样而放弃或者耽误你的灵感，是十分浪费的。<br>所以，在灵感还没来的时候就要「厚积」，而当灵感来敲门了，不管是否有足够的执行力，先开始了再说。</p>\n"},{"title":"盘点国内的那些ROM","date":"2015-03-03T11:21:12.000Z","_content":"\n## 前言\n\n最近新闻比较多，阿里入股魅族的消息除了轰动之余，不免会让人回想起去年的Flyme Powered by YunOS。腾讯推出的TOS，也会使人想起那年昙花一现的tita。一加公布其自主ROM正式改名OxygenOS的消息，也让人好奇刘作虎的下一步棋。\n百度的\"百度云OS\"、阿里的\"YunOS\"、腾讯的\"TOS\"、魅族的“FLymeOS”、小米的“MIUI”、锤子的“SmartisanOS”还有一加的“OxygenOS”等等，让人有一种在Android市场下欣欣向荣、百花齐放、百家争鸣的感觉。拥有一个自家的ROM，貌似成为了争夺移动互联网之战的入场券。我们不妨来看一下国内Android市场的那些你听过的没听过，用过没用过的那些ROM。\n\n## BAT巨头\n\n### 百度：百度云OS\n\n![](http://xia-dev.b0.upaiyun.com/463ff1a5-b814-485a-96f0-cf98439250f3.jpg)\n\n百度在2012年6月推出了基于Android进行开发的百度云OS。2013年战略投资过100+爱奇艺手机，在手机上内置百度云OS，并将旗下收购的爱奇艺视频业务整合到手机系统。近日，又传出消息称百度入股联想神奇工场。百度云OS适配机型众多，目前在“刷机党”中已有一定认知度和口碑。\n\n### 阿里：YunOS\n\n![](http://xia-dev.b0.upaiyun.com/8d2b6d92-5ef4-4662-85c5-f32d2bed93c7.jpg)\n\n2011年7月28日，阿里巴巴集团旗下阿里云计算有限公司在北京召开新闻发布会，正式推出了阿里云OS。根据阿里云公司官方的说法，阿里云OS是一个独立于Android之外，自助研发的独立操作系统，底层核心一样是用的Linux内核。但虚拟机却不是用Android的Dalvik虚拟机，而是阿里云自家的虚拟机。但是阿里没有把原始代码公布的做法，受到了开源信奉者的Linux以及Android的排挤，以至于发展道路坎坷。\n\n### 腾讯：TOS\n\n2015年2月10日，TencentOS官方微博发布内侧招募通知。TOS究竟是一种什么样性质的系统呢？腾讯没说。是真正的自主研发，还是安卓阵营中的一名新兵，还是改头换面式的“伪原创”，在它没有正式发售之前，我们还不得而知，所以我们只能猜测。曾经，腾讯有过一款名为Tita的产品，但最后“无疾而终”。有趣的是，TOS内侧招募和阿里入股魅族的日子只差了一天。\n\n## 手机厂商的软硬件结合之路\n\n### 魅族：FlymeOS\n\n![](http://xia-dev.b0.upaiyun.com/91b3008a-9be4-406c-aa31-f32a31551d54.png)\n\nFlyme OS是魅族公司基于Android系统深度定制的手机操作系统。在2012年6月，魅族旗下的手机操作系统正式改名为\"Flyme OS\"，而在此之前魅族有分别有基于WindowsCE内核以及Android自主研发的手机操作系统，但没有对外公布正式的名字，当然，那时也只是适配自家手机。不过，到目前为止，FlymeOS已经能适配HTC、三星、索尼、LG等品牌的手机了。其优秀的设计，也使魅族拥有了相当可观的粉丝群。\n\n### 中兴：MiFavor\n\n![](http://xia-dev.b0.upaiyun.com/c0e4bc32-0bf5-4c64-ba4a-2885d0ff9082.jpg)\n\n自2011年8月MiFavor v1.0发布以来，经过多次迭代，到目前为止已经是v3.0了，但是适配机型只是旗下的星星1号和天机。从这方面来看，中兴旗下有不少型号的手机，却没有配备自家的ROM，确实不太能够捕获人心。\n\n### OPPO：ColorOS\n\n![](http://xia-dev.b0.upaiyun.com/19fff263-7919-47f2-b219-c71d929c82f1.jpg)\n\n2013年9月，OPPO发布ColorOS 1.0版本，随后再2014年3月更新到2.0之后，一直到现在差不多有一年没更新了。如此迭代速度要在如此激烈的ROM市场中角逐，还是不容易的。不过有一点是，ColorOS适配的机器比Mifavor多一点，除了OPPO的手机以外，还适配三星、小米、HTC等品牌。\n\n### 小米：MIUI\n\n![](http://xia-dev.b0.upaiyun.com/e65a952b-cc06-45ed-b59d-eaf476db7b31.jpg)\n\nMIUI是小米科技基于CM及AOSP改进而来，作为ROM市场的一款明星产品，其受欢迎程度自不用多说。MIUI的稳定性，交互，设计，迭代速度是值得肯定。但是它抄袭IOS的嫌疑，以及捆绑腾讯安全管家引擎，还有不允许删除部分小米服务软件也一直受米黑所诟病。若抛开开源精神来说的话，MIUI确实是一款实用性不错的产品。\n\n### 锤子：SmartisanOS\n\n![](http://xia-dev.b0.upaiyun.com/a60af4f7-0c16-4dbf-85ac-8d0efead84d4.jpg)\n\n2014年5月20日，罗永浩在北京举办的产品发布会上，从曝光开始历时一年载的SmartisanOS以一种高调的方式出现在大家的眼前，和它的宿主SmartisanT1一样，SmartisanOS也被灌进满满的情怀。耳目一新的设计，贴心的交互方式，细腻的动画等等，都可以说SmartisanOS是一款优秀的OS，但是受Smartisan T1的出货量和ROM的适配机型少限制，装机量不太理想。\n\n### 一加：OxygenOS 和 H2OS\n\n傍CyanogenMod的大腿大半年，一加手机终于也开始捣弄属于自己的ROM了。刘作虎在2月6日微博给OxygenOS预热了一下，在2月12日放出了OxygenOS的开发团队的信息，但是并没有表明发布日期。值得注意的是，一加自主研发的ROM不仅仅只有OxygenOS，还有H2OS。中文翻译分别是“氧OS”和“氢OS”，据一加官方说法，前者是针对海外市场，界面非常接近原生。而后者则针对国内市场，采用全新的设计风格。\n\n### 酷派：CoolUI\n\nCoolUI是酷派旗下基于Android深度定制的ROOM，目前最新稳定版本是CoolUI 6.0，首次搭配在大神X7机型上。\n\n### VIVO：Funtouch OS\n\nFuntouch OS是VIVO手机2013年10月15日发布的深度定制的ROM，在2014年10月20日发布更新版本Funtouch OS 2.0。适配旗下的X1s/st、X3、Y17、Xplay、Xplay3s、Xshot等几款机型。目前没发现有适配其他手机品牌的ROM。\n\n### 华为：EMUI\n\n2012年7月推出以来，EMUI现在已经更新到3.0版本了，EMUI还有一个别称，Emotion UI。EMUI现在能适配的机型也只有自家的手机。\n\n## 民间中的明星团队\n\n### 乐蛙OS\n\n![](http://xia-dev.b0.upaiyun.com/67db2cfc-e52c-4cd1-bce1-27b59efa11ed.jpg)\n\n乐蛙OS是由上海的乐蛙科技在2011年12月30日发布的的基于Android深度定制的ROM，经过多次迭代，于2014年10月22日推出最新版本6.0。适配机型覆盖了酷派、华为、TCL、中兴、小米等著名国产品牌。\n\n### 新蜂ROM\n\n![](http://xia-dev.b0.upaiyun.com/e5a0cbea-e5fb-4551-ad46-70f0685200e5.jpg)\n\n新蜂ROM是新蜂工作室基于各Android深度定制的ROM，据说新蜂工作室只有十余人。适配机型70余款，覆盖中兴、联想、华为、三星、HTC、索尼、OPPO等品牌。\n\n### MokeeOS\n\n![](http://xia-dev.b0.upaiyun.com/17055a94-717c-4119-816c-d1402218d3fa.jpg)\n\nMokeeOS（Mokee OpenSource）是真正具有开源血统的开源项目，由魔趣论坛发起，民间自发组织开发的产物。适配机型达150余款，而且都在Github上公开源码，可以说能开源的ROM在现在的ROM市场上实属罕见。\n\n## 壮士一去兮不复还\n\n在ROM大潮中，后浪盖前浪，前浪死在沙滩上，在欣赏活跃的明星ROM在舞台上光彩夺目的舞姿以外，我们是否应缅怀一下那些曾经一度夺人眼球，但由于种种原因停止更新，最后化作成泥更护花的ROM？\n\n*   点心 (2010.8)\n*   LiGux (2011.6)\n*   魔趣 (2011.9)\n*   Joyos (2011.12)\n*   QissME (2012.2)\n*   乐众 (2012.2)\n*   腾讯tita (2012.4)\n*   深度OS (2012.4)\n*   X-UI (2012.9)\n*   ViBE UI (2013.9)\n\n## 后话\n\n自09年CM成立后，众多基于官方或CM进行深层定制的第三方Android ROM团队也相继成立并推出各自的OS或者UI，通过适配不同的机型来让更多的用户获得另类的ROM体验。部分手机厂商也开始发现自身不足，逐渐转为软硬结合的模式，跻身ROM定制行列。除提升手机硬件配置以外，还通过优化出厂系统来提升手机性能。此外，也有ROM团队与厂商合作，将品牌OS深度定制为手机出厂系统，发挥双方在线上线下的优势。","source":"_posts/盘点国内的那些ROM.md","raw":"---\ntitle: 盘点国内的那些ROM\ncategory: 搬砖码农\ndate: 2015-03-03 19:21:12\ntags: \n- ROM\n---\n\n## 前言\n\n最近新闻比较多，阿里入股魅族的消息除了轰动之余，不免会让人回想起去年的Flyme Powered by YunOS。腾讯推出的TOS，也会使人想起那年昙花一现的tita。一加公布其自主ROM正式改名OxygenOS的消息，也让人好奇刘作虎的下一步棋。\n百度的\"百度云OS\"、阿里的\"YunOS\"、腾讯的\"TOS\"、魅族的“FLymeOS”、小米的“MIUI”、锤子的“SmartisanOS”还有一加的“OxygenOS”等等，让人有一种在Android市场下欣欣向荣、百花齐放、百家争鸣的感觉。拥有一个自家的ROM，貌似成为了争夺移动互联网之战的入场券。我们不妨来看一下国内Android市场的那些你听过的没听过，用过没用过的那些ROM。\n\n## BAT巨头\n\n### 百度：百度云OS\n\n![](http://xia-dev.b0.upaiyun.com/463ff1a5-b814-485a-96f0-cf98439250f3.jpg)\n\n百度在2012年6月推出了基于Android进行开发的百度云OS。2013年战略投资过100+爱奇艺手机，在手机上内置百度云OS，并将旗下收购的爱奇艺视频业务整合到手机系统。近日，又传出消息称百度入股联想神奇工场。百度云OS适配机型众多，目前在“刷机党”中已有一定认知度和口碑。\n\n### 阿里：YunOS\n\n![](http://xia-dev.b0.upaiyun.com/8d2b6d92-5ef4-4662-85c5-f32d2bed93c7.jpg)\n\n2011年7月28日，阿里巴巴集团旗下阿里云计算有限公司在北京召开新闻发布会，正式推出了阿里云OS。根据阿里云公司官方的说法，阿里云OS是一个独立于Android之外，自助研发的独立操作系统，底层核心一样是用的Linux内核。但虚拟机却不是用Android的Dalvik虚拟机，而是阿里云自家的虚拟机。但是阿里没有把原始代码公布的做法，受到了开源信奉者的Linux以及Android的排挤，以至于发展道路坎坷。\n\n### 腾讯：TOS\n\n2015年2月10日，TencentOS官方微博发布内侧招募通知。TOS究竟是一种什么样性质的系统呢？腾讯没说。是真正的自主研发，还是安卓阵营中的一名新兵，还是改头换面式的“伪原创”，在它没有正式发售之前，我们还不得而知，所以我们只能猜测。曾经，腾讯有过一款名为Tita的产品，但最后“无疾而终”。有趣的是，TOS内侧招募和阿里入股魅族的日子只差了一天。\n\n## 手机厂商的软硬件结合之路\n\n### 魅族：FlymeOS\n\n![](http://xia-dev.b0.upaiyun.com/91b3008a-9be4-406c-aa31-f32a31551d54.png)\n\nFlyme OS是魅族公司基于Android系统深度定制的手机操作系统。在2012年6月，魅族旗下的手机操作系统正式改名为\"Flyme OS\"，而在此之前魅族有分别有基于WindowsCE内核以及Android自主研发的手机操作系统，但没有对外公布正式的名字，当然，那时也只是适配自家手机。不过，到目前为止，FlymeOS已经能适配HTC、三星、索尼、LG等品牌的手机了。其优秀的设计，也使魅族拥有了相当可观的粉丝群。\n\n### 中兴：MiFavor\n\n![](http://xia-dev.b0.upaiyun.com/c0e4bc32-0bf5-4c64-ba4a-2885d0ff9082.jpg)\n\n自2011年8月MiFavor v1.0发布以来，经过多次迭代，到目前为止已经是v3.0了，但是适配机型只是旗下的星星1号和天机。从这方面来看，中兴旗下有不少型号的手机，却没有配备自家的ROM，确实不太能够捕获人心。\n\n### OPPO：ColorOS\n\n![](http://xia-dev.b0.upaiyun.com/19fff263-7919-47f2-b219-c71d929c82f1.jpg)\n\n2013年9月，OPPO发布ColorOS 1.0版本，随后再2014年3月更新到2.0之后，一直到现在差不多有一年没更新了。如此迭代速度要在如此激烈的ROM市场中角逐，还是不容易的。不过有一点是，ColorOS适配的机器比Mifavor多一点，除了OPPO的手机以外，还适配三星、小米、HTC等品牌。\n\n### 小米：MIUI\n\n![](http://xia-dev.b0.upaiyun.com/e65a952b-cc06-45ed-b59d-eaf476db7b31.jpg)\n\nMIUI是小米科技基于CM及AOSP改进而来，作为ROM市场的一款明星产品，其受欢迎程度自不用多说。MIUI的稳定性，交互，设计，迭代速度是值得肯定。但是它抄袭IOS的嫌疑，以及捆绑腾讯安全管家引擎，还有不允许删除部分小米服务软件也一直受米黑所诟病。若抛开开源精神来说的话，MIUI确实是一款实用性不错的产品。\n\n### 锤子：SmartisanOS\n\n![](http://xia-dev.b0.upaiyun.com/a60af4f7-0c16-4dbf-85ac-8d0efead84d4.jpg)\n\n2014年5月20日，罗永浩在北京举办的产品发布会上，从曝光开始历时一年载的SmartisanOS以一种高调的方式出现在大家的眼前，和它的宿主SmartisanT1一样，SmartisanOS也被灌进满满的情怀。耳目一新的设计，贴心的交互方式，细腻的动画等等，都可以说SmartisanOS是一款优秀的OS，但是受Smartisan T1的出货量和ROM的适配机型少限制，装机量不太理想。\n\n### 一加：OxygenOS 和 H2OS\n\n傍CyanogenMod的大腿大半年，一加手机终于也开始捣弄属于自己的ROM了。刘作虎在2月6日微博给OxygenOS预热了一下，在2月12日放出了OxygenOS的开发团队的信息，但是并没有表明发布日期。值得注意的是，一加自主研发的ROM不仅仅只有OxygenOS，还有H2OS。中文翻译分别是“氧OS”和“氢OS”，据一加官方说法，前者是针对海外市场，界面非常接近原生。而后者则针对国内市场，采用全新的设计风格。\n\n### 酷派：CoolUI\n\nCoolUI是酷派旗下基于Android深度定制的ROOM，目前最新稳定版本是CoolUI 6.0，首次搭配在大神X7机型上。\n\n### VIVO：Funtouch OS\n\nFuntouch OS是VIVO手机2013年10月15日发布的深度定制的ROM，在2014年10月20日发布更新版本Funtouch OS 2.0。适配旗下的X1s/st、X3、Y17、Xplay、Xplay3s、Xshot等几款机型。目前没发现有适配其他手机品牌的ROM。\n\n### 华为：EMUI\n\n2012年7月推出以来，EMUI现在已经更新到3.0版本了，EMUI还有一个别称，Emotion UI。EMUI现在能适配的机型也只有自家的手机。\n\n## 民间中的明星团队\n\n### 乐蛙OS\n\n![](http://xia-dev.b0.upaiyun.com/67db2cfc-e52c-4cd1-bce1-27b59efa11ed.jpg)\n\n乐蛙OS是由上海的乐蛙科技在2011年12月30日发布的的基于Android深度定制的ROM，经过多次迭代，于2014年10月22日推出最新版本6.0。适配机型覆盖了酷派、华为、TCL、中兴、小米等著名国产品牌。\n\n### 新蜂ROM\n\n![](http://xia-dev.b0.upaiyun.com/e5a0cbea-e5fb-4551-ad46-70f0685200e5.jpg)\n\n新蜂ROM是新蜂工作室基于各Android深度定制的ROM，据说新蜂工作室只有十余人。适配机型70余款，覆盖中兴、联想、华为、三星、HTC、索尼、OPPO等品牌。\n\n### MokeeOS\n\n![](http://xia-dev.b0.upaiyun.com/17055a94-717c-4119-816c-d1402218d3fa.jpg)\n\nMokeeOS（Mokee OpenSource）是真正具有开源血统的开源项目，由魔趣论坛发起，民间自发组织开发的产物。适配机型达150余款，而且都在Github上公开源码，可以说能开源的ROM在现在的ROM市场上实属罕见。\n\n## 壮士一去兮不复还\n\n在ROM大潮中，后浪盖前浪，前浪死在沙滩上，在欣赏活跃的明星ROM在舞台上光彩夺目的舞姿以外，我们是否应缅怀一下那些曾经一度夺人眼球，但由于种种原因停止更新，最后化作成泥更护花的ROM？\n\n*   点心 (2010.8)\n*   LiGux (2011.6)\n*   魔趣 (2011.9)\n*   Joyos (2011.12)\n*   QissME (2012.2)\n*   乐众 (2012.2)\n*   腾讯tita (2012.4)\n*   深度OS (2012.4)\n*   X-UI (2012.9)\n*   ViBE UI (2013.9)\n\n## 后话\n\n自09年CM成立后，众多基于官方或CM进行深层定制的第三方Android ROM团队也相继成立并推出各自的OS或者UI，通过适配不同的机型来让更多的用户获得另类的ROM体验。部分手机厂商也开始发现自身不足，逐渐转为软硬结合的模式，跻身ROM定制行列。除提升手机硬件配置以外，还通过优化出厂系统来提升手机性能。此外，也有ROM团队与厂商合作，将品牌OS深度定制为手机出厂系统，发挥双方在线上线下的优势。","slug":"盘点国内的那些ROM","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8r2000oxwrle29760t8","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近新闻比较多，阿里入股魅族的消息除了轰动之余，不免会让人回想起去年的Flyme Powered by YunOS。腾讯推出的TOS，也会使人想起那年昙花一现的tita。一加公布其自主ROM正式改名OxygenOS的消息，也让人好奇刘作虎的下一步棋。<br>百度的”百度云OS”、阿里的”YunOS”、腾讯的”TOS”、魅族的“FLymeOS”、小米的“MIUI”、锤子的“SmartisanOS”还有一加的“OxygenOS”等等，让人有一种在Android市场下欣欣向荣、百花齐放、百家争鸣的感觉。拥有一个自家的ROM，貌似成为了争夺移动互联网之战的入场券。我们不妨来看一下国内Android市场的那些你听过的没听过，用过没用过的那些ROM。</p>\n<h2 id=\"BAT巨头\"><a href=\"#BAT巨头\" class=\"headerlink\" title=\"BAT巨头\"></a>BAT巨头</h2><h3 id=\"百度：百度云OS\"><a href=\"#百度：百度云OS\" class=\"headerlink\" title=\"百度：百度云OS\"></a>百度：百度云OS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/463ff1a5-b814-485a-96f0-cf98439250f3.jpg\" alt></p>\n<p>百度在2012年6月推出了基于Android进行开发的百度云OS。2013年战略投资过100+爱奇艺手机，在手机上内置百度云OS，并将旗下收购的爱奇艺视频业务整合到手机系统。近日，又传出消息称百度入股联想神奇工场。百度云OS适配机型众多，目前在“刷机党”中已有一定认知度和口碑。</p>\n<h3 id=\"阿里：YunOS\"><a href=\"#阿里：YunOS\" class=\"headerlink\" title=\"阿里：YunOS\"></a>阿里：YunOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/8d2b6d92-5ef4-4662-85c5-f32d2bed93c7.jpg\" alt></p>\n<p>2011年7月28日，阿里巴巴集团旗下阿里云计算有限公司在北京召开新闻发布会，正式推出了阿里云OS。根据阿里云公司官方的说法，阿里云OS是一个独立于Android之外，自助研发的独立操作系统，底层核心一样是用的Linux内核。但虚拟机却不是用Android的Dalvik虚拟机，而是阿里云自家的虚拟机。但是阿里没有把原始代码公布的做法，受到了开源信奉者的Linux以及Android的排挤，以至于发展道路坎坷。</p>\n<h3 id=\"腾讯：TOS\"><a href=\"#腾讯：TOS\" class=\"headerlink\" title=\"腾讯：TOS\"></a>腾讯：TOS</h3><p>2015年2月10日，TencentOS官方微博发布内侧招募通知。TOS究竟是一种什么样性质的系统呢？腾讯没说。是真正的自主研发，还是安卓阵营中的一名新兵，还是改头换面式的“伪原创”，在它没有正式发售之前，我们还不得而知，所以我们只能猜测。曾经，腾讯有过一款名为Tita的产品，但最后“无疾而终”。有趣的是，TOS内侧招募和阿里入股魅族的日子只差了一天。</p>\n<h2 id=\"手机厂商的软硬件结合之路\"><a href=\"#手机厂商的软硬件结合之路\" class=\"headerlink\" title=\"手机厂商的软硬件结合之路\"></a>手机厂商的软硬件结合之路</h2><h3 id=\"魅族：FlymeOS\"><a href=\"#魅族：FlymeOS\" class=\"headerlink\" title=\"魅族：FlymeOS\"></a>魅族：FlymeOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/91b3008a-9be4-406c-aa31-f32a31551d54.png\" alt></p>\n<p>Flyme OS是魅族公司基于Android系统深度定制的手机操作系统。在2012年6月，魅族旗下的手机操作系统正式改名为”Flyme OS”，而在此之前魅族有分别有基于WindowsCE内核以及Android自主研发的手机操作系统，但没有对外公布正式的名字，当然，那时也只是适配自家手机。不过，到目前为止，FlymeOS已经能适配HTC、三星、索尼、LG等品牌的手机了。其优秀的设计，也使魅族拥有了相当可观的粉丝群。</p>\n<h3 id=\"中兴：MiFavor\"><a href=\"#中兴：MiFavor\" class=\"headerlink\" title=\"中兴：MiFavor\"></a>中兴：MiFavor</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/c0e4bc32-0bf5-4c64-ba4a-2885d0ff9082.jpg\" alt></p>\n<p>自2011年8月MiFavor v1.0发布以来，经过多次迭代，到目前为止已经是v3.0了，但是适配机型只是旗下的星星1号和天机。从这方面来看，中兴旗下有不少型号的手机，却没有配备自家的ROM，确实不太能够捕获人心。</p>\n<h3 id=\"OPPO：ColorOS\"><a href=\"#OPPO：ColorOS\" class=\"headerlink\" title=\"OPPO：ColorOS\"></a>OPPO：ColorOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/19fff263-7919-47f2-b219-c71d929c82f1.jpg\" alt></p>\n<p>2013年9月，OPPO发布ColorOS 1.0版本，随后再2014年3月更新到2.0之后，一直到现在差不多有一年没更新了。如此迭代速度要在如此激烈的ROM市场中角逐，还是不容易的。不过有一点是，ColorOS适配的机器比Mifavor多一点，除了OPPO的手机以外，还适配三星、小米、HTC等品牌。</p>\n<h3 id=\"小米：MIUI\"><a href=\"#小米：MIUI\" class=\"headerlink\" title=\"小米：MIUI\"></a>小米：MIUI</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/e65a952b-cc06-45ed-b59d-eaf476db7b31.jpg\" alt></p>\n<p>MIUI是小米科技基于CM及AOSP改进而来，作为ROM市场的一款明星产品，其受欢迎程度自不用多说。MIUI的稳定性，交互，设计，迭代速度是值得肯定。但是它抄袭IOS的嫌疑，以及捆绑腾讯安全管家引擎，还有不允许删除部分小米服务软件也一直受米黑所诟病。若抛开开源精神来说的话，MIUI确实是一款实用性不错的产品。</p>\n<h3 id=\"锤子：SmartisanOS\"><a href=\"#锤子：SmartisanOS\" class=\"headerlink\" title=\"锤子：SmartisanOS\"></a>锤子：SmartisanOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/a60af4f7-0c16-4dbf-85ac-8d0efead84d4.jpg\" alt></p>\n<p>2014年5月20日，罗永浩在北京举办的产品发布会上，从曝光开始历时一年载的SmartisanOS以一种高调的方式出现在大家的眼前，和它的宿主SmartisanT1一样，SmartisanOS也被灌进满满的情怀。耳目一新的设计，贴心的交互方式，细腻的动画等等，都可以说SmartisanOS是一款优秀的OS，但是受Smartisan T1的出货量和ROM的适配机型少限制，装机量不太理想。</p>\n<h3 id=\"一加：OxygenOS-和-H2OS\"><a href=\"#一加：OxygenOS-和-H2OS\" class=\"headerlink\" title=\"一加：OxygenOS 和 H2OS\"></a>一加：OxygenOS 和 H2OS</h3><p>傍CyanogenMod的大腿大半年，一加手机终于也开始捣弄属于自己的ROM了。刘作虎在2月6日微博给OxygenOS预热了一下，在2月12日放出了OxygenOS的开发团队的信息，但是并没有表明发布日期。值得注意的是，一加自主研发的ROM不仅仅只有OxygenOS，还有H2OS。中文翻译分别是“氧OS”和“氢OS”，据一加官方说法，前者是针对海外市场，界面非常接近原生。而后者则针对国内市场，采用全新的设计风格。</p>\n<h3 id=\"酷派：CoolUI\"><a href=\"#酷派：CoolUI\" class=\"headerlink\" title=\"酷派：CoolUI\"></a>酷派：CoolUI</h3><p>CoolUI是酷派旗下基于Android深度定制的ROOM，目前最新稳定版本是CoolUI 6.0，首次搭配在大神X7机型上。</p>\n<h3 id=\"VIVO：Funtouch-OS\"><a href=\"#VIVO：Funtouch-OS\" class=\"headerlink\" title=\"VIVO：Funtouch OS\"></a>VIVO：Funtouch OS</h3><p>Funtouch OS是VIVO手机2013年10月15日发布的深度定制的ROM，在2014年10月20日发布更新版本Funtouch OS 2.0。适配旗下的X1s/st、X3、Y17、Xplay、Xplay3s、Xshot等几款机型。目前没发现有适配其他手机品牌的ROM。</p>\n<h3 id=\"华为：EMUI\"><a href=\"#华为：EMUI\" class=\"headerlink\" title=\"华为：EMUI\"></a>华为：EMUI</h3><p>2012年7月推出以来，EMUI现在已经更新到3.0版本了，EMUI还有一个别称，Emotion UI。EMUI现在能适配的机型也只有自家的手机。</p>\n<h2 id=\"民间中的明星团队\"><a href=\"#民间中的明星团队\" class=\"headerlink\" title=\"民间中的明星团队\"></a>民间中的明星团队</h2><h3 id=\"乐蛙OS\"><a href=\"#乐蛙OS\" class=\"headerlink\" title=\"乐蛙OS\"></a>乐蛙OS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/67db2cfc-e52c-4cd1-bce1-27b59efa11ed.jpg\" alt></p>\n<p>乐蛙OS是由上海的乐蛙科技在2011年12月30日发布的的基于Android深度定制的ROM，经过多次迭代，于2014年10月22日推出最新版本6.0。适配机型覆盖了酷派、华为、TCL、中兴、小米等著名国产品牌。</p>\n<h3 id=\"新蜂ROM\"><a href=\"#新蜂ROM\" class=\"headerlink\" title=\"新蜂ROM\"></a>新蜂ROM</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/e5a0cbea-e5fb-4551-ad46-70f0685200e5.jpg\" alt></p>\n<p>新蜂ROM是新蜂工作室基于各Android深度定制的ROM，据说新蜂工作室只有十余人。适配机型70余款，覆盖中兴、联想、华为、三星、HTC、索尼、OPPO等品牌。</p>\n<h3 id=\"MokeeOS\"><a href=\"#MokeeOS\" class=\"headerlink\" title=\"MokeeOS\"></a>MokeeOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/17055a94-717c-4119-816c-d1402218d3fa.jpg\" alt></p>\n<p>MokeeOS（Mokee OpenSource）是真正具有开源血统的开源项目，由魔趣论坛发起，民间自发组织开发的产物。适配机型达150余款，而且都在Github上公开源码，可以说能开源的ROM在现在的ROM市场上实属罕见。</p>\n<h2 id=\"壮士一去兮不复还\"><a href=\"#壮士一去兮不复还\" class=\"headerlink\" title=\"壮士一去兮不复还\"></a>壮士一去兮不复还</h2><p>在ROM大潮中，后浪盖前浪，前浪死在沙滩上，在欣赏活跃的明星ROM在舞台上光彩夺目的舞姿以外，我们是否应缅怀一下那些曾经一度夺人眼球，但由于种种原因停止更新，最后化作成泥更护花的ROM？</p>\n<ul>\n<li>点心 (2010.8)</li>\n<li>LiGux (2011.6)</li>\n<li>魔趣 (2011.9)</li>\n<li>Joyos (2011.12)</li>\n<li>QissME (2012.2)</li>\n<li>乐众 (2012.2)</li>\n<li>腾讯tita (2012.4)</li>\n<li>深度OS (2012.4)</li>\n<li>X-UI (2012.9)</li>\n<li>ViBE UI (2013.9)</li>\n</ul>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>自09年CM成立后，众多基于官方或CM进行深层定制的第三方Android ROM团队也相继成立并推出各自的OS或者UI，通过适配不同的机型来让更多的用户获得另类的ROM体验。部分手机厂商也开始发现自身不足，逐渐转为软硬结合的模式，跻身ROM定制行列。除提升手机硬件配置以外，还通过优化出厂系统来提升手机性能。此外，也有ROM团队与厂商合作，将品牌OS深度定制为手机出厂系统，发挥双方在线上线下的优势。</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近新闻比较多，阿里入股魅族的消息除了轰动之余，不免会让人回想起去年的Flyme Powered by YunOS。腾讯推出的TOS，也会使人想起那年昙花一现的tita。一加公布其自主ROM正式改名OxygenOS的消息，也让人好奇刘作虎的下一步棋。<br>百度的”百度云OS”、阿里的”YunOS”、腾讯的”TOS”、魅族的“FLymeOS”、小米的“MIUI”、锤子的“SmartisanOS”还有一加的“OxygenOS”等等，让人有一种在Android市场下欣欣向荣、百花齐放、百家争鸣的感觉。拥有一个自家的ROM，貌似成为了争夺移动互联网之战的入场券。我们不妨来看一下国内Android市场的那些你听过的没听过，用过没用过的那些ROM。</p>\n<h2 id=\"BAT巨头\"><a href=\"#BAT巨头\" class=\"headerlink\" title=\"BAT巨头\"></a>BAT巨头</h2><h3 id=\"百度：百度云OS\"><a href=\"#百度：百度云OS\" class=\"headerlink\" title=\"百度：百度云OS\"></a>百度：百度云OS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/463ff1a5-b814-485a-96f0-cf98439250f3.jpg\" alt=\"\"></p>\n<p>百度在2012年6月推出了基于Android进行开发的百度云OS。2013年战略投资过100+爱奇艺手机，在手机上内置百度云OS，并将旗下收购的爱奇艺视频业务整合到手机系统。近日，又传出消息称百度入股联想神奇工场。百度云OS适配机型众多，目前在“刷机党”中已有一定认知度和口碑。</p>\n<h3 id=\"阿里：YunOS\"><a href=\"#阿里：YunOS\" class=\"headerlink\" title=\"阿里：YunOS\"></a>阿里：YunOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/8d2b6d92-5ef4-4662-85c5-f32d2bed93c7.jpg\" alt=\"\"></p>\n<p>2011年7月28日，阿里巴巴集团旗下阿里云计算有限公司在北京召开新闻发布会，正式推出了阿里云OS。根据阿里云公司官方的说法，阿里云OS是一个独立于Android之外，自助研发的独立操作系统，底层核心一样是用的Linux内核。但虚拟机却不是用Android的Dalvik虚拟机，而是阿里云自家的虚拟机。但是阿里没有把原始代码公布的做法，受到了开源信奉者的Linux以及Android的排挤，以至于发展道路坎坷。</p>\n<h3 id=\"腾讯：TOS\"><a href=\"#腾讯：TOS\" class=\"headerlink\" title=\"腾讯：TOS\"></a>腾讯：TOS</h3><p>2015年2月10日，TencentOS官方微博发布内侧招募通知。TOS究竟是一种什么样性质的系统呢？腾讯没说。是真正的自主研发，还是安卓阵营中的一名新兵，还是改头换面式的“伪原创”，在它没有正式发售之前，我们还不得而知，所以我们只能猜测。曾经，腾讯有过一款名为Tita的产品，但最后“无疾而终”。有趣的是，TOS内侧招募和阿里入股魅族的日子只差了一天。</p>\n<h2 id=\"手机厂商的软硬件结合之路\"><a href=\"#手机厂商的软硬件结合之路\" class=\"headerlink\" title=\"手机厂商的软硬件结合之路\"></a>手机厂商的软硬件结合之路</h2><h3 id=\"魅族：FlymeOS\"><a href=\"#魅族：FlymeOS\" class=\"headerlink\" title=\"魅族：FlymeOS\"></a>魅族：FlymeOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/91b3008a-9be4-406c-aa31-f32a31551d54.png\" alt=\"\"></p>\n<p>Flyme OS是魅族公司基于Android系统深度定制的手机操作系统。在2012年6月，魅族旗下的手机操作系统正式改名为”Flyme OS”，而在此之前魅族有分别有基于WindowsCE内核以及Android自主研发的手机操作系统，但没有对外公布正式的名字，当然，那时也只是适配自家手机。不过，到目前为止，FlymeOS已经能适配HTC、三星、索尼、LG等品牌的手机了。其优秀的设计，也使魅族拥有了相当可观的粉丝群。</p>\n<h3 id=\"中兴：MiFavor\"><a href=\"#中兴：MiFavor\" class=\"headerlink\" title=\"中兴：MiFavor\"></a>中兴：MiFavor</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/c0e4bc32-0bf5-4c64-ba4a-2885d0ff9082.jpg\" alt=\"\"></p>\n<p>自2011年8月MiFavor v1.0发布以来，经过多次迭代，到目前为止已经是v3.0了，但是适配机型只是旗下的星星1号和天机。从这方面来看，中兴旗下有不少型号的手机，却没有配备自家的ROM，确实不太能够捕获人心。</p>\n<h3 id=\"OPPO：ColorOS\"><a href=\"#OPPO：ColorOS\" class=\"headerlink\" title=\"OPPO：ColorOS\"></a>OPPO：ColorOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/19fff263-7919-47f2-b219-c71d929c82f1.jpg\" alt=\"\"></p>\n<p>2013年9月，OPPO发布ColorOS 1.0版本，随后再2014年3月更新到2.0之后，一直到现在差不多有一年没更新了。如此迭代速度要在如此激烈的ROM市场中角逐，还是不容易的。不过有一点是，ColorOS适配的机器比Mifavor多一点，除了OPPO的手机以外，还适配三星、小米、HTC等品牌。</p>\n<h3 id=\"小米：MIUI\"><a href=\"#小米：MIUI\" class=\"headerlink\" title=\"小米：MIUI\"></a>小米：MIUI</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/e65a952b-cc06-45ed-b59d-eaf476db7b31.jpg\" alt=\"\"></p>\n<p>MIUI是小米科技基于CM及AOSP改进而来，作为ROM市场的一款明星产品，其受欢迎程度自不用多说。MIUI的稳定性，交互，设计，迭代速度是值得肯定。但是它抄袭IOS的嫌疑，以及捆绑腾讯安全管家引擎，还有不允许删除部分小米服务软件也一直受米黑所诟病。若抛开开源精神来说的话，MIUI确实是一款实用性不错的产品。</p>\n<h3 id=\"锤子：SmartisanOS\"><a href=\"#锤子：SmartisanOS\" class=\"headerlink\" title=\"锤子：SmartisanOS\"></a>锤子：SmartisanOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/a60af4f7-0c16-4dbf-85ac-8d0efead84d4.jpg\" alt=\"\"></p>\n<p>2014年5月20日，罗永浩在北京举办的产品发布会上，从曝光开始历时一年载的SmartisanOS以一种高调的方式出现在大家的眼前，和它的宿主SmartisanT1一样，SmartisanOS也被灌进满满的情怀。耳目一新的设计，贴心的交互方式，细腻的动画等等，都可以说SmartisanOS是一款优秀的OS，但是受Smartisan T1的出货量和ROM的适配机型少限制，装机量不太理想。</p>\n<h3 id=\"一加：OxygenOS-和-H2OS\"><a href=\"#一加：OxygenOS-和-H2OS\" class=\"headerlink\" title=\"一加：OxygenOS 和 H2OS\"></a>一加：OxygenOS 和 H2OS</h3><p>傍CyanogenMod的大腿大半年，一加手机终于也开始捣弄属于自己的ROM了。刘作虎在2月6日微博给OxygenOS预热了一下，在2月12日放出了OxygenOS的开发团队的信息，但是并没有表明发布日期。值得注意的是，一加自主研发的ROM不仅仅只有OxygenOS，还有H2OS。中文翻译分别是“氧OS”和“氢OS”，据一加官方说法，前者是针对海外市场，界面非常接近原生。而后者则针对国内市场，采用全新的设计风格。</p>\n<h3 id=\"酷派：CoolUI\"><a href=\"#酷派：CoolUI\" class=\"headerlink\" title=\"酷派：CoolUI\"></a>酷派：CoolUI</h3><p>CoolUI是酷派旗下基于Android深度定制的ROOM，目前最新稳定版本是CoolUI 6.0，首次搭配在大神X7机型上。</p>\n<h3 id=\"VIVO：Funtouch-OS\"><a href=\"#VIVO：Funtouch-OS\" class=\"headerlink\" title=\"VIVO：Funtouch OS\"></a>VIVO：Funtouch OS</h3><p>Funtouch OS是VIVO手机2013年10月15日发布的深度定制的ROM，在2014年10月20日发布更新版本Funtouch OS 2.0。适配旗下的X1s/st、X3、Y17、Xplay、Xplay3s、Xshot等几款机型。目前没发现有适配其他手机品牌的ROM。</p>\n<h3 id=\"华为：EMUI\"><a href=\"#华为：EMUI\" class=\"headerlink\" title=\"华为：EMUI\"></a>华为：EMUI</h3><p>2012年7月推出以来，EMUI现在已经更新到3.0版本了，EMUI还有一个别称，Emotion UI。EMUI现在能适配的机型也只有自家的手机。</p>\n<h2 id=\"民间中的明星团队\"><a href=\"#民间中的明星团队\" class=\"headerlink\" title=\"民间中的明星团队\"></a>民间中的明星团队</h2><h3 id=\"乐蛙OS\"><a href=\"#乐蛙OS\" class=\"headerlink\" title=\"乐蛙OS\"></a>乐蛙OS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/67db2cfc-e52c-4cd1-bce1-27b59efa11ed.jpg\" alt=\"\"></p>\n<p>乐蛙OS是由上海的乐蛙科技在2011年12月30日发布的的基于Android深度定制的ROM，经过多次迭代，于2014年10月22日推出最新版本6.0。适配机型覆盖了酷派、华为、TCL、中兴、小米等著名国产品牌。</p>\n<h3 id=\"新蜂ROM\"><a href=\"#新蜂ROM\" class=\"headerlink\" title=\"新蜂ROM\"></a>新蜂ROM</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/e5a0cbea-e5fb-4551-ad46-70f0685200e5.jpg\" alt=\"\"></p>\n<p>新蜂ROM是新蜂工作室基于各Android深度定制的ROM，据说新蜂工作室只有十余人。适配机型70余款，覆盖中兴、联想、华为、三星、HTC、索尼、OPPO等品牌。</p>\n<h3 id=\"MokeeOS\"><a href=\"#MokeeOS\" class=\"headerlink\" title=\"MokeeOS\"></a>MokeeOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/17055a94-717c-4119-816c-d1402218d3fa.jpg\" alt=\"\"></p>\n<p>MokeeOS（Mokee OpenSource）是真正具有开源血统的开源项目，由魔趣论坛发起，民间自发组织开发的产物。适配机型达150余款，而且都在Github上公开源码，可以说能开源的ROM在现在的ROM市场上实属罕见。</p>\n<h2 id=\"壮士一去兮不复还\"><a href=\"#壮士一去兮不复还\" class=\"headerlink\" title=\"壮士一去兮不复还\"></a>壮士一去兮不复还</h2><p>在ROM大潮中，后浪盖前浪，前浪死在沙滩上，在欣赏活跃的明星ROM在舞台上光彩夺目的舞姿以外，我们是否应缅怀一下那些曾经一度夺人眼球，但由于种种原因停止更新，最后化作成泥更护花的ROM？</p>\n<ul>\n<li>点心 (2010.8)</li>\n<li>LiGux (2011.6)</li>\n<li>魔趣 (2011.9)</li>\n<li>Joyos (2011.12)</li>\n<li>QissME (2012.2)</li>\n<li>乐众 (2012.2)</li>\n<li>腾讯tita (2012.4)</li>\n<li>深度OS (2012.4)</li>\n<li>X-UI (2012.9)</li>\n<li>ViBE UI (2013.9)</li>\n</ul>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>自09年CM成立后，众多基于官方或CM进行深层定制的第三方Android ROM团队也相继成立并推出各自的OS或者UI，通过适配不同的机型来让更多的用户获得另类的ROM体验。部分手机厂商也开始发现自身不足，逐渐转为软硬结合的模式，跻身ROM定制行列。除提升手机硬件配置以外，还通过优化出厂系统来提升手机性能。此外，也有ROM团队与厂商合作，将品牌OS深度定制为手机出厂系统，发挥双方在线上线下的优势。</p>\n"},{"title":"登录那些事儿","date":"2015-12-14T15:16:33.000Z","_content":"\n也不知道是什么原因，刚开始不久的职业生涯，在技术这条路走着走着，和「登录」总是有着一个不解之缘。还记得当初学习Web编程的时候么？不管是Java、.Net、PHP，继经典「Hello World」之后，要写的很有可能就是「登录」功能。至今「登录」的问题还是让我心中一万只草泥马奔过。\n下面，给分享一下各种「登录」相关的需求\n\n## 普通的登录\n这个是极其普通的登录需求，要的就是一个登录页面，输入账号密码，提交Form表单，后端查询数据库对应用户名的密码，匹配正确则把用户记录到Session，不正确则返回错误。\n这种登录，在上学的时候，也许敬爱的老师就已经教过你了。\n但可能他没有教你的是，密码需要hash加密，session为什么可以记录登录用户的原理。\n\n**密码Hash**\n密码hash，就是存进数据库的密码是一串密文，密文是明文密码通过不可逆算法得出的。在Nodejs中，你可以使用[bcryptjs](https://www.npmjs.com/package/bcryptjs)，它提供了`hash`以及对应的`compare`方法，非常适合用于密码的加密和对比。\n\n**Session原理**\nSession的原理其实还是依赖了Cookie，所以Cookie才是记录用户凭证的真理。它的原理大概是酱紫的：服务器端维护一个session的表，这个表的每一条记录存的就是与某一个客户端的会话，会话会有过期时间，过期的会话会被清理。然后这个会话，会有一个对应的id，一般是一串长长的看不懂的字符串，然后这个字符串会被存储在客户端的cookie中，每一次请求服务器端都会带上这个cookie，服务器端就知道访问的就是哪个客户端了。\n欲知更多有关「Session原理」请点击传送门：[Session原理](http://www.jianshu.com/p/2b7c10291aad)\n\n## 使用独立登录系统\n应项目需要，登录逻辑需要独立出来做成一个系统，就是另外一个项目。与原来的主站不是在同一个项目中了。一个域名是 `www.site.com`，一个则是`passport.site.com`了。要在不同的域名下进行登录，一般的方法是`www.site.com/login` 跳转到 `passport.site.com/login`，passport这边是一个登录页面，用户输入账号密码登录成功之后，passport会通过带着一个可逆加密的包含用户信息的token，重定向到`www.site.com`提供的回调处理地址，然后进行解密，匹配正确，则登录用户。\n要注意的是，这里的加密的信息需要包含一个时间戳，接收方需要认证这个时间戳，过期登录失败。避免token被窃取，被无限登录site系统。\n\n## 单点登录\n单点登录需要实现的需求，说白了就是在站点A的登录了，那么用户就自动在站点B、站点C、站点E、F、G登录。\n这又分两种情况，A站点和B站点是否在同一个二级域名下。\n假如是在同一个域名下，例如`siteA.site.com`与`siteB.site.com`，因为cookie允许设置到二级域名下`.site.com`，所以siteA和siteB是可以共享cookie的，用户的信息可以通过可逆加密放在二级域名下的cookie，并且设置`http only`，就可以一站登录，站站登录。\n而如果A站点和B站点不在同一二级域名下，例如`www.siteA.com`与`www.siteB.com`，他们就无法通过共享cookie的方式共享用户信息，所以需要用到jsonp的方式，用户在siteA登录之后，提供一个jsonp接口获取加密的用户信息，siteB访问这个jsonp获取加密信息。达到共享用户状态的效果。\n欲知更多有关「单点登录」请点击传送门：[单点登录的三种实现方式](http://www.jianshu.com/p/613e44d4a464)\n\n## OAuth2.0登录\n这就比较普遍了，现在随随便便做个网站，都接入「微信登录」、「微博登录」、「豆瓣登录」、「QQ登录」、「Github登录」、*@^*&@%#^%^@%&%@&#........\n这些统一叫做：「第三方登录」。\n第三方登录都是实现了OAuth2.0协议的，流程大概是酱紫的：\n第三方提供一个登录入口，也就是第三方域名下的登录页面。主站需要登录的时候，引导用户重定向到第三方的登录页面，用户输入账号密码之后，登录第三方系统，第三方系统匹配帐号成功之后，带上一个code到主站的回调地址，主站接收到code，短时间内拿着code请求第三方提供获取长期凭证的接口(因为code有一个比较短的过期时间)，这个长期凭证叫`access_token`，获取之后就把这个`access_token`存到数据库中，请求一些第三方提供的API，需要用到这个`access_token`，因为这个token就是记录用户在第三方系统的一个身份凭证。\n一些系统，在获取`access_token`的时候，还会返回一个副参数`refresh_token`，因为`access_token`是有过期时间的，一旦过期了，主站可以使用`refresh_token`请求第三方提供的接口获取新的`access_token`以及新的`refresh_token`。\n在Nodejs中，你可以使用`passport`来给第三方登录提供一个统一解决方案，而如果你是开发「微信公众号」授权，除了[passport](https://www.npmjs.com/package/passport)，也可以使用[wechat-oauth](https://www.npmjs.com/package/wechat-oauth)\n\n## 在最后\n其实登录问题，理解了Session原理是很重要的，这个也不难理解。然后站点之间的用户信息交流，就是通过各种跨域限制，各种加密解密而已。在做这个的时候，需要充分考虑到加密的token是否会被窃取的可能性，还要考虑让这个token加上时间的验证，在一些可能会被窃取，安全需求比较高的情况，就需要把token的时间设置的更短。还有就是加密的方式需要依照需求不同而选择可逆或者不可逆，hash sha1还是JWT(Json Web Token)。\nsha1加密，可以使用Nodejs自带的`crypto`，JWT可以使用[jsonwebtoken]()\n","source":"_posts/登录那些事儿.md","raw":"---\ntitle: 登录那些事儿\ncategory: 搬砖码农\ndate: 2015-12-14 23:16:33\ntags:\n- 单点登录\n- cookie\n- session\n- Nodejs\n---\n\n也不知道是什么原因，刚开始不久的职业生涯，在技术这条路走着走着，和「登录」总是有着一个不解之缘。还记得当初学习Web编程的时候么？不管是Java、.Net、PHP，继经典「Hello World」之后，要写的很有可能就是「登录」功能。至今「登录」的问题还是让我心中一万只草泥马奔过。\n下面，给分享一下各种「登录」相关的需求\n\n## 普通的登录\n这个是极其普通的登录需求，要的就是一个登录页面，输入账号密码，提交Form表单，后端查询数据库对应用户名的密码，匹配正确则把用户记录到Session，不正确则返回错误。\n这种登录，在上学的时候，也许敬爱的老师就已经教过你了。\n但可能他没有教你的是，密码需要hash加密，session为什么可以记录登录用户的原理。\n\n**密码Hash**\n密码hash，就是存进数据库的密码是一串密文，密文是明文密码通过不可逆算法得出的。在Nodejs中，你可以使用[bcryptjs](https://www.npmjs.com/package/bcryptjs)，它提供了`hash`以及对应的`compare`方法，非常适合用于密码的加密和对比。\n\n**Session原理**\nSession的原理其实还是依赖了Cookie，所以Cookie才是记录用户凭证的真理。它的原理大概是酱紫的：服务器端维护一个session的表，这个表的每一条记录存的就是与某一个客户端的会话，会话会有过期时间，过期的会话会被清理。然后这个会话，会有一个对应的id，一般是一串长长的看不懂的字符串，然后这个字符串会被存储在客户端的cookie中，每一次请求服务器端都会带上这个cookie，服务器端就知道访问的就是哪个客户端了。\n欲知更多有关「Session原理」请点击传送门：[Session原理](http://www.jianshu.com/p/2b7c10291aad)\n\n## 使用独立登录系统\n应项目需要，登录逻辑需要独立出来做成一个系统，就是另外一个项目。与原来的主站不是在同一个项目中了。一个域名是 `www.site.com`，一个则是`passport.site.com`了。要在不同的域名下进行登录，一般的方法是`www.site.com/login` 跳转到 `passport.site.com/login`，passport这边是一个登录页面，用户输入账号密码登录成功之后，passport会通过带着一个可逆加密的包含用户信息的token，重定向到`www.site.com`提供的回调处理地址，然后进行解密，匹配正确，则登录用户。\n要注意的是，这里的加密的信息需要包含一个时间戳，接收方需要认证这个时间戳，过期登录失败。避免token被窃取，被无限登录site系统。\n\n## 单点登录\n单点登录需要实现的需求，说白了就是在站点A的登录了，那么用户就自动在站点B、站点C、站点E、F、G登录。\n这又分两种情况，A站点和B站点是否在同一个二级域名下。\n假如是在同一个域名下，例如`siteA.site.com`与`siteB.site.com`，因为cookie允许设置到二级域名下`.site.com`，所以siteA和siteB是可以共享cookie的，用户的信息可以通过可逆加密放在二级域名下的cookie，并且设置`http only`，就可以一站登录，站站登录。\n而如果A站点和B站点不在同一二级域名下，例如`www.siteA.com`与`www.siteB.com`，他们就无法通过共享cookie的方式共享用户信息，所以需要用到jsonp的方式，用户在siteA登录之后，提供一个jsonp接口获取加密的用户信息，siteB访问这个jsonp获取加密信息。达到共享用户状态的效果。\n欲知更多有关「单点登录」请点击传送门：[单点登录的三种实现方式](http://www.jianshu.com/p/613e44d4a464)\n\n## OAuth2.0登录\n这就比较普遍了，现在随随便便做个网站，都接入「微信登录」、「微博登录」、「豆瓣登录」、「QQ登录」、「Github登录」、*@^*&@%#^%^@%&%@&#........\n这些统一叫做：「第三方登录」。\n第三方登录都是实现了OAuth2.0协议的，流程大概是酱紫的：\n第三方提供一个登录入口，也就是第三方域名下的登录页面。主站需要登录的时候，引导用户重定向到第三方的登录页面，用户输入账号密码之后，登录第三方系统，第三方系统匹配帐号成功之后，带上一个code到主站的回调地址，主站接收到code，短时间内拿着code请求第三方提供获取长期凭证的接口(因为code有一个比较短的过期时间)，这个长期凭证叫`access_token`，获取之后就把这个`access_token`存到数据库中，请求一些第三方提供的API，需要用到这个`access_token`，因为这个token就是记录用户在第三方系统的一个身份凭证。\n一些系统，在获取`access_token`的时候，还会返回一个副参数`refresh_token`，因为`access_token`是有过期时间的，一旦过期了，主站可以使用`refresh_token`请求第三方提供的接口获取新的`access_token`以及新的`refresh_token`。\n在Nodejs中，你可以使用`passport`来给第三方登录提供一个统一解决方案，而如果你是开发「微信公众号」授权，除了[passport](https://www.npmjs.com/package/passport)，也可以使用[wechat-oauth](https://www.npmjs.com/package/wechat-oauth)\n\n## 在最后\n其实登录问题，理解了Session原理是很重要的，这个也不难理解。然后站点之间的用户信息交流，就是通过各种跨域限制，各种加密解密而已。在做这个的时候，需要充分考虑到加密的token是否会被窃取的可能性，还要考虑让这个token加上时间的验证，在一些可能会被窃取，安全需求比较高的情况，就需要把token的时间设置的更短。还有就是加密的方式需要依照需求不同而选择可逆或者不可逆，hash sha1还是JWT(Json Web Token)。\nsha1加密，可以使用Nodejs自带的`crypto`，JWT可以使用[jsonwebtoken]()\n","slug":"登录那些事儿","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8r3000sxwrlp7rv1guf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>也不知道是什么原因，刚开始不久的职业生涯，在技术这条路走着走着，和「登录」总是有着一个不解之缘。还记得当初学习Web编程的时候么？不管是Java、.Net、PHP，继经典「Hello World」之后，要写的很有可能就是「登录」功能。至今「登录」的问题还是让我心中一万只草泥马奔过。<br>下面，给分享一下各种「登录」相关的需求</p>\n<h2 id=\"普通的登录\"><a href=\"#普通的登录\" class=\"headerlink\" title=\"普通的登录\"></a>普通的登录</h2><p>这个是极其普通的登录需求，要的就是一个登录页面，输入账号密码，提交Form表单，后端查询数据库对应用户名的密码，匹配正确则把用户记录到Session，不正确则返回错误。<br>这种登录，在上学的时候，也许敬爱的老师就已经教过你了。<br>但可能他没有教你的是，密码需要hash加密，session为什么可以记录登录用户的原理。</p>\n<p><strong>密码Hash</strong><br>密码hash，就是存进数据库的密码是一串密文，密文是明文密码通过不可逆算法得出的。在Nodejs中，你可以使用<a href=\"https://www.npmjs.com/package/bcryptjs\" target=\"_blank\" rel=\"external\">bcryptjs</a>，它提供了<code>hash</code>以及对应的<code>compare</code>方法，非常适合用于密码的加密和对比。</p>\n<p><strong>Session原理</strong><br>Session的原理其实还是依赖了Cookie，所以Cookie才是记录用户凭证的真理。它的原理大概是酱紫的：服务器端维护一个session的表，这个表的每一条记录存的就是与某一个客户端的会话，会话会有过期时间，过期的会话会被清理。然后这个会话，会有一个对应的id，一般是一串长长的看不懂的字符串，然后这个字符串会被存储在客户端的cookie中，每一次请求服务器端都会带上这个cookie，服务器端就知道访问的就是哪个客户端了。<br>欲知更多有关「Session原理」请点击传送门：<a href=\"http://www.jianshu.com/p/2b7c10291aad\" target=\"_blank\" rel=\"external\">Session原理</a></p>\n<h2 id=\"使用独立登录系统\"><a href=\"#使用独立登录系统\" class=\"headerlink\" title=\"使用独立登录系统\"></a>使用独立登录系统</h2><p>应项目需要，登录逻辑需要独立出来做成一个系统，就是另外一个项目。与原来的主站不是在同一个项目中了。一个域名是 <code>www.site.com</code>，一个则是<code>passport.site.com</code>了。要在不同的域名下进行登录，一般的方法是<code>www.site.com/login</code> 跳转到 <code>passport.site.com/login</code>，passport这边是一个登录页面，用户输入账号密码登录成功之后，passport会通过带着一个可逆加密的包含用户信息的token，重定向到<code>www.site.com</code>提供的回调处理地址，然后进行解密，匹配正确，则登录用户。<br>要注意的是，这里的加密的信息需要包含一个时间戳，接收方需要认证这个时间戳，过期登录失败。避免token被窃取，被无限登录site系统。</p>\n<h2 id=\"单点登录\"><a href=\"#单点登录\" class=\"headerlink\" title=\"单点登录\"></a>单点登录</h2><p>单点登录需要实现的需求，说白了就是在站点A的登录了，那么用户就自动在站点B、站点C、站点E、F、G登录。<br>这又分两种情况，A站点和B站点是否在同一个二级域名下。<br>假如是在同一个域名下，例如<code>siteA.site.com</code>与<code>siteB.site.com</code>，因为cookie允许设置到二级域名下<code>.site.com</code>，所以siteA和siteB是可以共享cookie的，用户的信息可以通过可逆加密放在二级域名下的cookie，并且设置<code>http only</code>，就可以一站登录，站站登录。<br>而如果A站点和B站点不在同一二级域名下，例如<code>www.siteA.com</code>与<code>www.siteB.com</code>，他们就无法通过共享cookie的方式共享用户信息，所以需要用到jsonp的方式，用户在siteA登录之后，提供一个jsonp接口获取加密的用户信息，siteB访问这个jsonp获取加密信息。达到共享用户状态的效果。<br>欲知更多有关「单点登录」请点击传送门：<a href=\"http://www.jianshu.com/p/613e44d4a464\" target=\"_blank\" rel=\"external\">单点登录的三种实现方式</a></p>\n<h2 id=\"OAuth2-0登录\"><a href=\"#OAuth2-0登录\" class=\"headerlink\" title=\"OAuth2.0登录\"></a>OAuth2.0登录</h2><p>这就比较普遍了，现在随随便便做个网站，都接入「微信登录」、「微博登录」、「豆瓣登录」、「QQ登录」、「Github登录」、<em>@^</em>&amp;@%#^%^@%&amp;%@&amp;#……..<br>这些统一叫做：「第三方登录」。<br>第三方登录都是实现了OAuth2.0协议的，流程大概是酱紫的：<br>第三方提供一个登录入口，也就是第三方域名下的登录页面。主站需要登录的时候，引导用户重定向到第三方的登录页面，用户输入账号密码之后，登录第三方系统，第三方系统匹配帐号成功之后，带上一个code到主站的回调地址，主站接收到code，短时间内拿着code请求第三方提供获取长期凭证的接口(因为code有一个比较短的过期时间)，这个长期凭证叫<code>access_token</code>，获取之后就把这个<code>access_token</code>存到数据库中，请求一些第三方提供的API，需要用到这个<code>access_token</code>，因为这个token就是记录用户在第三方系统的一个身份凭证。<br>一些系统，在获取<code>access_token</code>的时候，还会返回一个副参数<code>refresh_token</code>，因为<code>access_token</code>是有过期时间的，一旦过期了，主站可以使用<code>refresh_token</code>请求第三方提供的接口获取新的<code>access_token</code>以及新的<code>refresh_token</code>。<br>在Nodejs中，你可以使用<code>passport</code>来给第三方登录提供一个统一解决方案，而如果你是开发「微信公众号」授权，除了<a href=\"https://www.npmjs.com/package/passport\" target=\"_blank\" rel=\"external\">passport</a>，也可以使用<a href=\"https://www.npmjs.com/package/wechat-oauth\" target=\"_blank\" rel=\"external\">wechat-oauth</a></p>\n<h2 id=\"在最后\"><a href=\"#在最后\" class=\"headerlink\" title=\"在最后\"></a>在最后</h2><p>其实登录问题，理解了Session原理是很重要的，这个也不难理解。然后站点之间的用户信息交流，就是通过各种跨域限制，各种加密解密而已。在做这个的时候，需要充分考虑到加密的token是否会被窃取的可能性，还要考虑让这个token加上时间的验证，在一些可能会被窃取，安全需求比较高的情况，就需要把token的时间设置的更短。还有就是加密的方式需要依照需求不同而选择可逆或者不可逆，hash sha1还是JWT(Json Web Token)。<br>sha1加密，可以使用Nodejs自带的<code>crypto</code>，JWT可以使用<a href>jsonwebtoken</a></p>\n","excerpt":"","more":"<p>也不知道是什么原因，刚开始不久的职业生涯，在技术这条路走着走着，和「登录」总是有着一个不解之缘。还记得当初学习Web编程的时候么？不管是Java、.Net、PHP，继经典「Hello World」之后，要写的很有可能就是「登录」功能。至今「登录」的问题还是让我心中一万只草泥马奔过。<br>下面，给分享一下各种「登录」相关的需求</p>\n<h2 id=\"普通的登录\"><a href=\"#普通的登录\" class=\"headerlink\" title=\"普通的登录\"></a>普通的登录</h2><p>这个是极其普通的登录需求，要的就是一个登录页面，输入账号密码，提交Form表单，后端查询数据库对应用户名的密码，匹配正确则把用户记录到Session，不正确则返回错误。<br>这种登录，在上学的时候，也许敬爱的老师就已经教过你了。<br>但可能他没有教你的是，密码需要hash加密，session为什么可以记录登录用户的原理。</p>\n<p><strong>密码Hash</strong><br>密码hash，就是存进数据库的密码是一串密文，密文是明文密码通过不可逆算法得出的。在Nodejs中，你可以使用<a href=\"https://www.npmjs.com/package/bcryptjs\">bcryptjs</a>，它提供了<code>hash</code>以及对应的<code>compare</code>方法，非常适合用于密码的加密和对比。</p>\n<p><strong>Session原理</strong><br>Session的原理其实还是依赖了Cookie，所以Cookie才是记录用户凭证的真理。它的原理大概是酱紫的：服务器端维护一个session的表，这个表的每一条记录存的就是与某一个客户端的会话，会话会有过期时间，过期的会话会被清理。然后这个会话，会有一个对应的id，一般是一串长长的看不懂的字符串，然后这个字符串会被存储在客户端的cookie中，每一次请求服务器端都会带上这个cookie，服务器端就知道访问的就是哪个客户端了。<br>欲知更多有关「Session原理」请点击传送门：<a href=\"http://www.jianshu.com/p/2b7c10291aad\">Session原理</a></p>\n<h2 id=\"使用独立登录系统\"><a href=\"#使用独立登录系统\" class=\"headerlink\" title=\"使用独立登录系统\"></a>使用独立登录系统</h2><p>应项目需要，登录逻辑需要独立出来做成一个系统，就是另外一个项目。与原来的主站不是在同一个项目中了。一个域名是 <code>www.site.com</code>，一个则是<code>passport.site.com</code>了。要在不同的域名下进行登录，一般的方法是<code>www.site.com/login</code> 跳转到 <code>passport.site.com/login</code>，passport这边是一个登录页面，用户输入账号密码登录成功之后，passport会通过带着一个可逆加密的包含用户信息的token，重定向到<code>www.site.com</code>提供的回调处理地址，然后进行解密，匹配正确，则登录用户。<br>要注意的是，这里的加密的信息需要包含一个时间戳，接收方需要认证这个时间戳，过期登录失败。避免token被窃取，被无限登录site系统。</p>\n<h2 id=\"单点登录\"><a href=\"#单点登录\" class=\"headerlink\" title=\"单点登录\"></a>单点登录</h2><p>单点登录需要实现的需求，说白了就是在站点A的登录了，那么用户就自动在站点B、站点C、站点E、F、G登录。<br>这又分两种情况，A站点和B站点是否在同一个二级域名下。<br>假如是在同一个域名下，例如<code>siteA.site.com</code>与<code>siteB.site.com</code>，因为cookie允许设置到二级域名下<code>.site.com</code>，所以siteA和siteB是可以共享cookie的，用户的信息可以通过可逆加密放在二级域名下的cookie，并且设置<code>http only</code>，就可以一站登录，站站登录。<br>而如果A站点和B站点不在同一二级域名下，例如<code>www.siteA.com</code>与<code>www.siteB.com</code>，他们就无法通过共享cookie的方式共享用户信息，所以需要用到jsonp的方式，用户在siteA登录之后，提供一个jsonp接口获取加密的用户信息，siteB访问这个jsonp获取加密信息。达到共享用户状态的效果。<br>欲知更多有关「单点登录」请点击传送门：<a href=\"http://www.jianshu.com/p/613e44d4a464\">单点登录的三种实现方式</a></p>\n<h2 id=\"OAuth2-0登录\"><a href=\"#OAuth2-0登录\" class=\"headerlink\" title=\"OAuth2.0登录\"></a>OAuth2.0登录</h2><p>这就比较普遍了，现在随随便便做个网站，都接入「微信登录」、「微博登录」、「豆瓣登录」、「QQ登录」、「Github登录」、<em>@^</em>&amp;@%#^%^@%&amp;%@&amp;#……..<br>这些统一叫做：「第三方登录」。<br>第三方登录都是实现了OAuth2.0协议的，流程大概是酱紫的：<br>第三方提供一个登录入口，也就是第三方域名下的登录页面。主站需要登录的时候，引导用户重定向到第三方的登录页面，用户输入账号密码之后，登录第三方系统，第三方系统匹配帐号成功之后，带上一个code到主站的回调地址，主站接收到code，短时间内拿着code请求第三方提供获取长期凭证的接口(因为code有一个比较短的过期时间)，这个长期凭证叫<code>access_token</code>，获取之后就把这个<code>access_token</code>存到数据库中，请求一些第三方提供的API，需要用到这个<code>access_token</code>，因为这个token就是记录用户在第三方系统的一个身份凭证。<br>一些系统，在获取<code>access_token</code>的时候，还会返回一个副参数<code>refresh_token</code>，因为<code>access_token</code>是有过期时间的，一旦过期了，主站可以使用<code>refresh_token</code>请求第三方提供的接口获取新的<code>access_token</code>以及新的<code>refresh_token</code>。<br>在Nodejs中，你可以使用<code>passport</code>来给第三方登录提供一个统一解决方案，而如果你是开发「微信公众号」授权，除了<a href=\"https://www.npmjs.com/package/passport\">passport</a>，也可以使用<a href=\"https://www.npmjs.com/package/wechat-oauth\">wechat-oauth</a></p>\n<h2 id=\"在最后\"><a href=\"#在最后\" class=\"headerlink\" title=\"在最后\"></a>在最后</h2><p>其实登录问题，理解了Session原理是很重要的，这个也不难理解。然后站点之间的用户信息交流，就是通过各种跨域限制，各种加密解密而已。在做这个的时候，需要充分考虑到加密的token是否会被窃取的可能性，还要考虑让这个token加上时间的验证，在一些可能会被窃取，安全需求比较高的情况，就需要把token的时间设置的更短。还有就是加密的方式需要依照需求不同而选择可逆或者不可逆，hash sha1还是JWT(Json Web Token)。<br>sha1加密，可以使用Nodejs自带的<code>crypto</code>，JWT可以使用<a href=\"\">jsonwebtoken</a></p>\n"},{"title":"理解 CORS (Cross-Origin Resource Sharing)","date":"2016-05-15T15:22:25.000Z","_content":"\n## 存在即是合理\n> 首先理解一下「跨站HTTP请求」\n\n跨站HTTP(Cross-Site HTTP Reuqest)请求，是指发起请求的资源所在域不同于该请求所指向资源所在域的HTTP请求。\n比如说，域名A(`http://domaina.example`)的某 Web 应用程序中通过`<img>`标签引入了域名B(`http://domainb.foo`)站点的某图片资源(`http://domainb.foo/image.jpg`)，域名A的那 Web 应用就会导致浏览器发起一个跨站 HTTP 请求。\n在现在的Web开发中，使用跨站HTTP请求加载各类资源(包括CSS、图片、JavaScript脚本以及其他类资源)，已经成为了一种普遍且流行的方式。\n\n> 出于安全考虑，浏览器会限制脚本中发起的跨站请求\n\n比如，使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest 对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。\n要注意的是，跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是CSRF跨站攻击原理，请求是发送到了后端服务器无论是否跨域。\n\n\n## 理解同源策略\n\n[Cross-Site Sharing Standard](https://www.w3.org/TR/cors) 是W3C推荐的一种机制，让Web应用服务器能支持跨站访问控制，从而使得安全地进行跨站数据传输成为可能。下面截取其中「[Syntax](https://www.w3.org/TR/cors/#syntax)」章节，来说明一下请求与响应的规范。\n\n\n> For Response\n\n### Access-Control-Allow-Origin Response Header\n该请求头表示所请求的资源是否接受来自指定origin(根据 Origin Request Header)的请求.\n```\nAccess-Control-Allow-Origin: <origin> | *\n```\n举个栗子,允许来自 http://baidu.com 的请求,你可以这样指定:\n```\nAccess-Control-Allow-Origin: http://baidu.com\n```\n\n### Access-Control-Allow-Credentials Response Heade\n告知客户端,当请求的credientials属性是true的时候,响应是否可以被得到.当它作为预请求的响应的一部分时,它用来告知实际的请求是否使用了credentials.注意,简单的GET请求不会预检,所以如果一个请求是为了得到一个带有credentials的资源,而响应里又没有Access-Control-Allow-Credentials头信息,那么说明这个响应被忽略了.\n```\nAccess-Control-Allow-Credentials: true | false\n```\n\n### Access-Control-Expose-Headers Response Header\n设置浏览器允许访问的服务器响应请求的头信息的白名单:\n```\nAccess-Control-Expose-Headers: X-A-Custom-Header, X-B-Custom-Header\n```\n这样，浏览器就可以得到服务器响应请求的头信息中的` X-A-Custom-Header`、` X-B-Custom-Header`\n\n### Access-Control-Max-Age Response Header\n这个头告诉我们这次预请求的结果的有效期是多久：\n```\nAccess-Control-Max-Age: <delta-seconds>\n```\n`delta-seconds` 参数表示,允许这个预请求的参数缓存的秒数,在此期间,不用发出另一条预检请求. \n\n### Access-Control-Allow-Methods Response Header\n指明资源可以被请求的方式有哪些(一个或者多个). 这个响应头信息在客户端发出预检请求的时候会被返回.\n```\nAccess-Control-Allow-Methods: <method>[, <method>]*\n```\n\n### Access-Control-Allow-Headers Response Header\n也是在响应预检请求的时候使用.用来指明在实际的请求中,可以使用哪些自定义HTTP请求头.比如\n```\nAccess-Control-Allow-Headers: X-Custom-Header\n```\n这样在实际的请求里,请求头信息里就可以有这么一条:\n```\nX-Custom-Header: hello world\n```\n\n> For Request\n\n### Origin Request Header\n表明发送请求或者预请求的域\n```\nOrigin: <origin>\n```\n参数`origin`是一个URI,告诉服务器端,请求来自哪里.它不包含任何路径信息,只是服务器名.\n\n### Access-Control-Request-Method Request Header\n在发出预检请求时带有这个头信息,告诉服务器在实际请求时会使用的请求方式\n```\nAccess-Control-Request-Method: <method>\n```\n\n### Access-Control-Request-Headers\n在发出预检请求时带有这个头信息,告诉服务器在实际请求时会携带的自定义头信息.如有多个,可以用逗号分开.\n```\nAccess-Control-Request-Headers: <field-name>[, <field-name>]*\n```\n\n\n## 举三个栗子\n### 一个简单的请求\n比如说，假如站点 `http://foo.example` 的网页应用想要访问 `http://bar.other` 的资源。以下的 JavaScript 代码应该会在 foo.example 上执行：\n```\nvar invocation = new XMLHttpRequest();\nvar url = 'http://bar.other/resources/public-data/';\n   \nfunction callOtherDomain() {\n  if(invocation) {    \n    invocation.open('GET', url, true);\n    invocation.onreadystatechange = handler;\n    invocation.send(); \n  }\n}\n```\n让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：\n```\nGET /resources/public-data/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nReferer: http://foo.example/examples/access-control/simpleXSInvocation.html\nOrigin: http://foo.example\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 00:23:53 GMT\nServer: Apache/2.0.61 \nAccess-Control-Allow-Origin: *\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nTransfer-Encoding: chunked\nContent-Type: application/xml\n\n[XML Data]\n```\n第 1~10 行是 浏览器 发出的请求头。注意看第10行的请求头 Origin，它表明了该请求来自于 `http://foo.exmaple`。\n\n第 13~22 行则是 `http://bar.other` 服务器的响应。如第16行所示，服务器返回了响应头 Access-Control-Allow-Origin: *，这表明服务器接受来自任何站点的跨站请求。如果服务器端仅允许来自 `http://foo.example` 的跨站请求，它可以返回：\n```\nAccess-Control-Allow-Origin: http://foo.example\n```\n现在，除了 `http://foo.example`，其它站点就不能跨站访问 `http://bar.other` 的资源了。\n\n如上，通过使用 Origin 和 Access-Control-Allow-Origin 就可以完成最简单的跨站请求。不过 Access-Control-Allow-Origin 需要为 * 或者包含由 Origin 指明的站点。\n\n### 预请求 Prefilght\n不同于上面讨论的简单请求，“预请求”要求必须先发送一个 OPTIONS 请求给目的站点，来查明这个跨站请求对于目的站点是不是安全可接受的。这样做，是因为跨站请求可能会对目的站点的数据造成破坏。 当请求具备以下条件，就会被当成预请求处理：\n\n* 请求以 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求。\n* 使用自定义请求头（比如添加诸如 X-PINGOTHER\n\n如示例：\n```\nvar invocation = new XMLHttpRequest();\nvar url = 'http://bar.other/resources/post-here/';\nvar body = '{C}{C}{C}{C}{C}{C}{C}{C}{C}{C}Arun';\n    \nfunction callOtherDomain(){\n  if(invocation)\n    {\n      invocation.open('POST', url, true);\n      invocation.setRequestHeader('X-PINGOTHER', 'pingpong');\n      invocation.setRequestHeader('Content-Type', 'application/xml');\n      invocation.onreadystatechange = handler;\n      invocation.send(body); \n    }\n\n......\n```\n如上，以 XMLHttpRequest 创建了一个 POST 请求，为该请求添加了一个自定义请求头(X-PINGOTHER: pingpong)，并指定数据类型为 application/xml。所以，该请求是一个“预请求”形式的跨站请求。\n\n让我们看看服务器与浏览器之间具体的交互过程：\n```\nOPTIONS /resources/post-here/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nOrigin: http://foo.example\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: X-PINGOTHER\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER\nAccess-Control-Max-Age: 1728000\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n\nPOST /resources/post-here/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nX-PINGOTHER: pingpong\nContent-Type: text/xml; charset=UTF-8\nReferer: http://foo.example/examples/preflightInvocation.html\nContent-Length: 55\nOrigin: http://foo.example\nPragma: no-cache\nCache-Control: no-cache\n\nArun\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:40 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://foo.example\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 235\nKeep-Alive: timeout=2, max=99\nConnection: Keep-Alive\nContent-Type: text/plain\n\n[Some GZIP'd payload]\n```\n第1至12行，使用一个 OPTIONS 发送了一个“预请求”。浏览器 根据请求参数，决定需要发送一个“预请求”，来探明服务器端是否接受后续真正的请求。 OPTIONS 是 HTTP/1.1 里的方法，用来获取更多服务器端的信息，是一个不应该对服务器数据造成影响的方法。 随同 OPTIONS 请求，以下两个请求头一起被发送：\n```\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: X-PINGOTHER\n```\n请求头Access-Control-Request-Method可以提醒服务器跨站请求将使用POST方法，而请求头Access-Control-Request-Headers则告知服务器该跨站请求将携带一个自定义请求头X-PINGOTHER。这样，服务器就可以决定，在当前情况下，是否接受该跨站请求访问。\n\n第15至27行是服务器的响应。该响应表明，服务器接受了客服端的跨站请求。具体可以看看第18至21行：\n```\nAccess-Control-Allow-Origin: http://foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER\nAccess-Control-Max-Age: 1728000\n```\n响应头Access-Control-Allow-Methods表明服务器可以接受POST, GET和 OPTIONS的请求方法。请注意，这个响应头类似于HTTP/1.1 Allow: response header，但仅限于访问控制的场景下。而响应头Access-Control-Allow-Headers则表示服务器接受自定义请求头X-PINGOTHER。就像Access-Control-Allow-Methods一样，Access-Control-Allow-Headers允许以逗号分隔，传递一个可接受的自定义请求头列表。最后，响应头Access-Control-Max-Age告诉浏览器，本次“预请求”的响应结果有效时间是多久。在上面的例子里，1728000秒代表着20天内，浏览器在处理针对该服务器的跨站请求，都可以无需再发送“预请求”，只需根据本次结果进行判断处理。\n\n\n### 附带凭证信息的请求\nXMLHttpRequest和访问控制功能，最有趣的特性就是，发送凭证请求（HTTP Cookies和验证信息）的功能。一般而言，对于跨站请求，浏览器是不会发送凭证信息的。但如果将XMLHttpRequest的一个特殊标志位设置为true，浏览器就将允许该请求的发送。\n\n`http://foo.example`站点的脚本向`http://bar.other`站点发送一个GET请求，并设置了一个Cookies值。脚本代码如下：\n```\nvar invocation = new XMLHttpRequest();\nvar url = 'http://bar.other/resources/credentialed-content/';\n    \nfunction callOtherDomain(){\n  if(invocation) {\n    invocation.open('GET', url, true);\n    invocation.withCredentials = true;\n    invocation.onreadystatechange = handler;\n    invocation.send(); \n  }\n```\n如你所见，第七行代码将XMLHttpRequest的withCredentials标志设置为true，从而使得Cookies可以随着请求发送。因为这是一个简单的GET请求，所以浏览器不会发送一个“预请求”。但是，如果服务器端的响应中，如果没有返回Access-Control-Allow-Credentials: true的响应头，那么浏览器将不会把响应结果传递给发出请求的脚本程序，以保证信息的安全。\n\n客服端与服务器端交互示例如下：\n```\nGET /resources/access-control-with-credentials/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nReferer: http://foo.example/examples/credential.html\nOrigin: http://foo.example\nCookie: pageAccess=2\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:34:52 GMT\nServer: Apache/2.0.61 (Unix) PHP/4.4.7 mod_ssl/2.0.61 OpenSSL/0.9.7e mod_fastcgi/2.4.2 DAV/2 SVN/1.4.2\nX-Powered-By: PHP/5.2.6\nAccess-Control-Allow-Origin: http://foo.example\nAccess-Control-Allow-Credentials: true\nCache-Control: no-cache\nPragma: no-cache\nSet-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 106\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n\n\n[text/plain payload]\n```\n虽然第11行指定了要提交到`http://bar.other`的内容的Cookie信息,但是如果bar.other的响应头里没有Access-Control-Allow-Credentials:true(第19行),则响应会被忽略. 特别注意: 给一个带有withCredentials的请求发送响应的时候,服务器端必须指定允许请求的域名,不能使用'*'.上面这个例子中,如果响应头是这样的:Access-Control-Allow-Origin: * ,则响应会失败. 在这个例子里,因为Access-Control-Allow-Origin的值是`http://foo.example`这个指定的请求域名,所以客户端把带有凭证信息的内容被返回给了客户端. 另外注意第22行,更多的cookie信息也被创建了\n\n## 参考\n[Access_control_CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)\n[Cross-Origin Resource Sharing Standard](https://www.w3.org/TR/cors/)\n[Same-origin_policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)","source":"_posts/理解 CORS (Cross-Origin Resource Sharing).md","raw":"---\ntitle: 理解 CORS (Cross-Origin Resource Sharing)\ncategory: 搬砖码农\ndate: 2016-05-15 23:22:25\ntags: \n- http\n- cors\n---\n\n## 存在即是合理\n> 首先理解一下「跨站HTTP请求」\n\n跨站HTTP(Cross-Site HTTP Reuqest)请求，是指发起请求的资源所在域不同于该请求所指向资源所在域的HTTP请求。\n比如说，域名A(`http://domaina.example`)的某 Web 应用程序中通过`<img>`标签引入了域名B(`http://domainb.foo`)站点的某图片资源(`http://domainb.foo/image.jpg`)，域名A的那 Web 应用就会导致浏览器发起一个跨站 HTTP 请求。\n在现在的Web开发中，使用跨站HTTP请求加载各类资源(包括CSS、图片、JavaScript脚本以及其他类资源)，已经成为了一种普遍且流行的方式。\n\n> 出于安全考虑，浏览器会限制脚本中发起的跨站请求\n\n比如，使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest 对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。\n要注意的是，跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是CSRF跨站攻击原理，请求是发送到了后端服务器无论是否跨域。\n\n\n## 理解同源策略\n\n[Cross-Site Sharing Standard](https://www.w3.org/TR/cors) 是W3C推荐的一种机制，让Web应用服务器能支持跨站访问控制，从而使得安全地进行跨站数据传输成为可能。下面截取其中「[Syntax](https://www.w3.org/TR/cors/#syntax)」章节，来说明一下请求与响应的规范。\n\n\n> For Response\n\n### Access-Control-Allow-Origin Response Header\n该请求头表示所请求的资源是否接受来自指定origin(根据 Origin Request Header)的请求.\n```\nAccess-Control-Allow-Origin: <origin> | *\n```\n举个栗子,允许来自 http://baidu.com 的请求,你可以这样指定:\n```\nAccess-Control-Allow-Origin: http://baidu.com\n```\n\n### Access-Control-Allow-Credentials Response Heade\n告知客户端,当请求的credientials属性是true的时候,响应是否可以被得到.当它作为预请求的响应的一部分时,它用来告知实际的请求是否使用了credentials.注意,简单的GET请求不会预检,所以如果一个请求是为了得到一个带有credentials的资源,而响应里又没有Access-Control-Allow-Credentials头信息,那么说明这个响应被忽略了.\n```\nAccess-Control-Allow-Credentials: true | false\n```\n\n### Access-Control-Expose-Headers Response Header\n设置浏览器允许访问的服务器响应请求的头信息的白名单:\n```\nAccess-Control-Expose-Headers: X-A-Custom-Header, X-B-Custom-Header\n```\n这样，浏览器就可以得到服务器响应请求的头信息中的` X-A-Custom-Header`、` X-B-Custom-Header`\n\n### Access-Control-Max-Age Response Header\n这个头告诉我们这次预请求的结果的有效期是多久：\n```\nAccess-Control-Max-Age: <delta-seconds>\n```\n`delta-seconds` 参数表示,允许这个预请求的参数缓存的秒数,在此期间,不用发出另一条预检请求. \n\n### Access-Control-Allow-Methods Response Header\n指明资源可以被请求的方式有哪些(一个或者多个). 这个响应头信息在客户端发出预检请求的时候会被返回.\n```\nAccess-Control-Allow-Methods: <method>[, <method>]*\n```\n\n### Access-Control-Allow-Headers Response Header\n也是在响应预检请求的时候使用.用来指明在实际的请求中,可以使用哪些自定义HTTP请求头.比如\n```\nAccess-Control-Allow-Headers: X-Custom-Header\n```\n这样在实际的请求里,请求头信息里就可以有这么一条:\n```\nX-Custom-Header: hello world\n```\n\n> For Request\n\n### Origin Request Header\n表明发送请求或者预请求的域\n```\nOrigin: <origin>\n```\n参数`origin`是一个URI,告诉服务器端,请求来自哪里.它不包含任何路径信息,只是服务器名.\n\n### Access-Control-Request-Method Request Header\n在发出预检请求时带有这个头信息,告诉服务器在实际请求时会使用的请求方式\n```\nAccess-Control-Request-Method: <method>\n```\n\n### Access-Control-Request-Headers\n在发出预检请求时带有这个头信息,告诉服务器在实际请求时会携带的自定义头信息.如有多个,可以用逗号分开.\n```\nAccess-Control-Request-Headers: <field-name>[, <field-name>]*\n```\n\n\n## 举三个栗子\n### 一个简单的请求\n比如说，假如站点 `http://foo.example` 的网页应用想要访问 `http://bar.other` 的资源。以下的 JavaScript 代码应该会在 foo.example 上执行：\n```\nvar invocation = new XMLHttpRequest();\nvar url = 'http://bar.other/resources/public-data/';\n   \nfunction callOtherDomain() {\n  if(invocation) {    \n    invocation.open('GET', url, true);\n    invocation.onreadystatechange = handler;\n    invocation.send(); \n  }\n}\n```\n让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：\n```\nGET /resources/public-data/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nReferer: http://foo.example/examples/access-control/simpleXSInvocation.html\nOrigin: http://foo.example\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 00:23:53 GMT\nServer: Apache/2.0.61 \nAccess-Control-Allow-Origin: *\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nTransfer-Encoding: chunked\nContent-Type: application/xml\n\n[XML Data]\n```\n第 1~10 行是 浏览器 发出的请求头。注意看第10行的请求头 Origin，它表明了该请求来自于 `http://foo.exmaple`。\n\n第 13~22 行则是 `http://bar.other` 服务器的响应。如第16行所示，服务器返回了响应头 Access-Control-Allow-Origin: *，这表明服务器接受来自任何站点的跨站请求。如果服务器端仅允许来自 `http://foo.example` 的跨站请求，它可以返回：\n```\nAccess-Control-Allow-Origin: http://foo.example\n```\n现在，除了 `http://foo.example`，其它站点就不能跨站访问 `http://bar.other` 的资源了。\n\n如上，通过使用 Origin 和 Access-Control-Allow-Origin 就可以完成最简单的跨站请求。不过 Access-Control-Allow-Origin 需要为 * 或者包含由 Origin 指明的站点。\n\n### 预请求 Prefilght\n不同于上面讨论的简单请求，“预请求”要求必须先发送一个 OPTIONS 请求给目的站点，来查明这个跨站请求对于目的站点是不是安全可接受的。这样做，是因为跨站请求可能会对目的站点的数据造成破坏。 当请求具备以下条件，就会被当成预请求处理：\n\n* 请求以 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求。\n* 使用自定义请求头（比如添加诸如 X-PINGOTHER\n\n如示例：\n```\nvar invocation = new XMLHttpRequest();\nvar url = 'http://bar.other/resources/post-here/';\nvar body = '{C}{C}{C}{C}{C}{C}{C}{C}{C}{C}Arun';\n    \nfunction callOtherDomain(){\n  if(invocation)\n    {\n      invocation.open('POST', url, true);\n      invocation.setRequestHeader('X-PINGOTHER', 'pingpong');\n      invocation.setRequestHeader('Content-Type', 'application/xml');\n      invocation.onreadystatechange = handler;\n      invocation.send(body); \n    }\n\n......\n```\n如上，以 XMLHttpRequest 创建了一个 POST 请求，为该请求添加了一个自定义请求头(X-PINGOTHER: pingpong)，并指定数据类型为 application/xml。所以，该请求是一个“预请求”形式的跨站请求。\n\n让我们看看服务器与浏览器之间具体的交互过程：\n```\nOPTIONS /resources/post-here/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nOrigin: http://foo.example\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: X-PINGOTHER\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER\nAccess-Control-Max-Age: 1728000\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n\nPOST /resources/post-here/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nX-PINGOTHER: pingpong\nContent-Type: text/xml; charset=UTF-8\nReferer: http://foo.example/examples/preflightInvocation.html\nContent-Length: 55\nOrigin: http://foo.example\nPragma: no-cache\nCache-Control: no-cache\n\nArun\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:40 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://foo.example\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 235\nKeep-Alive: timeout=2, max=99\nConnection: Keep-Alive\nContent-Type: text/plain\n\n[Some GZIP'd payload]\n```\n第1至12行，使用一个 OPTIONS 发送了一个“预请求”。浏览器 根据请求参数，决定需要发送一个“预请求”，来探明服务器端是否接受后续真正的请求。 OPTIONS 是 HTTP/1.1 里的方法，用来获取更多服务器端的信息，是一个不应该对服务器数据造成影响的方法。 随同 OPTIONS 请求，以下两个请求头一起被发送：\n```\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: X-PINGOTHER\n```\n请求头Access-Control-Request-Method可以提醒服务器跨站请求将使用POST方法，而请求头Access-Control-Request-Headers则告知服务器该跨站请求将携带一个自定义请求头X-PINGOTHER。这样，服务器就可以决定，在当前情况下，是否接受该跨站请求访问。\n\n第15至27行是服务器的响应。该响应表明，服务器接受了客服端的跨站请求。具体可以看看第18至21行：\n```\nAccess-Control-Allow-Origin: http://foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER\nAccess-Control-Max-Age: 1728000\n```\n响应头Access-Control-Allow-Methods表明服务器可以接受POST, GET和 OPTIONS的请求方法。请注意，这个响应头类似于HTTP/1.1 Allow: response header，但仅限于访问控制的场景下。而响应头Access-Control-Allow-Headers则表示服务器接受自定义请求头X-PINGOTHER。就像Access-Control-Allow-Methods一样，Access-Control-Allow-Headers允许以逗号分隔，传递一个可接受的自定义请求头列表。最后，响应头Access-Control-Max-Age告诉浏览器，本次“预请求”的响应结果有效时间是多久。在上面的例子里，1728000秒代表着20天内，浏览器在处理针对该服务器的跨站请求，都可以无需再发送“预请求”，只需根据本次结果进行判断处理。\n\n\n### 附带凭证信息的请求\nXMLHttpRequest和访问控制功能，最有趣的特性就是，发送凭证请求（HTTP Cookies和验证信息）的功能。一般而言，对于跨站请求，浏览器是不会发送凭证信息的。但如果将XMLHttpRequest的一个特殊标志位设置为true，浏览器就将允许该请求的发送。\n\n`http://foo.example`站点的脚本向`http://bar.other`站点发送一个GET请求，并设置了一个Cookies值。脚本代码如下：\n```\nvar invocation = new XMLHttpRequest();\nvar url = 'http://bar.other/resources/credentialed-content/';\n    \nfunction callOtherDomain(){\n  if(invocation) {\n    invocation.open('GET', url, true);\n    invocation.withCredentials = true;\n    invocation.onreadystatechange = handler;\n    invocation.send(); \n  }\n```\n如你所见，第七行代码将XMLHttpRequest的withCredentials标志设置为true，从而使得Cookies可以随着请求发送。因为这是一个简单的GET请求，所以浏览器不会发送一个“预请求”。但是，如果服务器端的响应中，如果没有返回Access-Control-Allow-Credentials: true的响应头，那么浏览器将不会把响应结果传递给发出请求的脚本程序，以保证信息的安全。\n\n客服端与服务器端交互示例如下：\n```\nGET /resources/access-control-with-credentials/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nReferer: http://foo.example/examples/credential.html\nOrigin: http://foo.example\nCookie: pageAccess=2\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:34:52 GMT\nServer: Apache/2.0.61 (Unix) PHP/4.4.7 mod_ssl/2.0.61 OpenSSL/0.9.7e mod_fastcgi/2.4.2 DAV/2 SVN/1.4.2\nX-Powered-By: PHP/5.2.6\nAccess-Control-Allow-Origin: http://foo.example\nAccess-Control-Allow-Credentials: true\nCache-Control: no-cache\nPragma: no-cache\nSet-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 106\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n\n\n[text/plain payload]\n```\n虽然第11行指定了要提交到`http://bar.other`的内容的Cookie信息,但是如果bar.other的响应头里没有Access-Control-Allow-Credentials:true(第19行),则响应会被忽略. 特别注意: 给一个带有withCredentials的请求发送响应的时候,服务器端必须指定允许请求的域名,不能使用'*'.上面这个例子中,如果响应头是这样的:Access-Control-Allow-Origin: * ,则响应会失败. 在这个例子里,因为Access-Control-Allow-Origin的值是`http://foo.example`这个指定的请求域名,所以客户端把带有凭证信息的内容被返回给了客户端. 另外注意第22行,更多的cookie信息也被创建了\n\n## 参考\n[Access_control_CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)\n[Cross-Origin Resource Sharing Standard](https://www.w3.org/TR/cors/)\n[Same-origin_policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)","slug":"理解 CORS (Cross-Origin Resource Sharing)","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8r50012xwrloeq9o78f","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"存在即是合理\"><a href=\"#存在即是合理\" class=\"headerlink\" title=\"存在即是合理\"></a>存在即是合理</h2><blockquote>\n<p>首先理解一下「跨站HTTP请求」</p>\n</blockquote>\n<p>跨站HTTP(Cross-Site HTTP Reuqest)请求，是指发起请求的资源所在域不同于该请求所指向资源所在域的HTTP请求。<br>比如说，域名A(<code>http://domaina.example</code>)的某 Web 应用程序中通过<code>&lt;img&gt;</code>标签引入了域名B(<code>http://domainb.foo</code>)站点的某图片资源(<code>http://domainb.foo/image.jpg</code>)，域名A的那 Web 应用就会导致浏览器发起一个跨站 HTTP 请求。<br>在现在的Web开发中，使用跨站HTTP请求加载各类资源(包括CSS、图片、JavaScript脚本以及其他类资源)，已经成为了一种普遍且流行的方式。</p>\n<blockquote>\n<p>出于安全考虑，浏览器会限制脚本中发起的跨站请求</p>\n</blockquote>\n<p>比如，使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest 对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。<br>要注意的是，跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是CSRF跨站攻击原理，请求是发送到了后端服务器无论是否跨域。</p>\n<h2 id=\"理解同源策略\"><a href=\"#理解同源策略\" class=\"headerlink\" title=\"理解同源策略\"></a>理解同源策略</h2><p><a href=\"https://www.w3.org/TR/cors\" target=\"_blank\" rel=\"external\">Cross-Site Sharing Standard</a> 是W3C推荐的一种机制，让Web应用服务器能支持跨站访问控制，从而使得安全地进行跨站数据传输成为可能。下面截取其中「<a href=\"https://www.w3.org/TR/cors/#syntax\" target=\"_blank\" rel=\"external\">Syntax</a>」章节，来说明一下请求与响应的规范。</p>\n<blockquote>\n<p>For Response</p>\n</blockquote>\n<h3 id=\"Access-Control-Allow-Origin-Response-Header\"><a href=\"#Access-Control-Allow-Origin-Response-Header\" class=\"headerlink\" title=\"Access-Control-Allow-Origin Response Header\"></a>Access-Control-Allow-Origin Response Header</h3><p>该请求头表示所请求的资源是否接受来自指定origin(根据 Origin Request Header)的请求.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: &lt;origin&gt; | *</span><br></pre></td></tr></table></figure></p>\n<p>举个栗子,允许来自 <a href=\"http://baidu.com\" target=\"_blank\" rel=\"external\">http://baidu.com</a> 的请求,你可以这样指定:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: http://baidu.com</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Allow-Credentials-Response-Heade\"><a href=\"#Access-Control-Allow-Credentials-Response-Heade\" class=\"headerlink\" title=\"Access-Control-Allow-Credentials Response Heade\"></a>Access-Control-Allow-Credentials Response Heade</h3><p>告知客户端,当请求的credientials属性是true的时候,响应是否可以被得到.当它作为预请求的响应的一部分时,它用来告知实际的请求是否使用了credentials.注意,简单的GET请求不会预检,所以如果一个请求是为了得到一个带有credentials的资源,而响应里又没有Access-Control-Allow-Credentials头信息,那么说明这个响应被忽略了.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Credentials: true | false</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Expose-Headers-Response-Header\"><a href=\"#Access-Control-Expose-Headers-Response-Header\" class=\"headerlink\" title=\"Access-Control-Expose-Headers Response Header\"></a>Access-Control-Expose-Headers Response Header</h3><p>设置浏览器允许访问的服务器响应请求的头信息的白名单:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Expose-Headers: X-A-Custom-Header, X-B-Custom-Header</span><br></pre></td></tr></table></figure></p>\n<p>这样，浏览器就可以得到服务器响应请求的头信息中的<code>X-A-Custom-Header</code>、<code>X-B-Custom-Header</code></p>\n<h3 id=\"Access-Control-Max-Age-Response-Header\"><a href=\"#Access-Control-Max-Age-Response-Header\" class=\"headerlink\" title=\"Access-Control-Max-Age Response Header\"></a>Access-Control-Max-Age Response Header</h3><p>这个头告诉我们这次预请求的结果的有效期是多久：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Max-Age: &lt;delta-seconds&gt;</span><br></pre></td></tr></table></figure></p>\n<p><code>delta-seconds</code> 参数表示,允许这个预请求的参数缓存的秒数,在此期间,不用发出另一条预检请求. </p>\n<h3 id=\"Access-Control-Allow-Methods-Response-Header\"><a href=\"#Access-Control-Allow-Methods-Response-Header\" class=\"headerlink\" title=\"Access-Control-Allow-Methods Response Header\"></a>Access-Control-Allow-Methods Response Header</h3><p>指明资源可以被请求的方式有哪些(一个或者多个). 这个响应头信息在客户端发出预检请求的时候会被返回.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Allow-Headers-Response-Header\"><a href=\"#Access-Control-Allow-Headers-Response-Header\" class=\"headerlink\" title=\"Access-Control-Allow-Headers Response Header\"></a>Access-Control-Allow-Headers Response Header</h3><p>也是在响应预检请求的时候使用.用来指明在实际的请求中,可以使用哪些自定义HTTP请求头.比如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Headers: X-Custom-Header</span><br></pre></td></tr></table></figure></p>\n<p>这样在实际的请求里,请求头信息里就可以有这么一条:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X-Custom-Header: hello world</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>For Request</p>\n</blockquote>\n<h3 id=\"Origin-Request-Header\"><a href=\"#Origin-Request-Header\" class=\"headerlink\" title=\"Origin Request Header\"></a>Origin Request Header</h3><p>表明发送请求或者预请求的域<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Origin: &lt;origin&gt;</span><br></pre></td></tr></table></figure></p>\n<p>参数<code>origin</code>是一个URI,告诉服务器端,请求来自哪里.它不包含任何路径信息,只是服务器名.</p>\n<h3 id=\"Access-Control-Request-Method-Request-Header\"><a href=\"#Access-Control-Request-Method-Request-Header\" class=\"headerlink\" title=\"Access-Control-Request-Method Request Header\"></a>Access-Control-Request-Method Request Header</h3><p>在发出预检请求时带有这个头信息,告诉服务器在实际请求时会使用的请求方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Request-Method: &lt;method&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Request-Headers\"><a href=\"#Access-Control-Request-Headers\" class=\"headerlink\" title=\"Access-Control-Request-Headers\"></a>Access-Control-Request-Headers</h3><p>在发出预检请求时带有这个头信息,告诉服务器在实际请求时会携带的自定义头信息.如有多个,可以用逗号分开.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"举三个栗子\"><a href=\"#举三个栗子\" class=\"headerlink\" title=\"举三个栗子\"></a>举三个栗子</h2><h3 id=\"一个简单的请求\"><a href=\"#一个简单的请求\" class=\"headerlink\" title=\"一个简单的请求\"></a>一个简单的请求</h3><p>比如说，假如站点 <code>http://foo.example</code> 的网页应用想要访问 <code>http://bar.other</code> 的资源。以下的 JavaScript 代码应该会在 foo.example 上执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var invocation = new XMLHttpRequest();</span><br><span class=\"line\">var url = &apos;http://bar.other/resources/public-data/&apos;;</span><br><span class=\"line\">   </span><br><span class=\"line\">function callOtherDomain() &#123;</span><br><span class=\"line\">  if(invocation) &#123;    </span><br><span class=\"line\">    invocation.open(&apos;GET&apos;, url, true);</span><br><span class=\"line\">    invocation.onreadystatechange = handler;</span><br><span class=\"line\">    invocation.send(); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /resources/public-data/ HTTP/1.1</span><br><span class=\"line\">Host: bar.other</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\">Accept-Language: en-us,en;q=0.5</span><br><span class=\"line\">Accept-Encoding: gzip,deflate</span><br><span class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Referer: http://foo.example/examples/access-control/simpleXSInvocation.html</span><br><span class=\"line\">Origin: http://foo.example</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Date: Mon, 01 Dec 2008 00:23:53 GMT</span><br><span class=\"line\">Server: Apache/2.0.61 </span><br><span class=\"line\">Access-Control-Allow-Origin: *</span><br><span class=\"line\">Keep-Alive: timeout=2, max=100</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\">Content-Type: application/xml</span><br><span class=\"line\"></span><br><span class=\"line\">[XML Data]</span><br></pre></td></tr></table></figure></p>\n<p>第 1~10 行是 浏览器 发出的请求头。注意看第10行的请求头 Origin，它表明了该请求来自于 <code>http://foo.exmaple</code>。</p>\n<p>第 13~22 行则是 <code>http://bar.other</code> 服务器的响应。如第16行所示，服务器返回了响应头 Access-Control-Allow-Origin: *，这表明服务器接受来自任何站点的跨站请求。如果服务器端仅允许来自 <code>http://foo.example</code> 的跨站请求，它可以返回：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: http://foo.example</span><br></pre></td></tr></table></figure></p>\n<p>现在，除了 <code>http://foo.example</code>，其它站点就不能跨站访问 <code>http://bar.other</code> 的资源了。</p>\n<p>如上，通过使用 Origin 和 Access-Control-Allow-Origin 就可以完成最简单的跨站请求。不过 Access-Control-Allow-Origin 需要为 * 或者包含由 Origin 指明的站点。</p>\n<h3 id=\"预请求-Prefilght\"><a href=\"#预请求-Prefilght\" class=\"headerlink\" title=\"预请求 Prefilght\"></a>预请求 Prefilght</h3><p>不同于上面讨论的简单请求，“预请求”要求必须先发送一个 OPTIONS 请求给目的站点，来查明这个跨站请求对于目的站点是不是安全可接受的。这样做，是因为跨站请求可能会对目的站点的数据造成破坏。 当请求具备以下条件，就会被当成预请求处理：</p>\n<ul>\n<li>请求以 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求。</li>\n<li>使用自定义请求头（比如添加诸如 X-PINGOTHER</li>\n</ul>\n<p>如示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var invocation = new XMLHttpRequest();</span><br><span class=\"line\">var url = &apos;http://bar.other/resources/post-here/&apos;;</span><br><span class=\"line\">var body = &apos;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;Arun&apos;;</span><br><span class=\"line\">    </span><br><span class=\"line\">function callOtherDomain()&#123;</span><br><span class=\"line\">  if(invocation)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      invocation.open(&apos;POST&apos;, url, true);</span><br><span class=\"line\">      invocation.setRequestHeader(&apos;X-PINGOTHER&apos;, &apos;pingpong&apos;);</span><br><span class=\"line\">      invocation.setRequestHeader(&apos;Content-Type&apos;, &apos;application/xml&apos;);</span><br><span class=\"line\">      invocation.onreadystatechange = handler;</span><br><span class=\"line\">      invocation.send(body); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure></p>\n<p>如上，以 XMLHttpRequest 创建了一个 POST 请求，为该请求添加了一个自定义请求头(X-PINGOTHER: pingpong)，并指定数据类型为 application/xml。所以，该请求是一个“预请求”形式的跨站请求。</p>\n<p>让我们看看服务器与浏览器之间具体的交互过程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OPTIONS /resources/post-here/ HTTP/1.1</span><br><span class=\"line\">Host: bar.other</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\">Accept-Language: en-us,en;q=0.5</span><br><span class=\"line\">Accept-Encoding: gzip,deflate</span><br><span class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Origin: http://foo.example</span><br><span class=\"line\">Access-Control-Request-Method: POST</span><br><span class=\"line\">Access-Control-Request-Headers: X-PINGOTHER</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class=\"line\">Server: Apache/2.0.61 (Unix)</span><br><span class=\"line\">Access-Control-Allow-Origin: http://foo.example</span><br><span class=\"line\">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class=\"line\">Access-Control-Allow-Headers: X-PINGOTHER</span><br><span class=\"line\">Access-Control-Max-Age: 1728000</span><br><span class=\"line\">Vary: Accept-Encoding, Origin</span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Length: 0</span><br><span class=\"line\">Keep-Alive: timeout=2, max=100</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\"></span><br><span class=\"line\">POST /resources/post-here/ HTTP/1.1</span><br><span class=\"line\">Host: bar.other</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\">Accept-Language: en-us,en;q=0.5</span><br><span class=\"line\">Accept-Encoding: gzip,deflate</span><br><span class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">X-PINGOTHER: pingpong</span><br><span class=\"line\">Content-Type: text/xml; charset=UTF-8</span><br><span class=\"line\">Referer: http://foo.example/examples/preflightInvocation.html</span><br><span class=\"line\">Content-Length: 55</span><br><span class=\"line\">Origin: http://foo.example</span><br><span class=\"line\">Pragma: no-cache</span><br><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\"></span><br><span class=\"line\">Arun</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Date: Mon, 01 Dec 2008 01:15:40 GMT</span><br><span class=\"line\">Server: Apache/2.0.61 (Unix)</span><br><span class=\"line\">Access-Control-Allow-Origin: http://foo.example</span><br><span class=\"line\">Vary: Accept-Encoding, Origin</span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Length: 235</span><br><span class=\"line\">Keep-Alive: timeout=2, max=99</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\"></span><br><span class=\"line\">[Some GZIP&apos;d payload]</span><br></pre></td></tr></table></figure></p>\n<p>第1至12行，使用一个 OPTIONS 发送了一个“预请求”。浏览器 根据请求参数，决定需要发送一个“预请求”，来探明服务器端是否接受后续真正的请求。 OPTIONS 是 HTTP/1.1 里的方法，用来获取更多服务器端的信息，是一个不应该对服务器数据造成影响的方法。 随同 OPTIONS 请求，以下两个请求头一起被发送：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Request-Method: POST</span><br><span class=\"line\">Access-Control-Request-Headers: X-PINGOTHER</span><br></pre></td></tr></table></figure></p>\n<p>请求头Access-Control-Request-Method可以提醒服务器跨站请求将使用POST方法，而请求头Access-Control-Request-Headers则告知服务器该跨站请求将携带一个自定义请求头X-PINGOTHER。这样，服务器就可以决定，在当前情况下，是否接受该跨站请求访问。</p>\n<p>第15至27行是服务器的响应。该响应表明，服务器接受了客服端的跨站请求。具体可以看看第18至21行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: http://foo.example</span><br><span class=\"line\">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class=\"line\">Access-Control-Allow-Headers: X-PINGOTHER</span><br><span class=\"line\">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure></p>\n<p>响应头Access-Control-Allow-Methods表明服务器可以接受POST, GET和 OPTIONS的请求方法。请注意，这个响应头类似于HTTP/1.1 Allow: response header，但仅限于访问控制的场景下。而响应头Access-Control-Allow-Headers则表示服务器接受自定义请求头X-PINGOTHER。就像Access-Control-Allow-Methods一样，Access-Control-Allow-Headers允许以逗号分隔，传递一个可接受的自定义请求头列表。最后，响应头Access-Control-Max-Age告诉浏览器，本次“预请求”的响应结果有效时间是多久。在上面的例子里，1728000秒代表着20天内，浏览器在处理针对该服务器的跨站请求，都可以无需再发送“预请求”，只需根据本次结果进行判断处理。</p>\n<h3 id=\"附带凭证信息的请求\"><a href=\"#附带凭证信息的请求\" class=\"headerlink\" title=\"附带凭证信息的请求\"></a>附带凭证信息的请求</h3><p>XMLHttpRequest和访问控制功能，最有趣的特性就是，发送凭证请求（HTTP Cookies和验证信息）的功能。一般而言，对于跨站请求，浏览器是不会发送凭证信息的。但如果将XMLHttpRequest的一个特殊标志位设置为true，浏览器就将允许该请求的发送。</p>\n<p><code>http://foo.example</code>站点的脚本向<code>http://bar.other</code>站点发送一个GET请求，并设置了一个Cookies值。脚本代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var invocation = new XMLHttpRequest();</span><br><span class=\"line\">var url = &apos;http://bar.other/resources/credentialed-content/&apos;;</span><br><span class=\"line\">    </span><br><span class=\"line\">function callOtherDomain()&#123;</span><br><span class=\"line\">  if(invocation) &#123;</span><br><span class=\"line\">    invocation.open(&apos;GET&apos;, url, true);</span><br><span class=\"line\">    invocation.withCredentials = true;</span><br><span class=\"line\">    invocation.onreadystatechange = handler;</span><br><span class=\"line\">    invocation.send(); </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>如你所见，第七行代码将XMLHttpRequest的withCredentials标志设置为true，从而使得Cookies可以随着请求发送。因为这是一个简单的GET请求，所以浏览器不会发送一个“预请求”。但是，如果服务器端的响应中，如果没有返回Access-Control-Allow-Credentials: true的响应头，那么浏览器将不会把响应结果传递给发出请求的脚本程序，以保证信息的安全。</p>\n<p>客服端与服务器端交互示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /resources/access-control-with-credentials/ HTTP/1.1</span><br><span class=\"line\">Host: bar.other</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\">Accept-Language: en-us,en;q=0.5</span><br><span class=\"line\">Accept-Encoding: gzip,deflate</span><br><span class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Referer: http://foo.example/examples/credential.html</span><br><span class=\"line\">Origin: http://foo.example</span><br><span class=\"line\">Cookie: pageAccess=2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Date: Mon, 01 Dec 2008 01:34:52 GMT</span><br><span class=\"line\">Server: Apache/2.0.61 (Unix) PHP/4.4.7 mod_ssl/2.0.61 OpenSSL/0.9.7e mod_fastcgi/2.4.2 DAV/2 SVN/1.4.2</span><br><span class=\"line\">X-Powered-By: PHP/5.2.6</span><br><span class=\"line\">Access-Control-Allow-Origin: http://foo.example</span><br><span class=\"line\">Access-Control-Allow-Credentials: true</span><br><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\">Pragma: no-cache</span><br><span class=\"line\">Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT</span><br><span class=\"line\">Vary: Accept-Encoding, Origin</span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Length: 106</span><br><span class=\"line\">Keep-Alive: timeout=2, max=100</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[text/plain payload]</span><br></pre></td></tr></table></figure></p>\n<p>虽然第11行指定了要提交到<code>http://bar.other</code>的内容的Cookie信息,但是如果bar.other的响应头里没有Access-Control-Allow-Credentials:true(第19行),则响应会被忽略. 特别注意: 给一个带有withCredentials的请求发送响应的时候,服务器端必须指定允许请求的域名,不能使用’<em>‘.上面这个例子中,如果响应头是这样的:Access-Control-Allow-Origin: </em> ,则响应会失败. 在这个例子里,因为Access-Control-Allow-Origin的值是<code>http://foo.example</code>这个指定的请求域名,所以客户端把带有凭证信息的内容被返回给了客户端. 另外注意第22行,更多的cookie信息也被创建了</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\" target=\"_blank\" rel=\"external\">Access_control_CORS</a><br><a href=\"https://www.w3.org/TR/cors/\" target=\"_blank\" rel=\"external\">Cross-Origin Resource Sharing Standard</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\" target=\"_blank\" rel=\"external\">Same-origin_policy</a></p>\n","excerpt":"","more":"<h2 id=\"存在即是合理\"><a href=\"#存在即是合理\" class=\"headerlink\" title=\"存在即是合理\"></a>存在即是合理</h2><blockquote>\n<p>首先理解一下「跨站HTTP请求」</p>\n</blockquote>\n<p>跨站HTTP(Cross-Site HTTP Reuqest)请求，是指发起请求的资源所在域不同于该请求所指向资源所在域的HTTP请求。<br>比如说，域名A(<code>http://domaina.example</code>)的某 Web 应用程序中通过<code>&lt;img&gt;</code>标签引入了域名B(<code>http://domainb.foo</code>)站点的某图片资源(<code>http://domainb.foo/image.jpg</code>)，域名A的那 Web 应用就会导致浏览器发起一个跨站 HTTP 请求。<br>在现在的Web开发中，使用跨站HTTP请求加载各类资源(包括CSS、图片、JavaScript脚本以及其他类资源)，已经成为了一种普遍且流行的方式。</p>\n<blockquote>\n<p>出于安全考虑，浏览器会限制脚本中发起的跨站请求</p>\n</blockquote>\n<p>比如，使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest 对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。<br>要注意的是，跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是CSRF跨站攻击原理，请求是发送到了后端服务器无论是否跨域。</p>\n<h2 id=\"理解同源策略\"><a href=\"#理解同源策略\" class=\"headerlink\" title=\"理解同源策略\"></a>理解同源策略</h2><p><a href=\"https://www.w3.org/TR/cors\">Cross-Site Sharing Standard</a> 是W3C推荐的一种机制，让Web应用服务器能支持跨站访问控制，从而使得安全地进行跨站数据传输成为可能。下面截取其中「<a href=\"https://www.w3.org/TR/cors/#syntax\">Syntax</a>」章节，来说明一下请求与响应的规范。</p>\n<blockquote>\n<p>For Response</p>\n</blockquote>\n<h3 id=\"Access-Control-Allow-Origin-Response-Header\"><a href=\"#Access-Control-Allow-Origin-Response-Header\" class=\"headerlink\" title=\"Access-Control-Allow-Origin Response Header\"></a>Access-Control-Allow-Origin Response Header</h3><p>该请求头表示所请求的资源是否接受来自指定origin(根据 Origin Request Header)的请求.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: &lt;origin&gt; | *</span><br></pre></td></tr></table></figure></p>\n<p>举个栗子,允许来自 <a href=\"http://baidu.com\">http://baidu.com</a> 的请求,你可以这样指定:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: http://baidu.com</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Allow-Credentials-Response-Heade\"><a href=\"#Access-Control-Allow-Credentials-Response-Heade\" class=\"headerlink\" title=\"Access-Control-Allow-Credentials Response Heade\"></a>Access-Control-Allow-Credentials Response Heade</h3><p>告知客户端,当请求的credientials属性是true的时候,响应是否可以被得到.当它作为预请求的响应的一部分时,它用来告知实际的请求是否使用了credentials.注意,简单的GET请求不会预检,所以如果一个请求是为了得到一个带有credentials的资源,而响应里又没有Access-Control-Allow-Credentials头信息,那么说明这个响应被忽略了.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Credentials: true | false</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Expose-Headers-Response-Header\"><a href=\"#Access-Control-Expose-Headers-Response-Header\" class=\"headerlink\" title=\"Access-Control-Expose-Headers Response Header\"></a>Access-Control-Expose-Headers Response Header</h3><p>设置浏览器允许访问的服务器响应请求的头信息的白名单:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Expose-Headers: X-A-Custom-Header, X-B-Custom-Header</span><br></pre></td></tr></table></figure></p>\n<p>这样，浏览器就可以得到服务器响应请求的头信息中的<code>X-A-Custom-Header</code>、<code>X-B-Custom-Header</code></p>\n<h3 id=\"Access-Control-Max-Age-Response-Header\"><a href=\"#Access-Control-Max-Age-Response-Header\" class=\"headerlink\" title=\"Access-Control-Max-Age Response Header\"></a>Access-Control-Max-Age Response Header</h3><p>这个头告诉我们这次预请求的结果的有效期是多久：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Max-Age: &lt;delta-seconds&gt;</span><br></pre></td></tr></table></figure></p>\n<p><code>delta-seconds</code> 参数表示,允许这个预请求的参数缓存的秒数,在此期间,不用发出另一条预检请求. </p>\n<h3 id=\"Access-Control-Allow-Methods-Response-Header\"><a href=\"#Access-Control-Allow-Methods-Response-Header\" class=\"headerlink\" title=\"Access-Control-Allow-Methods Response Header\"></a>Access-Control-Allow-Methods Response Header</h3><p>指明资源可以被请求的方式有哪些(一个或者多个). 这个响应头信息在客户端发出预检请求的时候会被返回.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Allow-Headers-Response-Header\"><a href=\"#Access-Control-Allow-Headers-Response-Header\" class=\"headerlink\" title=\"Access-Control-Allow-Headers Response Header\"></a>Access-Control-Allow-Headers Response Header</h3><p>也是在响应预检请求的时候使用.用来指明在实际的请求中,可以使用哪些自定义HTTP请求头.比如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Headers: X-Custom-Header</span><br></pre></td></tr></table></figure></p>\n<p>这样在实际的请求里,请求头信息里就可以有这么一条:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X-Custom-Header: hello world</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>For Request</p>\n</blockquote>\n<h3 id=\"Origin-Request-Header\"><a href=\"#Origin-Request-Header\" class=\"headerlink\" title=\"Origin Request Header\"></a>Origin Request Header</h3><p>表明发送请求或者预请求的域<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Origin: &lt;origin&gt;</span><br></pre></td></tr></table></figure></p>\n<p>参数<code>origin</code>是一个URI,告诉服务器端,请求来自哪里.它不包含任何路径信息,只是服务器名.</p>\n<h3 id=\"Access-Control-Request-Method-Request-Header\"><a href=\"#Access-Control-Request-Method-Request-Header\" class=\"headerlink\" title=\"Access-Control-Request-Method Request Header\"></a>Access-Control-Request-Method Request Header</h3><p>在发出预检请求时带有这个头信息,告诉服务器在实际请求时会使用的请求方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Request-Method: &lt;method&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Request-Headers\"><a href=\"#Access-Control-Request-Headers\" class=\"headerlink\" title=\"Access-Control-Request-Headers\"></a>Access-Control-Request-Headers</h3><p>在发出预检请求时带有这个头信息,告诉服务器在实际请求时会携带的自定义头信息.如有多个,可以用逗号分开.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"举三个栗子\"><a href=\"#举三个栗子\" class=\"headerlink\" title=\"举三个栗子\"></a>举三个栗子</h2><h3 id=\"一个简单的请求\"><a href=\"#一个简单的请求\" class=\"headerlink\" title=\"一个简单的请求\"></a>一个简单的请求</h3><p>比如说，假如站点 <code>http://foo.example</code> 的网页应用想要访问 <code>http://bar.other</code> 的资源。以下的 JavaScript 代码应该会在 foo.example 上执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var invocation = new XMLHttpRequest();</span><br><span class=\"line\">var url = &apos;http://bar.other/resources/public-data/&apos;;</span><br><span class=\"line\">   </span><br><span class=\"line\">function callOtherDomain() &#123;</span><br><span class=\"line\">  if(invocation) &#123;    </span><br><span class=\"line\">    invocation.open(&apos;GET&apos;, url, true);</span><br><span class=\"line\">    invocation.onreadystatechange = handler;</span><br><span class=\"line\">    invocation.send(); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /resources/public-data/ HTTP/1.1</span><br><span class=\"line\">Host: bar.other</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\">Accept-Language: en-us,en;q=0.5</span><br><span class=\"line\">Accept-Encoding: gzip,deflate</span><br><span class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Referer: http://foo.example/examples/access-control/simpleXSInvocation.html</span><br><span class=\"line\">Origin: http://foo.example</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Date: Mon, 01 Dec 2008 00:23:53 GMT</span><br><span class=\"line\">Server: Apache/2.0.61 </span><br><span class=\"line\">Access-Control-Allow-Origin: *</span><br><span class=\"line\">Keep-Alive: timeout=2, max=100</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\">Content-Type: application/xml</span><br><span class=\"line\"></span><br><span class=\"line\">[XML Data]</span><br></pre></td></tr></table></figure></p>\n<p>第 1~10 行是 浏览器 发出的请求头。注意看第10行的请求头 Origin，它表明了该请求来自于 <code>http://foo.exmaple</code>。</p>\n<p>第 13~22 行则是 <code>http://bar.other</code> 服务器的响应。如第16行所示，服务器返回了响应头 Access-Control-Allow-Origin: *，这表明服务器接受来自任何站点的跨站请求。如果服务器端仅允许来自 <code>http://foo.example</code> 的跨站请求，它可以返回：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: http://foo.example</span><br></pre></td></tr></table></figure></p>\n<p>现在，除了 <code>http://foo.example</code>，其它站点就不能跨站访问 <code>http://bar.other</code> 的资源了。</p>\n<p>如上，通过使用 Origin 和 Access-Control-Allow-Origin 就可以完成最简单的跨站请求。不过 Access-Control-Allow-Origin 需要为 * 或者包含由 Origin 指明的站点。</p>\n<h3 id=\"预请求-Prefilght\"><a href=\"#预请求-Prefilght\" class=\"headerlink\" title=\"预请求 Prefilght\"></a>预请求 Prefilght</h3><p>不同于上面讨论的简单请求，“预请求”要求必须先发送一个 OPTIONS 请求给目的站点，来查明这个跨站请求对于目的站点是不是安全可接受的。这样做，是因为跨站请求可能会对目的站点的数据造成破坏。 当请求具备以下条件，就会被当成预请求处理：</p>\n<ul>\n<li>请求以 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求。</li>\n<li>使用自定义请求头（比如添加诸如 X-PINGOTHER</li>\n</ul>\n<p>如示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var invocation = new XMLHttpRequest();</span><br><span class=\"line\">var url = &apos;http://bar.other/resources/post-here/&apos;;</span><br><span class=\"line\">var body = &apos;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;Arun&apos;;</span><br><span class=\"line\">    </span><br><span class=\"line\">function callOtherDomain()&#123;</span><br><span class=\"line\">  if(invocation)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      invocation.open(&apos;POST&apos;, url, true);</span><br><span class=\"line\">      invocation.setRequestHeader(&apos;X-PINGOTHER&apos;, &apos;pingpong&apos;);</span><br><span class=\"line\">      invocation.setRequestHeader(&apos;Content-Type&apos;, &apos;application/xml&apos;);</span><br><span class=\"line\">      invocation.onreadystatechange = handler;</span><br><span class=\"line\">      invocation.send(body); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure></p>\n<p>如上，以 XMLHttpRequest 创建了一个 POST 请求，为该请求添加了一个自定义请求头(X-PINGOTHER: pingpong)，并指定数据类型为 application/xml。所以，该请求是一个“预请求”形式的跨站请求。</p>\n<p>让我们看看服务器与浏览器之间具体的交互过程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OPTIONS /resources/post-here/ HTTP/1.1</span><br><span class=\"line\">Host: bar.other</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\">Accept-Language: en-us,en;q=0.5</span><br><span class=\"line\">Accept-Encoding: gzip,deflate</span><br><span class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Origin: http://foo.example</span><br><span class=\"line\">Access-Control-Request-Method: POST</span><br><span class=\"line\">Access-Control-Request-Headers: X-PINGOTHER</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class=\"line\">Server: Apache/2.0.61 (Unix)</span><br><span class=\"line\">Access-Control-Allow-Origin: http://foo.example</span><br><span class=\"line\">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class=\"line\">Access-Control-Allow-Headers: X-PINGOTHER</span><br><span class=\"line\">Access-Control-Max-Age: 1728000</span><br><span class=\"line\">Vary: Accept-Encoding, Origin</span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Length: 0</span><br><span class=\"line\">Keep-Alive: timeout=2, max=100</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\"></span><br><span class=\"line\">POST /resources/post-here/ HTTP/1.1</span><br><span class=\"line\">Host: bar.other</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\">Accept-Language: en-us,en;q=0.5</span><br><span class=\"line\">Accept-Encoding: gzip,deflate</span><br><span class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">X-PINGOTHER: pingpong</span><br><span class=\"line\">Content-Type: text/xml; charset=UTF-8</span><br><span class=\"line\">Referer: http://foo.example/examples/preflightInvocation.html</span><br><span class=\"line\">Content-Length: 55</span><br><span class=\"line\">Origin: http://foo.example</span><br><span class=\"line\">Pragma: no-cache</span><br><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\"></span><br><span class=\"line\">Arun</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Date: Mon, 01 Dec 2008 01:15:40 GMT</span><br><span class=\"line\">Server: Apache/2.0.61 (Unix)</span><br><span class=\"line\">Access-Control-Allow-Origin: http://foo.example</span><br><span class=\"line\">Vary: Accept-Encoding, Origin</span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Length: 235</span><br><span class=\"line\">Keep-Alive: timeout=2, max=99</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\"></span><br><span class=\"line\">[Some GZIP&apos;d payload]</span><br></pre></td></tr></table></figure></p>\n<p>第1至12行，使用一个 OPTIONS 发送了一个“预请求”。浏览器 根据请求参数，决定需要发送一个“预请求”，来探明服务器端是否接受后续真正的请求。 OPTIONS 是 HTTP/1.1 里的方法，用来获取更多服务器端的信息，是一个不应该对服务器数据造成影响的方法。 随同 OPTIONS 请求，以下两个请求头一起被发送：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Request-Method: POST</span><br><span class=\"line\">Access-Control-Request-Headers: X-PINGOTHER</span><br></pre></td></tr></table></figure></p>\n<p>请求头Access-Control-Request-Method可以提醒服务器跨站请求将使用POST方法，而请求头Access-Control-Request-Headers则告知服务器该跨站请求将携带一个自定义请求头X-PINGOTHER。这样，服务器就可以决定，在当前情况下，是否接受该跨站请求访问。</p>\n<p>第15至27行是服务器的响应。该响应表明，服务器接受了客服端的跨站请求。具体可以看看第18至21行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: http://foo.example</span><br><span class=\"line\">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class=\"line\">Access-Control-Allow-Headers: X-PINGOTHER</span><br><span class=\"line\">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure></p>\n<p>响应头Access-Control-Allow-Methods表明服务器可以接受POST, GET和 OPTIONS的请求方法。请注意，这个响应头类似于HTTP/1.1 Allow: response header，但仅限于访问控制的场景下。而响应头Access-Control-Allow-Headers则表示服务器接受自定义请求头X-PINGOTHER。就像Access-Control-Allow-Methods一样，Access-Control-Allow-Headers允许以逗号分隔，传递一个可接受的自定义请求头列表。最后，响应头Access-Control-Max-Age告诉浏览器，本次“预请求”的响应结果有效时间是多久。在上面的例子里，1728000秒代表着20天内，浏览器在处理针对该服务器的跨站请求，都可以无需再发送“预请求”，只需根据本次结果进行判断处理。</p>\n<h3 id=\"附带凭证信息的请求\"><a href=\"#附带凭证信息的请求\" class=\"headerlink\" title=\"附带凭证信息的请求\"></a>附带凭证信息的请求</h3><p>XMLHttpRequest和访问控制功能，最有趣的特性就是，发送凭证请求（HTTP Cookies和验证信息）的功能。一般而言，对于跨站请求，浏览器是不会发送凭证信息的。但如果将XMLHttpRequest的一个特殊标志位设置为true，浏览器就将允许该请求的发送。</p>\n<p><code>http://foo.example</code>站点的脚本向<code>http://bar.other</code>站点发送一个GET请求，并设置了一个Cookies值。脚本代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var invocation = new XMLHttpRequest();</span><br><span class=\"line\">var url = &apos;http://bar.other/resources/credentialed-content/&apos;;</span><br><span class=\"line\">    </span><br><span class=\"line\">function callOtherDomain()&#123;</span><br><span class=\"line\">  if(invocation) &#123;</span><br><span class=\"line\">    invocation.open(&apos;GET&apos;, url, true);</span><br><span class=\"line\">    invocation.withCredentials = true;</span><br><span class=\"line\">    invocation.onreadystatechange = handler;</span><br><span class=\"line\">    invocation.send(); </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>如你所见，第七行代码将XMLHttpRequest的withCredentials标志设置为true，从而使得Cookies可以随着请求发送。因为这是一个简单的GET请求，所以浏览器不会发送一个“预请求”。但是，如果服务器端的响应中，如果没有返回Access-Control-Allow-Credentials: true的响应头，那么浏览器将不会把响应结果传递给发出请求的脚本程序，以保证信息的安全。</p>\n<p>客服端与服务器端交互示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /resources/access-control-with-credentials/ HTTP/1.1</span><br><span class=\"line\">Host: bar.other</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\">Accept-Language: en-us,en;q=0.5</span><br><span class=\"line\">Accept-Encoding: gzip,deflate</span><br><span class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Referer: http://foo.example/examples/credential.html</span><br><span class=\"line\">Origin: http://foo.example</span><br><span class=\"line\">Cookie: pageAccess=2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Date: Mon, 01 Dec 2008 01:34:52 GMT</span><br><span class=\"line\">Server: Apache/2.0.61 (Unix) PHP/4.4.7 mod_ssl/2.0.61 OpenSSL/0.9.7e mod_fastcgi/2.4.2 DAV/2 SVN/1.4.2</span><br><span class=\"line\">X-Powered-By: PHP/5.2.6</span><br><span class=\"line\">Access-Control-Allow-Origin: http://foo.example</span><br><span class=\"line\">Access-Control-Allow-Credentials: true</span><br><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\">Pragma: no-cache</span><br><span class=\"line\">Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT</span><br><span class=\"line\">Vary: Accept-Encoding, Origin</span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Length: 106</span><br><span class=\"line\">Keep-Alive: timeout=2, max=100</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[text/plain payload]</span><br></pre></td></tr></table></figure></p>\n<p>虽然第11行指定了要提交到<code>http://bar.other</code>的内容的Cookie信息,但是如果bar.other的响应头里没有Access-Control-Allow-Credentials:true(第19行),则响应会被忽略. 特别注意: 给一个带有withCredentials的请求发送响应的时候,服务器端必须指定允许请求的域名,不能使用’<em>‘.上面这个例子中,如果响应头是这样的:Access-Control-Allow-Origin: </em> ,则响应会失败. 在这个例子里,因为Access-Control-Allow-Origin的值是<code>http://foo.example</code>这个指定的请求域名,所以客户端把带有凭证信息的内容被返回给了客户端. 另外注意第22行,更多的cookie信息也被创建了</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\">Access_control_CORS</a><br><a href=\"https://www.w3.org/TR/cors/\">Cross-Origin Resource Sharing Standard</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\">Same-origin_policy</a></p>\n"},{"title":"消息系统设计与实现「下篇」","date":"2015-11-15T10:16:55.000Z","_content":"\n\n## 模型设计\n\n### Notify\n```javascript\nid\t\t\t: {type: 'integer', primaryKey: true},\t\t// 主键\ncontent     : {type: 'text'},\t// 消息的内容\ntype        : {type: 'integer', required: true, enum: [1, 2, 3]},  // 消息的类型，1: 公告 Announce，2: 提醒 Remind，3：信息 Message\ntarget      : {type: 'integer'},    // 目标的ID\ntargetType  : {type: 'string'},    // 目标的类型\naction      : {type: 'string'},    // 提醒信息的动作类型\nsender      : {type: 'integer'},    // 发送者的ID\ncreatedAt\t: {type: 'datetime', required: true}\n```\n\n**Save Remind**\n消息表，我们需要`target`、`targetType`字段，来记录该条提醒所关联的对象。而`action`字段，则记录该条提醒所关联的动作。\n比如消息：「小明喜欢了文章」\n则：\n```javascript\ntarget = 123,  // 文章ID\ntargetType = 'post',  // 指明target所属类型是文章\nsender = 123456  // 小明ID\n```\n\n**Save Announce and Message**\n当然，Notify还支持存储公告和信息。它们会用到`content`字段，而不会用到`target`、`targetType`、`action`字段。\n\n### UserNotify\n```javascript\nid\t\t\t: {type: 'integer', primaryKey: true},\t\t// 主键\nisRead      : {type: 'boolean', required: true},   \nuser        : {type: 'integer', required: true},  // 用户消息所属者\nnotify      : {type: 'integer', required: true}   // 关联的Notify\ncreatedAt\t: {type: 'datetime', required: true}\n```\n\n我们用UserNotify来存储用户的消息队列，它关联一则提醒(Notify)的具体内容。\nUserNotify的创建，主要通过两个途径：\n1. 遍历订阅(Subscription)表拉取公告(Announce)和提醒(Remind)的时候创建\n2. 新建信息(Message)之后，立刻创建。\n\n### Subscription\n```javascript\ntarget      : {type: 'integer', required: true},    // 目标的ID\ntargetType  : {type: 'string', required: true},    // 目标的类型\naction      : {type: 'string'},   // 订阅动作,如: comment/like/post/update etc.\nuser        : {type: 'integer'}，\ncreatedAt\t: {type: 'datetime', required: true}\n```\n订阅，是从Notify表拉取消息到UserNotify的前提，用户首先订阅了某一个目标的某一个动作，在此之后产生这个目标的这个动作的消息，才会被通知到该用户。\n如：「小明关注了产品A的评论」，数据表现为：\n```javascript\ntarget: 123,  // 产品A的ID\ntargetType: 'product',\naction: 'comment',\nuser: 123  // 小明的ID\n```\n这样，产品A下产生的每一条评论，都会产生通知给小明了。\n\n### SubscriptionConfig\n```javascript\naction: {type: 'json', required: true},   // 用户的设置\nuser: {type: 'integer'}\n```\n不同用户可能会有不一样的订阅习惯，在这个表中，用户可以统一针对某种动作进行是否订阅的设置。而默认是使用系统提供的默认配置：\n```javascript\ndefaultSubscriptionConfig: {\n  'comment'   : true,    // 评论\n  'like'      : true,    // 喜欢\n}\n```\n\n> 在这套模型中，`targetType`、`action`是可以根据需求来扩展的，例如我们还可以增加多几个动作的提醒：`hate`被踩、`update`被更新....诸如此类。\n\n## 配置文件 NotifyConfig\n```javascript\n// 提醒关联的目标类型\ntargetType: {\n  PRODUCT : 'product',    // 产品\n  POST    : 'post'    // 文章\n},\n\n// 提醒关联的动作\naction: {\n  COMMENT   : 'comment',  // 评论\n  LIKE      : 'like',     // 喜欢\n},\n\n// 订阅原因对应订阅事件\nreasonAction: {\n  'create_product'  : ['comment', 'like']\n  'like_product'    : ['comment'],\n  'like_post'       : ['comment'],\n},\n\n// 默认订阅配置\ndefaultSubscriptionConfig: {\n  'comment'   : true,    // 评论\n  'like'      : true,    // 喜欢\n}\n```\n\n## 服务层 NotifyService\n#### NotifyService拥有以下方法:\n* createAnnounce(content, sender)\n* createRemind(target, targetType, action, sender, content)\n* createMessage(content, sender, receiver)\n* pullAnnounce(user)\n* pullRemind(user)\n* subscribe(user, target, targetType, reason)\n* cancelSubscription(user, target ,targetType)\n* getSubscriptionConfig(userID)\n* updateSubscriptionConfig(userID)\n* getUserNotify(userID)\n* read(user, notifyIDs)\n\n#### 各方法的处理逻辑如下：\n**createAnnounce(content, sender)**\n1. 往Notify表中插入一条公告记录\n\n**createRemind(target, targetType, action, sender, content)**\n1. 往Notify表中插入一条提醒记录\n\n**createMessage(content, sender, receiver)**\n1. 往Notify表中插入一条信息记录\n2. 往UserNotify表中插入一条记录，并关联新建的Notify\n\n**pullAnnounce(user)**\n1. 从UserNotify中获取最近的一条公告信息的创建时间: `lastTime`\n2. 用`lastTime`作为过滤条件，查询Notify的公告信息\n3. 新建UserNotify并关联查询出来的公告信息\n\n**pullRemind(user)**\n1. 查询用户的订阅表，得到用户的一系列订阅记录\n2. 通过每一条的订阅记录的`target`、`targetType`、`action`、`createdAt`去查询Notify表，获取订阅的Notify记录。（注意订阅时间必须早于提醒创建时间）\n3. 查询用户的配置文件SubscriptionConfig，如果没有则使用默认的配置DefaultSubscriptionConfig\n4. 使用订阅配置，过滤查询出来的Notify\n5. 使用过滤好的Notify作为关联新建UserNotify\n\n**subscribe(user, target, targetType, reason)**\n1. 通过reason，查询NotifyConfig，获取对应的动作组:`actions`\n2. 遍历动作组，每一个动作新建一则Subscription记录\n\n**cancelSubscription(user, target ,targetType)**\n1. 删除`user`、`target`、`targetType`对应的一则或多则记录\n\n**getSubscriptionConfig(userID)**\n1. 查询SubscriptionConfig表，获取用户的订阅配置\n\n**updateSubscriptionConfig(userID)**\n1. 更新用户的SubscriptionConfig记录\n\n**getUserNotify(userID)**\n1. 获取用户的消息列表\n\n**read(user, notifyIDs)**\n1. 更新指定的notify，把isRead属性设置为true\n\n## 时序图\n### 提醒的订阅、创建、拉取\n![提醒的订阅、创建、拉取](//dn-cnode.qbox.me/FrvQvJn3YzSnYjlGTaBkhZ-PdZtZ)\n\n我们可以在产品创建之后，调用`NotifyService.subscribe`方法，\n然后在产品被评论之后调用`NotifyService.createRemind`方法，\n再就是用户登录系统或者其他的某一个时刻调用`NotifyService.pullRemind`方法，\n最后在用户查询消息队列的时候调用`NotifyService.getUserNotify`方法。\n\n\n### 公告的创建、拉取\n![公告的创建、拉取](//dn-cnode.qbox.me/FiTeODLU97C8VG6V-rRQwgZYS8ff)\n\n在管理员发送了一则公告的时候，调用`NotifyService.createAnnounce`方法，\n然后在用户登录系统或者其他的某一个时刻调用`NotifyService.pullAnnounce`方法，\n最后在用户查询消息队列的时候调用`NotifyService.getUserNotify`方法。\n\n### 信息的创建\n![信息的创建](//dn-cnode.qbox.me/Fjvq4egEZcMeoynkUUURWKgGP9KF)\n信息的创建，只需要直接调用`NotifyService.createMessage`方法就可以了，\n在下一次用户查询消息队列的时候，就会查询这条信息。\n","source":"_posts/消息系统设计与实现「下篇」.md","raw":"---\ntitle: 消息系统设计与实现「下篇」\ncategory: 搬砖码农\ndate: 2015-11-15 18:16:55\ntags:\n- 架构\n- 消息系统\n---\n\n\n## 模型设计\n\n### Notify\n```javascript\nid\t\t\t: {type: 'integer', primaryKey: true},\t\t// 主键\ncontent     : {type: 'text'},\t// 消息的内容\ntype        : {type: 'integer', required: true, enum: [1, 2, 3]},  // 消息的类型，1: 公告 Announce，2: 提醒 Remind，3：信息 Message\ntarget      : {type: 'integer'},    // 目标的ID\ntargetType  : {type: 'string'},    // 目标的类型\naction      : {type: 'string'},    // 提醒信息的动作类型\nsender      : {type: 'integer'},    // 发送者的ID\ncreatedAt\t: {type: 'datetime', required: true}\n```\n\n**Save Remind**\n消息表，我们需要`target`、`targetType`字段，来记录该条提醒所关联的对象。而`action`字段，则记录该条提醒所关联的动作。\n比如消息：「小明喜欢了文章」\n则：\n```javascript\ntarget = 123,  // 文章ID\ntargetType = 'post',  // 指明target所属类型是文章\nsender = 123456  // 小明ID\n```\n\n**Save Announce and Message**\n当然，Notify还支持存储公告和信息。它们会用到`content`字段，而不会用到`target`、`targetType`、`action`字段。\n\n### UserNotify\n```javascript\nid\t\t\t: {type: 'integer', primaryKey: true},\t\t// 主键\nisRead      : {type: 'boolean', required: true},   \nuser        : {type: 'integer', required: true},  // 用户消息所属者\nnotify      : {type: 'integer', required: true}   // 关联的Notify\ncreatedAt\t: {type: 'datetime', required: true}\n```\n\n我们用UserNotify来存储用户的消息队列，它关联一则提醒(Notify)的具体内容。\nUserNotify的创建，主要通过两个途径：\n1. 遍历订阅(Subscription)表拉取公告(Announce)和提醒(Remind)的时候创建\n2. 新建信息(Message)之后，立刻创建。\n\n### Subscription\n```javascript\ntarget      : {type: 'integer', required: true},    // 目标的ID\ntargetType  : {type: 'string', required: true},    // 目标的类型\naction      : {type: 'string'},   // 订阅动作,如: comment/like/post/update etc.\nuser        : {type: 'integer'}，\ncreatedAt\t: {type: 'datetime', required: true}\n```\n订阅，是从Notify表拉取消息到UserNotify的前提，用户首先订阅了某一个目标的某一个动作，在此之后产生这个目标的这个动作的消息，才会被通知到该用户。\n如：「小明关注了产品A的评论」，数据表现为：\n```javascript\ntarget: 123,  // 产品A的ID\ntargetType: 'product',\naction: 'comment',\nuser: 123  // 小明的ID\n```\n这样，产品A下产生的每一条评论，都会产生通知给小明了。\n\n### SubscriptionConfig\n```javascript\naction: {type: 'json', required: true},   // 用户的设置\nuser: {type: 'integer'}\n```\n不同用户可能会有不一样的订阅习惯，在这个表中，用户可以统一针对某种动作进行是否订阅的设置。而默认是使用系统提供的默认配置：\n```javascript\ndefaultSubscriptionConfig: {\n  'comment'   : true,    // 评论\n  'like'      : true,    // 喜欢\n}\n```\n\n> 在这套模型中，`targetType`、`action`是可以根据需求来扩展的，例如我们还可以增加多几个动作的提醒：`hate`被踩、`update`被更新....诸如此类。\n\n## 配置文件 NotifyConfig\n```javascript\n// 提醒关联的目标类型\ntargetType: {\n  PRODUCT : 'product',    // 产品\n  POST    : 'post'    // 文章\n},\n\n// 提醒关联的动作\naction: {\n  COMMENT   : 'comment',  // 评论\n  LIKE      : 'like',     // 喜欢\n},\n\n// 订阅原因对应订阅事件\nreasonAction: {\n  'create_product'  : ['comment', 'like']\n  'like_product'    : ['comment'],\n  'like_post'       : ['comment'],\n},\n\n// 默认订阅配置\ndefaultSubscriptionConfig: {\n  'comment'   : true,    // 评论\n  'like'      : true,    // 喜欢\n}\n```\n\n## 服务层 NotifyService\n#### NotifyService拥有以下方法:\n* createAnnounce(content, sender)\n* createRemind(target, targetType, action, sender, content)\n* createMessage(content, sender, receiver)\n* pullAnnounce(user)\n* pullRemind(user)\n* subscribe(user, target, targetType, reason)\n* cancelSubscription(user, target ,targetType)\n* getSubscriptionConfig(userID)\n* updateSubscriptionConfig(userID)\n* getUserNotify(userID)\n* read(user, notifyIDs)\n\n#### 各方法的处理逻辑如下：\n**createAnnounce(content, sender)**\n1. 往Notify表中插入一条公告记录\n\n**createRemind(target, targetType, action, sender, content)**\n1. 往Notify表中插入一条提醒记录\n\n**createMessage(content, sender, receiver)**\n1. 往Notify表中插入一条信息记录\n2. 往UserNotify表中插入一条记录，并关联新建的Notify\n\n**pullAnnounce(user)**\n1. 从UserNotify中获取最近的一条公告信息的创建时间: `lastTime`\n2. 用`lastTime`作为过滤条件，查询Notify的公告信息\n3. 新建UserNotify并关联查询出来的公告信息\n\n**pullRemind(user)**\n1. 查询用户的订阅表，得到用户的一系列订阅记录\n2. 通过每一条的订阅记录的`target`、`targetType`、`action`、`createdAt`去查询Notify表，获取订阅的Notify记录。（注意订阅时间必须早于提醒创建时间）\n3. 查询用户的配置文件SubscriptionConfig，如果没有则使用默认的配置DefaultSubscriptionConfig\n4. 使用订阅配置，过滤查询出来的Notify\n5. 使用过滤好的Notify作为关联新建UserNotify\n\n**subscribe(user, target, targetType, reason)**\n1. 通过reason，查询NotifyConfig，获取对应的动作组:`actions`\n2. 遍历动作组，每一个动作新建一则Subscription记录\n\n**cancelSubscription(user, target ,targetType)**\n1. 删除`user`、`target`、`targetType`对应的一则或多则记录\n\n**getSubscriptionConfig(userID)**\n1. 查询SubscriptionConfig表，获取用户的订阅配置\n\n**updateSubscriptionConfig(userID)**\n1. 更新用户的SubscriptionConfig记录\n\n**getUserNotify(userID)**\n1. 获取用户的消息列表\n\n**read(user, notifyIDs)**\n1. 更新指定的notify，把isRead属性设置为true\n\n## 时序图\n### 提醒的订阅、创建、拉取\n![提醒的订阅、创建、拉取](//dn-cnode.qbox.me/FrvQvJn3YzSnYjlGTaBkhZ-PdZtZ)\n\n我们可以在产品创建之后，调用`NotifyService.subscribe`方法，\n然后在产品被评论之后调用`NotifyService.createRemind`方法，\n再就是用户登录系统或者其他的某一个时刻调用`NotifyService.pullRemind`方法，\n最后在用户查询消息队列的时候调用`NotifyService.getUserNotify`方法。\n\n\n### 公告的创建、拉取\n![公告的创建、拉取](//dn-cnode.qbox.me/FiTeODLU97C8VG6V-rRQwgZYS8ff)\n\n在管理员发送了一则公告的时候，调用`NotifyService.createAnnounce`方法，\n然后在用户登录系统或者其他的某一个时刻调用`NotifyService.pullAnnounce`方法，\n最后在用户查询消息队列的时候调用`NotifyService.getUserNotify`方法。\n\n### 信息的创建\n![信息的创建](//dn-cnode.qbox.me/Fjvq4egEZcMeoynkUUURWKgGP9KF)\n信息的创建，只需要直接调用`NotifyService.createMessage`方法就可以了，\n在下一次用户查询消息队列的时候，就会查询这条信息。\n","slug":"消息系统设计与实现「下篇」","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8r80018xwrlajsnpdzf","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"模型设计\"><a href=\"#模型设计\" class=\"headerlink\" title=\"模型设计\"></a>模型设计</h2><h3 id=\"Notify\"><a href=\"#Notify\" class=\"headerlink\" title=\"Notify\"></a>Notify</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id\t\t\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">primaryKey</span>: <span class=\"literal\">true</span>&#125;,\t\t<span class=\"comment\">// 主键</span></span><br><span class=\"line\">content     : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'text'</span>&#125;,\t<span class=\"comment\">// 消息的内容</span></span><br><span class=\"line\">type        : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>, <span class=\"attr\">enum</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]&#125;,  <span class=\"comment\">// 消息的类型，1: 公告 Announce，2: 提醒 Remind，3：信息 Message</span></span><br><span class=\"line\">target      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;,    <span class=\"comment\">// 目标的ID</span></span><br><span class=\"line\">targetType  : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>&#125;,    <span class=\"comment\">// 目标的类型</span></span><br><span class=\"line\">action      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>&#125;,    <span class=\"comment\">// 提醒信息的动作类型</span></span><br><span class=\"line\">sender      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;,    <span class=\"comment\">// 发送者的ID</span></span><br><span class=\"line\">createdAt\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'datetime'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Save Remind</strong><br>消息表，我们需要<code>target</code>、<code>targetType</code>字段，来记录该条提醒所关联的对象。而<code>action</code>字段，则记录该条提醒所关联的动作。<br>比如消息：「小明喜欢了文章」<br>则：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = <span class=\"number\">123</span>,  <span class=\"comment\">// 文章ID</span></span><br><span class=\"line\">targetType = <span class=\"string\">'post'</span>,  <span class=\"comment\">// 指明target所属类型是文章</span></span><br><span class=\"line\">sender = <span class=\"number\">123456</span>  <span class=\"comment\">// 小明ID</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>Save Announce and Message</strong><br>当然，Notify还支持存储公告和信息。它们会用到<code>content</code>字段，而不会用到<code>target</code>、<code>targetType</code>、<code>action</code>字段。</p>\n<h3 id=\"UserNotify\"><a href=\"#UserNotify\" class=\"headerlink\" title=\"UserNotify\"></a>UserNotify</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id\t\t\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">primaryKey</span>: <span class=\"literal\">true</span>&#125;,\t\t<span class=\"comment\">// 主键</span></span><br><span class=\"line\">isRead      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'boolean'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,   </span><br><span class=\"line\">user        : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,  <span class=\"comment\">// 用户消息所属者</span></span><br><span class=\"line\">notify      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;   <span class=\"comment\">// 关联的Notify</span></span><br><span class=\"line\">createdAt\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'datetime'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>我们用UserNotify来存储用户的消息队列，它关联一则提醒(Notify)的具体内容。<br>UserNotify的创建，主要通过两个途径：</p>\n<ol>\n<li>遍历订阅(Subscription)表拉取公告(Announce)和提醒(Remind)的时候创建</li>\n<li>新建信息(Message)之后，立刻创建。</li>\n</ol>\n<h3 id=\"Subscription\"><a href=\"#Subscription\" class=\"headerlink\" title=\"Subscription\"></a>Subscription</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,    <span class=\"comment\">// 目标的ID</span></span><br><span class=\"line\">targetType  : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,    <span class=\"comment\">// 目标的类型</span></span><br><span class=\"line\">action      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>&#125;,   <span class=\"comment\">// 订阅动作,如: comment/like/post/update etc.</span></span><br><span class=\"line\">user        : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;，</span><br><span class=\"line\">createdAt\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'datetime'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>订阅，是从Notify表拉取消息到UserNotify的前提，用户首先订阅了某一个目标的某一个动作，在此之后产生这个目标的这个动作的消息，才会被通知到该用户。<br>如：「小明关注了产品A的评论」，数据表现为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target: <span class=\"number\">123</span>,  <span class=\"comment\">// 产品A的ID</span></span><br><span class=\"line\">targetType: <span class=\"string\">'product'</span>,</span><br><span class=\"line\">action: <span class=\"string\">'comment'</span>,</span><br><span class=\"line\">user: <span class=\"number\">123</span>  <span class=\"comment\">// 小明的ID</span></span><br></pre></td></tr></table></figure></p>\n<p>这样，产品A下产生的每一条评论，都会产生通知给小明了。</p>\n<h3 id=\"SubscriptionConfig\"><a href=\"#SubscriptionConfig\" class=\"headerlink\" title=\"SubscriptionConfig\"></a>SubscriptionConfig</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">action: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'json'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,   <span class=\"comment\">// 用户的设置</span></span><br><span class=\"line\">user: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>不同用户可能会有不一样的订阅习惯，在这个表中，用户可以统一针对某种动作进行是否订阅的设置。而默认是使用系统提供的默认配置：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaultSubscriptionConfig: &#123;</span><br><span class=\"line\">  <span class=\"string\">'comment'</span>   : <span class=\"literal\">true</span>,    <span class=\"comment\">// 评论</span></span><br><span class=\"line\">  <span class=\"string\">'like'</span>      : <span class=\"literal\">true</span>,    <span class=\"comment\">// 喜欢</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在这套模型中，<code>targetType</code>、<code>action</code>是可以根据需求来扩展的，例如我们还可以增加多几个动作的提醒：<code>hate</code>被踩、<code>update</code>被更新….诸如此类。</p>\n</blockquote>\n<h2 id=\"配置文件-NotifyConfig\"><a href=\"#配置文件-NotifyConfig\" class=\"headerlink\" title=\"配置文件 NotifyConfig\"></a>配置文件 NotifyConfig</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 提醒关联的目标类型</span></span><br><span class=\"line\">targetType: &#123;</span><br><span class=\"line\">  PRODUCT : <span class=\"string\">'product'</span>,    <span class=\"comment\">// 产品</span></span><br><span class=\"line\">  POST    : <span class=\"string\">'post'</span>    <span class=\"comment\">// 文章</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提醒关联的动作</span></span><br><span class=\"line\">action: &#123;</span><br><span class=\"line\">  COMMENT   : <span class=\"string\">'comment'</span>,  <span class=\"comment\">// 评论</span></span><br><span class=\"line\">  LIKE      : <span class=\"string\">'like'</span>,     <span class=\"comment\">// 喜欢</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 订阅原因对应订阅事件</span></span><br><span class=\"line\">reasonAction: &#123;</span><br><span class=\"line\">  <span class=\"string\">'create_product'</span>  : [<span class=\"string\">'comment'</span>, <span class=\"string\">'like'</span>]</span><br><span class=\"line\">  <span class=\"string\">'like_product'</span>    : [<span class=\"string\">'comment'</span>],</span><br><span class=\"line\">  <span class=\"string\">'like_post'</span>       : [<span class=\"string\">'comment'</span>],</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 默认订阅配置</span></span><br><span class=\"line\">defaultSubscriptionConfig: &#123;</span><br><span class=\"line\">  <span class=\"string\">'comment'</span>   : <span class=\"literal\">true</span>,    <span class=\"comment\">// 评论</span></span><br><span class=\"line\">  <span class=\"string\">'like'</span>      : <span class=\"literal\">true</span>,    <span class=\"comment\">// 喜欢</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"服务层-NotifyService\"><a href=\"#服务层-NotifyService\" class=\"headerlink\" title=\"服务层 NotifyService\"></a>服务层 NotifyService</h2><h4 id=\"NotifyService拥有以下方法\"><a href=\"#NotifyService拥有以下方法\" class=\"headerlink\" title=\"NotifyService拥有以下方法:\"></a>NotifyService拥有以下方法:</h4><ul>\n<li>createAnnounce(content, sender)</li>\n<li>createRemind(target, targetType, action, sender, content)</li>\n<li>createMessage(content, sender, receiver)</li>\n<li>pullAnnounce(user)</li>\n<li>pullRemind(user)</li>\n<li>subscribe(user, target, targetType, reason)</li>\n<li>cancelSubscription(user, target ,targetType)</li>\n<li>getSubscriptionConfig(userID)</li>\n<li>updateSubscriptionConfig(userID)</li>\n<li>getUserNotify(userID)</li>\n<li>read(user, notifyIDs)</li>\n</ul>\n<h4 id=\"各方法的处理逻辑如下：\"><a href=\"#各方法的处理逻辑如下：\" class=\"headerlink\" title=\"各方法的处理逻辑如下：\"></a>各方法的处理逻辑如下：</h4><p><strong>createAnnounce(content, sender)</strong></p>\n<ol>\n<li>往Notify表中插入一条公告记录</li>\n</ol>\n<p><strong>createRemind(target, targetType, action, sender, content)</strong></p>\n<ol>\n<li>往Notify表中插入一条提醒记录</li>\n</ol>\n<p><strong>createMessage(content, sender, receiver)</strong></p>\n<ol>\n<li>往Notify表中插入一条信息记录</li>\n<li>往UserNotify表中插入一条记录，并关联新建的Notify</li>\n</ol>\n<p><strong>pullAnnounce(user)</strong></p>\n<ol>\n<li>从UserNotify中获取最近的一条公告信息的创建时间: <code>lastTime</code></li>\n<li>用<code>lastTime</code>作为过滤条件，查询Notify的公告信息</li>\n<li>新建UserNotify并关联查询出来的公告信息</li>\n</ol>\n<p><strong>pullRemind(user)</strong></p>\n<ol>\n<li>查询用户的订阅表，得到用户的一系列订阅记录</li>\n<li>通过每一条的订阅记录的<code>target</code>、<code>targetType</code>、<code>action</code>、<code>createdAt</code>去查询Notify表，获取订阅的Notify记录。（注意订阅时间必须早于提醒创建时间）</li>\n<li>查询用户的配置文件SubscriptionConfig，如果没有则使用默认的配置DefaultSubscriptionConfig</li>\n<li>使用订阅配置，过滤查询出来的Notify</li>\n<li>使用过滤好的Notify作为关联新建UserNotify</li>\n</ol>\n<p><strong>subscribe(user, target, targetType, reason)</strong></p>\n<ol>\n<li>通过reason，查询NotifyConfig，获取对应的动作组:<code>actions</code></li>\n<li>遍历动作组，每一个动作新建一则Subscription记录</li>\n</ol>\n<p><strong>cancelSubscription(user, target ,targetType)</strong></p>\n<ol>\n<li>删除<code>user</code>、<code>target</code>、<code>targetType</code>对应的一则或多则记录</li>\n</ol>\n<p><strong>getSubscriptionConfig(userID)</strong></p>\n<ol>\n<li>查询SubscriptionConfig表，获取用户的订阅配置</li>\n</ol>\n<p><strong>updateSubscriptionConfig(userID)</strong></p>\n<ol>\n<li>更新用户的SubscriptionConfig记录</li>\n</ol>\n<p><strong>getUserNotify(userID)</strong></p>\n<ol>\n<li>获取用户的消息列表</li>\n</ol>\n<p><strong>read(user, notifyIDs)</strong></p>\n<ol>\n<li>更新指定的notify，把isRead属性设置为true</li>\n</ol>\n<h2 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h2><h3 id=\"提醒的订阅、创建、拉取\"><a href=\"#提醒的订阅、创建、拉取\" class=\"headerlink\" title=\"提醒的订阅、创建、拉取\"></a>提醒的订阅、创建、拉取</h3><p><img src=\"//dn-cnode.qbox.me/FrvQvJn3YzSnYjlGTaBkhZ-PdZtZ\" alt=\"提醒的订阅、创建、拉取\"></p>\n<p>我们可以在产品创建之后，调用<code>NotifyService.subscribe</code>方法，<br>然后在产品被评论之后调用<code>NotifyService.createRemind</code>方法，<br>再就是用户登录系统或者其他的某一个时刻调用<code>NotifyService.pullRemind</code>方法，<br>最后在用户查询消息队列的时候调用<code>NotifyService.getUserNotify</code>方法。</p>\n<h3 id=\"公告的创建、拉取\"><a href=\"#公告的创建、拉取\" class=\"headerlink\" title=\"公告的创建、拉取\"></a>公告的创建、拉取</h3><p><img src=\"//dn-cnode.qbox.me/FiTeODLU97C8VG6V-rRQwgZYS8ff\" alt=\"公告的创建、拉取\"></p>\n<p>在管理员发送了一则公告的时候，调用<code>NotifyService.createAnnounce</code>方法，<br>然后在用户登录系统或者其他的某一个时刻调用<code>NotifyService.pullAnnounce</code>方法，<br>最后在用户查询消息队列的时候调用<code>NotifyService.getUserNotify</code>方法。</p>\n<h3 id=\"信息的创建\"><a href=\"#信息的创建\" class=\"headerlink\" title=\"信息的创建\"></a>信息的创建</h3><p><img src=\"//dn-cnode.qbox.me/Fjvq4egEZcMeoynkUUURWKgGP9KF\" alt=\"信息的创建\"><br>信息的创建，只需要直接调用<code>NotifyService.createMessage</code>方法就可以了，<br>在下一次用户查询消息队列的时候，就会查询这条信息。</p>\n","excerpt":"","more":"<h2 id=\"模型设计\"><a href=\"#模型设计\" class=\"headerlink\" title=\"模型设计\"></a>模型设计</h2><h3 id=\"Notify\"><a href=\"#Notify\" class=\"headerlink\" title=\"Notify\"></a>Notify</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id\t\t\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">primaryKey</span>: <span class=\"literal\">true</span>&#125;,\t\t<span class=\"comment\">// 主键</span></span><br><span class=\"line\">content     : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'text'</span>&#125;,\t<span class=\"comment\">// 消息的内容</span></span><br><span class=\"line\">type        : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>, <span class=\"attr\">enum</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]&#125;,  <span class=\"comment\">// 消息的类型，1: 公告 Announce，2: 提醒 Remind，3：信息 Message</span></span><br><span class=\"line\">target      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;,    <span class=\"comment\">// 目标的ID</span></span><br><span class=\"line\">targetType  : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>&#125;,    <span class=\"comment\">// 目标的类型</span></span><br><span class=\"line\">action      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>&#125;,    <span class=\"comment\">// 提醒信息的动作类型</span></span><br><span class=\"line\">sender      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;,    <span class=\"comment\">// 发送者的ID</span></span><br><span class=\"line\">createdAt\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'datetime'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Save Remind</strong><br>消息表，我们需要<code>target</code>、<code>targetType</code>字段，来记录该条提醒所关联的对象。而<code>action</code>字段，则记录该条提醒所关联的动作。<br>比如消息：「小明喜欢了文章」<br>则：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target = <span class=\"number\">123</span>,  <span class=\"comment\">// 文章ID</span></span><br><span class=\"line\">targetType = <span class=\"string\">'post'</span>,  <span class=\"comment\">// 指明target所属类型是文章</span></span><br><span class=\"line\">sender = <span class=\"number\">123456</span>  <span class=\"comment\">// 小明ID</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>Save Announce and Message</strong><br>当然，Notify还支持存储公告和信息。它们会用到<code>content</code>字段，而不会用到<code>target</code>、<code>targetType</code>、<code>action</code>字段。</p>\n<h3 id=\"UserNotify\"><a href=\"#UserNotify\" class=\"headerlink\" title=\"UserNotify\"></a>UserNotify</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id\t\t\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">primaryKey</span>: <span class=\"literal\">true</span>&#125;,\t\t<span class=\"comment\">// 主键</span></span><br><span class=\"line\">isRead      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'boolean'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,   </span><br><span class=\"line\">user        : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,  <span class=\"comment\">// 用户消息所属者</span></span><br><span class=\"line\">notify      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;   <span class=\"comment\">// 关联的Notify</span></span><br><span class=\"line\">createdAt\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'datetime'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>我们用UserNotify来存储用户的消息队列，它关联一则提醒(Notify)的具体内容。<br>UserNotify的创建，主要通过两个途径：</p>\n<ol>\n<li>遍历订阅(Subscription)表拉取公告(Announce)和提醒(Remind)的时候创建</li>\n<li>新建信息(Message)之后，立刻创建。</li>\n</ol>\n<h3 id=\"Subscription\"><a href=\"#Subscription\" class=\"headerlink\" title=\"Subscription\"></a>Subscription</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,    <span class=\"comment\">// 目标的ID</span></span><br><span class=\"line\">targetType  : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,    <span class=\"comment\">// 目标的类型</span></span><br><span class=\"line\">action      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>&#125;,   <span class=\"comment\">// 订阅动作,如: comment/like/post/update etc.</span></span><br><span class=\"line\">user        : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;，</span><br><span class=\"line\">createdAt\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'datetime'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>订阅，是从Notify表拉取消息到UserNotify的前提，用户首先订阅了某一个目标的某一个动作，在此之后产生这个目标的这个动作的消息，才会被通知到该用户。<br>如：「小明关注了产品A的评论」，数据表现为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target: <span class=\"number\">123</span>,  <span class=\"comment\">// 产品A的ID</span></span><br><span class=\"line\">targetType: <span class=\"string\">'product'</span>,</span><br><span class=\"line\">action: <span class=\"string\">'comment'</span>,</span><br><span class=\"line\">user: <span class=\"number\">123</span>  <span class=\"comment\">// 小明的ID</span></span><br></pre></td></tr></table></figure></p>\n<p>这样，产品A下产生的每一条评论，都会产生通知给小明了。</p>\n<h3 id=\"SubscriptionConfig\"><a href=\"#SubscriptionConfig\" class=\"headerlink\" title=\"SubscriptionConfig\"></a>SubscriptionConfig</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">action: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'json'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,   <span class=\"comment\">// 用户的设置</span></span><br><span class=\"line\">user: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>不同用户可能会有不一样的订阅习惯，在这个表中，用户可以统一针对某种动作进行是否订阅的设置。而默认是使用系统提供的默认配置：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaultSubscriptionConfig: &#123;</span><br><span class=\"line\">  <span class=\"string\">'comment'</span>   : <span class=\"literal\">true</span>,    <span class=\"comment\">// 评论</span></span><br><span class=\"line\">  <span class=\"string\">'like'</span>      : <span class=\"literal\">true</span>,    <span class=\"comment\">// 喜欢</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在这套模型中，<code>targetType</code>、<code>action</code>是可以根据需求来扩展的，例如我们还可以增加多几个动作的提醒：<code>hate</code>被踩、<code>update</code>被更新….诸如此类。</p>\n</blockquote>\n<h2 id=\"配置文件-NotifyConfig\"><a href=\"#配置文件-NotifyConfig\" class=\"headerlink\" title=\"配置文件 NotifyConfig\"></a>配置文件 NotifyConfig</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 提醒关联的目标类型</span></span><br><span class=\"line\">targetType: &#123;</span><br><span class=\"line\">  PRODUCT : <span class=\"string\">'product'</span>,    <span class=\"comment\">// 产品</span></span><br><span class=\"line\">  POST    : <span class=\"string\">'post'</span>    <span class=\"comment\">// 文章</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提醒关联的动作</span></span><br><span class=\"line\">action: &#123;</span><br><span class=\"line\">  COMMENT   : <span class=\"string\">'comment'</span>,  <span class=\"comment\">// 评论</span></span><br><span class=\"line\">  LIKE      : <span class=\"string\">'like'</span>,     <span class=\"comment\">// 喜欢</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 订阅原因对应订阅事件</span></span><br><span class=\"line\">reasonAction: &#123;</span><br><span class=\"line\">  <span class=\"string\">'create_product'</span>  : [<span class=\"string\">'comment'</span>, <span class=\"string\">'like'</span>]</span><br><span class=\"line\">  <span class=\"string\">'like_product'</span>    : [<span class=\"string\">'comment'</span>],</span><br><span class=\"line\">  <span class=\"string\">'like_post'</span>       : [<span class=\"string\">'comment'</span>],</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 默认订阅配置</span></span><br><span class=\"line\">defaultSubscriptionConfig: &#123;</span><br><span class=\"line\">  <span class=\"string\">'comment'</span>   : <span class=\"literal\">true</span>,    <span class=\"comment\">// 评论</span></span><br><span class=\"line\">  <span class=\"string\">'like'</span>      : <span class=\"literal\">true</span>,    <span class=\"comment\">// 喜欢</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"服务层-NotifyService\"><a href=\"#服务层-NotifyService\" class=\"headerlink\" title=\"服务层 NotifyService\"></a>服务层 NotifyService</h2><h4 id=\"NotifyService拥有以下方法\"><a href=\"#NotifyService拥有以下方法\" class=\"headerlink\" title=\"NotifyService拥有以下方法:\"></a>NotifyService拥有以下方法:</h4><ul>\n<li>createAnnounce(content, sender)</li>\n<li>createRemind(target, targetType, action, sender, content)</li>\n<li>createMessage(content, sender, receiver)</li>\n<li>pullAnnounce(user)</li>\n<li>pullRemind(user)</li>\n<li>subscribe(user, target, targetType, reason)</li>\n<li>cancelSubscription(user, target ,targetType)</li>\n<li>getSubscriptionConfig(userID)</li>\n<li>updateSubscriptionConfig(userID)</li>\n<li>getUserNotify(userID)</li>\n<li>read(user, notifyIDs)</li>\n</ul>\n<h4 id=\"各方法的处理逻辑如下：\"><a href=\"#各方法的处理逻辑如下：\" class=\"headerlink\" title=\"各方法的处理逻辑如下：\"></a>各方法的处理逻辑如下：</h4><p><strong>createAnnounce(content, sender)</strong></p>\n<ol>\n<li>往Notify表中插入一条公告记录</li>\n</ol>\n<p><strong>createRemind(target, targetType, action, sender, content)</strong></p>\n<ol>\n<li>往Notify表中插入一条提醒记录</li>\n</ol>\n<p><strong>createMessage(content, sender, receiver)</strong></p>\n<ol>\n<li>往Notify表中插入一条信息记录</li>\n<li>往UserNotify表中插入一条记录，并关联新建的Notify</li>\n</ol>\n<p><strong>pullAnnounce(user)</strong></p>\n<ol>\n<li>从UserNotify中获取最近的一条公告信息的创建时间: <code>lastTime</code></li>\n<li>用<code>lastTime</code>作为过滤条件，查询Notify的公告信息</li>\n<li>新建UserNotify并关联查询出来的公告信息</li>\n</ol>\n<p><strong>pullRemind(user)</strong></p>\n<ol>\n<li>查询用户的订阅表，得到用户的一系列订阅记录</li>\n<li>通过每一条的订阅记录的<code>target</code>、<code>targetType</code>、<code>action</code>、<code>createdAt</code>去查询Notify表，获取订阅的Notify记录。（注意订阅时间必须早于提醒创建时间）</li>\n<li>查询用户的配置文件SubscriptionConfig，如果没有则使用默认的配置DefaultSubscriptionConfig</li>\n<li>使用订阅配置，过滤查询出来的Notify</li>\n<li>使用过滤好的Notify作为关联新建UserNotify</li>\n</ol>\n<p><strong>subscribe(user, target, targetType, reason)</strong></p>\n<ol>\n<li>通过reason，查询NotifyConfig，获取对应的动作组:<code>actions</code></li>\n<li>遍历动作组，每一个动作新建一则Subscription记录</li>\n</ol>\n<p><strong>cancelSubscription(user, target ,targetType)</strong></p>\n<ol>\n<li>删除<code>user</code>、<code>target</code>、<code>targetType</code>对应的一则或多则记录</li>\n</ol>\n<p><strong>getSubscriptionConfig(userID)</strong></p>\n<ol>\n<li>查询SubscriptionConfig表，获取用户的订阅配置</li>\n</ol>\n<p><strong>updateSubscriptionConfig(userID)</strong></p>\n<ol>\n<li>更新用户的SubscriptionConfig记录</li>\n</ol>\n<p><strong>getUserNotify(userID)</strong></p>\n<ol>\n<li>获取用户的消息列表</li>\n</ol>\n<p><strong>read(user, notifyIDs)</strong></p>\n<ol>\n<li>更新指定的notify，把isRead属性设置为true</li>\n</ol>\n<h2 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h2><h3 id=\"提醒的订阅、创建、拉取\"><a href=\"#提醒的订阅、创建、拉取\" class=\"headerlink\" title=\"提醒的订阅、创建、拉取\"></a>提醒的订阅、创建、拉取</h3><p><img src=\"//dn-cnode.qbox.me/FrvQvJn3YzSnYjlGTaBkhZ-PdZtZ\" alt=\"提醒的订阅、创建、拉取\"></p>\n<p>我们可以在产品创建之后，调用<code>NotifyService.subscribe</code>方法，<br>然后在产品被评论之后调用<code>NotifyService.createRemind</code>方法，<br>再就是用户登录系统或者其他的某一个时刻调用<code>NotifyService.pullRemind</code>方法，<br>最后在用户查询消息队列的时候调用<code>NotifyService.getUserNotify</code>方法。</p>\n<h3 id=\"公告的创建、拉取\"><a href=\"#公告的创建、拉取\" class=\"headerlink\" title=\"公告的创建、拉取\"></a>公告的创建、拉取</h3><p><img src=\"//dn-cnode.qbox.me/FiTeODLU97C8VG6V-rRQwgZYS8ff\" alt=\"公告的创建、拉取\"></p>\n<p>在管理员发送了一则公告的时候，调用<code>NotifyService.createAnnounce</code>方法，<br>然后在用户登录系统或者其他的某一个时刻调用<code>NotifyService.pullAnnounce</code>方法，<br>最后在用户查询消息队列的时候调用<code>NotifyService.getUserNotify</code>方法。</p>\n<h3 id=\"信息的创建\"><a href=\"#信息的创建\" class=\"headerlink\" title=\"信息的创建\"></a>信息的创建</h3><p><img src=\"//dn-cnode.qbox.me/Fjvq4egEZcMeoynkUUURWKgGP9KF\" alt=\"信息的创建\"><br>信息的创建，只需要直接调用<code>NotifyService.createMessage</code>方法就可以了，<br>在下一次用户查询消息队列的时候，就会查询这条信息。</p>\n"},{"title":"消息系统设计与实现「上篇」","date":"2015-10-14T09:22:33.000Z","_content":"\n> 由于文章篇幅较长，而作者精力有限，不希望这么早就精尽人亡，故分成上下篇来写消息系统的设计与实现。上篇主要讲的是一些概念，搞清楚我们要做的这个消息系统的主要内容。而下篇主要讲具体的实现，会包括架构设计，数据库设计，业务流程详细的实现等。\n\n> 整个系统的设计与实现，并非我一人之力就可以完成的。这其中是同事们大家一起讨论与商讨的结果，而我只是把它细化，呈现出来。\n\n> 我只是一个会思考的idea搬运工。\n\n\n## 产品分析\n首先我们来看一下市场上关于消息的实现是怎么样的。\n\n### 简书\n简书的消息系统主要分了两种\n* 简信\n* 提醒\n\n**简信**\n简信的性质其实跟私信是一样的，是用户发送给用户的一则消息，有具体的信息内容。\n\n![简书简信](http://xia-dev.b0.upaiyun.com/c3aad7dc-5914-4c5c-9f88-34e40077d0ff.jpg)\n\n**提醒**\n而提醒，则是系统发送的一则消息，其文案格式是固定的，并且对特殊对象一般拥有超链接。\n![简书提醒](http://xia-dev.b0.upaiyun.com/b0ee917e-0776-4aa9-bf4a-0a2cd33ca853.jpg)\n\n### 知乎\n知乎跟简书一样，主要分了两种：\n* 私信\n* 消息\n\n**私信**\n跟简书一样，使用户发送给用户的一则消息，也可以是管理员发送给用户的消息。\n<img src=\"http://xia-dev.b0.upaiyun.com/a6b102ed-d337-41d2-a5d3-b3923650de16.jpg\" width=250></img>\n\n\n**消息**\n知乎的消息比简书的提醒有过之而无不及，知乎会对多条相似的消息进行聚会，以达到减轻用户阅读压力的体验。\n<img src=\"http://xia-dev.b0.upaiyun.com/5f90952e-2fe6-447f-affb-8a7c9a04d0ab.jpg\" width=450></img>\n\n## 消息的三种分类\n通过两种产品的简单分析，得出他们的消息有两种分类，在这基础上，我们再加上一种：公告。\n公告的主要性质是系统发送一则含有具体内容的消息，站内所有用户都能读取到这条消息。\n所以，消息有三种分类：\n1. 公告 Announce\n2. 提醒 Remind\n3. 私信 Message\n\n## 提醒的语言分析\n我们从简书取一组提醒样本：\n* 3dbe1bd90774 关注了你\n* magicdawn 喜欢了你的文章 《单点登录的三种实现方式》\n* 无良程序 喜欢了你的文章 《基于RESTful API 怎么设计用户权限控制？》\n* alexcc4 喜欢了你的文章 《在Nodejs中贯彻单元测试》\n*  你在《基于RESTful API 怎么设计用户权限控制？》中收到一条 cnlinjie 的评论\n*  你的文章《Session原理》已被加入专题 《ios开发》\n\n分析句子结构，提醒的内容无非就是\n\n>「谁对一样属于谁的事物做了什么操作」\n「someone do something in someone's something」\n\nsomeone = 提醒的触发者，或者发送者，标记为sender\ndo something = 提醒的动作，评论、喜欢、关注都属于一个动作，标记为action\nsomething = 提醒的动作作用对象，这就具体到是哪一篇文章，标记为target\nsomeone's = 提醒的动作作用对象的所有者，标记为targetOwner\n\n这就清楚了，sender和targetOwner就是网站的用户，而target是具体到哪一篇文章，如果提醒的对象不仅仅局限于文章，还有其他的话，就需要增加一项targetType，来标记目标是文章还是其他的什么。而action，则是固定的，整个网站会触发提醒的动作可能就只有那几样：评论、喜欢、关注.....（或者其他业务需要提醒的动作）\n\n## 消息的两种获取方式\n* 推 Push\n* 拉 Pull\n\n**以知乎为例**\n推的比较常见，需要针对某一个问题维护着一张关注者的列表，每当触发这个问题推送的条件时（例如有人回答问题），就把这个通知发送给每个关注者。\n\n拉的相对麻烦一点，就是推的反向，例如每个用户都有一张关注问题的列表，每当用户上线的时候，对每个问题进行轮询，当问题的事件列表出现了比我原本时间戳大的信息就进行拉取。\n\n**而我们则根据消息的不同分类采用不同的获取方式**：\n通告和提醒，适合使用拉取的方式，消息产生之后，会存在消息表中，用户在某一特定的时间根据自己关注问题的表进行消息的拉取，然后添加到自己的消息队列中，\n\n信息，适合使用推的方式，在发送者建立一条信息之后，同时指定接收者，把消息添加到接收者的消息队列中。\n\n## 订阅\n根据提醒使用拉取的方式，需要维护一个关注某一事物的列表。\n这种行为，我们称之为：**「订阅」Subscribe **\n\n**一则订阅有以下三个核心属性**：\n* 订阅的目标 target\n* 订阅的目标类型 targetType\n* 订阅的动作 action\n\n比如我发布了一篇文章，那么我会订阅文章《XXX》的评论动作，所以文章《XXX》每被人评论了，就需要发送一则提醒告知我。\n\n**订阅的规则还可以扩展**\n我喜欢了一篇文章，和我发布了一篇文章，订阅的动作可能不一样。\n喜欢了一篇文章，我希望我订阅这篇文章更新、评论的动作。\n而发布了一篇文章，我希望我只是订阅这篇文章的评论动作。\n\n这时候就需要多一个参数：subscribReason\n不同的subscribReason，对应着一个动作数组，\nsubscribReason = 喜欢，对应着 actions = [更新，评论]\nsubscribReason = 发布，对应着 actions = [评论]\n\n**订阅的规则还还可以扩展**\n用户可能会有一个自己的订阅设置，比如对于所有的喜欢的动作，我都不希望接收。\n比如Knewone的提醒设置\n<img src=\"http://xia-dev.b0.upaiyun.com/80cc4aaf-0568-478c-8513-b8821e57520f.jpg\" alt=\"Knewone提醒设置\" width=\"500\">\n\n所以我们需要再维护一个表：**SubscriptionConfig**，来存放用户的提醒设置。\n并且，当用户没有提醒设置的时候，可以使用系统提供的一套默认设置：**defaultSubscriptionConfig**\n\n\n## 聚合\n如果我发布了一篇文章《XXX》，在我不在线的时候，被评论了10遍，当我一上线的时候，应该是收到十条信息类似于：「谁谁谁评论了你的文章《XXX》」?\n还是应该收到一条信息：「甲、乙、丙、丁...评论了你的文章《XXX》」?\n\n知乎在聚合上做的很优秀，要知道他们要实现这个还是挺有技术的：\n[知乎的消息机制，在技术上如何设计与规划？](http://www.zhihu.com/question/22394809)\n[网站的消息（通知）系统一般是如何实现的？](http://www.zhihu.com/question/20380990/answer/14960006)\n\n关于这部分功能，我们还没有具体的实现方法，暂时也无法讲得更加详细。⊙﹏⊙\n\n## 五个实体\n通过上面的分析，大概知道做这个消息系统，需要哪些实体类：\n1. 用户消息队列 UserNotify\n2. 用户 User\n3. 订阅 Subscription\n4. 订阅设置 SubscriptionConfig\n5. 消息 Notify\n\t- 通告 Announce\n\t- 提醒 Remind\n\t- 信息 Message\n\n## 行为分解\n说了这么多，整理一下整个消息流程的一些行为：\n\n- 系统或者管理员，创建消息 \n\t- createNotify (make announce | remind | message)\n- 用户，订阅消息，取消订阅\n\t- subscribe, cancelSubscription\n- 用户管理订阅设置\n\t- getSubscriptionConfig, updateSubscriptionConfig\n- 用户，拉取消息\n\t- pullNotify (pull announce | remind | message | all)\n- 用户，查询消息队列\n\t- getUserNotify(get announce | remind | message | all)\n- 用户阅读消息\n\t- read\n\n\n> 在本文的「下篇」我们来探讨一下：模型怎么做、数据库怎么设计、代码结构怎么来、一些逻辑上的时序图应该是怎么样的。\n\n\n","source":"_posts/消息系统设计与实现「上篇」.md","raw":"---\ntitle: 消息系统设计与实现「上篇」\ncategory: 搬砖码农\ndate: 2015-10-14 17:22:33\ntags:\n- 架构\n- 消息系统\n---\n\n> 由于文章篇幅较长，而作者精力有限，不希望这么早就精尽人亡，故分成上下篇来写消息系统的设计与实现。上篇主要讲的是一些概念，搞清楚我们要做的这个消息系统的主要内容。而下篇主要讲具体的实现，会包括架构设计，数据库设计，业务流程详细的实现等。\n\n> 整个系统的设计与实现，并非我一人之力就可以完成的。这其中是同事们大家一起讨论与商讨的结果，而我只是把它细化，呈现出来。\n\n> 我只是一个会思考的idea搬运工。\n\n\n## 产品分析\n首先我们来看一下市场上关于消息的实现是怎么样的。\n\n### 简书\n简书的消息系统主要分了两种\n* 简信\n* 提醒\n\n**简信**\n简信的性质其实跟私信是一样的，是用户发送给用户的一则消息，有具体的信息内容。\n\n![简书简信](http://xia-dev.b0.upaiyun.com/c3aad7dc-5914-4c5c-9f88-34e40077d0ff.jpg)\n\n**提醒**\n而提醒，则是系统发送的一则消息，其文案格式是固定的，并且对特殊对象一般拥有超链接。\n![简书提醒](http://xia-dev.b0.upaiyun.com/b0ee917e-0776-4aa9-bf4a-0a2cd33ca853.jpg)\n\n### 知乎\n知乎跟简书一样，主要分了两种：\n* 私信\n* 消息\n\n**私信**\n跟简书一样，使用户发送给用户的一则消息，也可以是管理员发送给用户的消息。\n<img src=\"http://xia-dev.b0.upaiyun.com/a6b102ed-d337-41d2-a5d3-b3923650de16.jpg\" width=250></img>\n\n\n**消息**\n知乎的消息比简书的提醒有过之而无不及，知乎会对多条相似的消息进行聚会，以达到减轻用户阅读压力的体验。\n<img src=\"http://xia-dev.b0.upaiyun.com/5f90952e-2fe6-447f-affb-8a7c9a04d0ab.jpg\" width=450></img>\n\n## 消息的三种分类\n通过两种产品的简单分析，得出他们的消息有两种分类，在这基础上，我们再加上一种：公告。\n公告的主要性质是系统发送一则含有具体内容的消息，站内所有用户都能读取到这条消息。\n所以，消息有三种分类：\n1. 公告 Announce\n2. 提醒 Remind\n3. 私信 Message\n\n## 提醒的语言分析\n我们从简书取一组提醒样本：\n* 3dbe1bd90774 关注了你\n* magicdawn 喜欢了你的文章 《单点登录的三种实现方式》\n* 无良程序 喜欢了你的文章 《基于RESTful API 怎么设计用户权限控制？》\n* alexcc4 喜欢了你的文章 《在Nodejs中贯彻单元测试》\n*  你在《基于RESTful API 怎么设计用户权限控制？》中收到一条 cnlinjie 的评论\n*  你的文章《Session原理》已被加入专题 《ios开发》\n\n分析句子结构，提醒的内容无非就是\n\n>「谁对一样属于谁的事物做了什么操作」\n「someone do something in someone's something」\n\nsomeone = 提醒的触发者，或者发送者，标记为sender\ndo something = 提醒的动作，评论、喜欢、关注都属于一个动作，标记为action\nsomething = 提醒的动作作用对象，这就具体到是哪一篇文章，标记为target\nsomeone's = 提醒的动作作用对象的所有者，标记为targetOwner\n\n这就清楚了，sender和targetOwner就是网站的用户，而target是具体到哪一篇文章，如果提醒的对象不仅仅局限于文章，还有其他的话，就需要增加一项targetType，来标记目标是文章还是其他的什么。而action，则是固定的，整个网站会触发提醒的动作可能就只有那几样：评论、喜欢、关注.....（或者其他业务需要提醒的动作）\n\n## 消息的两种获取方式\n* 推 Push\n* 拉 Pull\n\n**以知乎为例**\n推的比较常见，需要针对某一个问题维护着一张关注者的列表，每当触发这个问题推送的条件时（例如有人回答问题），就把这个通知发送给每个关注者。\n\n拉的相对麻烦一点，就是推的反向，例如每个用户都有一张关注问题的列表，每当用户上线的时候，对每个问题进行轮询，当问题的事件列表出现了比我原本时间戳大的信息就进行拉取。\n\n**而我们则根据消息的不同分类采用不同的获取方式**：\n通告和提醒，适合使用拉取的方式，消息产生之后，会存在消息表中，用户在某一特定的时间根据自己关注问题的表进行消息的拉取，然后添加到自己的消息队列中，\n\n信息，适合使用推的方式，在发送者建立一条信息之后，同时指定接收者，把消息添加到接收者的消息队列中。\n\n## 订阅\n根据提醒使用拉取的方式，需要维护一个关注某一事物的列表。\n这种行为，我们称之为：**「订阅」Subscribe **\n\n**一则订阅有以下三个核心属性**：\n* 订阅的目标 target\n* 订阅的目标类型 targetType\n* 订阅的动作 action\n\n比如我发布了一篇文章，那么我会订阅文章《XXX》的评论动作，所以文章《XXX》每被人评论了，就需要发送一则提醒告知我。\n\n**订阅的规则还可以扩展**\n我喜欢了一篇文章，和我发布了一篇文章，订阅的动作可能不一样。\n喜欢了一篇文章，我希望我订阅这篇文章更新、评论的动作。\n而发布了一篇文章，我希望我只是订阅这篇文章的评论动作。\n\n这时候就需要多一个参数：subscribReason\n不同的subscribReason，对应着一个动作数组，\nsubscribReason = 喜欢，对应着 actions = [更新，评论]\nsubscribReason = 发布，对应着 actions = [评论]\n\n**订阅的规则还还可以扩展**\n用户可能会有一个自己的订阅设置，比如对于所有的喜欢的动作，我都不希望接收。\n比如Knewone的提醒设置\n<img src=\"http://xia-dev.b0.upaiyun.com/80cc4aaf-0568-478c-8513-b8821e57520f.jpg\" alt=\"Knewone提醒设置\" width=\"500\">\n\n所以我们需要再维护一个表：**SubscriptionConfig**，来存放用户的提醒设置。\n并且，当用户没有提醒设置的时候，可以使用系统提供的一套默认设置：**defaultSubscriptionConfig**\n\n\n## 聚合\n如果我发布了一篇文章《XXX》，在我不在线的时候，被评论了10遍，当我一上线的时候，应该是收到十条信息类似于：「谁谁谁评论了你的文章《XXX》」?\n还是应该收到一条信息：「甲、乙、丙、丁...评论了你的文章《XXX》」?\n\n知乎在聚合上做的很优秀，要知道他们要实现这个还是挺有技术的：\n[知乎的消息机制，在技术上如何设计与规划？](http://www.zhihu.com/question/22394809)\n[网站的消息（通知）系统一般是如何实现的？](http://www.zhihu.com/question/20380990/answer/14960006)\n\n关于这部分功能，我们还没有具体的实现方法，暂时也无法讲得更加详细。⊙﹏⊙\n\n## 五个实体\n通过上面的分析，大概知道做这个消息系统，需要哪些实体类：\n1. 用户消息队列 UserNotify\n2. 用户 User\n3. 订阅 Subscription\n4. 订阅设置 SubscriptionConfig\n5. 消息 Notify\n\t- 通告 Announce\n\t- 提醒 Remind\n\t- 信息 Message\n\n## 行为分解\n说了这么多，整理一下整个消息流程的一些行为：\n\n- 系统或者管理员，创建消息 \n\t- createNotify (make announce | remind | message)\n- 用户，订阅消息，取消订阅\n\t- subscribe, cancelSubscription\n- 用户管理订阅设置\n\t- getSubscriptionConfig, updateSubscriptionConfig\n- 用户，拉取消息\n\t- pullNotify (pull announce | remind | message | all)\n- 用户，查询消息队列\n\t- getUserNotify(get announce | remind | message | all)\n- 用户阅读消息\n\t- read\n\n\n> 在本文的「下篇」我们来探讨一下：模型怎么做、数据库怎么设计、代码结构怎么来、一些逻辑上的时序图应该是怎么样的。\n\n\n","slug":"消息系统设计与实现「上篇」","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8ra001exwrllkqpzppz","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>由于文章篇幅较长，而作者精力有限，不希望这么早就精尽人亡，故分成上下篇来写消息系统的设计与实现。上篇主要讲的是一些概念，搞清楚我们要做的这个消息系统的主要内容。而下篇主要讲具体的实现，会包括架构设计，数据库设计，业务流程详细的实现等。</p>\n</blockquote>\n<blockquote>\n<p>整个系统的设计与实现，并非我一人之力就可以完成的。这其中是同事们大家一起讨论与商讨的结果，而我只是把它细化，呈现出来。</p>\n</blockquote>\n<blockquote>\n<p>我只是一个会思考的idea搬运工。</p>\n</blockquote>\n<h2 id=\"产品分析\"><a href=\"#产品分析\" class=\"headerlink\" title=\"产品分析\"></a>产品分析</h2><p>首先我们来看一下市场上关于消息的实现是怎么样的。</p>\n<h3 id=\"简书\"><a href=\"#简书\" class=\"headerlink\" title=\"简书\"></a>简书</h3><p>简书的消息系统主要分了两种</p>\n<ul>\n<li>简信</li>\n<li>提醒</li>\n</ul>\n<p><strong>简信</strong><br>简信的性质其实跟私信是一样的，是用户发送给用户的一则消息，有具体的信息内容。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/c3aad7dc-5914-4c5c-9f88-34e40077d0ff.jpg\" alt=\"简书简信\"></p>\n<p><strong>提醒</strong><br>而提醒，则是系统发送的一则消息，其文案格式是固定的，并且对特殊对象一般拥有超链接。<br><img src=\"http://xia-dev.b0.upaiyun.com/b0ee917e-0776-4aa9-bf4a-0a2cd33ca853.jpg\" alt=\"简书提醒\"></p>\n<h3 id=\"知乎\"><a href=\"#知乎\" class=\"headerlink\" title=\"知乎\"></a>知乎</h3><p>知乎跟简书一样，主要分了两种：</p>\n<ul>\n<li>私信</li>\n<li>消息</li>\n</ul>\n<p><strong>私信</strong><br>跟简书一样，使用户发送给用户的一则消息，也可以是管理员发送给用户的消息。<br><img src=\"http://xia-dev.b0.upaiyun.com/a6b102ed-d337-41d2-a5d3-b3923650de16.jpg\" width=\"250\"></p>\n<p><strong>消息</strong><br>知乎的消息比简书的提醒有过之而无不及，知乎会对多条相似的消息进行聚会，以达到减轻用户阅读压力的体验。<br><img src=\"http://xia-dev.b0.upaiyun.com/5f90952e-2fe6-447f-affb-8a7c9a04d0ab.jpg\" width=\"450\"></p>\n<h2 id=\"消息的三种分类\"><a href=\"#消息的三种分类\" class=\"headerlink\" title=\"消息的三种分类\"></a>消息的三种分类</h2><p>通过两种产品的简单分析，得出他们的消息有两种分类，在这基础上，我们再加上一种：公告。<br>公告的主要性质是系统发送一则含有具体内容的消息，站内所有用户都能读取到这条消息。<br>所以，消息有三种分类：</p>\n<ol>\n<li>公告 Announce</li>\n<li>提醒 Remind</li>\n<li>私信 Message</li>\n</ol>\n<h2 id=\"提醒的语言分析\"><a href=\"#提醒的语言分析\" class=\"headerlink\" title=\"提醒的语言分析\"></a>提醒的语言分析</h2><p>我们从简书取一组提醒样本：</p>\n<ul>\n<li>3dbe1bd90774 关注了你</li>\n<li>magicdawn 喜欢了你的文章 《单点登录的三种实现方式》</li>\n<li>无良程序 喜欢了你的文章 《基于RESTful API 怎么设计用户权限控制？》</li>\n<li>alexcc4 喜欢了你的文章 《在Nodejs中贯彻单元测试》</li>\n<li>你在《基于RESTful API 怎么设计用户权限控制？》中收到一条 cnlinjie 的评论</li>\n<li>你的文章《Session原理》已被加入专题 《ios开发》</li>\n</ul>\n<p>分析句子结构，提醒的内容无非就是</p>\n<blockquote>\n<p>「谁对一样属于谁的事物做了什么操作」<br>「someone do something in someone’s something」</p>\n</blockquote>\n<p>someone = 提醒的触发者，或者发送者，标记为sender<br>do something = 提醒的动作，评论、喜欢、关注都属于一个动作，标记为action<br>something = 提醒的动作作用对象，这就具体到是哪一篇文章，标记为target<br>someone’s = 提醒的动作作用对象的所有者，标记为targetOwner</p>\n<p>这就清楚了，sender和targetOwner就是网站的用户，而target是具体到哪一篇文章，如果提醒的对象不仅仅局限于文章，还有其他的话，就需要增加一项targetType，来标记目标是文章还是其他的什么。而action，则是固定的，整个网站会触发提醒的动作可能就只有那几样：评论、喜欢、关注…..（或者其他业务需要提醒的动作）</p>\n<h2 id=\"消息的两种获取方式\"><a href=\"#消息的两种获取方式\" class=\"headerlink\" title=\"消息的两种获取方式\"></a>消息的两种获取方式</h2><ul>\n<li>推 Push</li>\n<li>拉 Pull</li>\n</ul>\n<p><strong>以知乎为例</strong><br>推的比较常见，需要针对某一个问题维护着一张关注者的列表，每当触发这个问题推送的条件时（例如有人回答问题），就把这个通知发送给每个关注者。</p>\n<p>拉的相对麻烦一点，就是推的反向，例如每个用户都有一张关注问题的列表，每当用户上线的时候，对每个问题进行轮询，当问题的事件列表出现了比我原本时间戳大的信息就进行拉取。</p>\n<p><strong>而我们则根据消息的不同分类采用不同的获取方式</strong>：<br>通告和提醒，适合使用拉取的方式，消息产生之后，会存在消息表中，用户在某一特定的时间根据自己关注问题的表进行消息的拉取，然后添加到自己的消息队列中，</p>\n<p>信息，适合使用推的方式，在发送者建立一条信息之后，同时指定接收者，把消息添加到接收者的消息队列中。</p>\n<h2 id=\"订阅\"><a href=\"#订阅\" class=\"headerlink\" title=\"订阅\"></a>订阅</h2><p>根据提醒使用拉取的方式，需要维护一个关注某一事物的列表。<br>这种行为，我们称之为：<strong>「订阅」Subscribe </strong></p>\n<p><strong>一则订阅有以下三个核心属性</strong>：</p>\n<ul>\n<li>订阅的目标 target</li>\n<li>订阅的目标类型 targetType</li>\n<li>订阅的动作 action</li>\n</ul>\n<p>比如我发布了一篇文章，那么我会订阅文章《XXX》的评论动作，所以文章《XXX》每被人评论了，就需要发送一则提醒告知我。</p>\n<p><strong>订阅的规则还可以扩展</strong><br>我喜欢了一篇文章，和我发布了一篇文章，订阅的动作可能不一样。<br>喜欢了一篇文章，我希望我订阅这篇文章更新、评论的动作。<br>而发布了一篇文章，我希望我只是订阅这篇文章的评论动作。</p>\n<p>这时候就需要多一个参数：subscribReason<br>不同的subscribReason，对应着一个动作数组，<br>subscribReason = 喜欢，对应着 actions = [更新，评论]<br>subscribReason = 发布，对应着 actions = [评论]</p>\n<p><strong>订阅的规则还还可以扩展</strong><br>用户可能会有一个自己的订阅设置，比如对于所有的喜欢的动作，我都不希望接收。<br>比如Knewone的提醒设置<br><img src=\"http://xia-dev.b0.upaiyun.com/80cc4aaf-0568-478c-8513-b8821e57520f.jpg\" alt=\"Knewone提醒设置\" width=\"500\"></p>\n<p>所以我们需要再维护一个表：<strong>SubscriptionConfig</strong>，来存放用户的提醒设置。<br>并且，当用户没有提醒设置的时候，可以使用系统提供的一套默认设置：<strong>defaultSubscriptionConfig</strong></p>\n<h2 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h2><p>如果我发布了一篇文章《XXX》，在我不在线的时候，被评论了10遍，当我一上线的时候，应该是收到十条信息类似于：「谁谁谁评论了你的文章《XXX》」?<br>还是应该收到一条信息：「甲、乙、丙、丁…评论了你的文章《XXX》」?</p>\n<p>知乎在聚合上做的很优秀，要知道他们要实现这个还是挺有技术的：<br><a href=\"http://www.zhihu.com/question/22394809\" target=\"_blank\" rel=\"external\">知乎的消息机制，在技术上如何设计与规划？</a><br><a href=\"http://www.zhihu.com/question/20380990/answer/14960006\" target=\"_blank\" rel=\"external\">网站的消息（通知）系统一般是如何实现的？</a></p>\n<p>关于这部分功能，我们还没有具体的实现方法，暂时也无法讲得更加详细。⊙﹏⊙</p>\n<h2 id=\"五个实体\"><a href=\"#五个实体\" class=\"headerlink\" title=\"五个实体\"></a>五个实体</h2><p>通过上面的分析，大概知道做这个消息系统，需要哪些实体类：</p>\n<ol>\n<li>用户消息队列 UserNotify</li>\n<li>用户 User</li>\n<li>订阅 Subscription</li>\n<li>订阅设置 SubscriptionConfig</li>\n<li>消息 Notify<ul>\n<li>通告 Announce</li>\n<li>提醒 Remind</li>\n<li>信息 Message</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"行为分解\"><a href=\"#行为分解\" class=\"headerlink\" title=\"行为分解\"></a>行为分解</h2><p>说了这么多，整理一下整个消息流程的一些行为：</p>\n<ul>\n<li>系统或者管理员，创建消息 <ul>\n<li>createNotify (make announce | remind | message)</li>\n</ul>\n</li>\n<li>用户，订阅消息，取消订阅<ul>\n<li>subscribe, cancelSubscription</li>\n</ul>\n</li>\n<li>用户管理订阅设置<ul>\n<li>getSubscriptionConfig, updateSubscriptionConfig</li>\n</ul>\n</li>\n<li>用户，拉取消息<ul>\n<li>pullNotify (pull announce | remind | message | all)</li>\n</ul>\n</li>\n<li>用户，查询消息队列<ul>\n<li>getUserNotify(get announce | remind | message | all)</li>\n</ul>\n</li>\n<li>用户阅读消息<ul>\n<li>read</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>在本文的「下篇」我们来探讨一下：模型怎么做、数据库怎么设计、代码结构怎么来、一些逻辑上的时序图应该是怎么样的。</p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>由于文章篇幅较长，而作者精力有限，不希望这么早就精尽人亡，故分成上下篇来写消息系统的设计与实现。上篇主要讲的是一些概念，搞清楚我们要做的这个消息系统的主要内容。而下篇主要讲具体的实现，会包括架构设计，数据库设计，业务流程详细的实现等。</p>\n</blockquote>\n<blockquote>\n<p>整个系统的设计与实现，并非我一人之力就可以完成的。这其中是同事们大家一起讨论与商讨的结果，而我只是把它细化，呈现出来。</p>\n</blockquote>\n<blockquote>\n<p>我只是一个会思考的idea搬运工。</p>\n</blockquote>\n<h2 id=\"产品分析\"><a href=\"#产品分析\" class=\"headerlink\" title=\"产品分析\"></a>产品分析</h2><p>首先我们来看一下市场上关于消息的实现是怎么样的。</p>\n<h3 id=\"简书\"><a href=\"#简书\" class=\"headerlink\" title=\"简书\"></a>简书</h3><p>简书的消息系统主要分了两种</p>\n<ul>\n<li>简信</li>\n<li>提醒</li>\n</ul>\n<p><strong>简信</strong><br>简信的性质其实跟私信是一样的，是用户发送给用户的一则消息，有具体的信息内容。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/c3aad7dc-5914-4c5c-9f88-34e40077d0ff.jpg\" alt=\"简书简信\"></p>\n<p><strong>提醒</strong><br>而提醒，则是系统发送的一则消息，其文案格式是固定的，并且对特殊对象一般拥有超链接。<br><img src=\"http://xia-dev.b0.upaiyun.com/b0ee917e-0776-4aa9-bf4a-0a2cd33ca853.jpg\" alt=\"简书提醒\"></p>\n<h3 id=\"知乎\"><a href=\"#知乎\" class=\"headerlink\" title=\"知乎\"></a>知乎</h3><p>知乎跟简书一样，主要分了两种：</p>\n<ul>\n<li>私信</li>\n<li>消息</li>\n</ul>\n<p><strong>私信</strong><br>跟简书一样，使用户发送给用户的一则消息，也可以是管理员发送给用户的消息。<br><img src=\"http://xia-dev.b0.upaiyun.com/a6b102ed-d337-41d2-a5d3-b3923650de16.jpg\" width=250></img></p>\n<p><strong>消息</strong><br>知乎的消息比简书的提醒有过之而无不及，知乎会对多条相似的消息进行聚会，以达到减轻用户阅读压力的体验。<br><img src=\"http://xia-dev.b0.upaiyun.com/5f90952e-2fe6-447f-affb-8a7c9a04d0ab.jpg\" width=450></img></p>\n<h2 id=\"消息的三种分类\"><a href=\"#消息的三种分类\" class=\"headerlink\" title=\"消息的三种分类\"></a>消息的三种分类</h2><p>通过两种产品的简单分析，得出他们的消息有两种分类，在这基础上，我们再加上一种：公告。<br>公告的主要性质是系统发送一则含有具体内容的消息，站内所有用户都能读取到这条消息。<br>所以，消息有三种分类：</p>\n<ol>\n<li>公告 Announce</li>\n<li>提醒 Remind</li>\n<li>私信 Message</li>\n</ol>\n<h2 id=\"提醒的语言分析\"><a href=\"#提醒的语言分析\" class=\"headerlink\" title=\"提醒的语言分析\"></a>提醒的语言分析</h2><p>我们从简书取一组提醒样本：</p>\n<ul>\n<li>3dbe1bd90774 关注了你</li>\n<li>magicdawn 喜欢了你的文章 《单点登录的三种实现方式》</li>\n<li>无良程序 喜欢了你的文章 《基于RESTful API 怎么设计用户权限控制？》</li>\n<li>alexcc4 喜欢了你的文章 《在Nodejs中贯彻单元测试》</li>\n<li>你在《基于RESTful API 怎么设计用户权限控制？》中收到一条 cnlinjie 的评论</li>\n<li>你的文章《Session原理》已被加入专题 《ios开发》</li>\n</ul>\n<p>分析句子结构，提醒的内容无非就是</p>\n<blockquote>\n<p>「谁对一样属于谁的事物做了什么操作」<br>「someone do something in someone’s something」</p>\n</blockquote>\n<p>someone = 提醒的触发者，或者发送者，标记为sender<br>do something = 提醒的动作，评论、喜欢、关注都属于一个动作，标记为action<br>something = 提醒的动作作用对象，这就具体到是哪一篇文章，标记为target<br>someone’s = 提醒的动作作用对象的所有者，标记为targetOwner</p>\n<p>这就清楚了，sender和targetOwner就是网站的用户，而target是具体到哪一篇文章，如果提醒的对象不仅仅局限于文章，还有其他的话，就需要增加一项targetType，来标记目标是文章还是其他的什么。而action，则是固定的，整个网站会触发提醒的动作可能就只有那几样：评论、喜欢、关注…..（或者其他业务需要提醒的动作）</p>\n<h2 id=\"消息的两种获取方式\"><a href=\"#消息的两种获取方式\" class=\"headerlink\" title=\"消息的两种获取方式\"></a>消息的两种获取方式</h2><ul>\n<li>推 Push</li>\n<li>拉 Pull</li>\n</ul>\n<p><strong>以知乎为例</strong><br>推的比较常见，需要针对某一个问题维护着一张关注者的列表，每当触发这个问题推送的条件时（例如有人回答问题），就把这个通知发送给每个关注者。</p>\n<p>拉的相对麻烦一点，就是推的反向，例如每个用户都有一张关注问题的列表，每当用户上线的时候，对每个问题进行轮询，当问题的事件列表出现了比我原本时间戳大的信息就进行拉取。</p>\n<p><strong>而我们则根据消息的不同分类采用不同的获取方式</strong>：<br>通告和提醒，适合使用拉取的方式，消息产生之后，会存在消息表中，用户在某一特定的时间根据自己关注问题的表进行消息的拉取，然后添加到自己的消息队列中，</p>\n<p>信息，适合使用推的方式，在发送者建立一条信息之后，同时指定接收者，把消息添加到接收者的消息队列中。</p>\n<h2 id=\"订阅\"><a href=\"#订阅\" class=\"headerlink\" title=\"订阅\"></a>订阅</h2><p>根据提醒使用拉取的方式，需要维护一个关注某一事物的列表。<br>这种行为，我们称之为：<strong>「订阅」Subscribe </strong></p>\n<p><strong>一则订阅有以下三个核心属性</strong>：</p>\n<ul>\n<li>订阅的目标 target</li>\n<li>订阅的目标类型 targetType</li>\n<li>订阅的动作 action</li>\n</ul>\n<p>比如我发布了一篇文章，那么我会订阅文章《XXX》的评论动作，所以文章《XXX》每被人评论了，就需要发送一则提醒告知我。</p>\n<p><strong>订阅的规则还可以扩展</strong><br>我喜欢了一篇文章，和我发布了一篇文章，订阅的动作可能不一样。<br>喜欢了一篇文章，我希望我订阅这篇文章更新、评论的动作。<br>而发布了一篇文章，我希望我只是订阅这篇文章的评论动作。</p>\n<p>这时候就需要多一个参数：subscribReason<br>不同的subscribReason，对应着一个动作数组，<br>subscribReason = 喜欢，对应着 actions = [更新，评论]<br>subscribReason = 发布，对应着 actions = [评论]</p>\n<p><strong>订阅的规则还还可以扩展</strong><br>用户可能会有一个自己的订阅设置，比如对于所有的喜欢的动作，我都不希望接收。<br>比如Knewone的提醒设置<br><img src=\"http://xia-dev.b0.upaiyun.com/80cc4aaf-0568-478c-8513-b8821e57520f.jpg\" alt=\"Knewone提醒设置\" width=\"500\"></p>\n<p>所以我们需要再维护一个表：<strong>SubscriptionConfig</strong>，来存放用户的提醒设置。<br>并且，当用户没有提醒设置的时候，可以使用系统提供的一套默认设置：<strong>defaultSubscriptionConfig</strong></p>\n<h2 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h2><p>如果我发布了一篇文章《XXX》，在我不在线的时候，被评论了10遍，当我一上线的时候，应该是收到十条信息类似于：「谁谁谁评论了你的文章《XXX》」?<br>还是应该收到一条信息：「甲、乙、丙、丁…评论了你的文章《XXX》」?</p>\n<p>知乎在聚合上做的很优秀，要知道他们要实现这个还是挺有技术的：<br><a href=\"http://www.zhihu.com/question/22394809\">知乎的消息机制，在技术上如何设计与规划？</a><br><a href=\"http://www.zhihu.com/question/20380990/answer/14960006\">网站的消息（通知）系统一般是如何实现的？</a></p>\n<p>关于这部分功能，我们还没有具体的实现方法，暂时也无法讲得更加详细。⊙﹏⊙</p>\n<h2 id=\"五个实体\"><a href=\"#五个实体\" class=\"headerlink\" title=\"五个实体\"></a>五个实体</h2><p>通过上面的分析，大概知道做这个消息系统，需要哪些实体类：</p>\n<ol>\n<li>用户消息队列 UserNotify</li>\n<li>用户 User</li>\n<li>订阅 Subscription</li>\n<li>订阅设置 SubscriptionConfig</li>\n<li>消息 Notify<ul>\n<li>通告 Announce</li>\n<li>提醒 Remind</li>\n<li>信息 Message</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"行为分解\"><a href=\"#行为分解\" class=\"headerlink\" title=\"行为分解\"></a>行为分解</h2><p>说了这么多，整理一下整个消息流程的一些行为：</p>\n<ul>\n<li>系统或者管理员，创建消息 <ul>\n<li>createNotify (make announce | remind | message)</li>\n</ul>\n</li>\n<li>用户，订阅消息，取消订阅<ul>\n<li>subscribe, cancelSubscription</li>\n</ul>\n</li>\n<li>用户管理订阅设置<ul>\n<li>getSubscriptionConfig, updateSubscriptionConfig</li>\n</ul>\n</li>\n<li>用户，拉取消息<ul>\n<li>pullNotify (pull announce | remind | message | all)</li>\n</ul>\n</li>\n<li>用户，查询消息队列<ul>\n<li>getUserNotify(get announce | remind | message | all)</li>\n</ul>\n</li>\n<li>用户阅读消息<ul>\n<li>read</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>在本文的「下篇」我们来探讨一下：模型怎么做、数据库怎么设计、代码结构怎么来、一些逻辑上的时序图应该是怎么样的。</p>\n</blockquote>\n"},{"title":"打造高效个性Terminal（二）之 zsh","date":"2016-08-11T13:16:00.000Z","_content":"\n# oh-my-zsh\n如果说**iTerm**塑造了一个婀娜多姿颜值高的貌美姑娘，那么**zsh**就是给她塑造了一个柔情侠骨百事通的女汉子之心。\n\n## 简介 <small>Introduction</small>\n\n对于**zsh**的作用，摘自池建强老师的一段：\n> 目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史「终极 Shell」，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：[https://github.com/robbyrussell/oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)。\n\n**oh-my-zsh** 是一个社区驱动用于管理zsh的框架，囊括了140多个主题，200多个可选插件（如rails, git, OSX, hub, brew, ant, php, python etc.）。\n\n## 安装 <small>Installation</small>\n**via curl**\n```\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n**via wget**\n```\nsh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"\n```\n\n## 配置 <small>Configuration</small>\nzsh的配置主要集中在用户当前目录的`.zshrc`里，用vim或者你喜欢的其他编辑器打开这个文件，在里面可以修改主题、插件以及定义自己的环境变量等操作。\n\n## 主题 <small>Themes</small>\n\n用vim打开`~/.zshrc`中，可以看到这样配置\n```\n...\n# Set name of the theme to load.\n# Look in ~/.oh-my-zsh/themes/\n# Optionally, if you set this to \"random\", it'll load a random theme each\n# time that oh-my-zsh is loaded.\nZSH_THEME=\"robbyrussell\"\n...\n```\n修改`ZSH_THEME`的值就可以更换主题。\n\n默认的主题是`robbyrussell`，这个并不是最精彩，也并不是最简单的一个，只是对于其作者Robby来说最适合的一个。\n\n可以通过访问`~/.oh-my-zsh/themes/`目录查看哪些可选的主题\n\n```\n$ tree themes\nthemes\n├── 3den.zsh-theme\n├── Soliah.zsh-theme\n├── adben.zsh-theme\n├── af-magic.zsh-theme\n├── afowler.zsh-theme\n├── agnoster.zsh-theme\n...\n0 directories, 141 files\n```\n\n更多关于各个主题的详细介绍见 [zsh themes](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)，另外还有不少并不是自带的主题，见[more external themes](https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes)\n\n### Powerline Fonts\n如果你查看过zsh的主题列表的话，你会发现不少主题会有这样的样式，\n\n![混合](/image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg)\n\n然而，当你选择了这样的主题，会发现实际是这样的\n\n![23.pic.jpg](/image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg)\n\n因为，这些主题都依赖于一种字体[powerline fonts](https://github.com/powerline/fonts)，`powerline fonts`是vim增强组件[vim powerline](https://github.com/Lokaltog/vim-powerline)附属的字体，如果要使用依赖这种字体的主题，要在系统中安装该字体。\n\n### 安装 powerline fonts\n```\n// 下载powerline fonts项目\ngit clone https://github.com/powerline/fonts\n// 执行安装\n./fonts/install.sh\n```\n\n### 配置iTerm\n在`Preperence → Profiles → Text → Front` 中，\n和`Preperence → Profiles → Text → Non-ASCII Font`中\n改变字体为`Sauce Code Powerline`\n\n![改变字体](/image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg)\n\n## 插件 <small>Plugins</small>\n用vim打开`~/.zshrc`中，可以看到这样配置\n```\n...\n# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)\n# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/\n# Example format: plugins=(rails git textmate ruby lighthouse)\n# Add wisely, as too many plugins slow down shell startup.\nplugins=(git)\n...\n```\n修改`plugins`的值就可以修改或添加插件。\n\n下面介绍几款我常用的插件\n\n### [autojump](https://github.com/wting/autojump)\n> A cd command that learns - easily navigate directories from the command line\n\n一款快捷跳转目标路径的插件，支持模糊匹配，自动补全，历史记录等功能。\n\n![autojump](/image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif)\n\n### [dirhistory](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#dirhistory)\n> This plugin allows you to navigate the history of previous current-working-directories using ALT-LEFT and ALT-RIGHT. ALT-LEFT moves back to directories that the user has changed to in the past, and ALT-RIGHT undoes ALT-LEFT.\n\n一款支持目录的上翻，下翻功能的插件。\n\n![dirhistory](/image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif)\n\n### [osx](https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx)\n> This plugin provides a few utilities to make it more enjoyable on OSX.\n\n一款增加了一些在OSX上实用的命令插件。\n\n\n| Command       | Description                                    |\n|:--------------|:-----------------------------------------------|\n| `tab`         | Open the current directory in a new tab        |\n| `ofd`         | Open the current directory in a Finder window  |\n| `pfd`         | Return the path of the frontmost Finder window |\n| `pfs`         | Return the current Finder selection            |\n| `cdf`         | `cd` to the current Finder directory           |\n| `pushdf`      | `pushd` to the current Finder directory        |\n| `quick-look`  | Quick-Look a specified file                    |\n| `man-preview` | Open a specified man page in Preview app       |\n\n\n### [git](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git)\n> The git plugin provides many aliases and a few useful functions.\n\n一款提供git别名命令以及一些方法命令的插件\n\n\n### [git-extras](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#git-extras)\n\n一款扩展了不少方便快捷git命令的插件\n\n### More Plugins\n更多的插件介绍见 [zsh plugins](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins)\n\n## vi(vim) 基础\n使用命令行的时候，难免会遇到要编辑文档的时刻，尽管不是vim党，但是如果掌握vim的基本操作，对效率还是有大大提升的。\n\n### vi与vim的关系\n简单来说，vi是老师的文字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。vim则可以说是程序开发者的一项很好用的工具，就连vim的官方网站([http://www.vim.org/](http://www.vim.org/))自己也说vim是一个「程序开发工具」而不是文字处理软件。\n\n### 三种模式\n基本上vi中共分为3种模式，分别是「一般模式」，「编辑模式」与「命令行模式」\n\n* 一般模式\n以vi打开一个文件，默认就是一般模式，这个模式中，可以按下`i`来进入编辑模式，按下`ESC`则退出编辑模式回到一般模式。\n在这个模式中可以删除字符、删除行、复制、黏贴。\n\n* 编辑模式\n编辑模式能真正的编辑文本。\n\n* 命令模式\n在一般模式中，输入`:`,`/`,`?`中的一个可以进入命令行模式，进行诸如数据查找操作，读取、保存、离开vi等等操作。\n\n### 常用操作\n掌握下面的十一个命令，就足够你在vim中生存了。\n\n**移动光标**\n\n* hjkl : 你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。\n\n**行操作**\n\n* dd : 删除当前行，并把删除的行存到剪贴板里\n* yy : 复制当前行。\n* p  : 黏贴剪贴板\n\n**保存退出**\n\n* :w : 保存已编辑的文集\n* :q : 退出编辑\n* :wq : 保存并退出\n* :help : 显示相关命令的帮助(退出帮助需要输入:q)\n\n**搜索**\n* /word : 向下寻找一个名为word的字符串 \n* ?word : 向上寻找一个名为word的字符串\n* n : 重复前一个查找的操作\n\n# 文末福利，安抚你的强迫症\n感谢你能耐心的看到这里，给你安利一个强迫症患者福音的窗口控制工具：[Spectacle](https://www.spectacleapp.com/)\n\nSpectacle能通过快捷键，很轻易的排列好窗口的大小。\n\n![Spectacle](/image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif)\n\n# 参考\nhttp://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively\nhttps://github.com/robbyrussell/oh-my-zsh/wiki/Plugins\nhttp://www.vim.org/\nhttp://macshuo.com/?p=676\nhttp://swiftcafe.io/2015/07/25/iterm/\n No newline at end of file\n","source":"_posts/打造高效个性Terminal（二）之 zsh.md","raw":"---\ntitle: 打造高效个性Terminal（二）之 zsh\ncategory: 搬砖码农\ndate: 2016-08-11 21:16:00\ntags:\n- Tool Kit\n---\n\n# oh-my-zsh\n如果说**iTerm**塑造了一个婀娜多姿颜值高的貌美姑娘，那么**zsh**就是给她塑造了一个柔情侠骨百事通的女汉子之心。\n\n## 简介 <small>Introduction</small>\n\n对于**zsh**的作用，摘自池建强老师的一段：\n> 目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史「终极 Shell」，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：[https://github.com/robbyrussell/oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)。\n\n**oh-my-zsh** 是一个社区驱动用于管理zsh的框架，囊括了140多个主题，200多个可选插件（如rails, git, OSX, hub, brew, ant, php, python etc.）。\n\n## 安装 <small>Installation</small>\n**via curl**\n```\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n**via wget**\n```\nsh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"\n```\n\n## 配置 <small>Configuration</small>\nzsh的配置主要集中在用户当前目录的`.zshrc`里，用vim或者你喜欢的其他编辑器打开这个文件，在里面可以修改主题、插件以及定义自己的环境变量等操作。\n\n## 主题 <small>Themes</small>\n\n用vim打开`~/.zshrc`中，可以看到这样配置\n```\n...\n# Set name of the theme to load.\n# Look in ~/.oh-my-zsh/themes/\n# Optionally, if you set this to \"random\", it'll load a random theme each\n# time that oh-my-zsh is loaded.\nZSH_THEME=\"robbyrussell\"\n...\n```\n修改`ZSH_THEME`的值就可以更换主题。\n\n默认的主题是`robbyrussell`，这个并不是最精彩，也并不是最简单的一个，只是对于其作者Robby来说最适合的一个。\n\n可以通过访问`~/.oh-my-zsh/themes/`目录查看哪些可选的主题\n\n```\n$ tree themes\nthemes\n├── 3den.zsh-theme\n├── Soliah.zsh-theme\n├── adben.zsh-theme\n├── af-magic.zsh-theme\n├── afowler.zsh-theme\n├── agnoster.zsh-theme\n...\n0 directories, 141 files\n```\n\n更多关于各个主题的详细介绍见 [zsh themes](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)，另外还有不少并不是自带的主题，见[more external themes](https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes)\n\n### Powerline Fonts\n如果你查看过zsh的主题列表的话，你会发现不少主题会有这样的样式，\n\n![混合](/image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg)\n\n然而，当你选择了这样的主题，会发现实际是这样的\n\n![23.pic.jpg](/image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg)\n\n因为，这些主题都依赖于一种字体[powerline fonts](https://github.com/powerline/fonts)，`powerline fonts`是vim增强组件[vim powerline](https://github.com/Lokaltog/vim-powerline)附属的字体，如果要使用依赖这种字体的主题，要在系统中安装该字体。\n\n### 安装 powerline fonts\n```\n// 下载powerline fonts项目\ngit clone https://github.com/powerline/fonts\n// 执行安装\n./fonts/install.sh\n```\n\n### 配置iTerm\n在`Preperence → Profiles → Text → Front` 中，\n和`Preperence → Profiles → Text → Non-ASCII Font`中\n改变字体为`Sauce Code Powerline`\n\n![改变字体](/image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg)\n\n## 插件 <small>Plugins</small>\n用vim打开`~/.zshrc`中，可以看到这样配置\n```\n...\n# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)\n# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/\n# Example format: plugins=(rails git textmate ruby lighthouse)\n# Add wisely, as too many plugins slow down shell startup.\nplugins=(git)\n...\n```\n修改`plugins`的值就可以修改或添加插件。\n\n下面介绍几款我常用的插件\n\n### [autojump](https://github.com/wting/autojump)\n> A cd command that learns - easily navigate directories from the command line\n\n一款快捷跳转目标路径的插件，支持模糊匹配，自动补全，历史记录等功能。\n\n![autojump](/image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif)\n\n### [dirhistory](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#dirhistory)\n> This plugin allows you to navigate the history of previous current-working-directories using ALT-LEFT and ALT-RIGHT. ALT-LEFT moves back to directories that the user has changed to in the past, and ALT-RIGHT undoes ALT-LEFT.\n\n一款支持目录的上翻，下翻功能的插件。\n\n![dirhistory](/image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif)\n\n### [osx](https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx)\n> This plugin provides a few utilities to make it more enjoyable on OSX.\n\n一款增加了一些在OSX上实用的命令插件。\n\n\n| Command       | Description                                    |\n|:--------------|:-----------------------------------------------|\n| `tab`         | Open the current directory in a new tab        |\n| `ofd`         | Open the current directory in a Finder window  |\n| `pfd`         | Return the path of the frontmost Finder window |\n| `pfs`         | Return the current Finder selection            |\n| `cdf`         | `cd` to the current Finder directory           |\n| `pushdf`      | `pushd` to the current Finder directory        |\n| `quick-look`  | Quick-Look a specified file                    |\n| `man-preview` | Open a specified man page in Preview app       |\n\n\n### [git](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git)\n> The git plugin provides many aliases and a few useful functions.\n\n一款提供git别名命令以及一些方法命令的插件\n\n\n### [git-extras](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#git-extras)\n\n一款扩展了不少方便快捷git命令的插件\n\n### More Plugins\n更多的插件介绍见 [zsh plugins](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins)\n\n## vi(vim) 基础\n使用命令行的时候，难免会遇到要编辑文档的时刻，尽管不是vim党，但是如果掌握vim的基本操作，对效率还是有大大提升的。\n\n### vi与vim的关系\n简单来说，vi是老师的文字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。vim则可以说是程序开发者的一项很好用的工具，就连vim的官方网站([http://www.vim.org/](http://www.vim.org/))自己也说vim是一个「程序开发工具」而不是文字处理软件。\n\n### 三种模式\n基本上vi中共分为3种模式，分别是「一般模式」，「编辑模式」与「命令行模式」\n\n* 一般模式\n以vi打开一个文件，默认就是一般模式，这个模式中，可以按下`i`来进入编辑模式，按下`ESC`则退出编辑模式回到一般模式。\n在这个模式中可以删除字符、删除行、复制、黏贴。\n\n* 编辑模式\n编辑模式能真正的编辑文本。\n\n* 命令模式\n在一般模式中，输入`:`,`/`,`?`中的一个可以进入命令行模式，进行诸如数据查找操作，读取、保存、离开vi等等操作。\n\n### 常用操作\n掌握下面的十一个命令，就足够你在vim中生存了。\n\n**移动光标**\n\n* hjkl : 你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。\n\n**行操作**\n\n* dd : 删除当前行，并把删除的行存到剪贴板里\n* yy : 复制当前行。\n* p  : 黏贴剪贴板\n\n**保存退出**\n\n* :w : 保存已编辑的文集\n* :q : 退出编辑\n* :wq : 保存并退出\n* :help : 显示相关命令的帮助(退出帮助需要输入:q)\n\n**搜索**\n* /word : 向下寻找一个名为word的字符串 \n* ?word : 向上寻找一个名为word的字符串\n* n : 重复前一个查找的操作\n\n# 文末福利，安抚你的强迫症\n感谢你能耐心的看到这里，给你安利一个强迫症患者福音的窗口控制工具：[Spectacle](https://www.spectacleapp.com/)\n\nSpectacle能通过快捷键，很轻易的排列好窗口的大小。\n\n![Spectacle](/image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif)\n\n# 参考\nhttp://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively\nhttps://github.com/robbyrussell/oh-my-zsh/wiki/Plugins\nhttp://www.vim.org/\nhttp://macshuo.com/?p=676\nhttp://swiftcafe.io/2015/07/25/iterm/\n No newline at end of file\n","slug":"打造高效个性Terminal（二）之 zsh","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8rc001ixwrlmrvk2dp4","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"oh-my-zsh\"><a href=\"#oh-my-zsh\" class=\"headerlink\" title=\"oh-my-zsh\"></a>oh-my-zsh</h1><p>如果说<strong>iTerm</strong>塑造了一个婀娜多姿颜值高的貌美姑娘，那么<strong>zsh</strong>就是给她塑造了一个柔情侠骨百事通的女汉子之心。</p>\n<h2 id=\"简介-Introduction\"><a href=\"#简介-Introduction\" class=\"headerlink\" title=\"简介 Introduction\"></a>简介 <small>Introduction</small></h2><p>对于<strong>zsh</strong>的作用，摘自池建强老师的一段：</p>\n<blockquote>\n<p>目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史「终极 Shell」，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：<a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"external\">https://github.com/robbyrussell/oh-my-zsh</a>。</p>\n</blockquote>\n<p><strong>oh-my-zsh</strong> 是一个社区驱动用于管理zsh的框架，囊括了140多个主题，200多个可选插件（如rails, git, OSX, hub, brew, ant, php, python etc.）。</p>\n<h2 id=\"安装-Installation\"><a href=\"#安装-Installation\" class=\"headerlink\" title=\"安装 Installation\"></a>安装 <small>Installation</small></h2><p><strong>via curl</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>via wget</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"配置-Configuration\"><a href=\"#配置-Configuration\" class=\"headerlink\" title=\"配置 Configuration\"></a>配置 <small>Configuration</small></h2><p>zsh的配置主要集中在用户当前目录的<code>.zshrc</code>里，用vim或者你喜欢的其他编辑器打开这个文件，在里面可以修改主题、插件以及定义自己的环境变量等操作。</p>\n<h2 id=\"主题-Themes\"><a href=\"#主题-Themes\" class=\"headerlink\" title=\"主题 Themes\"></a>主题 <small>Themes</small></h2><p>用vim打开<code>~/.zshrc</code>中，可以看到这样配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"># Set name of the theme to load.</span><br><span class=\"line\"># Look in ~/.oh-my-zsh/themes/</span><br><span class=\"line\"># Optionally, if you set this to &quot;random&quot;, it&apos;ll load a random theme each</span><br><span class=\"line\"># time that oh-my-zsh is loaded.</span><br><span class=\"line\">ZSH_THEME=&quot;robbyrussell&quot;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>修改<code>ZSH_THEME</code>的值就可以更换主题。</p>\n<p>默认的主题是<code>robbyrussell</code>，这个并不是最精彩，也并不是最简单的一个，只是对于其作者Robby来说最适合的一个。</p>\n<p>可以通过访问<code>~/.oh-my-zsh/themes/</code>目录查看哪些可选的主题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tree themes</span><br><span class=\"line\">themes</span><br><span class=\"line\">├── 3den.zsh-theme</span><br><span class=\"line\">├── Soliah.zsh-theme</span><br><span class=\"line\">├── adben.zsh-theme</span><br><span class=\"line\">├── af-magic.zsh-theme</span><br><span class=\"line\">├── afowler.zsh-theme</span><br><span class=\"line\">├── agnoster.zsh-theme</span><br><span class=\"line\">...</span><br><span class=\"line\">0 directories, 141 files</span><br></pre></td></tr></table></figure>\n<p>更多关于各个主题的详细介绍见 <a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/themes\" target=\"_blank\" rel=\"external\">zsh themes</a>，另外还有不少并不是自带的主题，见<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes\" target=\"_blank\" rel=\"external\">more external themes</a></p>\n<h3 id=\"Powerline-Fonts\"><a href=\"#Powerline-Fonts\" class=\"headerlink\" title=\"Powerline Fonts\"></a>Powerline Fonts</h3><p>如果你查看过zsh的主题列表的话，你会发现不少主题会有这样的样式，</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg\" alt=\"混合\"></p>\n<p>然而，当你选择了这样的主题，会发现实际是这样的</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg\" alt=\"23.pic.jpg\"></p>\n<p>因为，这些主题都依赖于一种字体<a href=\"https://github.com/powerline/fonts\" target=\"_blank\" rel=\"external\">powerline fonts</a>，<code>powerline fonts</code>是vim增强组件<a href=\"https://github.com/Lokaltog/vim-powerline\" target=\"_blank\" rel=\"external\">vim powerline</a>附属的字体，如果要使用依赖这种字体的主题，要在系统中安装该字体。</p>\n<h3 id=\"安装-powerline-fonts\"><a href=\"#安装-powerline-fonts\" class=\"headerlink\" title=\"安装 powerline fonts\"></a>安装 powerline fonts</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 下载powerline fonts项目</span><br><span class=\"line\">git clone https://github.com/powerline/fonts</span><br><span class=\"line\">// 执行安装</span><br><span class=\"line\">./fonts/install.sh</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置iTerm\"><a href=\"#配置iTerm\" class=\"headerlink\" title=\"配置iTerm\"></a>配置iTerm</h3><p>在<code>Preperence → Profiles → Text → Front</code> 中，<br>和<code>Preperence → Profiles → Text → Non-ASCII Font</code>中<br>改变字体为<code>Sauce Code Powerline</code></p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg\" alt=\"改变字体\"></p>\n<h2 id=\"插件-Plugins\"><a href=\"#插件-Plugins\" class=\"headerlink\" title=\"插件 Plugins\"></a>插件 <small>Plugins</small></h2><p>用vim打开<code>~/.zshrc</code>中，可以看到这样配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"># Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)</span><br><span class=\"line\"># Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span><br><span class=\"line\"># Example format: plugins=(rails git textmate ruby lighthouse)</span><br><span class=\"line\"># Add wisely, as too many plugins slow down shell startup.</span><br><span class=\"line\">plugins=(git)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>修改<code>plugins</code>的值就可以修改或添加插件。</p>\n<p>下面介绍几款我常用的插件</p>\n<h3 id=\"autojump\"><a href=\"#autojump\" class=\"headerlink\" title=\"autojump\"></a><a href=\"https://github.com/wting/autojump\" target=\"_blank\" rel=\"external\">autojump</a></h3><blockquote>\n<p>A cd command that learns - easily navigate directories from the command line</p>\n</blockquote>\n<p>一款快捷跳转目标路径的插件，支持模糊匹配，自动补全，历史记录等功能。</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif\" alt=\"autojump\"></p>\n<h3 id=\"dirhistory\"><a href=\"#dirhistory\" class=\"headerlink\" title=\"dirhistory\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#dirhistory\" target=\"_blank\" rel=\"external\">dirhistory</a></h3><blockquote>\n<p>This plugin allows you to navigate the history of previous current-working-directories using ALT-LEFT and ALT-RIGHT. ALT-LEFT moves back to directories that the user has changed to in the past, and ALT-RIGHT undoes ALT-LEFT.</p>\n</blockquote>\n<p>一款支持目录的上翻，下翻功能的插件。</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif\" alt=\"dirhistory\"></p>\n<h3 id=\"osx\"><a href=\"#osx\" class=\"headerlink\" title=\"osx\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx\" target=\"_blank\" rel=\"external\">osx</a></h3><blockquote>\n<p>This plugin provides a few utilities to make it more enjoyable on OSX.</p>\n</blockquote>\n<p>一款增加了一些在OSX上实用的命令插件。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>tab</code></td>\n<td style=\"text-align:left\">Open the current directory in a new tab</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ofd</code></td>\n<td style=\"text-align:left\">Open the current directory in a Finder window</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pfd</code></td>\n<td style=\"text-align:left\">Return the path of the frontmost Finder window</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pfs</code></td>\n<td style=\"text-align:left\">Return the current Finder selection</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>cdf</code></td>\n<td style=\"text-align:left\"><code>cd</code> to the current Finder directory</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pushdf</code></td>\n<td style=\"text-align:left\"><code>pushd</code> to the current Finder directory</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>quick-look</code></td>\n<td style=\"text-align:left\">Quick-Look a specified file</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>man-preview</code></td>\n<td style=\"text-align:left\">Open a specified man page in Preview app</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git\" target=\"_blank\" rel=\"external\">git</a></h3><blockquote>\n<p>The git plugin provides many aliases and a few useful functions.</p>\n</blockquote>\n<p>一款提供git别名命令以及一些方法命令的插件</p>\n<h3 id=\"git-extras\"><a href=\"#git-extras\" class=\"headerlink\" title=\"git-extras\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#git-extras\" target=\"_blank\" rel=\"external\">git-extras</a></h3><p>一款扩展了不少方便快捷git命令的插件</p>\n<h3 id=\"More-Plugins\"><a href=\"#More-Plugins\" class=\"headerlink\" title=\"More Plugins\"></a>More Plugins</h3><p>更多的插件介绍见 <a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins\" target=\"_blank\" rel=\"external\">zsh plugins</a></p>\n<h2 id=\"vi-vim-基础\"><a href=\"#vi-vim-基础\" class=\"headerlink\" title=\"vi(vim) 基础\"></a>vi(vim) 基础</h2><p>使用命令行的时候，难免会遇到要编辑文档的时刻，尽管不是vim党，但是如果掌握vim的基本操作，对效率还是有大大提升的。</p>\n<h3 id=\"vi与vim的关系\"><a href=\"#vi与vim的关系\" class=\"headerlink\" title=\"vi与vim的关系\"></a>vi与vim的关系</h3><p>简单来说，vi是老师的文字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。vim则可以说是程序开发者的一项很好用的工具，就连vim的官方网站(<a href=\"http://www.vim.org/\" target=\"_blank\" rel=\"external\">http://www.vim.org/</a>)自己也说vim是一个「程序开发工具」而不是文字处理软件。</p>\n<h3 id=\"三种模式\"><a href=\"#三种模式\" class=\"headerlink\" title=\"三种模式\"></a>三种模式</h3><p>基本上vi中共分为3种模式，分别是「一般模式」，「编辑模式」与「命令行模式」</p>\n<ul>\n<li><p>一般模式<br>以vi打开一个文件，默认就是一般模式，这个模式中，可以按下<code>i</code>来进入编辑模式，按下<code>ESC</code>则退出编辑模式回到一般模式。<br>在这个模式中可以删除字符、删除行、复制、黏贴。</p>\n</li>\n<li><p>编辑模式<br>编辑模式能真正的编辑文本。</p>\n</li>\n<li><p>命令模式<br>在一般模式中，输入<code>:</code>,<code>/</code>,<code>?</code>中的一个可以进入命令行模式，进行诸如数据查找操作，读取、保存、离开vi等等操作。</p>\n</li>\n</ul>\n<h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><p>掌握下面的十一个命令，就足够你在vim中生存了。</p>\n<p><strong>移动光标</strong></p>\n<ul>\n<li>hjkl : 你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。</li>\n</ul>\n<p><strong>行操作</strong></p>\n<ul>\n<li>dd : 删除当前行，并把删除的行存到剪贴板里</li>\n<li>yy : 复制当前行。</li>\n<li>p  : 黏贴剪贴板</li>\n</ul>\n<p><strong>保存退出</strong></p>\n<ul>\n<li>:w : 保存已编辑的文集</li>\n<li>:q : 退出编辑</li>\n<li>:wq : 保存并退出</li>\n<li>:help : 显示相关命令的帮助(退出帮助需要输入:q)</li>\n</ul>\n<p><strong>搜索</strong></p>\n<ul>\n<li>/word : 向下寻找一个名为word的字符串 </li>\n<li>?word : 向上寻找一个名为word的字符串</li>\n<li>n : 重复前一个查找的操作</li>\n</ul>\n<h1 id=\"文末福利，安抚你的强迫症\"><a href=\"#文末福利，安抚你的强迫症\" class=\"headerlink\" title=\"文末福利，安抚你的强迫症\"></a>文末福利，安抚你的强迫症</h1><p>感谢你能耐心的看到这里，给你安利一个强迫症患者福音的窗口控制工具：<a href=\"https://www.spectacleapp.com/\" target=\"_blank\" rel=\"external\">Spectacle</a></p>\n<p>Spectacle能通过快捷键，很轻易的排列好窗口的大小。</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif\" alt=\"Spectacle\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively\" target=\"_blank\" rel=\"external\">http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively</a><br><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins\" target=\"_blank\" rel=\"external\">https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins</a><br><a href=\"http://www.vim.org/\" target=\"_blank\" rel=\"external\">http://www.vim.org/</a><br><a href=\"http://macshuo.com/?p=676\" target=\"_blank\" rel=\"external\">http://macshuo.com/?p=676</a><br><a href=\"http://swiftcafe.io/2015/07/25/iterm/\" target=\"_blank\" rel=\"external\">http://swiftcafe.io/2015/07/25/iterm/</a><br> No newline at end of file</p>\n","excerpt":"","more":"<h1 id=\"oh-my-zsh\"><a href=\"#oh-my-zsh\" class=\"headerlink\" title=\"oh-my-zsh\"></a>oh-my-zsh</h1><p>如果说<strong>iTerm</strong>塑造了一个婀娜多姿颜值高的貌美姑娘，那么<strong>zsh</strong>就是给她塑造了一个柔情侠骨百事通的女汉子之心。</p>\n<h2 id=\"简介-Introduction\"><a href=\"#简介-Introduction\" class=\"headerlink\" title=\"简介 Introduction\"></a>简介 <small>Introduction</small></h2><p>对于<strong>zsh</strong>的作用，摘自池建强老师的一段：</p>\n<blockquote>\n<p>目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史「终极 Shell」，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：<a href=\"https://github.com/robbyrussell/oh-my-zsh\">https://github.com/robbyrussell/oh-my-zsh</a>。</p>\n</blockquote>\n<p><strong>oh-my-zsh</strong> 是一个社区驱动用于管理zsh的框架，囊括了140多个主题，200多个可选插件（如rails, git, OSX, hub, brew, ant, php, python etc.）。</p>\n<h2 id=\"安装-Installation\"><a href=\"#安装-Installation\" class=\"headerlink\" title=\"安装 Installation\"></a>安装 <small>Installation</small></h2><p><strong>via curl</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>via wget</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"配置-Configuration\"><a href=\"#配置-Configuration\" class=\"headerlink\" title=\"配置 Configuration\"></a>配置 <small>Configuration</small></h2><p>zsh的配置主要集中在用户当前目录的<code>.zshrc</code>里，用vim或者你喜欢的其他编辑器打开这个文件，在里面可以修改主题、插件以及定义自己的环境变量等操作。</p>\n<h2 id=\"主题-Themes\"><a href=\"#主题-Themes\" class=\"headerlink\" title=\"主题 Themes\"></a>主题 <small>Themes</small></h2><p>用vim打开<code>~/.zshrc</code>中，可以看到这样配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"># Set name of the theme to load.</span><br><span class=\"line\"># Look in ~/.oh-my-zsh/themes/</span><br><span class=\"line\"># Optionally, if you set this to &quot;random&quot;, it&apos;ll load a random theme each</span><br><span class=\"line\"># time that oh-my-zsh is loaded.</span><br><span class=\"line\">ZSH_THEME=&quot;robbyrussell&quot;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>修改<code>ZSH_THEME</code>的值就可以更换主题。</p>\n<p>默认的主题是<code>robbyrussell</code>，这个并不是最精彩，也并不是最简单的一个，只是对于其作者Robby来说最适合的一个。</p>\n<p>可以通过访问<code>~/.oh-my-zsh/themes/</code>目录查看哪些可选的主题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tree themes</span><br><span class=\"line\">themes</span><br><span class=\"line\">├── 3den.zsh-theme</span><br><span class=\"line\">├── Soliah.zsh-theme</span><br><span class=\"line\">├── adben.zsh-theme</span><br><span class=\"line\">├── af-magic.zsh-theme</span><br><span class=\"line\">├── afowler.zsh-theme</span><br><span class=\"line\">├── agnoster.zsh-theme</span><br><span class=\"line\">...</span><br><span class=\"line\">0 directories, 141 files</span><br></pre></td></tr></table></figure>\n<p>更多关于各个主题的详细介绍见 <a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/themes\">zsh themes</a>，另外还有不少并不是自带的主题，见<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes\">more external themes</a></p>\n<h3 id=\"Powerline-Fonts\"><a href=\"#Powerline-Fonts\" class=\"headerlink\" title=\"Powerline Fonts\"></a>Powerline Fonts</h3><p>如果你查看过zsh的主题列表的话，你会发现不少主题会有这样的样式，</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg\" alt=\"混合\"></p>\n<p>然而，当你选择了这样的主题，会发现实际是这样的</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg\" alt=\"23.pic.jpg\"></p>\n<p>因为，这些主题都依赖于一种字体<a href=\"https://github.com/powerline/fonts\">powerline fonts</a>，<code>powerline fonts</code>是vim增强组件<a href=\"https://github.com/Lokaltog/vim-powerline\">vim powerline</a>附属的字体，如果要使用依赖这种字体的主题，要在系统中安装该字体。</p>\n<h3 id=\"安装-powerline-fonts\"><a href=\"#安装-powerline-fonts\" class=\"headerlink\" title=\"安装 powerline fonts\"></a>安装 powerline fonts</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 下载powerline fonts项目</span><br><span class=\"line\">git clone https://github.com/powerline/fonts</span><br><span class=\"line\">// 执行安装</span><br><span class=\"line\">./fonts/install.sh</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置iTerm\"><a href=\"#配置iTerm\" class=\"headerlink\" title=\"配置iTerm\"></a>配置iTerm</h3><p>在<code>Preperence → Profiles → Text → Front</code> 中，<br>和<code>Preperence → Profiles → Text → Non-ASCII Font</code>中<br>改变字体为<code>Sauce Code Powerline</code></p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg\" alt=\"改变字体\"></p>\n<h2 id=\"插件-Plugins\"><a href=\"#插件-Plugins\" class=\"headerlink\" title=\"插件 Plugins\"></a>插件 <small>Plugins</small></h2><p>用vim打开<code>~/.zshrc</code>中，可以看到这样配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"># Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)</span><br><span class=\"line\"># Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span><br><span class=\"line\"># Example format: plugins=(rails git textmate ruby lighthouse)</span><br><span class=\"line\"># Add wisely, as too many plugins slow down shell startup.</span><br><span class=\"line\">plugins=(git)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>修改<code>plugins</code>的值就可以修改或添加插件。</p>\n<p>下面介绍几款我常用的插件</p>\n<h3 id=\"autojump\"><a href=\"#autojump\" class=\"headerlink\" title=\"autojump\"></a><a href=\"https://github.com/wting/autojump\">autojump</a></h3><blockquote>\n<p>A cd command that learns - easily navigate directories from the command line</p>\n</blockquote>\n<p>一款快捷跳转目标路径的插件，支持模糊匹配，自动补全，历史记录等功能。</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif\" alt=\"autojump\"></p>\n<h3 id=\"dirhistory\"><a href=\"#dirhistory\" class=\"headerlink\" title=\"dirhistory\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#dirhistory\">dirhistory</a></h3><blockquote>\n<p>This plugin allows you to navigate the history of previous current-working-directories using ALT-LEFT and ALT-RIGHT. ALT-LEFT moves back to directories that the user has changed to in the past, and ALT-RIGHT undoes ALT-LEFT.</p>\n</blockquote>\n<p>一款支持目录的上翻，下翻功能的插件。</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif\" alt=\"dirhistory\"></p>\n<h3 id=\"osx\"><a href=\"#osx\" class=\"headerlink\" title=\"osx\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx\">osx</a></h3><blockquote>\n<p>This plugin provides a few utilities to make it more enjoyable on OSX.</p>\n</blockquote>\n<p>一款增加了一些在OSX上实用的命令插件。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>tab</code></td>\n<td style=\"text-align:left\">Open the current directory in a new tab</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ofd</code></td>\n<td style=\"text-align:left\">Open the current directory in a Finder window</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pfd</code></td>\n<td style=\"text-align:left\">Return the path of the frontmost Finder window</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pfs</code></td>\n<td style=\"text-align:left\">Return the current Finder selection</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>cdf</code></td>\n<td style=\"text-align:left\"><code>cd</code> to the current Finder directory</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pushdf</code></td>\n<td style=\"text-align:left\"><code>pushd</code> to the current Finder directory</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>quick-look</code></td>\n<td style=\"text-align:left\">Quick-Look a specified file</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>man-preview</code></td>\n<td style=\"text-align:left\">Open a specified man page in Preview app</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git\">git</a></h3><blockquote>\n<p>The git plugin provides many aliases and a few useful functions.</p>\n</blockquote>\n<p>一款提供git别名命令以及一些方法命令的插件</p>\n<h3 id=\"git-extras\"><a href=\"#git-extras\" class=\"headerlink\" title=\"git-extras\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#git-extras\">git-extras</a></h3><p>一款扩展了不少方便快捷git命令的插件</p>\n<h3 id=\"More-Plugins\"><a href=\"#More-Plugins\" class=\"headerlink\" title=\"More Plugins\"></a>More Plugins</h3><p>更多的插件介绍见 <a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins\">zsh plugins</a></p>\n<h2 id=\"vi-vim-基础\"><a href=\"#vi-vim-基础\" class=\"headerlink\" title=\"vi(vim) 基础\"></a>vi(vim) 基础</h2><p>使用命令行的时候，难免会遇到要编辑文档的时刻，尽管不是vim党，但是如果掌握vim的基本操作，对效率还是有大大提升的。</p>\n<h3 id=\"vi与vim的关系\"><a href=\"#vi与vim的关系\" class=\"headerlink\" title=\"vi与vim的关系\"></a>vi与vim的关系</h3><p>简单来说，vi是老师的文字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。vim则可以说是程序开发者的一项很好用的工具，就连vim的官方网站(<a href=\"http://www.vim.org/\">http://www.vim.org/</a>)自己也说vim是一个「程序开发工具」而不是文字处理软件。</p>\n<h3 id=\"三种模式\"><a href=\"#三种模式\" class=\"headerlink\" title=\"三种模式\"></a>三种模式</h3><p>基本上vi中共分为3种模式，分别是「一般模式」，「编辑模式」与「命令行模式」</p>\n<ul>\n<li><p>一般模式<br>以vi打开一个文件，默认就是一般模式，这个模式中，可以按下<code>i</code>来进入编辑模式，按下<code>ESC</code>则退出编辑模式回到一般模式。<br>在这个模式中可以删除字符、删除行、复制、黏贴。</p>\n</li>\n<li><p>编辑模式<br>编辑模式能真正的编辑文本。</p>\n</li>\n<li><p>命令模式<br>在一般模式中，输入<code>:</code>,<code>/</code>,<code>?</code>中的一个可以进入命令行模式，进行诸如数据查找操作，读取、保存、离开vi等等操作。</p>\n</li>\n</ul>\n<h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><p>掌握下面的十一个命令，就足够你在vim中生存了。</p>\n<p><strong>移动光标</strong></p>\n<ul>\n<li>hjkl : 你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。</li>\n</ul>\n<p><strong>行操作</strong></p>\n<ul>\n<li>dd : 删除当前行，并把删除的行存到剪贴板里</li>\n<li>yy : 复制当前行。</li>\n<li>p  : 黏贴剪贴板</li>\n</ul>\n<p><strong>保存退出</strong></p>\n<ul>\n<li>:w : 保存已编辑的文集</li>\n<li>:q : 退出编辑</li>\n<li>:wq : 保存并退出</li>\n<li>:help : 显示相关命令的帮助(退出帮助需要输入:q)</li>\n</ul>\n<p><strong>搜索</strong></p>\n<ul>\n<li>/word : 向下寻找一个名为word的字符串 </li>\n<li>?word : 向上寻找一个名为word的字符串</li>\n<li>n : 重复前一个查找的操作</li>\n</ul>\n<h1 id=\"文末福利，安抚你的强迫症\"><a href=\"#文末福利，安抚你的强迫症\" class=\"headerlink\" title=\"文末福利，安抚你的强迫症\"></a>文末福利，安抚你的强迫症</h1><p>感谢你能耐心的看到这里，给你安利一个强迫症患者福音的窗口控制工具：<a href=\"https://www.spectacleapp.com/\">Spectacle</a></p>\n<p>Spectacle能通过快捷键，很轻易的排列好窗口的大小。</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif\" alt=\"Spectacle\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively\">http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively</a><br><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins\">https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins</a><br><a href=\"http://www.vim.org/\">http://www.vim.org/</a><br><a href=\"http://macshuo.com/?p=676\">http://macshuo.com/?p=676</a><br><a href=\"http://swiftcafe.io/2015/07/25/iterm/\">http://swiftcafe.io/2015/07/25/iterm/</a><br> No newline at end of file</p>\n"},{"title":"打造高效个性Terminal（一）之 iTerm","date":"2016-08-11T13:16:00.000Z","_content":"\n# 前言\n作为一个集效率控、颜值控、强迫症患者标签于一身的患者，对待自己工作用到的Terminal，自然是诸多要求。本文首先会讲一下怎么弄一个高颜值、个性化的Terminal，然后再说说怎么利用一些工具来提高Terminal的效率。\n\n~~PS：文末有彩蛋。~~\n\n# iTerm\n## 简介 <small>Introduction</small>\n> iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with OS X 10.8 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted.\n\n**iTerm**是一款免费的，专为Mac OS用户打造的命令行应用。作为系统自带**Terminal**的替代，它提供了很多方便且极客的功能。诸如隔离的面板、透明窗口、强大的正则表达式搜索、自动补全等、剪贴板历史记录，快照返回等功能，更多iTerm的特性见[iTerm Feature](http://www.iterm2.com/features.html)。\n下载见官网([http://www.iterm2.com/](http://www.iterm2.com/))，如果你不是Mac用户，那就跳过**iTerm**，直接看提高效率的**oh-my-zsh**\n\n## 塑造高颜值Terminal\n**iTerm**吸引我的地方，除了各种方面的特性之外，就是炫酷可定制的界面。\n满足我的视觉强迫症之外还可以提供方便的功能，应当是每个MacOS程序员必备的利器。\n\n对于使用命令行，我一般会有两个这样的使用场景\n一、快速打开，执行一两条命令，然后关闭，诸如打开文件，启动服务等等。\n二、长时间使用命令行，诸如调试程序，VIM编程等等。\n\n对于第一种情况，我希望是可以通过快捷键快速的打开命令行，然后同样的快捷键快速的隐藏它，直到我需要的时候再次来到我面前。\n而第二种情况，我希望是可以和正常的命令窗口界面那样，让我安安静静的调试程序。\n\n所以，在iTerm，我会建两个Profile配置。\n\n**第一种Profile**\n![my terminal part 1.gif](/image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif)\n\n**第二种Profile**\n![my terminal part 2.gif](/image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif)\n\n## 一步一步往前走\n\n### Step.1 创建第一种Profile\n\n首先在`Preperence → Profiles`，建立一个`Profiles`， 取名`HotKey Window`\n\n![建立Profile](/image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg)\n\n### Step.2 背景透明与模糊设置\n在`Preperence → Profiles → Window → Window Appearance` 进行设置\n\n![配置模糊透明背景](/image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg)\n\n### Step.3 窗口风格配置\n在`Preperence → Profiles → Window → Settings for New Windows` 进行设置\n\n![窗口风格配置](/image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg)\n\n### Step.4 设置HotKey\n在`Preperence → Profiles → Keys → HotKey` 进行设置\n\n![设置HotKey](/image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg)\n\n到目前为止，第一种Profile配置完成，你可以按下你设置的`HotKey`来方便快速打开和隐藏命令行。\n如果你需要打开一个会长时间使用的命令行窗口的话，按下`cmd + n`，但是你会发现窗口的样式又回到默认的了，所以下面进行第二个Profiles的配置。\n\n### Step.5 创建第二个Profile\n我们只需要在第一个窗口的基础上，进行「窗口风格」配置就可以了。\n\n在`Preperence → Profiles`，复制`HotKey Window`， 取名`Default of Hotkey Window`\n\n![第二个Profile](/image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg)\n\n### Step.6 窗口风格配置\n\n在`Preperence → Profiles → Window → Settings for New Windows` 进行设置\n\n![设置窗口风格配置](/image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg)\n\n### Step.7 设置默认\n\n在`Preperence → Profiles` 中，选中 `Default of HotKey Window`, 并设置为默认\n\n![设置默认](/image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg)\n\n自此，就完成了两种Profile的设置。\n\n\n## 常用功能快捷键\n在使用**iTerm**的过程中，下面对于控制窗口的快捷键使用频率会很高，不用记，用多了就形成肌肉记忆了。\n\n* cmd + n : 新建窗口\n* cmd + t : 新建TAB\n* cmd + d : 垂直新建TAB\n* cmd + shift + d : 水平新建TAB\n\n> [《打造高效个性Terminal（二）之 zsh》](/2016/08/11/打造高效个性Terminal（二）之%20zsh/)","source":"_posts/打造高效个性Terminal（一）之 iTerm.md","raw":"---\ntitle: 打造高效个性Terminal（一）之 iTerm\ncategory: 搬砖码农\ndate: 2016-08-11 21:16:00\ntags:\n- Tool Kit\n---\n\n# 前言\n作为一个集效率控、颜值控、强迫症患者标签于一身的患者，对待自己工作用到的Terminal，自然是诸多要求。本文首先会讲一下怎么弄一个高颜值、个性化的Terminal，然后再说说怎么利用一些工具来提高Terminal的效率。\n\n~~PS：文末有彩蛋。~~\n\n# iTerm\n## 简介 <small>Introduction</small>\n> iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with OS X 10.8 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted.\n\n**iTerm**是一款免费的，专为Mac OS用户打造的命令行应用。作为系统自带**Terminal**的替代，它提供了很多方便且极客的功能。诸如隔离的面板、透明窗口、强大的正则表达式搜索、自动补全等、剪贴板历史记录，快照返回等功能，更多iTerm的特性见[iTerm Feature](http://www.iterm2.com/features.html)。\n下载见官网([http://www.iterm2.com/](http://www.iterm2.com/))，如果你不是Mac用户，那就跳过**iTerm**，直接看提高效率的**oh-my-zsh**\n\n## 塑造高颜值Terminal\n**iTerm**吸引我的地方，除了各种方面的特性之外，就是炫酷可定制的界面。\n满足我的视觉强迫症之外还可以提供方便的功能，应当是每个MacOS程序员必备的利器。\n\n对于使用命令行，我一般会有两个这样的使用场景\n一、快速打开，执行一两条命令，然后关闭，诸如打开文件，启动服务等等。\n二、长时间使用命令行，诸如调试程序，VIM编程等等。\n\n对于第一种情况，我希望是可以通过快捷键快速的打开命令行，然后同样的快捷键快速的隐藏它，直到我需要的时候再次来到我面前。\n而第二种情况，我希望是可以和正常的命令窗口界面那样，让我安安静静的调试程序。\n\n所以，在iTerm，我会建两个Profile配置。\n\n**第一种Profile**\n![my terminal part 1.gif](/image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif)\n\n**第二种Profile**\n![my terminal part 2.gif](/image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif)\n\n## 一步一步往前走\n\n### Step.1 创建第一种Profile\n\n首先在`Preperence → Profiles`，建立一个`Profiles`， 取名`HotKey Window`\n\n![建立Profile](/image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg)\n\n### Step.2 背景透明与模糊设置\n在`Preperence → Profiles → Window → Window Appearance` 进行设置\n\n![配置模糊透明背景](/image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg)\n\n### Step.3 窗口风格配置\n在`Preperence → Profiles → Window → Settings for New Windows` 进行设置\n\n![窗口风格配置](/image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg)\n\n### Step.4 设置HotKey\n在`Preperence → Profiles → Keys → HotKey` 进行设置\n\n![设置HotKey](/image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg)\n\n到目前为止，第一种Profile配置完成，你可以按下你设置的`HotKey`来方便快速打开和隐藏命令行。\n如果你需要打开一个会长时间使用的命令行窗口的话，按下`cmd + n`，但是你会发现窗口的样式又回到默认的了，所以下面进行第二个Profiles的配置。\n\n### Step.5 创建第二个Profile\n我们只需要在第一个窗口的基础上，进行「窗口风格」配置就可以了。\n\n在`Preperence → Profiles`，复制`HotKey Window`， 取名`Default of Hotkey Window`\n\n![第二个Profile](/image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg)\n\n### Step.6 窗口风格配置\n\n在`Preperence → Profiles → Window → Settings for New Windows` 进行设置\n\n![设置窗口风格配置](/image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg)\n\n### Step.7 设置默认\n\n在`Preperence → Profiles` 中，选中 `Default of HotKey Window`, 并设置为默认\n\n![设置默认](/image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg)\n\n自此，就完成了两种Profile的设置。\n\n\n## 常用功能快捷键\n在使用**iTerm**的过程中，下面对于控制窗口的快捷键使用频率会很高，不用记，用多了就形成肌肉记忆了。\n\n* cmd + n : 新建窗口\n* cmd + t : 新建TAB\n* cmd + d : 垂直新建TAB\n* cmd + shift + d : 水平新建TAB\n\n> [《打造高效个性Terminal（二）之 zsh》](/2016/08/11/打造高效个性Terminal（二）之%20zsh/)","slug":"打造高效个性Terminal（一）之 iTerm","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8re001mxwrlfpimjjs6","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一个集效率控、颜值控、强迫症患者标签于一身的患者，对待自己工作用到的Terminal，自然是诸多要求。本文首先会讲一下怎么弄一个高颜值、个性化的Terminal，然后再说说怎么利用一些工具来提高Terminal的效率。</p>\n<p><del>PS：文末有彩蛋。</del></p>\n<h1 id=\"iTerm\"><a href=\"#iTerm\" class=\"headerlink\" title=\"iTerm\"></a>iTerm</h1><h2 id=\"简介-Introduction\"><a href=\"#简介-Introduction\" class=\"headerlink\" title=\"简介 Introduction\"></a>简介 <small>Introduction</small></h2><blockquote>\n<p>iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with OS X 10.8 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted.</p>\n</blockquote>\n<p><strong>iTerm</strong>是一款免费的，专为Mac OS用户打造的命令行应用。作为系统自带<strong>Terminal</strong>的替代，它提供了很多方便且极客的功能。诸如隔离的面板、透明窗口、强大的正则表达式搜索、自动补全等、剪贴板历史记录，快照返回等功能，更多iTerm的特性见<a href=\"http://www.iterm2.com/features.html\" target=\"_blank\" rel=\"external\">iTerm Feature</a>。<br>下载见官网(<a href=\"http://www.iterm2.com/\" target=\"_blank\" rel=\"external\">http://www.iterm2.com/</a>)，如果你不是Mac用户，那就跳过<strong>iTerm</strong>，直接看提高效率的<strong>oh-my-zsh</strong></p>\n<h2 id=\"塑造高颜值Terminal\"><a href=\"#塑造高颜值Terminal\" class=\"headerlink\" title=\"塑造高颜值Terminal\"></a>塑造高颜值Terminal</h2><p><strong>iTerm</strong>吸引我的地方，除了各种方面的特性之外，就是炫酷可定制的界面。<br>满足我的视觉强迫症之外还可以提供方便的功能，应当是每个MacOS程序员必备的利器。</p>\n<p>对于使用命令行，我一般会有两个这样的使用场景<br>一、快速打开，执行一两条命令，然后关闭，诸如打开文件，启动服务等等。<br>二、长时间使用命令行，诸如调试程序，VIM编程等等。</p>\n<p>对于第一种情况，我希望是可以通过快捷键快速的打开命令行，然后同样的快捷键快速的隐藏它，直到我需要的时候再次来到我面前。<br>而第二种情况，我希望是可以和正常的命令窗口界面那样，让我安安静静的调试程序。</p>\n<p>所以，在iTerm，我会建两个Profile配置。</p>\n<p><strong>第一种Profile</strong><br><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif\" alt=\"my terminal part 1.gif\"></p>\n<p><strong>第二种Profile</strong><br><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif\" alt=\"my terminal part 2.gif\"></p>\n<h2 id=\"一步一步往前走\"><a href=\"#一步一步往前走\" class=\"headerlink\" title=\"一步一步往前走\"></a>一步一步往前走</h2><h3 id=\"Step-1-创建第一种Profile\"><a href=\"#Step-1-创建第一种Profile\" class=\"headerlink\" title=\"Step.1 创建第一种Profile\"></a>Step.1 创建第一种Profile</h3><p>首先在<code>Preperence → Profiles</code>，建立一个<code>Profiles</code>， 取名<code>HotKey Window</code></p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg\" alt=\"建立Profile\"></p>\n<h3 id=\"Step-2-背景透明与模糊设置\"><a href=\"#Step-2-背景透明与模糊设置\" class=\"headerlink\" title=\"Step.2 背景透明与模糊设置\"></a>Step.2 背景透明与模糊设置</h3><p>在<code>Preperence → Profiles → Window → Window Appearance</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg\" alt=\"配置模糊透明背景\"></p>\n<h3 id=\"Step-3-窗口风格配置\"><a href=\"#Step-3-窗口风格配置\" class=\"headerlink\" title=\"Step.3 窗口风格配置\"></a>Step.3 窗口风格配置</h3><p>在<code>Preperence → Profiles → Window → Settings for New Windows</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg\" alt=\"窗口风格配置\"></p>\n<h3 id=\"Step-4-设置HotKey\"><a href=\"#Step-4-设置HotKey\" class=\"headerlink\" title=\"Step.4 设置HotKey\"></a>Step.4 设置HotKey</h3><p>在<code>Preperence → Profiles → Keys → HotKey</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg\" alt=\"设置HotKey\"></p>\n<p>到目前为止，第一种Profile配置完成，你可以按下你设置的<code>HotKey</code>来方便快速打开和隐藏命令行。<br>如果你需要打开一个会长时间使用的命令行窗口的话，按下<code>cmd + n</code>，但是你会发现窗口的样式又回到默认的了，所以下面进行第二个Profiles的配置。</p>\n<h3 id=\"Step-5-创建第二个Profile\"><a href=\"#Step-5-创建第二个Profile\" class=\"headerlink\" title=\"Step.5 创建第二个Profile\"></a>Step.5 创建第二个Profile</h3><p>我们只需要在第一个窗口的基础上，进行「窗口风格」配置就可以了。</p>\n<p>在<code>Preperence → Profiles</code>，复制<code>HotKey Window</code>， 取名<code>Default of Hotkey Window</code></p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg\" alt=\"第二个Profile\"></p>\n<h3 id=\"Step-6-窗口风格配置\"><a href=\"#Step-6-窗口风格配置\" class=\"headerlink\" title=\"Step.6 窗口风格配置\"></a>Step.6 窗口风格配置</h3><p>在<code>Preperence → Profiles → Window → Settings for New Windows</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg\" alt=\"设置窗口风格配置\"></p>\n<h3 id=\"Step-7-设置默认\"><a href=\"#Step-7-设置默认\" class=\"headerlink\" title=\"Step.7 设置默认\"></a>Step.7 设置默认</h3><p>在<code>Preperence → Profiles</code> 中，选中 <code>Default of HotKey Window</code>, 并设置为默认</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg\" alt=\"设置默认\"></p>\n<p>自此，就完成了两种Profile的设置。</p>\n<h2 id=\"常用功能快捷键\"><a href=\"#常用功能快捷键\" class=\"headerlink\" title=\"常用功能快捷键\"></a>常用功能快捷键</h2><p>在使用<strong>iTerm</strong>的过程中，下面对于控制窗口的快捷键使用频率会很高，不用记，用多了就形成肌肉记忆了。</p>\n<ul>\n<li>cmd + n : 新建窗口</li>\n<li>cmd + t : 新建TAB</li>\n<li>cmd + d : 垂直新建TAB</li>\n<li>cmd + shift + d : 水平新建TAB</li>\n</ul>\n<blockquote>\n<p><a href=\"/2016/08/11/打造高效个性Terminal（二）之%20zsh/\">《打造高效个性Terminal（二）之 zsh》</a></p>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一个集效率控、颜值控、强迫症患者标签于一身的患者，对待自己工作用到的Terminal，自然是诸多要求。本文首先会讲一下怎么弄一个高颜值、个性化的Terminal，然后再说说怎么利用一些工具来提高Terminal的效率。</p>\n<p><del>PS：文末有彩蛋。</del></p>\n<h1 id=\"iTerm\"><a href=\"#iTerm\" class=\"headerlink\" title=\"iTerm\"></a>iTerm</h1><h2 id=\"简介-Introduction\"><a href=\"#简介-Introduction\" class=\"headerlink\" title=\"简介 Introduction\"></a>简介 <small>Introduction</small></h2><blockquote>\n<p>iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with OS X 10.8 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted.</p>\n</blockquote>\n<p><strong>iTerm</strong>是一款免费的，专为Mac OS用户打造的命令行应用。作为系统自带<strong>Terminal</strong>的替代，它提供了很多方便且极客的功能。诸如隔离的面板、透明窗口、强大的正则表达式搜索、自动补全等、剪贴板历史记录，快照返回等功能，更多iTerm的特性见<a href=\"http://www.iterm2.com/features.html\">iTerm Feature</a>。<br>下载见官网(<a href=\"http://www.iterm2.com/\">http://www.iterm2.com/</a>)，如果你不是Mac用户，那就跳过<strong>iTerm</strong>，直接看提高效率的<strong>oh-my-zsh</strong></p>\n<h2 id=\"塑造高颜值Terminal\"><a href=\"#塑造高颜值Terminal\" class=\"headerlink\" title=\"塑造高颜值Terminal\"></a>塑造高颜值Terminal</h2><p><strong>iTerm</strong>吸引我的地方，除了各种方面的特性之外，就是炫酷可定制的界面。<br>满足我的视觉强迫症之外还可以提供方便的功能，应当是每个MacOS程序员必备的利器。</p>\n<p>对于使用命令行，我一般会有两个这样的使用场景<br>一、快速打开，执行一两条命令，然后关闭，诸如打开文件，启动服务等等。<br>二、长时间使用命令行，诸如调试程序，VIM编程等等。</p>\n<p>对于第一种情况，我希望是可以通过快捷键快速的打开命令行，然后同样的快捷键快速的隐藏它，直到我需要的时候再次来到我面前。<br>而第二种情况，我希望是可以和正常的命令窗口界面那样，让我安安静静的调试程序。</p>\n<p>所以，在iTerm，我会建两个Profile配置。</p>\n<p><strong>第一种Profile</strong><br><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif\" alt=\"my terminal part 1.gif\"></p>\n<p><strong>第二种Profile</strong><br><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif\" alt=\"my terminal part 2.gif\"></p>\n<h2 id=\"一步一步往前走\"><a href=\"#一步一步往前走\" class=\"headerlink\" title=\"一步一步往前走\"></a>一步一步往前走</h2><h3 id=\"Step-1-创建第一种Profile\"><a href=\"#Step-1-创建第一种Profile\" class=\"headerlink\" title=\"Step.1 创建第一种Profile\"></a>Step.1 创建第一种Profile</h3><p>首先在<code>Preperence → Profiles</code>，建立一个<code>Profiles</code>， 取名<code>HotKey Window</code></p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg\" alt=\"建立Profile\"></p>\n<h3 id=\"Step-2-背景透明与模糊设置\"><a href=\"#Step-2-背景透明与模糊设置\" class=\"headerlink\" title=\"Step.2 背景透明与模糊设置\"></a>Step.2 背景透明与模糊设置</h3><p>在<code>Preperence → Profiles → Window → Window Appearance</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg\" alt=\"配置模糊透明背景\"></p>\n<h3 id=\"Step-3-窗口风格配置\"><a href=\"#Step-3-窗口风格配置\" class=\"headerlink\" title=\"Step.3 窗口风格配置\"></a>Step.3 窗口风格配置</h3><p>在<code>Preperence → Profiles → Window → Settings for New Windows</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg\" alt=\"窗口风格配置\"></p>\n<h3 id=\"Step-4-设置HotKey\"><a href=\"#Step-4-设置HotKey\" class=\"headerlink\" title=\"Step.4 设置HotKey\"></a>Step.4 设置HotKey</h3><p>在<code>Preperence → Profiles → Keys → HotKey</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg\" alt=\"设置HotKey\"></p>\n<p>到目前为止，第一种Profile配置完成，你可以按下你设置的<code>HotKey</code>来方便快速打开和隐藏命令行。<br>如果你需要打开一个会长时间使用的命令行窗口的话，按下<code>cmd + n</code>，但是你会发现窗口的样式又回到默认的了，所以下面进行第二个Profiles的配置。</p>\n<h3 id=\"Step-5-创建第二个Profile\"><a href=\"#Step-5-创建第二个Profile\" class=\"headerlink\" title=\"Step.5 创建第二个Profile\"></a>Step.5 创建第二个Profile</h3><p>我们只需要在第一个窗口的基础上，进行「窗口风格」配置就可以了。</p>\n<p>在<code>Preperence → Profiles</code>，复制<code>HotKey Window</code>， 取名<code>Default of Hotkey Window</code></p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg\" alt=\"第二个Profile\"></p>\n<h3 id=\"Step-6-窗口风格配置\"><a href=\"#Step-6-窗口风格配置\" class=\"headerlink\" title=\"Step.6 窗口风格配置\"></a>Step.6 窗口风格配置</h3><p>在<code>Preperence → Profiles → Window → Settings for New Windows</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg\" alt=\"设置窗口风格配置\"></p>\n<h3 id=\"Step-7-设置默认\"><a href=\"#Step-7-设置默认\" class=\"headerlink\" title=\"Step.7 设置默认\"></a>Step.7 设置默认</h3><p>在<code>Preperence → Profiles</code> 中，选中 <code>Default of HotKey Window</code>, 并设置为默认</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg\" alt=\"设置默认\"></p>\n<p>自此，就完成了两种Profile的设置。</p>\n<h2 id=\"常用功能快捷键\"><a href=\"#常用功能快捷键\" class=\"headerlink\" title=\"常用功能快捷键\"></a>常用功能快捷键</h2><p>在使用<strong>iTerm</strong>的过程中，下面对于控制窗口的快捷键使用频率会很高，不用记，用多了就形成肌肉记忆了。</p>\n<ul>\n<li>cmd + n : 新建窗口</li>\n<li>cmd + t : 新建TAB</li>\n<li>cmd + d : 垂直新建TAB</li>\n<li>cmd + shift + d : 水平新建TAB</li>\n</ul>\n<blockquote>\n<p><a href=\"/2016/08/11/打造高效个性Terminal（二）之%20zsh/\">《打造高效个性Terminal（二）之 zsh》</a></p>\n</blockquote>\n"},{"title":"如果你用GitHub，可以这样提高效率","date":"2016-01-15T11:22:59.000Z","_content":"\n\n一年时间我们从几个人的开发团队发展到十几人的团队，最初的我们只有两个后端加两个前端，而且其中三个还是实习生。\n但今时不同往日，现在我们有前端、后端、测试、运维、设计、产品、交互，成功集齐了七个兵种，可以召唤神龙，赐我们一个敏捷的开发团队。\n作为一个敏捷性的开发团队，我们要保持快速的迭代速度的同时保证高质量的代码，这是一个艰巨的过程。\n\n### 版本管理 — Git~Hub\n>「开始的开始，我们还是孩子」(出自《北京路的日子》)\n\n开始的开始，我们还是用着SVN，代码存储在公司的服务器中，只有一个分支，提交代码无需审核，无需单元测试。因为我们只有几个人......\n\n作为一个有逼格的团队，后来我们用上了Git，并且把代码迁移到Coding中去，然后引入了名为「git flow」的工作流，关于这个工作流可以参考我们老大的文章：[「企业级开发：Gitflow Workflow工作流」](http://www.jianshu.com/p/104fa8b15d1e)\n\nCoding真的是一款很不错的产品，可称为业届良心。\n\n为什么当初没有直接用GitHub，因为私有仓库贵啊......\n\n但，作为一个有逼格的团队，我们是不会满足于此的。Coding自身的服务很不错了，但是相对于GitHub的一些专业的第三方服务，缺少了那么一些竞争力。我们当时想接入持续集成的服务，但是无奈找不到支持Coding的第三方服务，代码Review也没有一个更让我们舒心的体验，我承认我们要求比较高。再加上Coding的几次down机，其中一次是我们准备发布新版本的那一个下午.....\n\n终于有一天，我们老大两眼发光的跟我们说：我们要买GitHub的服务了，申请到资金了。\n\n于是乎，我们浩浩荡荡的迁移代码库。\n\n迁移到Github之后，我们开始接入各方工具，提高我们的工作效率（钱可不能白花啊）。\n\n### 武装GitHub — ZenHub\n> [ZenHub](https://www.zenhub.io/)     \n> Project management inside GitHub    \n> Transform your GitHub issues\n\n正如Zenhub所说，这是一款项目管理工具，嵌入式集成到GitHub中。作为插件，它的UI完全迎合了GitHub，以至于你难以分别出哪些功能是GitHub的，哪些功能是Zenhub的。\n\n如果你用了ZenHub，它会提供给你：\n\n1. **一套任务面板**，给不同的任务提供不同的泳道，直观的展示每个任务的进度。于是乎我抛弃了Teambition。\n2. **一套个人的Todo List**，如果有一个issue或者一个PR需要你来处理，但你现在没有空，你可以把它添加到Todo List中，于是乎我又抛弃了Wunderlist。\n3. **一套项目图标与统计**，结合着Github自带的项目图表，这个提供更多维度的数据，但是个人感觉意义不太大。\n4. **再加一些小彩蛋**，由于它是作为插件形式嵌入到Github中的，所以会在很多地方提供一些这样那样的按钮，等着你去发现了。\n\n### 持续集成 — TravisCI \n> [TravisCI](https://travis-ci.org/)    \n> Test and Deploy with Confidence    \n> Easily sync your GitHub projects with Travis CI and you’ll be testing your code in minutes!\n\n不知道你有没有好奇Github上的一些明星项目的这样的标签：\n\n[![Build Status](https://travis-ci.org/expressjs/express.svg?branch=master)](https://travis-ci.org/expressjs/express)\n\n这个是Express的构建状态的标签，格式是svg，它会根据Express的构建状态改变。如果Express的某一次提交是没有通过TravisCI构建的，他会变成 build failing。（有心人可以点击这个标签进去看看。）\n\n我们加入TravisCI主要目的是用于自动化的单元测试，每一次Commit与PR，TravisCI都会从Github仓库中拉取代码，然后执行我们写好的单元测试，通过与否会通过状态展示出来。    \n合并的人如果看到build failing，就不会合并了，这在一定程度上保证与提高了代码的质量。\n\nTravisCI除了可以用来自动化单元测试，还可以自动化部署，可以设定，通过测试之后，就自动部署上线。\n\nTravisCI对于公开仓库是免费的，但对于私有仓库是要收费的，而且价格也不便宜。    \n如果你觉得贵，这里还有一个可以代替的：**[CircleCI](https://circleci.com/)**    \nTravisCI可以做的，它都可以做得到，而且会提供一个免费的私有仓库。    \n\n### 代码Review — Reviewable\n> [Reviewable](https://reviewable.io/)\n> GitHub code reviews done right\n\n如果你觉得Github自带的Review还不够满足的话，可以尝试一下这款产品。\n当你提交一个PR之后，在你的PR中，会在你的评论框中嵌入这样的按钮\n\n![](//dn-cnode.qbox.me/FrDLVgDD6alCXnHAfk4XNHJCCnS_)\n\n点击进入Reviewable的页面对应的PR进行review。\n\n并且一个PR没有完成Review之前，是会一直被警告，让你警惕进行合并。\n\n### 代码覆盖率 — Coveralls\n> [Coveralls](http://coveralls.io/)    \n> We help you deliver code confidently by showing which parts of your code aren’t covered by your test suite. Free for open source repos. Pro accounts for private repos. Instant sign up through GitHub and Bitbucket.\n\n在明星项目Express的Github项目主页中，你可以看到这样的标签：\n\n[![Coverage Status](https://coveralls.io/repos/strongloop/express/badge.svg?branch=master&service=github)](https://coveralls.io/github/strongloop/express?branch=master)\n\n结合着TravisCI的自动化单元测试，加上这个测试覆盖率，提高你对项目的信心。\n\n\n### 快速进行沟通 — Slack\n> [Slack](https://slack.com/)    \n> A messaging app for teams who see through the Earth\n\n相信大部分团队都是使用微信进行沟通的，    \n再一次，最为一个有逼格的团队，我们使用了Slack进行团队上的沟通，在Slack上，你可以创建频道(Channel)，不同Channel不同的人进行着不同的话题沟通。我们有设计的Channel、产品的Channel、开发的Channel。我最欣赏的是，Slack可以接入很多第三方服务，Github是其中一个。\n\n接入Github之后，项目的每一个Commit、PR之类的动态信息，会被推送到聊天室中。\n\n助你时刻掌控项目动态。\n\n![](//dn-cnode.qbox.me/FjrMtthZ9pX08AWOKbIPlogDKBcK)\n\nSlack接入Githu只是其中的一个小功能而已，更强大的在于Slack本身，利器如何用，待君慢慢体会。  \n  \n**但**，Slack有一个硬伤：不会科学上网，用不了呀。\n\n\n### 最后\n\n再一次，作为一个有逼格的团队，我们依然不会满足现状。\n\n","source":"_posts/如果你用GitHub，可以这样提高效率.md","raw":"---\ntitle: 如果你用GitHub，可以这样提高效率\ncategory: 搬砖码农\ndate: 2016-01-15 19:22:59\ntags:\n- Nodejs\n- Tool Kit\n---\n\n\n一年时间我们从几个人的开发团队发展到十几人的团队，最初的我们只有两个后端加两个前端，而且其中三个还是实习生。\n但今时不同往日，现在我们有前端、后端、测试、运维、设计、产品、交互，成功集齐了七个兵种，可以召唤神龙，赐我们一个敏捷的开发团队。\n作为一个敏捷性的开发团队，我们要保持快速的迭代速度的同时保证高质量的代码，这是一个艰巨的过程。\n\n### 版本管理 — Git~Hub\n>「开始的开始，我们还是孩子」(出自《北京路的日子》)\n\n开始的开始，我们还是用着SVN，代码存储在公司的服务器中，只有一个分支，提交代码无需审核，无需单元测试。因为我们只有几个人......\n\n作为一个有逼格的团队，后来我们用上了Git，并且把代码迁移到Coding中去，然后引入了名为「git flow」的工作流，关于这个工作流可以参考我们老大的文章：[「企业级开发：Gitflow Workflow工作流」](http://www.jianshu.com/p/104fa8b15d1e)\n\nCoding真的是一款很不错的产品，可称为业届良心。\n\n为什么当初没有直接用GitHub，因为私有仓库贵啊......\n\n但，作为一个有逼格的团队，我们是不会满足于此的。Coding自身的服务很不错了，但是相对于GitHub的一些专业的第三方服务，缺少了那么一些竞争力。我们当时想接入持续集成的服务，但是无奈找不到支持Coding的第三方服务，代码Review也没有一个更让我们舒心的体验，我承认我们要求比较高。再加上Coding的几次down机，其中一次是我们准备发布新版本的那一个下午.....\n\n终于有一天，我们老大两眼发光的跟我们说：我们要买GitHub的服务了，申请到资金了。\n\n于是乎，我们浩浩荡荡的迁移代码库。\n\n迁移到Github之后，我们开始接入各方工具，提高我们的工作效率（钱可不能白花啊）。\n\n### 武装GitHub — ZenHub\n> [ZenHub](https://www.zenhub.io/)     \n> Project management inside GitHub    \n> Transform your GitHub issues\n\n正如Zenhub所说，这是一款项目管理工具，嵌入式集成到GitHub中。作为插件，它的UI完全迎合了GitHub，以至于你难以分别出哪些功能是GitHub的，哪些功能是Zenhub的。\n\n如果你用了ZenHub，它会提供给你：\n\n1. **一套任务面板**，给不同的任务提供不同的泳道，直观的展示每个任务的进度。于是乎我抛弃了Teambition。\n2. **一套个人的Todo List**，如果有一个issue或者一个PR需要你来处理，但你现在没有空，你可以把它添加到Todo List中，于是乎我又抛弃了Wunderlist。\n3. **一套项目图标与统计**，结合着Github自带的项目图表，这个提供更多维度的数据，但是个人感觉意义不太大。\n4. **再加一些小彩蛋**，由于它是作为插件形式嵌入到Github中的，所以会在很多地方提供一些这样那样的按钮，等着你去发现了。\n\n### 持续集成 — TravisCI \n> [TravisCI](https://travis-ci.org/)    \n> Test and Deploy with Confidence    \n> Easily sync your GitHub projects with Travis CI and you’ll be testing your code in minutes!\n\n不知道你有没有好奇Github上的一些明星项目的这样的标签：\n\n[![Build Status](https://travis-ci.org/expressjs/express.svg?branch=master)](https://travis-ci.org/expressjs/express)\n\n这个是Express的构建状态的标签，格式是svg，它会根据Express的构建状态改变。如果Express的某一次提交是没有通过TravisCI构建的，他会变成 build failing。（有心人可以点击这个标签进去看看。）\n\n我们加入TravisCI主要目的是用于自动化的单元测试，每一次Commit与PR，TravisCI都会从Github仓库中拉取代码，然后执行我们写好的单元测试，通过与否会通过状态展示出来。    \n合并的人如果看到build failing，就不会合并了，这在一定程度上保证与提高了代码的质量。\n\nTravisCI除了可以用来自动化单元测试，还可以自动化部署，可以设定，通过测试之后，就自动部署上线。\n\nTravisCI对于公开仓库是免费的，但对于私有仓库是要收费的，而且价格也不便宜。    \n如果你觉得贵，这里还有一个可以代替的：**[CircleCI](https://circleci.com/)**    \nTravisCI可以做的，它都可以做得到，而且会提供一个免费的私有仓库。    \n\n### 代码Review — Reviewable\n> [Reviewable](https://reviewable.io/)\n> GitHub code reviews done right\n\n如果你觉得Github自带的Review还不够满足的话，可以尝试一下这款产品。\n当你提交一个PR之后，在你的PR中，会在你的评论框中嵌入这样的按钮\n\n![](//dn-cnode.qbox.me/FrDLVgDD6alCXnHAfk4XNHJCCnS_)\n\n点击进入Reviewable的页面对应的PR进行review。\n\n并且一个PR没有完成Review之前，是会一直被警告，让你警惕进行合并。\n\n### 代码覆盖率 — Coveralls\n> [Coveralls](http://coveralls.io/)    \n> We help you deliver code confidently by showing which parts of your code aren’t covered by your test suite. Free for open source repos. Pro accounts for private repos. Instant sign up through GitHub and Bitbucket.\n\n在明星项目Express的Github项目主页中，你可以看到这样的标签：\n\n[![Coverage Status](https://coveralls.io/repos/strongloop/express/badge.svg?branch=master&service=github)](https://coveralls.io/github/strongloop/express?branch=master)\n\n结合着TravisCI的自动化单元测试，加上这个测试覆盖率，提高你对项目的信心。\n\n\n### 快速进行沟通 — Slack\n> [Slack](https://slack.com/)    \n> A messaging app for teams who see through the Earth\n\n相信大部分团队都是使用微信进行沟通的，    \n再一次，最为一个有逼格的团队，我们使用了Slack进行团队上的沟通，在Slack上，你可以创建频道(Channel)，不同Channel不同的人进行着不同的话题沟通。我们有设计的Channel、产品的Channel、开发的Channel。我最欣赏的是，Slack可以接入很多第三方服务，Github是其中一个。\n\n接入Github之后，项目的每一个Commit、PR之类的动态信息，会被推送到聊天室中。\n\n助你时刻掌控项目动态。\n\n![](//dn-cnode.qbox.me/FjrMtthZ9pX08AWOKbIPlogDKBcK)\n\nSlack接入Githu只是其中的一个小功能而已，更强大的在于Slack本身，利器如何用，待君慢慢体会。  \n  \n**但**，Slack有一个硬伤：不会科学上网，用不了呀。\n\n\n### 最后\n\n再一次，作为一个有逼格的团队，我们依然不会满足现状。\n\n","slug":"如果你用GitHub，可以这样提高效率","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8rg001pxwrlv9bg8klb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>一年时间我们从几个人的开发团队发展到十几人的团队，最初的我们只有两个后端加两个前端，而且其中三个还是实习生。<br>但今时不同往日，现在我们有前端、后端、测试、运维、设计、产品、交互，成功集齐了七个兵种，可以召唤神龙，赐我们一个敏捷的开发团队。<br>作为一个敏捷性的开发团队，我们要保持快速的迭代速度的同时保证高质量的代码，这是一个艰巨的过程。</p>\n<h3 id=\"版本管理-—-Git-Hub\"><a href=\"#版本管理-—-Git-Hub\" class=\"headerlink\" title=\"版本管理 — Git~Hub\"></a>版本管理 — Git~Hub</h3><blockquote>\n<p>「开始的开始，我们还是孩子」(出自《北京路的日子》)</p>\n</blockquote>\n<p>开始的开始，我们还是用着SVN，代码存储在公司的服务器中，只有一个分支，提交代码无需审核，无需单元测试。因为我们只有几个人……</p>\n<p>作为一个有逼格的团队，后来我们用上了Git，并且把代码迁移到Coding中去，然后引入了名为「git flow」的工作流，关于这个工作流可以参考我们老大的文章：<a href=\"http://www.jianshu.com/p/104fa8b15d1e\" target=\"_blank\" rel=\"external\">「企业级开发：Gitflow Workflow工作流」</a></p>\n<p>Coding真的是一款很不错的产品，可称为业届良心。</p>\n<p>为什么当初没有直接用GitHub，因为私有仓库贵啊……</p>\n<p>但，作为一个有逼格的团队，我们是不会满足于此的。Coding自身的服务很不错了，但是相对于GitHub的一些专业的第三方服务，缺少了那么一些竞争力。我们当时想接入持续集成的服务，但是无奈找不到支持Coding的第三方服务，代码Review也没有一个更让我们舒心的体验，我承认我们要求比较高。再加上Coding的几次down机，其中一次是我们准备发布新版本的那一个下午…..</p>\n<p>终于有一天，我们老大两眼发光的跟我们说：我们要买GitHub的服务了，申请到资金了。</p>\n<p>于是乎，我们浩浩荡荡的迁移代码库。</p>\n<p>迁移到Github之后，我们开始接入各方工具，提高我们的工作效率（钱可不能白花啊）。</p>\n<h3 id=\"武装GitHub-—-ZenHub\"><a href=\"#武装GitHub-—-ZenHub\" class=\"headerlink\" title=\"武装GitHub — ZenHub\"></a>武装GitHub — ZenHub</h3><blockquote>\n<p><a href=\"https://www.zenhub.io/\" target=\"_blank\" rel=\"external\">ZenHub</a><br>Project management inside GitHub<br>Transform your GitHub issues</p>\n</blockquote>\n<p>正如Zenhub所说，这是一款项目管理工具，嵌入式集成到GitHub中。作为插件，它的UI完全迎合了GitHub，以至于你难以分别出哪些功能是GitHub的，哪些功能是Zenhub的。</p>\n<p>如果你用了ZenHub，它会提供给你：</p>\n<ol>\n<li><strong>一套任务面板</strong>，给不同的任务提供不同的泳道，直观的展示每个任务的进度。于是乎我抛弃了Teambition。</li>\n<li><strong>一套个人的Todo List</strong>，如果有一个issue或者一个PR需要你来处理，但你现在没有空，你可以把它添加到Todo List中，于是乎我又抛弃了Wunderlist。</li>\n<li><strong>一套项目图标与统计</strong>，结合着Github自带的项目图表，这个提供更多维度的数据，但是个人感觉意义不太大。</li>\n<li><strong>再加一些小彩蛋</strong>，由于它是作为插件形式嵌入到Github中的，所以会在很多地方提供一些这样那样的按钮，等着你去发现了。</li>\n</ol>\n<h3 id=\"持续集成-—-TravisCI\"><a href=\"#持续集成-—-TravisCI\" class=\"headerlink\" title=\"持续集成 — TravisCI\"></a>持续集成 — TravisCI</h3><blockquote>\n<p><a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"external\">TravisCI</a><br>Test and Deploy with Confidence<br>Easily sync your GitHub projects with Travis CI and you’ll be testing your code in minutes!</p>\n</blockquote>\n<p>不知道你有没有好奇Github上的一些明星项目的这样的标签：</p>\n<p><a href=\"https://travis-ci.org/expressjs/express\" target=\"_blank\" rel=\"external\"><img src=\"https://travis-ci.org/expressjs/express.svg?branch=master\" alt=\"Build Status\"></a></p>\n<p>这个是Express的构建状态的标签，格式是svg，它会根据Express的构建状态改变。如果Express的某一次提交是没有通过TravisCI构建的，他会变成 build failing。（有心人可以点击这个标签进去看看。）</p>\n<p>我们加入TravisCI主要目的是用于自动化的单元测试，每一次Commit与PR，TravisCI都会从Github仓库中拉取代码，然后执行我们写好的单元测试，通过与否会通过状态展示出来。<br>合并的人如果看到build failing，就不会合并了，这在一定程度上保证与提高了代码的质量。</p>\n<p>TravisCI除了可以用来自动化单元测试，还可以自动化部署，可以设定，通过测试之后，就自动部署上线。</p>\n<p>TravisCI对于公开仓库是免费的，但对于私有仓库是要收费的，而且价格也不便宜。<br>如果你觉得贵，这里还有一个可以代替的：<strong><a href=\"https://circleci.com/\" target=\"_blank\" rel=\"external\">CircleCI</a></strong><br>TravisCI可以做的，它都可以做得到，而且会提供一个免费的私有仓库。    </p>\n<h3 id=\"代码Review-—-Reviewable\"><a href=\"#代码Review-—-Reviewable\" class=\"headerlink\" title=\"代码Review — Reviewable\"></a>代码Review — Reviewable</h3><blockquote>\n<p><a href=\"https://reviewable.io/\" target=\"_blank\" rel=\"external\">Reviewable</a><br>GitHub code reviews done right</p>\n</blockquote>\n<p>如果你觉得Github自带的Review还不够满足的话，可以尝试一下这款产品。<br>当你提交一个PR之后，在你的PR中，会在你的评论框中嵌入这样的按钮</p>\n<p><img src=\"//dn-cnode.qbox.me/FrDLVgDD6alCXnHAfk4XNHJCCnS_\" alt></p>\n<p>点击进入Reviewable的页面对应的PR进行review。</p>\n<p>并且一个PR没有完成Review之前，是会一直被警告，让你警惕进行合并。</p>\n<h3 id=\"代码覆盖率-—-Coveralls\"><a href=\"#代码覆盖率-—-Coveralls\" class=\"headerlink\" title=\"代码覆盖率 — Coveralls\"></a>代码覆盖率 — Coveralls</h3><blockquote>\n<p><a href=\"http://coveralls.io/\" target=\"_blank\" rel=\"external\">Coveralls</a><br>We help you deliver code confidently by showing which parts of your code aren’t covered by your test suite. Free for open source repos. Pro accounts for private repos. Instant sign up through GitHub and Bitbucket.</p>\n</blockquote>\n<p>在明星项目Express的Github项目主页中，你可以看到这样的标签：</p>\n<p><a href=\"https://coveralls.io/github/strongloop/express?branch=master\" target=\"_blank\" rel=\"external\"><img src=\"https://coveralls.io/repos/strongloop/express/badge.svg?branch=master&amp;service=github\" alt=\"Coverage Status\"></a></p>\n<p>结合着TravisCI的自动化单元测试，加上这个测试覆盖率，提高你对项目的信心。</p>\n<h3 id=\"快速进行沟通-—-Slack\"><a href=\"#快速进行沟通-—-Slack\" class=\"headerlink\" title=\"快速进行沟通 — Slack\"></a>快速进行沟通 — Slack</h3><blockquote>\n<p><a href=\"https://slack.com/\" target=\"_blank\" rel=\"external\">Slack</a><br>A messaging app for teams who see through the Earth</p>\n</blockquote>\n<p>相信大部分团队都是使用微信进行沟通的，<br>再一次，最为一个有逼格的团队，我们使用了Slack进行团队上的沟通，在Slack上，你可以创建频道(Channel)，不同Channel不同的人进行着不同的话题沟通。我们有设计的Channel、产品的Channel、开发的Channel。我最欣赏的是，Slack可以接入很多第三方服务，Github是其中一个。</p>\n<p>接入Github之后，项目的每一个Commit、PR之类的动态信息，会被推送到聊天室中。</p>\n<p>助你时刻掌控项目动态。</p>\n<p><img src=\"//dn-cnode.qbox.me/FjrMtthZ9pX08AWOKbIPlogDKBcK\" alt></p>\n<p>Slack接入Githu只是其中的一个小功能而已，更强大的在于Slack本身，利器如何用，待君慢慢体会。  </p>\n<p><strong>但</strong>，Slack有一个硬伤：不会科学上网，用不了呀。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>再一次，作为一个有逼格的团队，我们依然不会满足现状。</p>\n","excerpt":"","more":"<p>一年时间我们从几个人的开发团队发展到十几人的团队，最初的我们只有两个后端加两个前端，而且其中三个还是实习生。<br>但今时不同往日，现在我们有前端、后端、测试、运维、设计、产品、交互，成功集齐了七个兵种，可以召唤神龙，赐我们一个敏捷的开发团队。<br>作为一个敏捷性的开发团队，我们要保持快速的迭代速度的同时保证高质量的代码，这是一个艰巨的过程。</p>\n<h3 id=\"版本管理-—-Git-Hub\"><a href=\"#版本管理-—-Git-Hub\" class=\"headerlink\" title=\"版本管理 — Git~Hub\"></a>版本管理 — Git~Hub</h3><blockquote>\n<p>「开始的开始，我们还是孩子」(出自《北京路的日子》)</p>\n</blockquote>\n<p>开始的开始，我们还是用着SVN，代码存储在公司的服务器中，只有一个分支，提交代码无需审核，无需单元测试。因为我们只有几个人……</p>\n<p>作为一个有逼格的团队，后来我们用上了Git，并且把代码迁移到Coding中去，然后引入了名为「git flow」的工作流，关于这个工作流可以参考我们老大的文章：<a href=\"http://www.jianshu.com/p/104fa8b15d1e\">「企业级开发：Gitflow Workflow工作流」</a></p>\n<p>Coding真的是一款很不错的产品，可称为业届良心。</p>\n<p>为什么当初没有直接用GitHub，因为私有仓库贵啊……</p>\n<p>但，作为一个有逼格的团队，我们是不会满足于此的。Coding自身的服务很不错了，但是相对于GitHub的一些专业的第三方服务，缺少了那么一些竞争力。我们当时想接入持续集成的服务，但是无奈找不到支持Coding的第三方服务，代码Review也没有一个更让我们舒心的体验，我承认我们要求比较高。再加上Coding的几次down机，其中一次是我们准备发布新版本的那一个下午…..</p>\n<p>终于有一天，我们老大两眼发光的跟我们说：我们要买GitHub的服务了，申请到资金了。</p>\n<p>于是乎，我们浩浩荡荡的迁移代码库。</p>\n<p>迁移到Github之后，我们开始接入各方工具，提高我们的工作效率（钱可不能白花啊）。</p>\n<h3 id=\"武装GitHub-—-ZenHub\"><a href=\"#武装GitHub-—-ZenHub\" class=\"headerlink\" title=\"武装GitHub — ZenHub\"></a>武装GitHub — ZenHub</h3><blockquote>\n<p><a href=\"https://www.zenhub.io/\">ZenHub</a><br>Project management inside GitHub<br>Transform your GitHub issues</p>\n</blockquote>\n<p>正如Zenhub所说，这是一款项目管理工具，嵌入式集成到GitHub中。作为插件，它的UI完全迎合了GitHub，以至于你难以分别出哪些功能是GitHub的，哪些功能是Zenhub的。</p>\n<p>如果你用了ZenHub，它会提供给你：</p>\n<ol>\n<li><strong>一套任务面板</strong>，给不同的任务提供不同的泳道，直观的展示每个任务的进度。于是乎我抛弃了Teambition。</li>\n<li><strong>一套个人的Todo List</strong>，如果有一个issue或者一个PR需要你来处理，但你现在没有空，你可以把它添加到Todo List中，于是乎我又抛弃了Wunderlist。</li>\n<li><strong>一套项目图标与统计</strong>，结合着Github自带的项目图表，这个提供更多维度的数据，但是个人感觉意义不太大。</li>\n<li><strong>再加一些小彩蛋</strong>，由于它是作为插件形式嵌入到Github中的，所以会在很多地方提供一些这样那样的按钮，等着你去发现了。</li>\n</ol>\n<h3 id=\"持续集成-—-TravisCI\"><a href=\"#持续集成-—-TravisCI\" class=\"headerlink\" title=\"持续集成 — TravisCI\"></a>持续集成 — TravisCI</h3><blockquote>\n<p><a href=\"https://travis-ci.org/\">TravisCI</a><br>Test and Deploy with Confidence<br>Easily sync your GitHub projects with Travis CI and you’ll be testing your code in minutes!</p>\n</blockquote>\n<p>不知道你有没有好奇Github上的一些明星项目的这样的标签：</p>\n<p><a href=\"https://travis-ci.org/expressjs/express\"><img src=\"https://travis-ci.org/expressjs/express.svg?branch=master\" alt=\"Build Status\"></a></p>\n<p>这个是Express的构建状态的标签，格式是svg，它会根据Express的构建状态改变。如果Express的某一次提交是没有通过TravisCI构建的，他会变成 build failing。（有心人可以点击这个标签进去看看。）</p>\n<p>我们加入TravisCI主要目的是用于自动化的单元测试，每一次Commit与PR，TravisCI都会从Github仓库中拉取代码，然后执行我们写好的单元测试，通过与否会通过状态展示出来。<br>合并的人如果看到build failing，就不会合并了，这在一定程度上保证与提高了代码的质量。</p>\n<p>TravisCI除了可以用来自动化单元测试，还可以自动化部署，可以设定，通过测试之后，就自动部署上线。</p>\n<p>TravisCI对于公开仓库是免费的，但对于私有仓库是要收费的，而且价格也不便宜。<br>如果你觉得贵，这里还有一个可以代替的：<strong><a href=\"https://circleci.com/\">CircleCI</a></strong><br>TravisCI可以做的，它都可以做得到，而且会提供一个免费的私有仓库。    </p>\n<h3 id=\"代码Review-—-Reviewable\"><a href=\"#代码Review-—-Reviewable\" class=\"headerlink\" title=\"代码Review — Reviewable\"></a>代码Review — Reviewable</h3><blockquote>\n<p><a href=\"https://reviewable.io/\">Reviewable</a><br>GitHub code reviews done right</p>\n</blockquote>\n<p>如果你觉得Github自带的Review还不够满足的话，可以尝试一下这款产品。<br>当你提交一个PR之后，在你的PR中，会在你的评论框中嵌入这样的按钮</p>\n<p><img src=\"//dn-cnode.qbox.me/FrDLVgDD6alCXnHAfk4XNHJCCnS_\" alt=\"\"></p>\n<p>点击进入Reviewable的页面对应的PR进行review。</p>\n<p>并且一个PR没有完成Review之前，是会一直被警告，让你警惕进行合并。</p>\n<h3 id=\"代码覆盖率-—-Coveralls\"><a href=\"#代码覆盖率-—-Coveralls\" class=\"headerlink\" title=\"代码覆盖率 — Coveralls\"></a>代码覆盖率 — Coveralls</h3><blockquote>\n<p><a href=\"http://coveralls.io/\">Coveralls</a><br>We help you deliver code confidently by showing which parts of your code aren’t covered by your test suite. Free for open source repos. Pro accounts for private repos. Instant sign up through GitHub and Bitbucket.</p>\n</blockquote>\n<p>在明星项目Express的Github项目主页中，你可以看到这样的标签：</p>\n<p><a href=\"https://coveralls.io/github/strongloop/express?branch=master\"><img src=\"https://coveralls.io/repos/strongloop/express/badge.svg?branch=master&amp;service=github\" alt=\"Coverage Status\"></a></p>\n<p>结合着TravisCI的自动化单元测试，加上这个测试覆盖率，提高你对项目的信心。</p>\n<h3 id=\"快速进行沟通-—-Slack\"><a href=\"#快速进行沟通-—-Slack\" class=\"headerlink\" title=\"快速进行沟通 — Slack\"></a>快速进行沟通 — Slack</h3><blockquote>\n<p><a href=\"https://slack.com/\">Slack</a><br>A messaging app for teams who see through the Earth</p>\n</blockquote>\n<p>相信大部分团队都是使用微信进行沟通的，<br>再一次，最为一个有逼格的团队，我们使用了Slack进行团队上的沟通，在Slack上，你可以创建频道(Channel)，不同Channel不同的人进行着不同的话题沟通。我们有设计的Channel、产品的Channel、开发的Channel。我最欣赏的是，Slack可以接入很多第三方服务，Github是其中一个。</p>\n<p>接入Github之后，项目的每一个Commit、PR之类的动态信息，会被推送到聊天室中。</p>\n<p>助你时刻掌控项目动态。</p>\n<p><img src=\"//dn-cnode.qbox.me/FjrMtthZ9pX08AWOKbIPlogDKBcK\" alt=\"\"></p>\n<p>Slack接入Githu只是其中的一个小功能而已，更强大的在于Slack本身，利器如何用，待君慢慢体会。  </p>\n<p><strong>但</strong>，Slack有一个硬伤：不会科学上网，用不了呀。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>再一次，作为一个有逼格的团队，我们依然不会满足现状。</p>\n"},{"title":"基于jQuery的2048游戏","date":"2014-07-12T08:29:09.000Z","_content":"\n### 前言\n受网上看到的一个2048视频游戏制作的启发，做了一个网页版的，很多细节参照了一下别人的。暂时还没有分数统计功能，找时间再做好。先上一个demo版。\n\n### 截图\n![截图](/image/blog/imgFile1412172676130.jpg)\n\n### 程序架构\n![脑图](/image/blog/imgFile1412172691061.jpeg)\n\n\n**演示地址**：[http://jerryc8080.github.io/My2048/](http://jerryc8080.github.io/My2048/)\n**程序地址**：[https://github.com/JerryC8080/My2048](http://jerryc8080.github.io/My2048/)\n\n\n代码：太多了就不贴了，有兴趣的看管请到以上地址下载吧。\n","source":"_posts/基于jQuery的2048游戏.md","raw":"---\ntitle: 基于jQuery的2048游戏\ncategory: 搬砖码农\ndate: 2014-07-12 16:29:09\ntags:\n---\n\n### 前言\n受网上看到的一个2048视频游戏制作的启发，做了一个网页版的，很多细节参照了一下别人的。暂时还没有分数统计功能，找时间再做好。先上一个demo版。\n\n### 截图\n![截图](/image/blog/imgFile1412172676130.jpg)\n\n### 程序架构\n![脑图](/image/blog/imgFile1412172691061.jpeg)\n\n\n**演示地址**：[http://jerryc8080.github.io/My2048/](http://jerryc8080.github.io/My2048/)\n**程序地址**：[https://github.com/JerryC8080/My2048](http://jerryc8080.github.io/My2048/)\n\n\n代码：太多了就不贴了，有兴趣的看管请到以上地址下载吧。\n","slug":"基于jQuery的2048游戏","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8rh001txwrlp6u31v4g","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>受网上看到的一个2048视频游戏制作的启发，做了一个网页版的，很多细节参照了一下别人的。暂时还没有分数统计功能，找时间再做好。先上一个demo版。</p>\n<h3 id=\"截图\"><a href=\"#截图\" class=\"headerlink\" title=\"截图\"></a>截图</h3><p><img src=\"/image/blog/imgFile1412172676130.jpg\" alt=\"截图\"></p>\n<h3 id=\"程序架构\"><a href=\"#程序架构\" class=\"headerlink\" title=\"程序架构\"></a>程序架构</h3><p><img src=\"/image/blog/imgFile1412172691061.jpeg\" alt=\"脑图\"></p>\n<p><strong>演示地址</strong>：<a href=\"http://jerryc8080.github.io/My2048/\" target=\"_blank\" rel=\"external\">http://jerryc8080.github.io/My2048/</a><br><strong>程序地址</strong>：<a href=\"http://jerryc8080.github.io/My2048/\" target=\"_blank\" rel=\"external\">https://github.com/JerryC8080/My2048</a></p>\n<p>代码：太多了就不贴了，有兴趣的看管请到以上地址下载吧。</p>\n","excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>受网上看到的一个2048视频游戏制作的启发，做了一个网页版的，很多细节参照了一下别人的。暂时还没有分数统计功能，找时间再做好。先上一个demo版。</p>\n<h3 id=\"截图\"><a href=\"#截图\" class=\"headerlink\" title=\"截图\"></a>截图</h3><p><img src=\"/image/blog/imgFile1412172676130.jpg\" alt=\"截图\"></p>\n<h3 id=\"程序架构\"><a href=\"#程序架构\" class=\"headerlink\" title=\"程序架构\"></a>程序架构</h3><p><img src=\"/image/blog/imgFile1412172691061.jpeg\" alt=\"脑图\"></p>\n<p><strong>演示地址</strong>：<a href=\"http://jerryc8080.github.io/My2048/\">http://jerryc8080.github.io/My2048/</a><br><strong>程序地址</strong>：<a href=\"http://jerryc8080.github.io/My2048/\">https://github.com/JerryC8080/My2048</a></p>\n<p>代码：太多了就不贴了，有兴趣的看管请到以上地址下载吧。</p>\n"},{"title":"基于RESTful-API-怎么设计用户权限控制","date":"2015-03-29T13:38:59.000Z","_content":"\n\n## 前言\n\n有人说，每个人都是平等的；\n也有人说，人生来就是不平等的；\n在人类社会中，并没有绝对的公平，\n一件事，并不是所有人都能去做；\n一样物，并不是所有人都能够拥有。\n每个人都有自己的角色，每种角色都有对某种资源的一定权利，或许是拥有，或许只能是远观而不可亵玩。\n把这种人类社会中如此抽象的事实，提取出来，然后写成程序，还原本质的工作，就是我们程序员该做的事了。\n有了一个这么有范儿的开头，下面便来谈谈基于RESTful，如何实现不同的人不同的角色对于不同的资源不同的操作的权限控制。\n\n## RESTful简述\n\n本文是基于RESTful描述的，需要你对这个有初步的了解。\nRESTful是什么？\n**Representational State Transfer**，简称**REST**，是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。\nREST比较重要的点是**资源**和**状态转换**，\n所谓\"**资源**\"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。\n而 \"**状态转换**\"，则是把对应的HTTP协议里面，四个表示操作方式的动词分别对应四种基本操作：\n\n1.  GET，用来浏览(browse)资源    \n2.  POST，用来新建(create)资源    \n3.  PUT，用来更新(update)资源    \n4.  DELETE，用来删除(delete)资源        \n\n![RESTful CURD](http://xia-dev.b0.upaiyun.com/7860df36-189a-4f33-a884-156b4e0cb32d.png)\n\n## 资源的分类及操作\n\n清楚了资源的概念，然后再来对资源进行一下分类，我把资源分为下面三类：\n\n1.  私人资源 (Personal Source)\n2.  角色资源 (Roles Source)\n3.  公共资源 (Public Source)\n\n![Sources](http://xia-dev.b0.upaiyun.com/966064e4-b954-4aab-8cec-f0a9513835b2.png)\n\n**\"私人资源\"**：是属于某一个用户所有的资源，只有用户本人才能操作，其他用户不能操作。例如用户的个人信息、订单、收货地址等等。 \n**\"角色资源\"**：与私人资源不同，角色资源范畴更大，一个角色可以对应多个人，也就是一群人。如果给某角色分配了权限，那么只有身为该角色的用户才能拥有这些权限。例如系统资源只能够管理员操作，一般用户不能操作。 \n**\"公共资源\"**：所有人无论角色都能够访问并操作的资源。 \n\n而对资源的操作，无非就是分为四种：\n\n1.  浏览 (browse)    \n2.  新增 (create)    \n3.  更新 (update)    \n4.  删除 (delete)    \n\n## 角色、用户、权限之间的关系\n\n角色和用户的概念，自不用多说，大家都懂，但是权限的概念需要提一提。    \n**\"权限\"**，就是资源与操作的一套组合，例如\"增加用户\"是一种权限，\"删除用户\"是一种权限，所以对于一种资源所对应的权限有且只有四种。\n\n![Permissions](http://xia-dev.b0.upaiyun.com/3f78aa79-82ae-40d1-9691-976e007dcfd3.png)\n\n**角色**与**用户**的关系：一个角色对应一群用户，一个用户也可以扮演多个角色，所以它们是多对多的关系。    \n**角色**与**权限**的关系：一个角色拥有一堆权限，一个权限却只能属于一个角色，所以它们是一(角色)对多(权限)的关系    \n**权限**与**用户**的关系：由于一个用户可以扮演多个角色，一个角色拥有多个权限，所以用户与权限是间接的多对多关系。\n\n![Relations](http://xia-dev.b0.upaiyun.com/0c724f72-aa01-44b8-9540-f463e50924d0.png)\n\n需要注意两种特别情况：\n\n1.  私人资源与用户的关系，一种私人资源对应的四种权限只能属于一个用户，所以这种情况下，用户和权限是一(用户)对多(权限)的关系。\n2.  超级管理员的角色，这个角色是神一般的存在，能无视一切阻碍，对所有资源拥有绝对权限，甭管你是私人资源还是角色资源。\n\n## 数据库表的设计\n\n角色、用户、权限的模型应该怎么样设计，才能满足它们之间的关系？\n\n![Models](http://xia-dev.b0.upaiyun.com/b3c4a7ba-6ec8-4530-b576-ecbae2d9b239.png)\n\n对上图的一些关键字段进行说明：\n\n###### Source\n\n*   name: 资源的名称，也就是其他模型的名称，例如：user、role等等。\n*   identity: 资源的唯一标识，可以像uuid，shortid这些字符串，也可以是model的名称。\n*   permissions : 一种资源对应有四种权限，分别对这种资源的browse、create、update、delete\n\n###### Permission\n\n*   source : 该权限对应的资源，也就是Source的某一条记录的唯一标识\n*   action ：对应资源的操作，只能是browse、create、update、delete四个之一\n*   relation：用来标记该权限是属于私人的，还是角色的，用于OwnerPolicy检测\n*   roles: 拥有该权限的角色\n\n###### Role\n\n*   users : 角色所对应的用户群，一个角色可以对应多个用户\n*   permissions: 权限列表，一个角色拥有多项权利\n\n###### User\n\n*   createBy : 该记录的拥有者，在user标里，一般等于该记录的唯一标识，这一属性用于OwnerPolicy的检测，其他私有资源的模型设计，也需要加上这一字段来标识资源的拥有者。\n*   roles : 用户所拥有的角色\n\n## 策略/过滤器\n\n在sails下称为策略(Policy)，在java SSH下称为过滤器(Filter)，无论名称如何，他们工作原理是大同小异的，主要是在一条HTTP请求访问一个Controller下的action之前进行检测。所以在这一层，我们可以自定义一些策略/过滤器来实现权限控制。    \n为行文方便，下面姑且允许我使用策略这一词。\n\n** 策略 (Policy) **\n> 下面排版顺序对应Policy的运行顺序\n\n1.  **SessionAuthPolicy**：    \n检测用户是否已经登录，用户登录是进行下面检测的前提。\n2.  **SourcePolicy**：    \n检测访问的资源是否存在，主要检测Source表的记录\n3.  **PermissionPolicy**：    \n检测该用户所属的角色，是否有对所访问资源进行对应操作的权限。\n4.  **OwnerPolicy**：    \n如果所访问的资源属于私人资源，则检测当前用户是否该资源的拥有者。\n\n如果通过所有policy的检测，则把请求转发到目标action。\n\n![Policies](http://xia-dev.b0.upaiyun.com/73b94749-99ba-4e35-a9a3-42604ecb7af9.png)\n\n## Sails下的权限控制实现\n\n在Sails下，有一个很方便的套件[sails-permissions](https://github.com/tjwebb/sails-permissions)，集成了一套权限管理的方案，本文也是基于该套件的源码所引出来的权限管理解决方案。\n\n## 结语\n\n对程序员最大的挑战，并不是能否掌握了哪些编程语言，哪些软件框架，而是对业务和需求的理解，然后在此基础上，把要点抽象出来，写成计算机能理解的语言。    \n最后，希望这篇文章，能够帮助你对权限管理这一课题增加多一点点理解。\n\n## 写作参考\n\n*   [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n*   [REST wiki](http://zh.wikipedia.org/wiki/REST)\n*   [sails-permissions 源码](https://github.com/tjwebb/sails-permissions)\n","source":"_posts/基于RESTful-API-怎么设计用户权限控制.md","raw":"---\ntitle: 基于RESTful-API-怎么设计用户权限控制\ncategory: 搬砖码农\ndate: 2015-03-29 21:38:59\ntags:\n- RESTful\n- 权限系统\n- 架构\n---\n\n\n## 前言\n\n有人说，每个人都是平等的；\n也有人说，人生来就是不平等的；\n在人类社会中，并没有绝对的公平，\n一件事，并不是所有人都能去做；\n一样物，并不是所有人都能够拥有。\n每个人都有自己的角色，每种角色都有对某种资源的一定权利，或许是拥有，或许只能是远观而不可亵玩。\n把这种人类社会中如此抽象的事实，提取出来，然后写成程序，还原本质的工作，就是我们程序员该做的事了。\n有了一个这么有范儿的开头，下面便来谈谈基于RESTful，如何实现不同的人不同的角色对于不同的资源不同的操作的权限控制。\n\n## RESTful简述\n\n本文是基于RESTful描述的，需要你对这个有初步的了解。\nRESTful是什么？\n**Representational State Transfer**，简称**REST**，是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。\nREST比较重要的点是**资源**和**状态转换**，\n所谓\"**资源**\"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。\n而 \"**状态转换**\"，则是把对应的HTTP协议里面，四个表示操作方式的动词分别对应四种基本操作：\n\n1.  GET，用来浏览(browse)资源    \n2.  POST，用来新建(create)资源    \n3.  PUT，用来更新(update)资源    \n4.  DELETE，用来删除(delete)资源        \n\n![RESTful CURD](http://xia-dev.b0.upaiyun.com/7860df36-189a-4f33-a884-156b4e0cb32d.png)\n\n## 资源的分类及操作\n\n清楚了资源的概念，然后再来对资源进行一下分类，我把资源分为下面三类：\n\n1.  私人资源 (Personal Source)\n2.  角色资源 (Roles Source)\n3.  公共资源 (Public Source)\n\n![Sources](http://xia-dev.b0.upaiyun.com/966064e4-b954-4aab-8cec-f0a9513835b2.png)\n\n**\"私人资源\"**：是属于某一个用户所有的资源，只有用户本人才能操作，其他用户不能操作。例如用户的个人信息、订单、收货地址等等。 \n**\"角色资源\"**：与私人资源不同，角色资源范畴更大，一个角色可以对应多个人，也就是一群人。如果给某角色分配了权限，那么只有身为该角色的用户才能拥有这些权限。例如系统资源只能够管理员操作，一般用户不能操作。 \n**\"公共资源\"**：所有人无论角色都能够访问并操作的资源。 \n\n而对资源的操作，无非就是分为四种：\n\n1.  浏览 (browse)    \n2.  新增 (create)    \n3.  更新 (update)    \n4.  删除 (delete)    \n\n## 角色、用户、权限之间的关系\n\n角色和用户的概念，自不用多说，大家都懂，但是权限的概念需要提一提。    \n**\"权限\"**，就是资源与操作的一套组合，例如\"增加用户\"是一种权限，\"删除用户\"是一种权限，所以对于一种资源所对应的权限有且只有四种。\n\n![Permissions](http://xia-dev.b0.upaiyun.com/3f78aa79-82ae-40d1-9691-976e007dcfd3.png)\n\n**角色**与**用户**的关系：一个角色对应一群用户，一个用户也可以扮演多个角色，所以它们是多对多的关系。    \n**角色**与**权限**的关系：一个角色拥有一堆权限，一个权限却只能属于一个角色，所以它们是一(角色)对多(权限)的关系    \n**权限**与**用户**的关系：由于一个用户可以扮演多个角色，一个角色拥有多个权限，所以用户与权限是间接的多对多关系。\n\n![Relations](http://xia-dev.b0.upaiyun.com/0c724f72-aa01-44b8-9540-f463e50924d0.png)\n\n需要注意两种特别情况：\n\n1.  私人资源与用户的关系，一种私人资源对应的四种权限只能属于一个用户，所以这种情况下，用户和权限是一(用户)对多(权限)的关系。\n2.  超级管理员的角色，这个角色是神一般的存在，能无视一切阻碍，对所有资源拥有绝对权限，甭管你是私人资源还是角色资源。\n\n## 数据库表的设计\n\n角色、用户、权限的模型应该怎么样设计，才能满足它们之间的关系？\n\n![Models](http://xia-dev.b0.upaiyun.com/b3c4a7ba-6ec8-4530-b576-ecbae2d9b239.png)\n\n对上图的一些关键字段进行说明：\n\n###### Source\n\n*   name: 资源的名称，也就是其他模型的名称，例如：user、role等等。\n*   identity: 资源的唯一标识，可以像uuid，shortid这些字符串，也可以是model的名称。\n*   permissions : 一种资源对应有四种权限，分别对这种资源的browse、create、update、delete\n\n###### Permission\n\n*   source : 该权限对应的资源，也就是Source的某一条记录的唯一标识\n*   action ：对应资源的操作，只能是browse、create、update、delete四个之一\n*   relation：用来标记该权限是属于私人的，还是角色的，用于OwnerPolicy检测\n*   roles: 拥有该权限的角色\n\n###### Role\n\n*   users : 角色所对应的用户群，一个角色可以对应多个用户\n*   permissions: 权限列表，一个角色拥有多项权利\n\n###### User\n\n*   createBy : 该记录的拥有者，在user标里，一般等于该记录的唯一标识，这一属性用于OwnerPolicy的检测，其他私有资源的模型设计，也需要加上这一字段来标识资源的拥有者。\n*   roles : 用户所拥有的角色\n\n## 策略/过滤器\n\n在sails下称为策略(Policy)，在java SSH下称为过滤器(Filter)，无论名称如何，他们工作原理是大同小异的，主要是在一条HTTP请求访问一个Controller下的action之前进行检测。所以在这一层，我们可以自定义一些策略/过滤器来实现权限控制。    \n为行文方便，下面姑且允许我使用策略这一词。\n\n** 策略 (Policy) **\n> 下面排版顺序对应Policy的运行顺序\n\n1.  **SessionAuthPolicy**：    \n检测用户是否已经登录，用户登录是进行下面检测的前提。\n2.  **SourcePolicy**：    \n检测访问的资源是否存在，主要检测Source表的记录\n3.  **PermissionPolicy**：    \n检测该用户所属的角色，是否有对所访问资源进行对应操作的权限。\n4.  **OwnerPolicy**：    \n如果所访问的资源属于私人资源，则检测当前用户是否该资源的拥有者。\n\n如果通过所有policy的检测，则把请求转发到目标action。\n\n![Policies](http://xia-dev.b0.upaiyun.com/73b94749-99ba-4e35-a9a3-42604ecb7af9.png)\n\n## Sails下的权限控制实现\n\n在Sails下，有一个很方便的套件[sails-permissions](https://github.com/tjwebb/sails-permissions)，集成了一套权限管理的方案，本文也是基于该套件的源码所引出来的权限管理解决方案。\n\n## 结语\n\n对程序员最大的挑战，并不是能否掌握了哪些编程语言，哪些软件框架，而是对业务和需求的理解，然后在此基础上，把要点抽象出来，写成计算机能理解的语言。    \n最后，希望这篇文章，能够帮助你对权限管理这一课题增加多一点点理解。\n\n## 写作参考\n\n*   [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n*   [REST wiki](http://zh.wikipedia.org/wiki/REST)\n*   [sails-permissions 源码](https://github.com/tjwebb/sails-permissions)\n","slug":"基于RESTful-API-怎么设计用户权限控制","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8rj001vxwrl0yrr10li","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有人说，每个人都是平等的；<br>也有人说，人生来就是不平等的；<br>在人类社会中，并没有绝对的公平，<br>一件事，并不是所有人都能去做；<br>一样物，并不是所有人都能够拥有。<br>每个人都有自己的角色，每种角色都有对某种资源的一定权利，或许是拥有，或许只能是远观而不可亵玩。<br>把这种人类社会中如此抽象的事实，提取出来，然后写成程序，还原本质的工作，就是我们程序员该做的事了。<br>有了一个这么有范儿的开头，下面便来谈谈基于RESTful，如何实现不同的人不同的角色对于不同的资源不同的操作的权限控制。</p>\n<h2 id=\"RESTful简述\"><a href=\"#RESTful简述\" class=\"headerlink\" title=\"RESTful简述\"></a>RESTful简述</h2><p>本文是基于RESTful描述的，需要你对这个有初步的了解。<br>RESTful是什么？<br><strong>Representational State Transfer</strong>，简称<strong>REST</strong>，是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。<br>REST比较重要的点是<strong>资源</strong>和<strong>状态转换</strong>，<br>所谓”<strong>资源</strong>“，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。<br>而 “<strong>状态转换</strong>“，则是把对应的HTTP协议里面，四个表示操作方式的动词分别对应四种基本操作：</p>\n<ol>\n<li>GET，用来浏览(browse)资源    </li>\n<li>POST，用来新建(create)资源    </li>\n<li>PUT，用来更新(update)资源    </li>\n<li>DELETE，用来删除(delete)资源        </li>\n</ol>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/7860df36-189a-4f33-a884-156b4e0cb32d.png\" alt=\"RESTful CURD\"></p>\n<h2 id=\"资源的分类及操作\"><a href=\"#资源的分类及操作\" class=\"headerlink\" title=\"资源的分类及操作\"></a>资源的分类及操作</h2><p>清楚了资源的概念，然后再来对资源进行一下分类，我把资源分为下面三类：</p>\n<ol>\n<li>私人资源 (Personal Source)</li>\n<li>角色资源 (Roles Source)</li>\n<li>公共资源 (Public Source)</li>\n</ol>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/966064e4-b954-4aab-8cec-f0a9513835b2.png\" alt=\"Sources\"></p>\n<p><strong>“私人资源”</strong>：是属于某一个用户所有的资源，只有用户本人才能操作，其他用户不能操作。例如用户的个人信息、订单、收货地址等等。<br><strong>“角色资源”</strong>：与私人资源不同，角色资源范畴更大，一个角色可以对应多个人，也就是一群人。如果给某角色分配了权限，那么只有身为该角色的用户才能拥有这些权限。例如系统资源只能够管理员操作，一般用户不能操作。<br><strong>“公共资源”</strong>：所有人无论角色都能够访问并操作的资源。 </p>\n<p>而对资源的操作，无非就是分为四种：</p>\n<ol>\n<li>浏览 (browse)    </li>\n<li>新增 (create)    </li>\n<li>更新 (update)    </li>\n<li>删除 (delete)    </li>\n</ol>\n<h2 id=\"角色、用户、权限之间的关系\"><a href=\"#角色、用户、权限之间的关系\" class=\"headerlink\" title=\"角色、用户、权限之间的关系\"></a>角色、用户、权限之间的关系</h2><p>角色和用户的概念，自不用多说，大家都懂，但是权限的概念需要提一提。<br><strong>“权限”</strong>，就是资源与操作的一套组合，例如”增加用户”是一种权限，”删除用户”是一种权限，所以对于一种资源所对应的权限有且只有四种。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/3f78aa79-82ae-40d1-9691-976e007dcfd3.png\" alt=\"Permissions\"></p>\n<p><strong>角色</strong>与<strong>用户</strong>的关系：一个角色对应一群用户，一个用户也可以扮演多个角色，所以它们是多对多的关系。<br><strong>角色</strong>与<strong>权限</strong>的关系：一个角色拥有一堆权限，一个权限却只能属于一个角色，所以它们是一(角色)对多(权限)的关系<br><strong>权限</strong>与<strong>用户</strong>的关系：由于一个用户可以扮演多个角色，一个角色拥有多个权限，所以用户与权限是间接的多对多关系。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/0c724f72-aa01-44b8-9540-f463e50924d0.png\" alt=\"Relations\"></p>\n<p>需要注意两种特别情况：</p>\n<ol>\n<li>私人资源与用户的关系，一种私人资源对应的四种权限只能属于一个用户，所以这种情况下，用户和权限是一(用户)对多(权限)的关系。</li>\n<li>超级管理员的角色，这个角色是神一般的存在，能无视一切阻碍，对所有资源拥有绝对权限，甭管你是私人资源还是角色资源。</li>\n</ol>\n<h2 id=\"数据库表的设计\"><a href=\"#数据库表的设计\" class=\"headerlink\" title=\"数据库表的设计\"></a>数据库表的设计</h2><p>角色、用户、权限的模型应该怎么样设计，才能满足它们之间的关系？</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/b3c4a7ba-6ec8-4530-b576-ecbae2d9b239.png\" alt=\"Models\"></p>\n<p>对上图的一些关键字段进行说明：</p>\n<h6 id=\"Source\"><a href=\"#Source\" class=\"headerlink\" title=\"Source\"></a>Source</h6><ul>\n<li>name: 资源的名称，也就是其他模型的名称，例如：user、role等等。</li>\n<li>identity: 资源的唯一标识，可以像uuid，shortid这些字符串，也可以是model的名称。</li>\n<li>permissions : 一种资源对应有四种权限，分别对这种资源的browse、create、update、delete</li>\n</ul>\n<h6 id=\"Permission\"><a href=\"#Permission\" class=\"headerlink\" title=\"Permission\"></a>Permission</h6><ul>\n<li>source : 该权限对应的资源，也就是Source的某一条记录的唯一标识</li>\n<li>action ：对应资源的操作，只能是browse、create、update、delete四个之一</li>\n<li>relation：用来标记该权限是属于私人的，还是角色的，用于OwnerPolicy检测</li>\n<li>roles: 拥有该权限的角色</li>\n</ul>\n<h6 id=\"Role\"><a href=\"#Role\" class=\"headerlink\" title=\"Role\"></a>Role</h6><ul>\n<li>users : 角色所对应的用户群，一个角色可以对应多个用户</li>\n<li>permissions: 权限列表，一个角色拥有多项权利</li>\n</ul>\n<h6 id=\"User\"><a href=\"#User\" class=\"headerlink\" title=\"User\"></a>User</h6><ul>\n<li>createBy : 该记录的拥有者，在user标里，一般等于该记录的唯一标识，这一属性用于OwnerPolicy的检测，其他私有资源的模型设计，也需要加上这一字段来标识资源的拥有者。</li>\n<li>roles : 用户所拥有的角色</li>\n</ul>\n<h2 id=\"策略-过滤器\"><a href=\"#策略-过滤器\" class=\"headerlink\" title=\"策略/过滤器\"></a>策略/过滤器</h2><p>在sails下称为策略(Policy)，在java SSH下称为过滤器(Filter)，无论名称如何，他们工作原理是大同小异的，主要是在一条HTTP请求访问一个Controller下的action之前进行检测。所以在这一层，我们可以自定义一些策略/过滤器来实现权限控制。<br>为行文方便，下面姑且允许我使用策略这一词。</p>\n<p><strong> 策略 (Policy) </strong></p>\n<blockquote>\n<p>下面排版顺序对应Policy的运行顺序</p>\n</blockquote>\n<ol>\n<li><strong>SessionAuthPolicy</strong>：<br>检测用户是否已经登录，用户登录是进行下面检测的前提。</li>\n<li><strong>SourcePolicy</strong>：<br>检测访问的资源是否存在，主要检测Source表的记录</li>\n<li><strong>PermissionPolicy</strong>：<br>检测该用户所属的角色，是否有对所访问资源进行对应操作的权限。</li>\n<li><strong>OwnerPolicy</strong>：<br>如果所访问的资源属于私人资源，则检测当前用户是否该资源的拥有者。</li>\n</ol>\n<p>如果通过所有policy的检测，则把请求转发到目标action。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/73b94749-99ba-4e35-a9a3-42604ecb7af9.png\" alt=\"Policies\"></p>\n<h2 id=\"Sails下的权限控制实现\"><a href=\"#Sails下的权限控制实现\" class=\"headerlink\" title=\"Sails下的权限控制实现\"></a>Sails下的权限控制实现</h2><p>在Sails下，有一个很方便的套件<a href=\"https://github.com/tjwebb/sails-permissions\" target=\"_blank\" rel=\"external\">sails-permissions</a>，集成了一套权限管理的方案，本文也是基于该套件的源码所引出来的权限管理解决方案。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>对程序员最大的挑战，并不是能否掌握了哪些编程语言，哪些软件框架，而是对业务和需求的理解，然后在此基础上，把要点抽象出来，写成计算机能理解的语言。<br>最后，希望这篇文章，能够帮助你对权限管理这一课题增加多一点点理解。</p>\n<h2 id=\"写作参考\"><a href=\"#写作参考\" class=\"headerlink\" title=\"写作参考\"></a>写作参考</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"external\">理解RESTful架构</a></li>\n<li><a href=\"http://zh.wikipedia.org/wiki/REST\" target=\"_blank\" rel=\"external\">REST wiki</a></li>\n<li><a href=\"https://github.com/tjwebb/sails-permissions\" target=\"_blank\" rel=\"external\">sails-permissions 源码</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有人说，每个人都是平等的；<br>也有人说，人生来就是不平等的；<br>在人类社会中，并没有绝对的公平，<br>一件事，并不是所有人都能去做；<br>一样物，并不是所有人都能够拥有。<br>每个人都有自己的角色，每种角色都有对某种资源的一定权利，或许是拥有，或许只能是远观而不可亵玩。<br>把这种人类社会中如此抽象的事实，提取出来，然后写成程序，还原本质的工作，就是我们程序员该做的事了。<br>有了一个这么有范儿的开头，下面便来谈谈基于RESTful，如何实现不同的人不同的角色对于不同的资源不同的操作的权限控制。</p>\n<h2 id=\"RESTful简述\"><a href=\"#RESTful简述\" class=\"headerlink\" title=\"RESTful简述\"></a>RESTful简述</h2><p>本文是基于RESTful描述的，需要你对这个有初步的了解。<br>RESTful是什么？<br><strong>Representational State Transfer</strong>，简称<strong>REST</strong>，是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。<br>REST比较重要的点是<strong>资源</strong>和<strong>状态转换</strong>，<br>所谓”<strong>资源</strong>“，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。<br>而 “<strong>状态转换</strong>“，则是把对应的HTTP协议里面，四个表示操作方式的动词分别对应四种基本操作：</p>\n<ol>\n<li>GET，用来浏览(browse)资源    </li>\n<li>POST，用来新建(create)资源    </li>\n<li>PUT，用来更新(update)资源    </li>\n<li>DELETE，用来删除(delete)资源        </li>\n</ol>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/7860df36-189a-4f33-a884-156b4e0cb32d.png\" alt=\"RESTful CURD\"></p>\n<h2 id=\"资源的分类及操作\"><a href=\"#资源的分类及操作\" class=\"headerlink\" title=\"资源的分类及操作\"></a>资源的分类及操作</h2><p>清楚了资源的概念，然后再来对资源进行一下分类，我把资源分为下面三类：</p>\n<ol>\n<li>私人资源 (Personal Source)</li>\n<li>角色资源 (Roles Source)</li>\n<li>公共资源 (Public Source)</li>\n</ol>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/966064e4-b954-4aab-8cec-f0a9513835b2.png\" alt=\"Sources\"></p>\n<p><strong>“私人资源”</strong>：是属于某一个用户所有的资源，只有用户本人才能操作，其他用户不能操作。例如用户的个人信息、订单、收货地址等等。<br><strong>“角色资源”</strong>：与私人资源不同，角色资源范畴更大，一个角色可以对应多个人，也就是一群人。如果给某角色分配了权限，那么只有身为该角色的用户才能拥有这些权限。例如系统资源只能够管理员操作，一般用户不能操作。<br><strong>“公共资源”</strong>：所有人无论角色都能够访问并操作的资源。 </p>\n<p>而对资源的操作，无非就是分为四种：</p>\n<ol>\n<li>浏览 (browse)    </li>\n<li>新增 (create)    </li>\n<li>更新 (update)    </li>\n<li>删除 (delete)    </li>\n</ol>\n<h2 id=\"角色、用户、权限之间的关系\"><a href=\"#角色、用户、权限之间的关系\" class=\"headerlink\" title=\"角色、用户、权限之间的关系\"></a>角色、用户、权限之间的关系</h2><p>角色和用户的概念，自不用多说，大家都懂，但是权限的概念需要提一提。<br><strong>“权限”</strong>，就是资源与操作的一套组合，例如”增加用户”是一种权限，”删除用户”是一种权限，所以对于一种资源所对应的权限有且只有四种。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/3f78aa79-82ae-40d1-9691-976e007dcfd3.png\" alt=\"Permissions\"></p>\n<p><strong>角色</strong>与<strong>用户</strong>的关系：一个角色对应一群用户，一个用户也可以扮演多个角色，所以它们是多对多的关系。<br><strong>角色</strong>与<strong>权限</strong>的关系：一个角色拥有一堆权限，一个权限却只能属于一个角色，所以它们是一(角色)对多(权限)的关系<br><strong>权限</strong>与<strong>用户</strong>的关系：由于一个用户可以扮演多个角色，一个角色拥有多个权限，所以用户与权限是间接的多对多关系。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/0c724f72-aa01-44b8-9540-f463e50924d0.png\" alt=\"Relations\"></p>\n<p>需要注意两种特别情况：</p>\n<ol>\n<li>私人资源与用户的关系，一种私人资源对应的四种权限只能属于一个用户，所以这种情况下，用户和权限是一(用户)对多(权限)的关系。</li>\n<li>超级管理员的角色，这个角色是神一般的存在，能无视一切阻碍，对所有资源拥有绝对权限，甭管你是私人资源还是角色资源。</li>\n</ol>\n<h2 id=\"数据库表的设计\"><a href=\"#数据库表的设计\" class=\"headerlink\" title=\"数据库表的设计\"></a>数据库表的设计</h2><p>角色、用户、权限的模型应该怎么样设计，才能满足它们之间的关系？</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/b3c4a7ba-6ec8-4530-b576-ecbae2d9b239.png\" alt=\"Models\"></p>\n<p>对上图的一些关键字段进行说明：</p>\n<h6 id=\"Source\"><a href=\"#Source\" class=\"headerlink\" title=\"Source\"></a>Source</h6><ul>\n<li>name: 资源的名称，也就是其他模型的名称，例如：user、role等等。</li>\n<li>identity: 资源的唯一标识，可以像uuid，shortid这些字符串，也可以是model的名称。</li>\n<li>permissions : 一种资源对应有四种权限，分别对这种资源的browse、create、update、delete</li>\n</ul>\n<h6 id=\"Permission\"><a href=\"#Permission\" class=\"headerlink\" title=\"Permission\"></a>Permission</h6><ul>\n<li>source : 该权限对应的资源，也就是Source的某一条记录的唯一标识</li>\n<li>action ：对应资源的操作，只能是browse、create、update、delete四个之一</li>\n<li>relation：用来标记该权限是属于私人的，还是角色的，用于OwnerPolicy检测</li>\n<li>roles: 拥有该权限的角色</li>\n</ul>\n<h6 id=\"Role\"><a href=\"#Role\" class=\"headerlink\" title=\"Role\"></a>Role</h6><ul>\n<li>users : 角色所对应的用户群，一个角色可以对应多个用户</li>\n<li>permissions: 权限列表，一个角色拥有多项权利</li>\n</ul>\n<h6 id=\"User\"><a href=\"#User\" class=\"headerlink\" title=\"User\"></a>User</h6><ul>\n<li>createBy : 该记录的拥有者，在user标里，一般等于该记录的唯一标识，这一属性用于OwnerPolicy的检测，其他私有资源的模型设计，也需要加上这一字段来标识资源的拥有者。</li>\n<li>roles : 用户所拥有的角色</li>\n</ul>\n<h2 id=\"策略-过滤器\"><a href=\"#策略-过滤器\" class=\"headerlink\" title=\"策略/过滤器\"></a>策略/过滤器</h2><p>在sails下称为策略(Policy)，在java SSH下称为过滤器(Filter)，无论名称如何，他们工作原理是大同小异的，主要是在一条HTTP请求访问一个Controller下的action之前进行检测。所以在这一层，我们可以自定义一些策略/过滤器来实现权限控制。<br>为行文方便，下面姑且允许我使用策略这一词。</p>\n<p><strong> 策略 (Policy) </strong></p>\n<blockquote>\n<p>下面排版顺序对应Policy的运行顺序</p>\n</blockquote>\n<ol>\n<li><strong>SessionAuthPolicy</strong>：<br>检测用户是否已经登录，用户登录是进行下面检测的前提。</li>\n<li><strong>SourcePolicy</strong>：<br>检测访问的资源是否存在，主要检测Source表的记录</li>\n<li><strong>PermissionPolicy</strong>：<br>检测该用户所属的角色，是否有对所访问资源进行对应操作的权限。</li>\n<li><strong>OwnerPolicy</strong>：<br>如果所访问的资源属于私人资源，则检测当前用户是否该资源的拥有者。</li>\n</ol>\n<p>如果通过所有policy的检测，则把请求转发到目标action。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/73b94749-99ba-4e35-a9a3-42604ecb7af9.png\" alt=\"Policies\"></p>\n<h2 id=\"Sails下的权限控制实现\"><a href=\"#Sails下的权限控制实现\" class=\"headerlink\" title=\"Sails下的权限控制实现\"></a>Sails下的权限控制实现</h2><p>在Sails下，有一个很方便的套件<a href=\"https://github.com/tjwebb/sails-permissions\">sails-permissions</a>，集成了一套权限管理的方案，本文也是基于该套件的源码所引出来的权限管理解决方案。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>对程序员最大的挑战，并不是能否掌握了哪些编程语言，哪些软件框架，而是对业务和需求的理解，然后在此基础上，把要点抽象出来，写成计算机能理解的语言。<br>最后，希望这篇文章，能够帮助你对权限管理这一课题增加多一点点理解。</p>\n<h2 id=\"写作参考\"><a href=\"#写作参考\" class=\"headerlink\" title=\"写作参考\"></a>写作参考</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\">理解RESTful架构</a></li>\n<li><a href=\"http://zh.wikipedia.org/wiki/REST\">REST wiki</a></li>\n<li><a href=\"https://github.com/tjwebb/sails-permissions\">sails-permissions 源码</a></li>\n</ul>\n"},{"title":"在Nodejs中贯彻单元测试","date":"2015-07-30T08:32:34.000Z","_content":"\n在团队合作中，你写好了一个函数，供队友使用，跑去跟你的队友说，你传个A值进去，他就会返回B结果了。过了一会，你队友跑过来说，我传个A值却返回C结果，怎么回事？你丫的有没有测试过啊？\n\n大家一起写个项目，难免会有我要写的函数里面依赖别人的函数，但是这个函数到底值不值得信赖？单元测试是衡量代码质量的一重要标准，纵观Github的受欢迎项目，都是有test文件夹，并且buliding-pass的。如果你也为社区贡献过module，想更多人使用的话，加上单元测试吧，让你的module值得别人信赖。\n\n要在Nodejs中写单元测试的话，你需要知道用什么测试框架，怎么测试异步函数，怎么测试私有方法，怎么模拟测试环境，怎么测试依赖HTTP协议的web应用，需要了解TDD和BDD，还有需要提供测试的覆盖率。\n\n> 本文的示例代码会备份到 Github : [unittest-demo](https://github.com/JerryC8080/unittest-demo)\n\n## 目录\n\n1. 测试框架\n2. 断言库\n3. 需求变更\n4. 异步测试\n5. 异常测试\n6. 测试私有方法\n7. 测试Web应用\n8. 覆盖率\n9. 使用Makefile把测试串起来\n10. 持续集成，Travis-cli\n11. 一些观点\n12. 彩蛋\n13. 整理\n\n\n\n## 测试框架\n\nNodejs的测试框架还用说？大家都在用，Mocha。\n\nMocha 是一个功能丰富的Javascript测试框架，它能运行在Node.js和浏览器中，支持**BDD**、**TDD**、**QUnit**、**Exports**式的测试，本文主要示例是使用更接近与思考方式的BDD，\b如果了解更多可以访问Mocha的[官网](http://mochajs.org/)\n\n#### \b\n\n#### 测试接口\n\nMocha的BDD接口有：\n\n- `describe()`\n- `it()`\n- `before()`\n- `after()`\n- `beforeEach()`\n- `afterEach()`\n\n\n\n#### 安装\n\n`npm install mocha -g`\n\n\n\n#### 编写一个稳定可靠的模块\n\n模块具备limit方法，输入一个数值，小于0的时候返回0，其余正常返回\n\n``` javascript\nexports.limit = function (num) {\n  if (num < 0) {\n    return 0;\n  }\n  return num;\n};\n```\n\n\n\n#### 目录分配\n\n- `lib`，存放模块代码的地方\n- `test`，存放单元测试代码的地方\n- `index.js`，向外导出模块的地方\n- `package.json`，包描述文件\n\n\n\n#### 测试\n\n``` javascript\nvar lib = require('index');\n\ndescribe('module', function () {\n  describe('limit', function () {\n    it('limit should success', function () {\n      lib.limit(10);\n    });\n  });\n});\n```\n\n\n\n#### 结果\n\n在当前目录下执行`mocha`：\n\n``` \n$ mocha\n\n  ․\n\n  ✔ 1 test complete (2ms)\n```\n\n\n\n## 断言库\n\n上面的代码只是运行了代码，并没有对结果进行检查，这时候就要用到断言库了，Node.js中常用的断言库有：\n\n- should.js\n- expect.js\n- chai\n\n\n\n#### 加上断言\n\n使用`should`库为测试用例加上断言\n\n``` javascript\nit('limit should success', function () {\n  lib.limit(10).should.be.equal(10);\n});\n```\n\n\n\n## \b需求变更\n\n需求变更啦： `limit`这个方法还要求返回值大于100时返回100。\n\n针对需求重构代码之后，正是测试用例的价值所在了，\n\n它能确保你的改动对原有成果没有造成破坏。\n\n但是，你要多做的一些工作的是，需要为新的需求编写新的测试代码。\n\n\n\n## 异步测试\n\n#### 测试异步回调\n\nlib库中新增async函数：\n\n``` javascript\nexports.async = function (callback) {\n  setTimeout(function () {\n    callback(10);\n  }, 10);\n};\t\n```\n\n测试异步代码：\n\n``` javascript\ndescribe('async', function () {\n  it('async', function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n```\n\n\n\n#### 测试Promise\n\n使用should提供的Promise断言接口:\n\n- `finally` | `eventually`\n- `fulfilled`\n- `fulfilledWith`\n- `rejected`\n- `rejectedWith`\n- `then`\n\n测试代码\n\n``` javascript\ndescribe('should', function () {\n  describe('#Promise', function () {\n    it('should.reject', function () {\n      (new Promise(function (resolve, reject) {\n        reject(new Error('wrong'));\n      })).should.be.rejectedWith('wrong');\n    });\n\n    it('should.fulfilled', function () {\n      (new Promise(function (resolve, reject) {\n        resolve({username: 'jc', age: 18, gender: 'male'})\n      })).should.be.fulfilled().then(function (it) {\n          it.should.have.property('username', 'jc');\n        })\n    });\n  });\n});\n```\n\n\n\n#### 异步方法的超时支持\n\nMocha的超时设定默认是2s，如果执行的测试超过2s的话，就会报timeout错误。\n\n可以主动修改超时时间，有两种方法。\n\n\n\n#### 命令行式\n\n`mocha -t 10000`\n\n\n\n#### API式\n\n``` javascript\ndescribe('async', function () {\n  this.timeout(10000);\n  it('async', function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n```\n\n这样的话`async`执行时间不超过10s，就不会报错timeout错误了。\n\n\n\n## 异常测试\n\n异常应该怎么测试，现在有`getContent`方法，他会读取指定文件的内容，但是不一定会成功，会抛出异常。\n\n``` javascript\nexports.getContent = function (filename, callback) {\n  fs.readFile(filename, 'utf-8', callback);\n};\n```\n\n这时候就应该模拟(mock)错误环境了\n\n#### 简单Mock\n\n``` javascript\ndescribe(\"getContent\", function () {\n  var _readFile;\n  before(function () {\n    _readFile = fs.readFile;\n    fs.readFile = function (filename, encoding, callback) {\n      process.nextTick(function () {\n        callback(new Error(\"mock readFile error\"));\n      });\n    };\t\n  });\n  // it();\n  after(function () {\n    // 用完之后记得还原。否则影响其他case\n    fs.readFile = _readFile;\n  })\n});\n```\n\n\n\n#### \bMock库\n\nMock小模块：[`muk`](https://github.com/fent/node-muk) ，略微优美的写法：\n\n``` javascript\nvar fs = require('fs');\nvar muk = require('muk');\n\nbefore(function () {\n  muk(fs, 'readFile', function(path, encoding, callback) {\n    process.nextTick(function () {\n      callback(new Error(\"mock readFile error\"));\n    });\n  });\n});\n// it();\nafter(function () {\n  muk.restore();\n});\n```\n\n\n\n## 测试私有方法\n\n针对一些内部的方法，没有通过exports暴露出来，怎么测试它？\n\n``` javascript\nfunction _adding(num1, num2) {\n  return num1 + num2;\n}\n```\n\n#### 通过rewire导出方法\n\n模块：[`rewire`](http://jhnns.github.com/rewire/)\n\n``` \nit('limit should return success', function () {\n  var lib = rewire('../lib/index.js');\n  var litmit = lib.__get__('limit');\n  litmit(10);\n});\n```\n\n\n\n## 测试Web应用\n\n在开发Web项目的时候，要测试某一个API，如：`/user`，到底怎么编写测试用例呢？\n\n使用：[`supertest`](https://github.com/visionmedia/supertest)\n\n``` javascript\nvar express = require(\"express\");\nvar request = require(\"supertest\");\nvar app = express();\n\n// 定义路由\napp.get('/user', function(req, res){\n  res.send(200, { name: 'jerryc' });\n});\n\ndescribe('GET /user', function(){\n  it('respond with json', function(done){\n    request(app)\n      .get('/user')\n      .set('Accept', 'application/json')\n      .expect('Content-Type', /json/)\n      .expect(200)\n      .end(function (err, res) {\n        if (err){\n          done(err);\n        }\n        res.body.name.should.be.eql('jerryc');\n        done();\n      })\n  });\n});\n```\n\n\n\n## 覆盖率\n\n测试的时候，我们常常关心，是否所有代码都测试到了。\n\n这个指标就叫做[\"代码覆盖率\"](http://en.wikipedia.org/wiki/Code_coverage)（code coverage）。它有四个测量维度。\n\n> - **行覆盖率**（line coverage）：是否每一行都执行了？\n> - **函数覆盖率**（function coverage）：是否每个函数都调用了？\n> - **分支覆盖率**（branch coverage）：是否每个if代码块都执行了？\n> - **语句覆盖率**（statement coverage）：是否每个语句都执行了？\n\n[Istanbul](https://github.com/gotwarlost/istanbul) 是 JavaScript 程序的代码覆盖率工具。\n\n#### 安装\n\n`$ npm install -g istanbul`\n\n\n\n#### 覆盖率测试\n\n在编写过以上的测试用例之后，执行命令：\n\n`istanbul cover _mocha`\n\n就能得到覆盖率:\n\n``` javascript\nJerryC% istanbul cover _mocha                                                                                                                                                                \n\n\n  module\n    limit\n      ✓ limit should success\n    async\n      ✓ async\n    getContent\n      ✓ getContent\n    add\n      ✓ add\n\n  should\n    #Promise\n      ✓ should.reject\n      ✓ should fulfilled\n\n\n  6 passing (32ms)\n\n\n================== Coverage summary ======================\nStatements   : 100% ( 10/10 )\nBranches     : 100% ( 2/2 )\nFunctions    : 100% ( 5/5 )\nLines        : 100% ( 10/10 )\n==========================================================\n```\n\n这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。\n\n![覆盖率html](http://xia-dev.b0.upaiyun.com/eac87dbf-4e4b-426e-80ac-7c50e1b9a1cb.jpg)\n\n\n\n上面命令中，`istanbul cover` 命令后面跟的是 `_mocha` 命令，前面的下划线是不能省略的。\n\n因为，[mocha 和 _mocha 是两个不同的命令](https://github.com/gotwarlost/istanbul/issues/44)，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。\n\n如果要向 mocha 传入参数，可以写成下面的样子。\n\n``` \n$ istanbul cover _mocha -- tests/test.sqrt.js -R spec\n```\n\n上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接[1](http://www.clock.co.uk/blog/npm-module-code-coverage-in-2-simple-steps)，[2](http://www.vapidspace.com/coding/2014/10/29/code-coverage-metrics-with-mocha-and-istanbul/)）。\n\n\n\n## 使用Makefile串起项目 \n\n``` \nTESTS = test/*.test.js\nREPORTER = spec\nTIMEOUT = 10000\nJSCOVERAGE = ./node_modules/jscover/bin/jscover\n\ntest:\n    @NODE_ENV=test ./node_modules/mocha/bin/mocha -R $(REPORTER) -t $(TIMEOUT) $(TESTS)\n\ntest-cov: lib-cov\n    @LIB_COV=1 $(MAKE) test REPORTER=dot\n    @LIB_COV=1 $(MAKE) test REPORTER=html-cov > coverage.html\n\nlib-cov:\n    @rm -rf ./lib-cov\n    @$(JSCOVERAGE) lib lib-cov\n\n.PHONY: test test-cov lib-cov\n\nmake test\nmake test-cov\n\n```\n\n用项目自身的jscover和mocha，避免版本冲突和混乱\n\n\n\n## 持续集成，Travis-cli\n\n- [Travis-ci](https://travis-ci.org/)\n  - 绑定Github帐号\n  - 在Github仓库的Admin打开Services hook\n  - 打开Travis\n  - 每次push将会hook触发执行`npm test`命令\n\n注意：Travis会将未描述的项目当作Ruby项目。所以需要在根目录下加入`.travis.yml`文件。内容如下：\n\n``` yaml\nlanguage: node_js\nnode_js:\n  - \"0.12\"\n```\n\nTravis-cli还会对项目颁发标签，\n\n![/](https://camo.githubusercontent.com/f479d6cf4ac300093da5a90d70565cebf8c8ed40/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f4a61636b736f6e5469616e2f626167706970652e706e67)or ![/](https://camo.githubusercontent.com/08478cd5a732822aec47e6e60d5f823ef0898dec/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f54424544502f64617461766a732e706e67)\n\n如果项目通过所有测试，就会build-passing，\n\n如果项目没有通过所有测试，就会build-failing\n\n\n\n## 一些观点\n\n实施单元测试的时候, 如果没有一份经过实践证明的详细规范, 很难掌握测试的 \"度\", 范围太小施展不开, 太大又侵犯 \"别人的\" 地盘. 上帝的归上帝, 凯撒的归凯撒, 给单元测试念念紧箍咒不见得是件坏事, 反而更有利于发挥单元测试的威力, 为代码重构和提高代码质量提供动力.\n\n这份文档来自 Geotechnical, 是一份非常难得的经验准则. 你完全可以以这份准则作为模板, 结合所在团队的经验, 整理出一份内部单元测试准则.\n\n\n\n[单元测试准则](https://github.com/yangyubo/zh-unit-testing-guidelines)\n\n\n\n## 彩蛋\n\n最后，介绍一个库：[`faker`](https://github.com/Marak/Faker.js)\n\n他是一个能伪造用户数据的库，包括用户常包含的属性：个人信息、头像、地址等等。\n\n是一个开发初期，模拟用户数据的绝佳好库。\n\n支持Node.js和浏览器端。\n\n![生成用户](http://xia-dev.b0.upaiyun.com/43075e5e-026f-4acb-a51f-a998cf1a6e11.jpg)\n\n## 整理\n\n#### Nodejs的单元测试工具\n\n1. 测试框架 mocha\n2. 断言库：should.js、expect.js、chai\n3. 覆盖率：istanbul、jscover、blanket\n4. Mock库：muk\n5. 测试私有方法：rewire\n6. Web测试：supertest\n7. 持续集成：Travis-cli\n\n\n\n## 参考\n\n- [https://github.com/JacksonTian/unittesting](https://github.com/JacksonTian/unittesting)\n- []()[http://html5ify.com/unittesting/slides/index.html](http://html5ify.com/unittesting/slides/index.html)\n- [http://www.ruanyifeng.com/blog/2015/06/istanbul.html](http://www.ruanyifeng.com/blog/2015/06/istanbul.html)\n- [http://coolshell.cn/articles/8209.html](http://coolshell.cn/articles/8209.html)\n- [http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests](http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests)\n- [https://github.com/yangyubo/zh-unit-testing-guidelines](https://github.com/yangyubo/zh-unit-testing-guidelines)\n- [http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming](http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming)\n- [http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D](http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D)\n- [https://github.com/yangyubo/zh-unit-testing-guidelines](https://github.com/yangyubo/zh-unit-testing-guidelines)\n- [https://github.com/visionmedia/superagent/blob/master/Makefile](https://github.com/visionmedia/superagent/blob/master/Makefile)\n","source":"_posts/在Nodejs中贯彻单元测试.md","raw":"---\ntitle: 在Nodejs中贯彻单元测试\ncategory: 搬砖码农\ndate: 2015-07-30 16:32:34\ntags:\n- mocha\n- unit test\n- Nodejs\n---\n\n在团队合作中，你写好了一个函数，供队友使用，跑去跟你的队友说，你传个A值进去，他就会返回B结果了。过了一会，你队友跑过来说，我传个A值却返回C结果，怎么回事？你丫的有没有测试过啊？\n\n大家一起写个项目，难免会有我要写的函数里面依赖别人的函数，但是这个函数到底值不值得信赖？单元测试是衡量代码质量的一重要标准，纵观Github的受欢迎项目，都是有test文件夹，并且buliding-pass的。如果你也为社区贡献过module，想更多人使用的话，加上单元测试吧，让你的module值得别人信赖。\n\n要在Nodejs中写单元测试的话，你需要知道用什么测试框架，怎么测试异步函数，怎么测试私有方法，怎么模拟测试环境，怎么测试依赖HTTP协议的web应用，需要了解TDD和BDD，还有需要提供测试的覆盖率。\n\n> 本文的示例代码会备份到 Github : [unittest-demo](https://github.com/JerryC8080/unittest-demo)\n\n## 目录\n\n1. 测试框架\n2. 断言库\n3. 需求变更\n4. 异步测试\n5. 异常测试\n6. 测试私有方法\n7. 测试Web应用\n8. 覆盖率\n9. 使用Makefile把测试串起来\n10. 持续集成，Travis-cli\n11. 一些观点\n12. 彩蛋\n13. 整理\n\n\n\n## 测试框架\n\nNodejs的测试框架还用说？大家都在用，Mocha。\n\nMocha 是一个功能丰富的Javascript测试框架，它能运行在Node.js和浏览器中，支持**BDD**、**TDD**、**QUnit**、**Exports**式的测试，本文主要示例是使用更接近与思考方式的BDD，\b如果了解更多可以访问Mocha的[官网](http://mochajs.org/)\n\n#### \b\n\n#### 测试接口\n\nMocha的BDD接口有：\n\n- `describe()`\n- `it()`\n- `before()`\n- `after()`\n- `beforeEach()`\n- `afterEach()`\n\n\n\n#### 安装\n\n`npm install mocha -g`\n\n\n\n#### 编写一个稳定可靠的模块\n\n模块具备limit方法，输入一个数值，小于0的时候返回0，其余正常返回\n\n``` javascript\nexports.limit = function (num) {\n  if (num < 0) {\n    return 0;\n  }\n  return num;\n};\n```\n\n\n\n#### 目录分配\n\n- `lib`，存放模块代码的地方\n- `test`，存放单元测试代码的地方\n- `index.js`，向外导出模块的地方\n- `package.json`，包描述文件\n\n\n\n#### 测试\n\n``` javascript\nvar lib = require('index');\n\ndescribe('module', function () {\n  describe('limit', function () {\n    it('limit should success', function () {\n      lib.limit(10);\n    });\n  });\n});\n```\n\n\n\n#### 结果\n\n在当前目录下执行`mocha`：\n\n``` \n$ mocha\n\n  ․\n\n  ✔ 1 test complete (2ms)\n```\n\n\n\n## 断言库\n\n上面的代码只是运行了代码，并没有对结果进行检查，这时候就要用到断言库了，Node.js中常用的断言库有：\n\n- should.js\n- expect.js\n- chai\n\n\n\n#### 加上断言\n\n使用`should`库为测试用例加上断言\n\n``` javascript\nit('limit should success', function () {\n  lib.limit(10).should.be.equal(10);\n});\n```\n\n\n\n## \b需求变更\n\n需求变更啦： `limit`这个方法还要求返回值大于100时返回100。\n\n针对需求重构代码之后，正是测试用例的价值所在了，\n\n它能确保你的改动对原有成果没有造成破坏。\n\n但是，你要多做的一些工作的是，需要为新的需求编写新的测试代码。\n\n\n\n## 异步测试\n\n#### 测试异步回调\n\nlib库中新增async函数：\n\n``` javascript\nexports.async = function (callback) {\n  setTimeout(function () {\n    callback(10);\n  }, 10);\n};\t\n```\n\n测试异步代码：\n\n``` javascript\ndescribe('async', function () {\n  it('async', function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n```\n\n\n\n#### 测试Promise\n\n使用should提供的Promise断言接口:\n\n- `finally` | `eventually`\n- `fulfilled`\n- `fulfilledWith`\n- `rejected`\n- `rejectedWith`\n- `then`\n\n测试代码\n\n``` javascript\ndescribe('should', function () {\n  describe('#Promise', function () {\n    it('should.reject', function () {\n      (new Promise(function (resolve, reject) {\n        reject(new Error('wrong'));\n      })).should.be.rejectedWith('wrong');\n    });\n\n    it('should.fulfilled', function () {\n      (new Promise(function (resolve, reject) {\n        resolve({username: 'jc', age: 18, gender: 'male'})\n      })).should.be.fulfilled().then(function (it) {\n          it.should.have.property('username', 'jc');\n        })\n    });\n  });\n});\n```\n\n\n\n#### 异步方法的超时支持\n\nMocha的超时设定默认是2s，如果执行的测试超过2s的话，就会报timeout错误。\n\n可以主动修改超时时间，有两种方法。\n\n\n\n#### 命令行式\n\n`mocha -t 10000`\n\n\n\n#### API式\n\n``` javascript\ndescribe('async', function () {\n  this.timeout(10000);\n  it('async', function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n```\n\n这样的话`async`执行时间不超过10s，就不会报错timeout错误了。\n\n\n\n## 异常测试\n\n异常应该怎么测试，现在有`getContent`方法，他会读取指定文件的内容，但是不一定会成功，会抛出异常。\n\n``` javascript\nexports.getContent = function (filename, callback) {\n  fs.readFile(filename, 'utf-8', callback);\n};\n```\n\n这时候就应该模拟(mock)错误环境了\n\n#### 简单Mock\n\n``` javascript\ndescribe(\"getContent\", function () {\n  var _readFile;\n  before(function () {\n    _readFile = fs.readFile;\n    fs.readFile = function (filename, encoding, callback) {\n      process.nextTick(function () {\n        callback(new Error(\"mock readFile error\"));\n      });\n    };\t\n  });\n  // it();\n  after(function () {\n    // 用完之后记得还原。否则影响其他case\n    fs.readFile = _readFile;\n  })\n});\n```\n\n\n\n#### \bMock库\n\nMock小模块：[`muk`](https://github.com/fent/node-muk) ，略微优美的写法：\n\n``` javascript\nvar fs = require('fs');\nvar muk = require('muk');\n\nbefore(function () {\n  muk(fs, 'readFile', function(path, encoding, callback) {\n    process.nextTick(function () {\n      callback(new Error(\"mock readFile error\"));\n    });\n  });\n});\n// it();\nafter(function () {\n  muk.restore();\n});\n```\n\n\n\n## 测试私有方法\n\n针对一些内部的方法，没有通过exports暴露出来，怎么测试它？\n\n``` javascript\nfunction _adding(num1, num2) {\n  return num1 + num2;\n}\n```\n\n#### 通过rewire导出方法\n\n模块：[`rewire`](http://jhnns.github.com/rewire/)\n\n``` \nit('limit should return success', function () {\n  var lib = rewire('../lib/index.js');\n  var litmit = lib.__get__('limit');\n  litmit(10);\n});\n```\n\n\n\n## 测试Web应用\n\n在开发Web项目的时候，要测试某一个API，如：`/user`，到底怎么编写测试用例呢？\n\n使用：[`supertest`](https://github.com/visionmedia/supertest)\n\n``` javascript\nvar express = require(\"express\");\nvar request = require(\"supertest\");\nvar app = express();\n\n// 定义路由\napp.get('/user', function(req, res){\n  res.send(200, { name: 'jerryc' });\n});\n\ndescribe('GET /user', function(){\n  it('respond with json', function(done){\n    request(app)\n      .get('/user')\n      .set('Accept', 'application/json')\n      .expect('Content-Type', /json/)\n      .expect(200)\n      .end(function (err, res) {\n        if (err){\n          done(err);\n        }\n        res.body.name.should.be.eql('jerryc');\n        done();\n      })\n  });\n});\n```\n\n\n\n## 覆盖率\n\n测试的时候，我们常常关心，是否所有代码都测试到了。\n\n这个指标就叫做[\"代码覆盖率\"](http://en.wikipedia.org/wiki/Code_coverage)（code coverage）。它有四个测量维度。\n\n> - **行覆盖率**（line coverage）：是否每一行都执行了？\n> - **函数覆盖率**（function coverage）：是否每个函数都调用了？\n> - **分支覆盖率**（branch coverage）：是否每个if代码块都执行了？\n> - **语句覆盖率**（statement coverage）：是否每个语句都执行了？\n\n[Istanbul](https://github.com/gotwarlost/istanbul) 是 JavaScript 程序的代码覆盖率工具。\n\n#### 安装\n\n`$ npm install -g istanbul`\n\n\n\n#### 覆盖率测试\n\n在编写过以上的测试用例之后，执行命令：\n\n`istanbul cover _mocha`\n\n就能得到覆盖率:\n\n``` javascript\nJerryC% istanbul cover _mocha                                                                                                                                                                \n\n\n  module\n    limit\n      ✓ limit should success\n    async\n      ✓ async\n    getContent\n      ✓ getContent\n    add\n      ✓ add\n\n  should\n    #Promise\n      ✓ should.reject\n      ✓ should fulfilled\n\n\n  6 passing (32ms)\n\n\n================== Coverage summary ======================\nStatements   : 100% ( 10/10 )\nBranches     : 100% ( 2/2 )\nFunctions    : 100% ( 5/5 )\nLines        : 100% ( 10/10 )\n==========================================================\n```\n\n这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。\n\n![覆盖率html](http://xia-dev.b0.upaiyun.com/eac87dbf-4e4b-426e-80ac-7c50e1b9a1cb.jpg)\n\n\n\n上面命令中，`istanbul cover` 命令后面跟的是 `_mocha` 命令，前面的下划线是不能省略的。\n\n因为，[mocha 和 _mocha 是两个不同的命令](https://github.com/gotwarlost/istanbul/issues/44)，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。\n\n如果要向 mocha 传入参数，可以写成下面的样子。\n\n``` \n$ istanbul cover _mocha -- tests/test.sqrt.js -R spec\n```\n\n上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接[1](http://www.clock.co.uk/blog/npm-module-code-coverage-in-2-simple-steps)，[2](http://www.vapidspace.com/coding/2014/10/29/code-coverage-metrics-with-mocha-and-istanbul/)）。\n\n\n\n## 使用Makefile串起项目 \n\n``` \nTESTS = test/*.test.js\nREPORTER = spec\nTIMEOUT = 10000\nJSCOVERAGE = ./node_modules/jscover/bin/jscover\n\ntest:\n    @NODE_ENV=test ./node_modules/mocha/bin/mocha -R $(REPORTER) -t $(TIMEOUT) $(TESTS)\n\ntest-cov: lib-cov\n    @LIB_COV=1 $(MAKE) test REPORTER=dot\n    @LIB_COV=1 $(MAKE) test REPORTER=html-cov > coverage.html\n\nlib-cov:\n    @rm -rf ./lib-cov\n    @$(JSCOVERAGE) lib lib-cov\n\n.PHONY: test test-cov lib-cov\n\nmake test\nmake test-cov\n\n```\n\n用项目自身的jscover和mocha，避免版本冲突和混乱\n\n\n\n## 持续集成，Travis-cli\n\n- [Travis-ci](https://travis-ci.org/)\n  - 绑定Github帐号\n  - 在Github仓库的Admin打开Services hook\n  - 打开Travis\n  - 每次push将会hook触发执行`npm test`命令\n\n注意：Travis会将未描述的项目当作Ruby项目。所以需要在根目录下加入`.travis.yml`文件。内容如下：\n\n``` yaml\nlanguage: node_js\nnode_js:\n  - \"0.12\"\n```\n\nTravis-cli还会对项目颁发标签，\n\n![/](https://camo.githubusercontent.com/f479d6cf4ac300093da5a90d70565cebf8c8ed40/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f4a61636b736f6e5469616e2f626167706970652e706e67)or ![/](https://camo.githubusercontent.com/08478cd5a732822aec47e6e60d5f823ef0898dec/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f54424544502f64617461766a732e706e67)\n\n如果项目通过所有测试，就会build-passing，\n\n如果项目没有通过所有测试，就会build-failing\n\n\n\n## 一些观点\n\n实施单元测试的时候, 如果没有一份经过实践证明的详细规范, 很难掌握测试的 \"度\", 范围太小施展不开, 太大又侵犯 \"别人的\" 地盘. 上帝的归上帝, 凯撒的归凯撒, 给单元测试念念紧箍咒不见得是件坏事, 反而更有利于发挥单元测试的威力, 为代码重构和提高代码质量提供动力.\n\n这份文档来自 Geotechnical, 是一份非常难得的经验准则. 你完全可以以这份准则作为模板, 结合所在团队的经验, 整理出一份内部单元测试准则.\n\n\n\n[单元测试准则](https://github.com/yangyubo/zh-unit-testing-guidelines)\n\n\n\n## 彩蛋\n\n最后，介绍一个库：[`faker`](https://github.com/Marak/Faker.js)\n\n他是一个能伪造用户数据的库，包括用户常包含的属性：个人信息、头像、地址等等。\n\n是一个开发初期，模拟用户数据的绝佳好库。\n\n支持Node.js和浏览器端。\n\n![生成用户](http://xia-dev.b0.upaiyun.com/43075e5e-026f-4acb-a51f-a998cf1a6e11.jpg)\n\n## 整理\n\n#### Nodejs的单元测试工具\n\n1. 测试框架 mocha\n2. 断言库：should.js、expect.js、chai\n3. 覆盖率：istanbul、jscover、blanket\n4. Mock库：muk\n5. 测试私有方法：rewire\n6. Web测试：supertest\n7. 持续集成：Travis-cli\n\n\n\n## 参考\n\n- [https://github.com/JacksonTian/unittesting](https://github.com/JacksonTian/unittesting)\n- []()[http://html5ify.com/unittesting/slides/index.html](http://html5ify.com/unittesting/slides/index.html)\n- [http://www.ruanyifeng.com/blog/2015/06/istanbul.html](http://www.ruanyifeng.com/blog/2015/06/istanbul.html)\n- [http://coolshell.cn/articles/8209.html](http://coolshell.cn/articles/8209.html)\n- [http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests](http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests)\n- [https://github.com/yangyubo/zh-unit-testing-guidelines](https://github.com/yangyubo/zh-unit-testing-guidelines)\n- [http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming](http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming)\n- [http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D](http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D)\n- [https://github.com/yangyubo/zh-unit-testing-guidelines](https://github.com/yangyubo/zh-unit-testing-guidelines)\n- [https://github.com/visionmedia/superagent/blob/master/Makefile](https://github.com/visionmedia/superagent/blob/master/Makefile)\n","slug":"在Nodejs中贯彻单元测试","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8rm0022xwrl8rld7ubf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在团队合作中，你写好了一个函数，供队友使用，跑去跟你的队友说，你传个A值进去，他就会返回B结果了。过了一会，你队友跑过来说，我传个A值却返回C结果，怎么回事？你丫的有没有测试过啊？</p>\n<p>大家一起写个项目，难免会有我要写的函数里面依赖别人的函数，但是这个函数到底值不值得信赖？单元测试是衡量代码质量的一重要标准，纵观Github的受欢迎项目，都是有test文件夹，并且buliding-pass的。如果你也为社区贡献过module，想更多人使用的话，加上单元测试吧，让你的module值得别人信赖。</p>\n<p>要在Nodejs中写单元测试的话，你需要知道用什么测试框架，怎么测试异步函数，怎么测试私有方法，怎么模拟测试环境，怎么测试依赖HTTP协议的web应用，需要了解TDD和BDD，还有需要提供测试的覆盖率。</p>\n<blockquote>\n<p>本文的示例代码会备份到 Github : <a href=\"https://github.com/JerryC8080/unittest-demo\" target=\"_blank\" rel=\"external\">unittest-demo</a></p>\n</blockquote>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li>测试框架</li>\n<li>断言库</li>\n<li>需求变更</li>\n<li>异步测试</li>\n<li>异常测试</li>\n<li>测试私有方法</li>\n<li>测试Web应用</li>\n<li>覆盖率</li>\n<li>使用Makefile把测试串起来</li>\n<li>持续集成，Travis-cli</li>\n<li>一些观点</li>\n<li>彩蛋</li>\n<li>整理</li>\n</ol>\n<h2 id=\"测试框架\"><a href=\"#测试框架\" class=\"headerlink\" title=\"测试框架\"></a>测试框架</h2><p>Nodejs的测试框架还用说？大家都在用，Mocha。</p>\n<p>Mocha 是一个功能丰富的Javascript测试框架，它能运行在Node.js和浏览器中，支持<strong>BDD</strong>、<strong>TDD</strong>、<strong>QUnit</strong>、<strong>Exports</strong>式的测试，本文主要示例是使用更接近与思考方式的BDD，\b如果了解更多可以访问Mocha的<a href=\"http://mochajs.org/\" target=\"_blank\" rel=\"external\">官网</a></p>\n<h4 id><a href=\"#\" class=\"headerlink\" title=\"\b\"></a>\b</h4><h4 id=\"测试接口\"><a href=\"#测试接口\" class=\"headerlink\" title=\"测试接口\"></a>测试接口</h4><p>Mocha的BDD接口有：</p>\n<ul>\n<li><code>describe()</code></li>\n<li><code>it()</code></li>\n<li><code>before()</code></li>\n<li><code>after()</code></li>\n<li><code>beforeEach()</code></li>\n<li><code>afterEach()</code></li>\n</ul>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p><code>npm install mocha -g</code></p>\n<h4 id=\"编写一个稳定可靠的模块\"><a href=\"#编写一个稳定可靠的模块\" class=\"headerlink\" title=\"编写一个稳定可靠的模块\"></a>编写一个稳定可靠的模块</h4><p>模块具备limit方法，输入一个数值，小于0的时候返回0，其余正常返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.limit = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"目录分配\"><a href=\"#目录分配\" class=\"headerlink\" title=\"目录分配\"></a>目录分配</h4><ul>\n<li><code>lib</code>，存放模块代码的地方</li>\n<li><code>test</code>，存放单元测试代码的地方</li>\n<li><code>index.js</code>，向外导出模块的地方</li>\n<li><code>package.json</code>，包描述文件</li>\n</ul>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lib = <span class=\"built_in\">require</span>(<span class=\"string\">'index'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'module'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  describe(<span class=\"string\">'limit'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    it(<span class=\"string\">'limit should success'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      lib.limit(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h4><p>在当前目录下执行<code>mocha</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha</span><br><span class=\"line\"></span><br><span class=\"line\">  ․</span><br><span class=\"line\"></span><br><span class=\"line\">  ✔ 1 test complete (2ms)</span><br></pre></td></tr></table></figure>\n<h2 id=\"断言库\"><a href=\"#断言库\" class=\"headerlink\" title=\"断言库\"></a>断言库</h2><p>上面的代码只是运行了代码，并没有对结果进行检查，这时候就要用到断言库了，Node.js中常用的断言库有：</p>\n<ul>\n<li>should.js</li>\n<li>expect.js</li>\n<li>chai</li>\n</ul>\n<h4 id=\"加上断言\"><a href=\"#加上断言\" class=\"headerlink\" title=\"加上断言\"></a>加上断言</h4><p>使用<code>should</code>库为测试用例加上断言</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'limit should success'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  lib.limit(<span class=\"number\">10</span>).should.be.equal(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"需求变更\"><a href=\"#需求变更\" class=\"headerlink\" title=\"\b需求变更\"></a>\b需求变更</h2><p>需求变更啦： <code>limit</code>这个方法还要求返回值大于100时返回100。</p>\n<p>针对需求重构代码之后，正是测试用例的价值所在了，</p>\n<p>它能确保你的改动对原有成果没有造成破坏。</p>\n<p>但是，你要多做的一些工作的是，需要为新的需求编写新的测试代码。</p>\n<h2 id=\"异步测试\"><a href=\"#异步测试\" class=\"headerlink\" title=\"异步测试\"></a>异步测试</h2><h4 id=\"测试异步回调\"><a href=\"#测试异步回调\" class=\"headerlink\" title=\"测试异步回调\"></a>测试异步回调</h4><p>lib库中新增async函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.async = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    callback(<span class=\"number\">10</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试异步代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">done</span>) </span>&#123;</span><br><span class=\"line\">    lib.async(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">      done();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"测试Promise\"><a href=\"#测试Promise\" class=\"headerlink\" title=\"测试Promise\"></a>测试Promise</h4><p>使用should提供的Promise断言接口:</p>\n<ul>\n<li><code>finally</code> | <code>eventually</code></li>\n<li><code>fulfilled</code></li>\n<li><code>fulfilledWith</code></li>\n<li><code>rejected</code></li>\n<li><code>rejectedWith</code></li>\n<li><code>then</code></li>\n</ul>\n<p>测试代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'should'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  describe(<span class=\"string\">'#Promise'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    it(<span class=\"string\">'should.reject'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'wrong'</span>));</span><br><span class=\"line\">      &#125;)).should.be.rejectedWith(<span class=\"string\">'wrong'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    it(<span class=\"string\">'should.fulfilled'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        resolve(&#123;<span class=\"attr\">username</span>: <span class=\"string\">'jc'</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span>, <span class=\"attr\">gender</span>: <span class=\"string\">'male'</span>&#125;)</span><br><span class=\"line\">      &#125;)).should.be.fulfilled().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">it</span>) </span>&#123;</span><br><span class=\"line\">          it.should.have.property(<span class=\"string\">'username'</span>, <span class=\"string\">'jc'</span>);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"异步方法的超时支持\"><a href=\"#异步方法的超时支持\" class=\"headerlink\" title=\"异步方法的超时支持\"></a>异步方法的超时支持</h4><p>Mocha的超时设定默认是2s，如果执行的测试超过2s的话，就会报timeout错误。</p>\n<p>可以主动修改超时时间，有两种方法。</p>\n<h4 id=\"命令行式\"><a href=\"#命令行式\" class=\"headerlink\" title=\"命令行式\"></a>命令行式</h4><p><code>mocha -t 10000</code></p>\n<h4 id=\"API式\"><a href=\"#API式\" class=\"headerlink\" title=\"API式\"></a>API式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.timeout(<span class=\"number\">10000</span>);</span><br><span class=\"line\">  it(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">done</span>) </span>&#123;</span><br><span class=\"line\">    lib.async(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">      done();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这样的话<code>async</code>执行时间不超过10s，就不会报错timeout错误了。</p>\n<h2 id=\"异常测试\"><a href=\"#异常测试\" class=\"headerlink\" title=\"异常测试\"></a>异常测试</h2><p>异常应该怎么测试，现在有<code>getContent</code>方法，他会读取指定文件的内容，但是不一定会成功，会抛出异常。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.getContent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">filename, callback</span>) </span>&#123;</span><br><span class=\"line\">  fs.readFile(filename, <span class=\"string\">'utf-8'</span>, callback);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这时候就应该模拟(mock)错误环境了</p>\n<h4 id=\"简单Mock\"><a href=\"#简单Mock\" class=\"headerlink\" title=\"简单Mock\"></a>简单Mock</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">\"getContent\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _readFile;</span><br><span class=\"line\">  before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    _readFile = fs.readFile;</span><br><span class=\"line\">    fs.readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">filename, encoding, callback</span>) </span>&#123;</span><br><span class=\"line\">      process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        callback(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"mock readFile error\"</span>));</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;;\t</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// it();</span></span><br><span class=\"line\">  after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用完之后记得还原。否则影响其他case</span></span><br><span class=\"line\">    fs.readFile = _readFile;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock库\"><a href=\"#Mock库\" class=\"headerlink\" title=\"\bMock库\"></a>\bMock库</h4><p>Mock小模块：<a href=\"https://github.com/fent/node-muk\" target=\"_blank\" rel=\"external\"><code>muk</code></a> ，略微优美的写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> muk = <span class=\"built_in\">require</span>(<span class=\"string\">'muk'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  muk(fs, <span class=\"string\">'readFile'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, encoding, callback</span>) </span>&#123;</span><br><span class=\"line\">    process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      callback(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"mock readFile error\"</span>));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// it();</span></span><br><span class=\"line\">after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  muk.restore();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试私有方法\"><a href=\"#测试私有方法\" class=\"headerlink\" title=\"测试私有方法\"></a>测试私有方法</h2><p>针对一些内部的方法，没有通过exports暴露出来，怎么测试它？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_adding</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过rewire导出方法\"><a href=\"#通过rewire导出方法\" class=\"headerlink\" title=\"通过rewire导出方法\"></a>通过rewire导出方法</h4><p>模块：<a href=\"http://jhnns.github.com/rewire/\" target=\"_blank\" rel=\"external\"><code>rewire</code></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(&apos;limit should return success&apos;, function () &#123;</span><br><span class=\"line\">  var lib = rewire(&apos;../lib/index.js&apos;);</span><br><span class=\"line\">  var litmit = lib.__get__(&apos;limit&apos;);</span><br><span class=\"line\">  litmit(10);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试Web应用\"><a href=\"#测试Web应用\" class=\"headerlink\" title=\"测试Web应用\"></a>测试Web应用</h2><p>在开发Web项目的时候，要测试某一个API，如：<code>/user</code>，到底怎么编写测试用例呢？</p>\n<p>使用：<a href=\"https://github.com/visionmedia/supertest\" target=\"_blank\" rel=\"external\"><code>supertest</code></a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">\"express\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">\"supertest\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义路由</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/user'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">  res.send(<span class=\"number\">200</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'jerryc'</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'GET /user'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">'respond with json'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>)</span>&#123;</span><br><span class=\"line\">    request(app)</span><br><span class=\"line\">      .get(<span class=\"string\">'/user'</span>)</span><br><span class=\"line\">      .set(<span class=\"string\">'Accept'</span>, <span class=\"string\">'application/json'</span>)</span><br><span class=\"line\">      .expect(<span class=\"string\">'Content-Type'</span>, /json/)</span><br><span class=\"line\">      .expect(<span class=\"number\">200</span>)</span><br><span class=\"line\">      .end(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err)&#123;</span><br><span class=\"line\">          done(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.body.name.should.be.eql(<span class=\"string\">'jerryc'</span>);</span><br><span class=\"line\">        done();</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"覆盖率\"><a href=\"#覆盖率\" class=\"headerlink\" title=\"覆盖率\"></a>覆盖率</h2><p>测试的时候，我们常常关心，是否所有代码都测试到了。</p>\n<p>这个指标就叫做<a href=\"http://en.wikipedia.org/wiki/Code_coverage\" target=\"_blank\" rel=\"external\">“代码覆盖率”</a>（code coverage）。它有四个测量维度。</p>\n<blockquote>\n<ul>\n<li><strong>行覆盖率</strong>（line coverage）：是否每一行都执行了？</li>\n<li><strong>函数覆盖率</strong>（function coverage）：是否每个函数都调用了？</li>\n<li><strong>分支覆盖率</strong>（branch coverage）：是否每个if代码块都执行了？</li>\n<li><strong>语句覆盖率</strong>（statement coverage）：是否每个语句都执行了？</li>\n</ul>\n</blockquote>\n<p><a href=\"https://github.com/gotwarlost/istanbul\" target=\"_blank\" rel=\"external\">Istanbul</a> 是 JavaScript 程序的代码覆盖率工具。</p>\n<h4 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p><code>$ npm install -g istanbul</code></p>\n<h4 id=\"覆盖率测试\"><a href=\"#覆盖率测试\" class=\"headerlink\" title=\"覆盖率测试\"></a>覆盖率测试</h4><p>在编写过以上的测试用例之后，执行命令：</p>\n<p><code>istanbul cover _mocha</code></p>\n<p>就能得到覆盖率:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JerryC% istanbul cover _mocha                                                                                                                                                                </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span></span><br><span class=\"line\">    limit</span><br><span class=\"line\">      ✓ limit should success</span><br><span class=\"line\">    <span class=\"keyword\">async</span></span><br><span class=\"line\">      ✓ <span class=\"keyword\">async</span></span><br><span class=\"line\">    getContent</span><br><span class=\"line\">      ✓ getContent</span><br><span class=\"line\">    add</span><br><span class=\"line\">      ✓ add</span><br><span class=\"line\"></span><br><span class=\"line\">  should</span><br><span class=\"line\">    #Promise</span><br><span class=\"line\">      ✓ should.reject</span><br><span class=\"line\">      ✓ should fulfilled</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"number\">6</span> passing (<span class=\"number\">32</span>ms)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">================== Coverage summary ======================</span><br><span class=\"line\">Statements   : <span class=\"number\">100</span>% ( <span class=\"number\">10</span>/<span class=\"number\">10</span> )</span><br><span class=\"line\">Branches     : <span class=\"number\">100</span>% ( <span class=\"number\">2</span>/<span class=\"number\">2</span> )</span><br><span class=\"line\">Functions    : <span class=\"number\">100</span>% ( <span class=\"number\">5</span>/<span class=\"number\">5</span> )</span><br><span class=\"line\">Lines        : <span class=\"number\">100</span>% ( <span class=\"number\">10</span>/<span class=\"number\">10</span> )</span><br><span class=\"line\">==========================================================</span><br></pre></td></tr></table></figure>\n<p>这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/eac87dbf-4e4b-426e-80ac-7c50e1b9a1cb.jpg\" alt=\"覆盖率html\"></p>\n<p>上面命令中，<code>istanbul cover</code> 命令后面跟的是 <code>_mocha</code> 命令，前面的下划线是不能省略的。</p>\n<p>因为，<a href=\"https://github.com/gotwarlost/istanbul/issues/44\" target=\"_blank\" rel=\"external\">mocha 和 _mocha 是两个不同的命令</a>，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。</p>\n<p>如果要向 mocha 传入参数，可以写成下面的样子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ istanbul cover _mocha -- tests/test.sqrt.js -R spec</span><br></pre></td></tr></table></figure>\n<p>上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接<a href=\"http://www.clock.co.uk/blog/npm-module-code-coverage-in-2-simple-steps\" target=\"_blank\" rel=\"external\">1</a>，<a href=\"http://www.vapidspace.com/coding/2014/10/29/code-coverage-metrics-with-mocha-and-istanbul/\" target=\"_blank\" rel=\"external\">2</a>）。</p>\n<h2 id=\"使用Makefile串起项目\"><a href=\"#使用Makefile串起项目\" class=\"headerlink\" title=\"使用Makefile串起项目\"></a>使用Makefile串起项目</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TESTS = test/*.test.js</span><br><span class=\"line\">REPORTER = spec</span><br><span class=\"line\">TIMEOUT = 10000</span><br><span class=\"line\">JSCOVERAGE = ./node_modules/jscover/bin/jscover</span><br><span class=\"line\"></span><br><span class=\"line\">test:</span><br><span class=\"line\">    @NODE_ENV=test ./node_modules/mocha/bin/mocha -R $(REPORTER) -t $(TIMEOUT) $(TESTS)</span><br><span class=\"line\"></span><br><span class=\"line\">test-cov: lib-cov</span><br><span class=\"line\">    @LIB_COV=1 $(MAKE) test REPORTER=dot</span><br><span class=\"line\">    @LIB_COV=1 $(MAKE) test REPORTER=html-cov &gt; coverage.html</span><br><span class=\"line\"></span><br><span class=\"line\">lib-cov:</span><br><span class=\"line\">    @rm -rf ./lib-cov</span><br><span class=\"line\">    @$(JSCOVERAGE) lib lib-cov</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY: test test-cov lib-cov</span><br><span class=\"line\"></span><br><span class=\"line\">make test</span><br><span class=\"line\">make test-cov</span><br></pre></td></tr></table></figure>\n<p>用项目自身的jscover和mocha，避免版本冲突和混乱</p>\n<h2 id=\"持续集成，Travis-cli\"><a href=\"#持续集成，Travis-cli\" class=\"headerlink\" title=\"持续集成，Travis-cli\"></a>持续集成，Travis-cli</h2><ul>\n<li><a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"external\">Travis-ci</a><ul>\n<li>绑定Github帐号</li>\n<li>在Github仓库的Admin打开Services hook</li>\n<li>打开Travis</li>\n<li>每次push将会hook触发执行<code>npm test</code>命令</li>\n</ul>\n</li>\n</ul>\n<p>注意：Travis会将未描述的项目当作Ruby项目。所以需要在根目录下加入<code>.travis.yml</code>文件。内容如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span></span><br><span class=\"line\"><span class=\"attr\">node_js:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">\"0.12\"</span></span><br></pre></td></tr></table></figure>\n<p>Travis-cli还会对项目颁发标签，</p>\n<p><img src=\"https://camo.githubusercontent.com/f479d6cf4ac300093da5a90d70565cebf8c8ed40/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f4a61636b736f6e5469616e2f626167706970652e706e67\" alt=\"/\">or <img src=\"https://camo.githubusercontent.com/08478cd5a732822aec47e6e60d5f823ef0898dec/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f54424544502f64617461766a732e706e67\" alt=\"/\"></p>\n<p>如果项目通过所有测试，就会build-passing，</p>\n<p>如果项目没有通过所有测试，就会build-failing</p>\n<h2 id=\"一些观点\"><a href=\"#一些观点\" class=\"headerlink\" title=\"一些观点\"></a>一些观点</h2><p>实施单元测试的时候, 如果没有一份经过实践证明的详细规范, 很难掌握测试的 “度”, 范围太小施展不开, 太大又侵犯 “别人的” 地盘. 上帝的归上帝, 凯撒的归凯撒, 给单元测试念念紧箍咒不见得是件坏事, 反而更有利于发挥单元测试的威力, 为代码重构和提高代码质量提供动力.</p>\n<p>这份文档来自 Geotechnical, 是一份非常难得的经验准则. 你完全可以以这份准则作为模板, 结合所在团队的经验, 整理出一份内部单元测试准则.</p>\n<p><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\" target=\"_blank\" rel=\"external\">单元测试准则</a></p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><p>最后，介绍一个库：<a href=\"https://github.com/Marak/Faker.js\" target=\"_blank\" rel=\"external\"><code>faker</code></a></p>\n<p>他是一个能伪造用户数据的库，包括用户常包含的属性：个人信息、头像、地址等等。</p>\n<p>是一个开发初期，模拟用户数据的绝佳好库。</p>\n<p>支持Node.js和浏览器端。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/43075e5e-026f-4acb-a51f-a998cf1a6e11.jpg\" alt=\"生成用户\"></p>\n<h2 id=\"整理\"><a href=\"#整理\" class=\"headerlink\" title=\"整理\"></a>整理</h2><h4 id=\"Nodejs的单元测试工具\"><a href=\"#Nodejs的单元测试工具\" class=\"headerlink\" title=\"Nodejs的单元测试工具\"></a>Nodejs的单元测试工具</h4><ol>\n<li>测试框架 mocha</li>\n<li>断言库：should.js、expect.js、chai</li>\n<li>覆盖率：istanbul、jscover、blanket</li>\n<li>Mock库：muk</li>\n<li>测试私有方法：rewire</li>\n<li>Web测试：supertest</li>\n<li>持续集成：Travis-cli</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/JacksonTian/unittesting\" target=\"_blank\" rel=\"external\">https://github.com/JacksonTian/unittesting</a></li>\n<li><a href></a><a href=\"http://html5ify.com/unittesting/slides/index.html\" target=\"_blank\" rel=\"external\">http://html5ify.com/unittesting/slides/index.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/06/istanbul.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2015/06/istanbul.html</a></li>\n<li><a href=\"http://coolshell.cn/articles/8209.html\" target=\"_blank\" rel=\"external\">http://coolshell.cn/articles/8209.html</a></li>\n<li><a href=\"http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\" target=\"_blank\" rel=\"external\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming\" target=\"_blank\" rel=\"external\">http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming</a></li>\n<li><a href=\"http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D\" target=\"_blank\" rel=\"external\">http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\" target=\"_blank\" rel=\"external\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"https://github.com/visionmedia/superagent/blob/master/Makefile\" target=\"_blank\" rel=\"external\">https://github.com/visionmedia/superagent/blob/master/Makefile</a></li>\n</ul>\n","excerpt":"","more":"<p>在团队合作中，你写好了一个函数，供队友使用，跑去跟你的队友说，你传个A值进去，他就会返回B结果了。过了一会，你队友跑过来说，我传个A值却返回C结果，怎么回事？你丫的有没有测试过啊？</p>\n<p>大家一起写个项目，难免会有我要写的函数里面依赖别人的函数，但是这个函数到底值不值得信赖？单元测试是衡量代码质量的一重要标准，纵观Github的受欢迎项目，都是有test文件夹，并且buliding-pass的。如果你也为社区贡献过module，想更多人使用的话，加上单元测试吧，让你的module值得别人信赖。</p>\n<p>要在Nodejs中写单元测试的话，你需要知道用什么测试框架，怎么测试异步函数，怎么测试私有方法，怎么模拟测试环境，怎么测试依赖HTTP协议的web应用，需要了解TDD和BDD，还有需要提供测试的覆盖率。</p>\n<blockquote>\n<p>本文的示例代码会备份到 Github : <a href=\"https://github.com/JerryC8080/unittest-demo\">unittest-demo</a></p>\n</blockquote>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li>测试框架</li>\n<li>断言库</li>\n<li>需求变更</li>\n<li>异步测试</li>\n<li>异常测试</li>\n<li>测试私有方法</li>\n<li>测试Web应用</li>\n<li>覆盖率</li>\n<li>使用Makefile把测试串起来</li>\n<li>持续集成，Travis-cli</li>\n<li>一些观点</li>\n<li>彩蛋</li>\n<li>整理</li>\n</ol>\n<h2 id=\"测试框架\"><a href=\"#测试框架\" class=\"headerlink\" title=\"测试框架\"></a>测试框架</h2><p>Nodejs的测试框架还用说？大家都在用，Mocha。</p>\n<p>Mocha 是一个功能丰富的Javascript测试框架，它能运行在Node.js和浏览器中，支持<strong>BDD</strong>、<strong>TDD</strong>、<strong>QUnit</strong>、<strong>Exports</strong>式的测试，本文主要示例是使用更接近与思考方式的BDD，\b如果了解更多可以访问Mocha的<a href=\"http://mochajs.org/\">官网</a></p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\b\"></a>\b</h4><h4 id=\"测试接口\"><a href=\"#测试接口\" class=\"headerlink\" title=\"测试接口\"></a>测试接口</h4><p>Mocha的BDD接口有：</p>\n<ul>\n<li><code>describe()</code></li>\n<li><code>it()</code></li>\n<li><code>before()</code></li>\n<li><code>after()</code></li>\n<li><code>beforeEach()</code></li>\n<li><code>afterEach()</code></li>\n</ul>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p><code>npm install mocha -g</code></p>\n<h4 id=\"编写一个稳定可靠的模块\"><a href=\"#编写一个稳定可靠的模块\" class=\"headerlink\" title=\"编写一个稳定可靠的模块\"></a>编写一个稳定可靠的模块</h4><p>模块具备limit方法，输入一个数值，小于0的时候返回0，其余正常返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.limit = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"目录分配\"><a href=\"#目录分配\" class=\"headerlink\" title=\"目录分配\"></a>目录分配</h4><ul>\n<li><code>lib</code>，存放模块代码的地方</li>\n<li><code>test</code>，存放单元测试代码的地方</li>\n<li><code>index.js</code>，向外导出模块的地方</li>\n<li><code>package.json</code>，包描述文件</li>\n</ul>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lib = <span class=\"built_in\">require</span>(<span class=\"string\">'index'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'module'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  describe(<span class=\"string\">'limit'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    it(<span class=\"string\">'limit should success'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      lib.limit(<span class=\"number\">10</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h4><p>在当前目录下执行<code>mocha</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mocha</span><br><span class=\"line\"></span><br><span class=\"line\">  ․</span><br><span class=\"line\"></span><br><span class=\"line\">  ✔ 1 test complete (2ms)</span><br></pre></td></tr></table></figure>\n<h2 id=\"断言库\"><a href=\"#断言库\" class=\"headerlink\" title=\"断言库\"></a>断言库</h2><p>上面的代码只是运行了代码，并没有对结果进行检查，这时候就要用到断言库了，Node.js中常用的断言库有：</p>\n<ul>\n<li>should.js</li>\n<li>expect.js</li>\n<li>chai</li>\n</ul>\n<h4 id=\"加上断言\"><a href=\"#加上断言\" class=\"headerlink\" title=\"加上断言\"></a>加上断言</h4><p>使用<code>should</code>库为测试用例加上断言</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'limit should success'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  lib.limit(<span class=\"number\">10</span>).should.be.equal(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"需求变更\"><a href=\"#需求变更\" class=\"headerlink\" title=\"\b需求变更\"></a>\b需求变更</h2><p>需求变更啦： <code>limit</code>这个方法还要求返回值大于100时返回100。</p>\n<p>针对需求重构代码之后，正是测试用例的价值所在了，</p>\n<p>它能确保你的改动对原有成果没有造成破坏。</p>\n<p>但是，你要多做的一些工作的是，需要为新的需求编写新的测试代码。</p>\n<h2 id=\"异步测试\"><a href=\"#异步测试\" class=\"headerlink\" title=\"异步测试\"></a>异步测试</h2><h4 id=\"测试异步回调\"><a href=\"#测试异步回调\" class=\"headerlink\" title=\"测试异步回调\"></a>测试异步回调</h4><p>lib库中新增async函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.async = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    callback(<span class=\"number\">10</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试异步代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">done</span>) </span>&#123;</span><br><span class=\"line\">    lib.async(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">      done();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"测试Promise\"><a href=\"#测试Promise\" class=\"headerlink\" title=\"测试Promise\"></a>测试Promise</h4><p>使用should提供的Promise断言接口:</p>\n<ul>\n<li><code>finally</code> | <code>eventually</code></li>\n<li><code>fulfilled</code></li>\n<li><code>fulfilledWith</code></li>\n<li><code>rejected</code></li>\n<li><code>rejectedWith</code></li>\n<li><code>then</code></li>\n</ul>\n<p>测试代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'should'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  describe(<span class=\"string\">'#Promise'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    it(<span class=\"string\">'should.reject'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'wrong'</span>));</span><br><span class=\"line\">      &#125;)).should.be.rejectedWith(<span class=\"string\">'wrong'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    it(<span class=\"string\">'should.fulfilled'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        resolve(&#123;<span class=\"attr\">username</span>: <span class=\"string\">'jc'</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span>, <span class=\"attr\">gender</span>: <span class=\"string\">'male'</span>&#125;)</span><br><span class=\"line\">      &#125;)).should.be.fulfilled().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">it</span>) </span>&#123;</span><br><span class=\"line\">          it.should.have.property(<span class=\"string\">'username'</span>, <span class=\"string\">'jc'</span>);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"异步方法的超时支持\"><a href=\"#异步方法的超时支持\" class=\"headerlink\" title=\"异步方法的超时支持\"></a>异步方法的超时支持</h4><p>Mocha的超时设定默认是2s，如果执行的测试超过2s的话，就会报timeout错误。</p>\n<p>可以主动修改超时时间，有两种方法。</p>\n<h4 id=\"命令行式\"><a href=\"#命令行式\" class=\"headerlink\" title=\"命令行式\"></a>命令行式</h4><p><code>mocha -t 10000</code></p>\n<h4 id=\"API式\"><a href=\"#API式\" class=\"headerlink\" title=\"API式\"></a>API式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.timeout(<span class=\"number\">10000</span>);</span><br><span class=\"line\">  it(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">done</span>) </span>&#123;</span><br><span class=\"line\">    lib.async(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">      done();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这样的话<code>async</code>执行时间不超过10s，就不会报错timeout错误了。</p>\n<h2 id=\"异常测试\"><a href=\"#异常测试\" class=\"headerlink\" title=\"异常测试\"></a>异常测试</h2><p>异常应该怎么测试，现在有<code>getContent</code>方法，他会读取指定文件的内容，但是不一定会成功，会抛出异常。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.getContent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">filename, callback</span>) </span>&#123;</span><br><span class=\"line\">  fs.readFile(filename, <span class=\"string\">'utf-8'</span>, callback);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这时候就应该模拟(mock)错误环境了</p>\n<h4 id=\"简单Mock\"><a href=\"#简单Mock\" class=\"headerlink\" title=\"简单Mock\"></a>简单Mock</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">\"getContent\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _readFile;</span><br><span class=\"line\">  before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    _readFile = fs.readFile;</span><br><span class=\"line\">    fs.readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">filename, encoding, callback</span>) </span>&#123;</span><br><span class=\"line\">      process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        callback(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"mock readFile error\"</span>));</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;;\t</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// it();</span></span><br><span class=\"line\">  after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用完之后记得还原。否则影响其他case</span></span><br><span class=\"line\">    fs.readFile = _readFile;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mock库\"><a href=\"#Mock库\" class=\"headerlink\" title=\"\bMock库\"></a>\bMock库</h4><p>Mock小模块：<a href=\"https://github.com/fent/node-muk\"><code>muk</code></a> ，略微优美的写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> muk = <span class=\"built_in\">require</span>(<span class=\"string\">'muk'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  muk(fs, <span class=\"string\">'readFile'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, encoding, callback</span>) </span>&#123;</span><br><span class=\"line\">    process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      callback(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"mock readFile error\"</span>));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// it();</span></span><br><span class=\"line\">after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  muk.restore();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试私有方法\"><a href=\"#测试私有方法\" class=\"headerlink\" title=\"测试私有方法\"></a>测试私有方法</h2><p>针对一些内部的方法，没有通过exports暴露出来，怎么测试它？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_adding</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过rewire导出方法\"><a href=\"#通过rewire导出方法\" class=\"headerlink\" title=\"通过rewire导出方法\"></a>通过rewire导出方法</h4><p>模块：<a href=\"http://jhnns.github.com/rewire/\"><code>rewire</code></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(&apos;limit should return success&apos;, function () &#123;</span><br><span class=\"line\">  var lib = rewire(&apos;../lib/index.js&apos;);</span><br><span class=\"line\">  var litmit = lib.__get__(&apos;limit&apos;);</span><br><span class=\"line\">  litmit(10);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试Web应用\"><a href=\"#测试Web应用\" class=\"headerlink\" title=\"测试Web应用\"></a>测试Web应用</h2><p>在开发Web项目的时候，要测试某一个API，如：<code>/user</code>，到底怎么编写测试用例呢？</p>\n<p>使用：<a href=\"https://github.com/visionmedia/supertest\"><code>supertest</code></a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">\"express\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">\"supertest\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义路由</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/user'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">  res.send(<span class=\"number\">200</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'jerryc'</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'GET /user'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  it(<span class=\"string\">'respond with json'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>)</span>&#123;</span><br><span class=\"line\">    request(app)</span><br><span class=\"line\">      .get(<span class=\"string\">'/user'</span>)</span><br><span class=\"line\">      .set(<span class=\"string\">'Accept'</span>, <span class=\"string\">'application/json'</span>)</span><br><span class=\"line\">      .expect(<span class=\"string\">'Content-Type'</span>, /json/)</span><br><span class=\"line\">      .expect(<span class=\"number\">200</span>)</span><br><span class=\"line\">      .end(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err)&#123;</span><br><span class=\"line\">          done(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.body.name.should.be.eql(<span class=\"string\">'jerryc'</span>);</span><br><span class=\"line\">        done();</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"覆盖率\"><a href=\"#覆盖率\" class=\"headerlink\" title=\"覆盖率\"></a>覆盖率</h2><p>测试的时候，我们常常关心，是否所有代码都测试到了。</p>\n<p>这个指标就叫做<a href=\"http://en.wikipedia.org/wiki/Code_coverage\">“代码覆盖率”</a>（code coverage）。它有四个测量维度。</p>\n<blockquote>\n<ul>\n<li><strong>行覆盖率</strong>（line coverage）：是否每一行都执行了？</li>\n<li><strong>函数覆盖率</strong>（function coverage）：是否每个函数都调用了？</li>\n<li><strong>分支覆盖率</strong>（branch coverage）：是否每个if代码块都执行了？</li>\n<li><strong>语句覆盖率</strong>（statement coverage）：是否每个语句都执行了？</li>\n</ul>\n</blockquote>\n<p><a href=\"https://github.com/gotwarlost/istanbul\">Istanbul</a> 是 JavaScript 程序的代码覆盖率工具。</p>\n<h4 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p><code>$ npm install -g istanbul</code></p>\n<h4 id=\"覆盖率测试\"><a href=\"#覆盖率测试\" class=\"headerlink\" title=\"覆盖率测试\"></a>覆盖率测试</h4><p>在编写过以上的测试用例之后，执行命令：</p>\n<p><code>istanbul cover _mocha</code></p>\n<p>就能得到覆盖率:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JerryC% istanbul cover _mocha                                                                                                                                                                </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span></span><br><span class=\"line\">    limit</span><br><span class=\"line\">      ✓ limit should success</span><br><span class=\"line\">    <span class=\"keyword\">async</span></span><br><span class=\"line\">      ✓ <span class=\"keyword\">async</span></span><br><span class=\"line\">    getContent</span><br><span class=\"line\">      ✓ getContent</span><br><span class=\"line\">    add</span><br><span class=\"line\">      ✓ add</span><br><span class=\"line\"></span><br><span class=\"line\">  should</span><br><span class=\"line\">    #Promise</span><br><span class=\"line\">      ✓ should.reject</span><br><span class=\"line\">      ✓ should fulfilled</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"number\">6</span> passing (<span class=\"number\">32</span>ms)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">================== Coverage summary ======================</span><br><span class=\"line\">Statements   : <span class=\"number\">100</span>% ( <span class=\"number\">10</span>/<span class=\"number\">10</span> )</span><br><span class=\"line\">Branches     : <span class=\"number\">100</span>% ( <span class=\"number\">2</span>/<span class=\"number\">2</span> )</span><br><span class=\"line\">Functions    : <span class=\"number\">100</span>% ( <span class=\"number\">5</span>/<span class=\"number\">5</span> )</span><br><span class=\"line\">Lines        : <span class=\"number\">100</span>% ( <span class=\"number\">10</span>/<span class=\"number\">10</span> )</span><br><span class=\"line\">==========================================================</span><br></pre></td></tr></table></figure>\n<p>这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/eac87dbf-4e4b-426e-80ac-7c50e1b9a1cb.jpg\" alt=\"覆盖率html\"></p>\n<p>上面命令中，<code>istanbul cover</code> 命令后面跟的是 <code>_mocha</code> 命令，前面的下划线是不能省略的。</p>\n<p>因为，<a href=\"https://github.com/gotwarlost/istanbul/issues/44\">mocha 和 _mocha 是两个不同的命令</a>，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。</p>\n<p>如果要向 mocha 传入参数，可以写成下面的样子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ istanbul cover _mocha -- tests/test.sqrt.js -R spec</span><br></pre></td></tr></table></figure>\n<p>上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接<a href=\"http://www.clock.co.uk/blog/npm-module-code-coverage-in-2-simple-steps\">1</a>，<a href=\"http://www.vapidspace.com/coding/2014/10/29/code-coverage-metrics-with-mocha-and-istanbul/\">2</a>）。</p>\n<h2 id=\"使用Makefile串起项目\"><a href=\"#使用Makefile串起项目\" class=\"headerlink\" title=\"使用Makefile串起项目\"></a>使用Makefile串起项目</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TESTS = test/*.test.js</span><br><span class=\"line\">REPORTER = spec</span><br><span class=\"line\">TIMEOUT = 10000</span><br><span class=\"line\">JSCOVERAGE = ./node_modules/jscover/bin/jscover</span><br><span class=\"line\"></span><br><span class=\"line\">test:</span><br><span class=\"line\">    @NODE_ENV=test ./node_modules/mocha/bin/mocha -R $(REPORTER) -t $(TIMEOUT) $(TESTS)</span><br><span class=\"line\"></span><br><span class=\"line\">test-cov: lib-cov</span><br><span class=\"line\">    @LIB_COV=1 $(MAKE) test REPORTER=dot</span><br><span class=\"line\">    @LIB_COV=1 $(MAKE) test REPORTER=html-cov &gt; coverage.html</span><br><span class=\"line\"></span><br><span class=\"line\">lib-cov:</span><br><span class=\"line\">    @rm -rf ./lib-cov</span><br><span class=\"line\">    @$(JSCOVERAGE) lib lib-cov</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY: test test-cov lib-cov</span><br><span class=\"line\"></span><br><span class=\"line\">make test</span><br><span class=\"line\">make test-cov</span><br></pre></td></tr></table></figure>\n<p>用项目自身的jscover和mocha，避免版本冲突和混乱</p>\n<h2 id=\"持续集成，Travis-cli\"><a href=\"#持续集成，Travis-cli\" class=\"headerlink\" title=\"持续集成，Travis-cli\"></a>持续集成，Travis-cli</h2><ul>\n<li><a href=\"https://travis-ci.org/\">Travis-ci</a><ul>\n<li>绑定Github帐号</li>\n<li>在Github仓库的Admin打开Services hook</li>\n<li>打开Travis</li>\n<li>每次push将会hook触发执行<code>npm test</code>命令</li>\n</ul>\n</li>\n</ul>\n<p>注意：Travis会将未描述的项目当作Ruby项目。所以需要在根目录下加入<code>.travis.yml</code>文件。内容如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span></span><br><span class=\"line\"><span class=\"attr\">node_js:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">\"0.12\"</span></span><br></pre></td></tr></table></figure>\n<p>Travis-cli还会对项目颁发标签，</p>\n<p><img src=\"https://camo.githubusercontent.com/f479d6cf4ac300093da5a90d70565cebf8c8ed40/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f4a61636b736f6e5469616e2f626167706970652e706e67\" alt=\"/\">or <img src=\"https://camo.githubusercontent.com/08478cd5a732822aec47e6e60d5f823ef0898dec/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f54424544502f64617461766a732e706e67\" alt=\"/\"></p>\n<p>如果项目通过所有测试，就会build-passing，</p>\n<p>如果项目没有通过所有测试，就会build-failing</p>\n<h2 id=\"一些观点\"><a href=\"#一些观点\" class=\"headerlink\" title=\"一些观点\"></a>一些观点</h2><p>实施单元测试的时候, 如果没有一份经过实践证明的详细规范, 很难掌握测试的 “度”, 范围太小施展不开, 太大又侵犯 “别人的” 地盘. 上帝的归上帝, 凯撒的归凯撒, 给单元测试念念紧箍咒不见得是件坏事, 反而更有利于发挥单元测试的威力, 为代码重构和提高代码质量提供动力.</p>\n<p>这份文档来自 Geotechnical, 是一份非常难得的经验准则. 你完全可以以这份准则作为模板, 结合所在团队的经验, 整理出一份内部单元测试准则.</p>\n<p><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">单元测试准则</a></p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><p>最后，介绍一个库：<a href=\"https://github.com/Marak/Faker.js\"><code>faker</code></a></p>\n<p>他是一个能伪造用户数据的库，包括用户常包含的属性：个人信息、头像、地址等等。</p>\n<p>是一个开发初期，模拟用户数据的绝佳好库。</p>\n<p>支持Node.js和浏览器端。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/43075e5e-026f-4acb-a51f-a998cf1a6e11.jpg\" alt=\"生成用户\"></p>\n<h2 id=\"整理\"><a href=\"#整理\" class=\"headerlink\" title=\"整理\"></a>整理</h2><h4 id=\"Nodejs的单元测试工具\"><a href=\"#Nodejs的单元测试工具\" class=\"headerlink\" title=\"Nodejs的单元测试工具\"></a>Nodejs的单元测试工具</h4><ol>\n<li>测试框架 mocha</li>\n<li>断言库：should.js、expect.js、chai</li>\n<li>覆盖率：istanbul、jscover、blanket</li>\n<li>Mock库：muk</li>\n<li>测试私有方法：rewire</li>\n<li>Web测试：supertest</li>\n<li>持续集成：Travis-cli</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/JacksonTian/unittesting\">https://github.com/JacksonTian/unittesting</a></li>\n<li><a href=\"\"></a><a href=\"http://html5ify.com/unittesting/slides/index.html\">http://html5ify.com/unittesting/slides/index.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/06/istanbul.html\">http://www.ruanyifeng.com/blog/2015/06/istanbul.html</a></li>\n<li><a href=\"http://coolshell.cn/articles/8209.html\">http://coolshell.cn/articles/8209.html</a></li>\n<li><a href=\"http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests\">http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming\">http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming</a></li>\n<li><a href=\"http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D\">http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"https://github.com/visionmedia/superagent/blob/master/Makefile\">https://github.com/visionmedia/superagent/blob/master/Makefile</a></li>\n</ul>\n"},{"title":"原生JavaScript实现拖拽效果","date":"2014-07-12T07:45:37.000Z","_content":"\n## 前言\n\n闲着无事干，突然想做一个类Q+ Web桌面的东西，当然那是一个大工程（对本菜鸟来说）。那么，这个Demo就是第一步，起码可以实现图标的拖拽效果。\n截图：\n\n\n\n\n```HTML\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title>Drag Demo</title>\n    <style>\n        body{\n            background:url(images/bg.jpg) no-repeat;\n            background-size:100%;\n            padding: 20px ;\n        }\n        .icon{\n            width: 100px;height: 100px;margin-bottom:15px;position: absolute;cursor: move;\n        }\n        .icon-0{\n            background: url(\"images/png/0.png\") no-repeat;background-size: 100%;\n            top: 20px;\n            left: 20px;\n        }\n        .icon-1{\n            background: url(\"images/png/1.png\") no-repeat;background-size: 100%;\n            top: 140px;\n            left: 20px;\n        }\n        .icon-2{\n            background: url(\"images/png/2.png\") no-repeat;background-size: 100%;\n            top: 260px;\n            left: 20px;\n        }\n        .icon-3{\n            background: url(\"images/png/3.png\") no-repeat;background-size: 100%;\n            top: 380px;\n            left: 20px;\n        }\n        .icon-4{\n             background: url(\"images/png/4.png\") no-repeat;background-size: 100%;\n             top: 500px;\n             left: 20px;\n        }\n\n\n    </style>\n</head>\n\n<body>\n    <div class=\"icon icon-0\"></div>\n    <div class=\"icon icon-1\"></div>\n    <div class=\"icon icon-2\"></div>\n    <div class=\"icon icon-3\"></div>\n    <div class=\"icon icon-4\"></div>\n</body>\n\n<script type=\"text/javascript\">\n    function g(el){ return document.getElementsByClassName(el);}\n\n    var icons = g('icon');\n    var instace = false; //存放当前移动对象信息\n\n    for(var i =0 ; i<icons.length ; i++){\n        if(icons[i]) {\n            icons[i].addEventListener('mousedown', function (e) {\n\n                instace = {};\n                var e = e || window.event;\n                var el = e.toElement || e.target;\n                console.log(e);\n                instace.moveElement = el;\n\n                //  获取鼠标的坐标\n                var mouseX = e.pageX;\n                var mouseY = e.pageY;\n\n                //  获取元素左上角的坐标\n                var elX = el.offsetLeft;\n                var elY = el.offsetTop;\n\n                //  计算出偏移量\n                instace.offSetX = mouseX - elX;\n                instace.offSetY = mouseY - elY;\n\n                instace.moveElement.style.zIndex = 9000;\n            });\n        }\n    }\n\n    document.onmouseup = function(e){\n        instace.moveElement.style.zIndex = 2;\n        instace = false;\n    };\n\n    document.onmousemove = function(e){\n\n        if(instace){\n\n            //  获取当前鼠标坐标\n            var mouseX = e.pageX;\n            var mouseY = e.pageY;\n\n            //  计算元素移动坐标\n            var moveX = mouseX - instace.offSetX;\n            var moveY = mouseY - instace.offSetY;\n\n            //  计算最大移动坐标\n            var maxX = document.documentElement.clientWidth  - instace.moveElement.offsetWidth;\n            var maxY = document.documentElement.clientHeight - instace.moveElement.offsetHeight;\n\n            //  设置元素的坐标\n            instace.moveElement.style.left = Math.max(0,Math.min(maxX,moveX)) + 'px';\n            instace.moveElement.style.top  = Math.max(0,Math.min(maxY,moveY)) + 'px';\n        }\n    };\n</script>\n</html>\n```\n\n\n演示地址：http://jerryc8080.github.io/dragDemo/\n项目地址：https://github.com/JerryC8080/dragDemo/\n","source":"_posts/原生JavaScript实现拖拽效果.md","raw":"---\ntitle: 原生JavaScript实现拖拽效果\ncategory: 搬砖码农\ndate: 2014-07-12 15:45:37\ntags:\n- Javascript\n---\n\n## 前言\n\n闲着无事干，突然想做一个类Q+ Web桌面的东西，当然那是一个大工程（对本菜鸟来说）。那么，这个Demo就是第一步，起码可以实现图标的拖拽效果。\n截图：\n\n\n\n\n```HTML\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title>Drag Demo</title>\n    <style>\n        body{\n            background:url(images/bg.jpg) no-repeat;\n            background-size:100%;\n            padding: 20px ;\n        }\n        .icon{\n            width: 100px;height: 100px;margin-bottom:15px;position: absolute;cursor: move;\n        }\n        .icon-0{\n            background: url(\"images/png/0.png\") no-repeat;background-size: 100%;\n            top: 20px;\n            left: 20px;\n        }\n        .icon-1{\n            background: url(\"images/png/1.png\") no-repeat;background-size: 100%;\n            top: 140px;\n            left: 20px;\n        }\n        .icon-2{\n            background: url(\"images/png/2.png\") no-repeat;background-size: 100%;\n            top: 260px;\n            left: 20px;\n        }\n        .icon-3{\n            background: url(\"images/png/3.png\") no-repeat;background-size: 100%;\n            top: 380px;\n            left: 20px;\n        }\n        .icon-4{\n             background: url(\"images/png/4.png\") no-repeat;background-size: 100%;\n             top: 500px;\n             left: 20px;\n        }\n\n\n    </style>\n</head>\n\n<body>\n    <div class=\"icon icon-0\"></div>\n    <div class=\"icon icon-1\"></div>\n    <div class=\"icon icon-2\"></div>\n    <div class=\"icon icon-3\"></div>\n    <div class=\"icon icon-4\"></div>\n</body>\n\n<script type=\"text/javascript\">\n    function g(el){ return document.getElementsByClassName(el);}\n\n    var icons = g('icon');\n    var instace = false; //存放当前移动对象信息\n\n    for(var i =0 ; i<icons.length ; i++){\n        if(icons[i]) {\n            icons[i].addEventListener('mousedown', function (e) {\n\n                instace = {};\n                var e = e || window.event;\n                var el = e.toElement || e.target;\n                console.log(e);\n                instace.moveElement = el;\n\n                //  获取鼠标的坐标\n                var mouseX = e.pageX;\n                var mouseY = e.pageY;\n\n                //  获取元素左上角的坐标\n                var elX = el.offsetLeft;\n                var elY = el.offsetTop;\n\n                //  计算出偏移量\n                instace.offSetX = mouseX - elX;\n                instace.offSetY = mouseY - elY;\n\n                instace.moveElement.style.zIndex = 9000;\n            });\n        }\n    }\n\n    document.onmouseup = function(e){\n        instace.moveElement.style.zIndex = 2;\n        instace = false;\n    };\n\n    document.onmousemove = function(e){\n\n        if(instace){\n\n            //  获取当前鼠标坐标\n            var mouseX = e.pageX;\n            var mouseY = e.pageY;\n\n            //  计算元素移动坐标\n            var moveX = mouseX - instace.offSetX;\n            var moveY = mouseY - instace.offSetY;\n\n            //  计算最大移动坐标\n            var maxX = document.documentElement.clientWidth  - instace.moveElement.offsetWidth;\n            var maxY = document.documentElement.clientHeight - instace.moveElement.offsetHeight;\n\n            //  设置元素的坐标\n            instace.moveElement.style.left = Math.max(0,Math.min(maxX,moveX)) + 'px';\n            instace.moveElement.style.top  = Math.max(0,Math.min(maxY,moveY)) + 'px';\n        }\n    };\n</script>\n</html>\n```\n\n\n演示地址：http://jerryc8080.github.io/dragDemo/\n项目地址：https://github.com/JerryC8080/dragDemo/\n","slug":"原生JavaScript实现拖拽效果","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8rp0029xwrlzcd3kw3a","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>闲着无事干，突然想做一个类Q+ Web桌面的东西，当然那是一个大工程（对本菜鸟来说）。那么，这个Demo就是第一步，起码可以实现图标的拖拽效果。<br>截图：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Drag Demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        body&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            background:url(images/bg.jpg) no-repeat;</span></span><br><span class=\"line\"><span class=\"undefined\">            background-size:100%;</span></span><br><span class=\"line\"><span class=\"undefined\">            padding: 20px ;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        .icon&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            width: 100px;height: 100px;margin-bottom:15px;position: absolute;cursor: move;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        .icon-0&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            background: url(\"images/png/0.png\") no-repeat;background-size: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">            top: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">            left: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        .icon-1&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            background: url(\"images/png/1.png\") no-repeat;background-size: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">            top: 140px;</span></span><br><span class=\"line\"><span class=\"undefined\">            left: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        .icon-2&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            background: url(\"images/png/2.png\") no-repeat;background-size: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">            top: 260px;</span></span><br><span class=\"line\"><span class=\"undefined\">            left: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        .icon-3&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            background: url(\"images/png/3.png\") no-repeat;background-size: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">            top: 380px;</span></span><br><span class=\"line\"><span class=\"undefined\">            left: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        .icon-4&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">             background: url(\"images/png/4.png\") no-repeat;background-size: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">             top: 500px;</span></span><br><span class=\"line\"><span class=\"undefined\">             left: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-0\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-3\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-4\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\">el</span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementsByClassName(el);&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> icons = g(<span class=\"string\">'icon'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> instace = <span class=\"literal\">false</span>; <span class=\"comment\">//存放当前移动对象信息</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i =<span class=\"number\">0</span> ; i&lt;icons.length ; i++)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">if</span>(icons[i]) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            icons[i].addEventListener(<span class=\"string\">'mousedown'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">                instace = &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> e = e || <span class=\"built_in\">window</span>.event;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> el = e.toElement || e.target;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(e);</span></span><br><span class=\"line\"><span class=\"undefined\">                instace.moveElement = el;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//  获取鼠标的坐标</span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> mouseX = e.pageX;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> mouseY = e.pageY;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//  获取元素左上角的坐标</span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> elX = el.offsetLeft;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> elY = el.offsetTop;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//  计算出偏移量</span></span></span><br><span class=\"line\"><span class=\"undefined\">                instace.offSetX = mouseX - elX;</span></span><br><span class=\"line\"><span class=\"undefined\">                instace.offSetY = mouseY - elY;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">                instace.moveElement.style.zIndex = 9000;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.onmouseup = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        instace.moveElement.style.zIndex = 2;</span></span><br><span class=\"line\"><span class=\"javascript\">        instace = <span class=\"literal\">false</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.onmousemove = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">if</span>(instace)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//  获取当前鼠标坐标</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> mouseX = e.pageX;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> mouseY = e.pageY;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//  计算元素移动坐标</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> moveX = mouseX - instace.offSetX;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> moveY = mouseY - instace.offSetY;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//  计算最大移动坐标</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> maxX = <span class=\"built_in\">document</span>.documentElement.clientWidth  - instace.moveElement.offsetWidth;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> maxY = <span class=\"built_in\">document</span>.documentElement.clientHeight - instace.moveElement.offsetHeight;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//  设置元素的坐标</span></span></span><br><span class=\"line\"><span class=\"javascript\">            instace.moveElement.style.left = <span class=\"built_in\">Math</span>.max(<span class=\"number\">0</span>,<span class=\"built_in\">Math</span>.min(maxX,moveX)) + <span class=\"string\">'px'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            instace.moveElement.style.top  = <span class=\"built_in\">Math</span>.max(<span class=\"number\">0</span>,<span class=\"built_in\">Math</span>.min(maxY,moveY)) + <span class=\"string\">'px'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>演示地址：<a href=\"http://jerryc8080.github.io/dragDemo/\" target=\"_blank\" rel=\"external\">http://jerryc8080.github.io/dragDemo/</a><br>项目地址：<a href=\"https://github.com/JerryC8080/dragDemo/\" target=\"_blank\" rel=\"external\">https://github.com/JerryC8080/dragDemo/</a></p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>闲着无事干，突然想做一个类Q+ Web桌面的东西，当然那是一个大工程（对本菜鸟来说）。那么，这个Demo就是第一步，起码可以实现图标的拖拽效果。<br>截图：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Drag Demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        body&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            background:url(images/bg.jpg) no-repeat;</span></span><br><span class=\"line\"><span class=\"undefined\">            background-size:100%;</span></span><br><span class=\"line\"><span class=\"undefined\">            padding: 20px ;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        .icon&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            width: 100px;height: 100px;margin-bottom:15px;position: absolute;cursor: move;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        .icon-0&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            background: url(\"images/png/0.png\") no-repeat;background-size: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">            top: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">            left: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        .icon-1&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            background: url(\"images/png/1.png\") no-repeat;background-size: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">            top: 140px;</span></span><br><span class=\"line\"><span class=\"undefined\">            left: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        .icon-2&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            background: url(\"images/png/2.png\") no-repeat;background-size: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">            top: 260px;</span></span><br><span class=\"line\"><span class=\"undefined\">            left: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        .icon-3&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            background: url(\"images/png/3.png\") no-repeat;background-size: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">            top: 380px;</span></span><br><span class=\"line\"><span class=\"undefined\">            left: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        .icon-4&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">             background: url(\"images/png/4.png\") no-repeat;background-size: 100%;</span></span><br><span class=\"line\"><span class=\"undefined\">             top: 500px;</span></span><br><span class=\"line\"><span class=\"undefined\">             left: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-0\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-3\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-4\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\">el</span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementsByClassName(el);&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> icons = g(<span class=\"string\">'icon'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> instace = <span class=\"literal\">false</span>; <span class=\"comment\">//存放当前移动对象信息</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i =<span class=\"number\">0</span> ; i&lt;icons.length ; i++)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">if</span>(icons[i]) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            icons[i].addEventListener(<span class=\"string\">'mousedown'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">                instace = &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> e = e || <span class=\"built_in\">window</span>.event;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> el = e.toElement || e.target;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(e);</span></span><br><span class=\"line\"><span class=\"undefined\">                instace.moveElement = el;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//  获取鼠标的坐标</span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> mouseX = e.pageX;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> mouseY = e.pageY;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//  获取元素左上角的坐标</span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> elX = el.offsetLeft;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> elY = el.offsetTop;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//  计算出偏移量</span></span></span><br><span class=\"line\"><span class=\"undefined\">                instace.offSetX = mouseX - elX;</span></span><br><span class=\"line\"><span class=\"undefined\">                instace.offSetY = mouseY - elY;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">                instace.moveElement.style.zIndex = 9000;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.onmouseup = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        instace.moveElement.style.zIndex = 2;</span></span><br><span class=\"line\"><span class=\"javascript\">        instace = <span class=\"literal\">false</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.onmousemove = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">if</span>(instace)&#123;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//  获取当前鼠标坐标</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> mouseX = e.pageX;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> mouseY = e.pageY;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//  计算元素移动坐标</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> moveX = mouseX - instace.offSetX;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> moveY = mouseY - instace.offSetY;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//  计算最大移动坐标</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> maxX = <span class=\"built_in\">document</span>.documentElement.clientWidth  - instace.moveElement.offsetWidth;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> maxY = <span class=\"built_in\">document</span>.documentElement.clientHeight - instace.moveElement.offsetHeight;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//  设置元素的坐标</span></span></span><br><span class=\"line\"><span class=\"javascript\">            instace.moveElement.style.left = <span class=\"built_in\">Math</span>.max(<span class=\"number\">0</span>,<span class=\"built_in\">Math</span>.min(maxX,moveX)) + <span class=\"string\">'px'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            instace.moveElement.style.top  = <span class=\"built_in\">Math</span>.max(<span class=\"number\">0</span>,<span class=\"built_in\">Math</span>.min(maxY,moveY)) + <span class=\"string\">'px'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>演示地址：<a href=\"http://jerryc8080.github.io/dragDemo/\">http://jerryc8080.github.io/dragDemo/</a><br>项目地址：<a href=\"https://github.com/JerryC8080/dragDemo/\">https://github.com/JerryC8080/dragDemo/</a></p>\n"},{"title":"单点登录的三种实现方式","date":"2015-09-14T09:18:40.000Z","_content":"\n\n单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。单点登录在大型网站里使用得非常频繁，例如像阿里巴巴这样的网站，在网站的背后是成百上千的子系统，用户一次操作或交易可能涉及到几十个子系统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯掉。实现单点登录说到底就是要解决如何产生和存储那个信任，再就是其他系统如何验证这个信任的有效性，因此要点也就以下两个：\n* 存储信任\n* 验证信任\n\n如果一个系统做到了开头所讲的效果，也就算单点登录，单点登录有不同的实现方式，本文就罗列我开发中所遇见过的实现方式。\n\n## 以Cookie作为凭证媒介\n最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。\n用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie并进行校验，校验通过则登录当前用户。\n\n![Auth via cookie](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/79702-b33138a8d24fc12b.jpg)\n\n不难发现以上方式把信任存储在客户端的Cookie中，这种方式很容易令人质疑：\n* Cookie不安全\n* 不能跨域实现免登\n\n对于第一个问题，通过加密Cookie可以保证安全性，当然这是在源代码不泄露的前提下。如果Cookie的加密算法泄露，攻击者通过伪造Cookie则可以伪造特定用户身份，这是很危险的。\n对于第二个问题，更是硬伤。\n\n## 通过JSONP实现\n对于跨域问题，可以使用JSONP实现。\n用户在父应用中登录后，跟Session匹配的Cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的Cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。\n\n![Auth via jsonp](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/79702-7ddba46df098374b.jpg)\n\n这种方式虽然能解决跨域问题，但是安全性其实跟把信任存储到Cookie是差不多的。如果一旦加密算法泄露了，攻击者可以在本地建立一个实现了登录接口的假冒父应用，通过绑定Host来把子应用发起的请求指向本地的假冒父应用，并作出回应。\n因为攻击者完全可以按照加密算法来伪造响应请求，子应用接收到这个响应之后一样可以通过验证，并且登录特定用户。\n\n## 通过页面重定向的方式\n最后一种介绍的方式，是通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。\n父应用提供一个GET方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。如果用户已经登录了，则生成加密的Token，并且重定向到子应用提供的验证Token的接口，通过解密和校验之后，子应用登录当前用户。\n\n![Auth via redirect](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/79702-6409eeef6e923407.jpg)\n\n这种方式较前面两种方式，接解决了上面两种方法暴露出来的安全性问题和跨域的问题，但是并没有前面两种方式方便。\n安全与方便，本来就是一对矛盾。\n\n## 使用独立登录系统\n一般说来，大型应用会把授权的逻辑与用户信息的相关逻辑独立成一个应用，称为用户中心。\n用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。\n","source":"_posts/单点登录的三种实现方式.md","raw":"---\ntitle: 单点登录的三种实现方式\ncategory: 搬砖码农\ndate: 2015-09-14 17:18:40\ntags:\n- 单点登录\n- cookie\n- session\n- 架构\n---\n\n\n单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。单点登录在大型网站里使用得非常频繁，例如像阿里巴巴这样的网站，在网站的背后是成百上千的子系统，用户一次操作或交易可能涉及到几十个子系统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯掉。实现单点登录说到底就是要解决如何产生和存储那个信任，再就是其他系统如何验证这个信任的有效性，因此要点也就以下两个：\n* 存储信任\n* 验证信任\n\n如果一个系统做到了开头所讲的效果，也就算单点登录，单点登录有不同的实现方式，本文就罗列我开发中所遇见过的实现方式。\n\n## 以Cookie作为凭证媒介\n最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。\n用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie并进行校验，校验通过则登录当前用户。\n\n![Auth via cookie](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/79702-b33138a8d24fc12b.jpg)\n\n不难发现以上方式把信任存储在客户端的Cookie中，这种方式很容易令人质疑：\n* Cookie不安全\n* 不能跨域实现免登\n\n对于第一个问题，通过加密Cookie可以保证安全性，当然这是在源代码不泄露的前提下。如果Cookie的加密算法泄露，攻击者通过伪造Cookie则可以伪造特定用户身份，这是很危险的。\n对于第二个问题，更是硬伤。\n\n## 通过JSONP实现\n对于跨域问题，可以使用JSONP实现。\n用户在父应用中登录后，跟Session匹配的Cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的Cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。\n\n![Auth via jsonp](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/79702-7ddba46df098374b.jpg)\n\n这种方式虽然能解决跨域问题，但是安全性其实跟把信任存储到Cookie是差不多的。如果一旦加密算法泄露了，攻击者可以在本地建立一个实现了登录接口的假冒父应用，通过绑定Host来把子应用发起的请求指向本地的假冒父应用，并作出回应。\n因为攻击者完全可以按照加密算法来伪造响应请求，子应用接收到这个响应之后一样可以通过验证，并且登录特定用户。\n\n## 通过页面重定向的方式\n最后一种介绍的方式，是通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。\n父应用提供一个GET方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。如果用户已经登录了，则生成加密的Token，并且重定向到子应用提供的验证Token的接口，通过解密和校验之后，子应用登录当前用户。\n\n![Auth via redirect](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/79702-6409eeef6e923407.jpg)\n\n这种方式较前面两种方式，接解决了上面两种方法暴露出来的安全性问题和跨域的问题，但是并没有前面两种方式方便。\n安全与方便，本来就是一对矛盾。\n\n## 使用独立登录系统\n一般说来，大型应用会把授权的逻辑与用户信息的相关逻辑独立成一个应用，称为用户中心。\n用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。\n","slug":"单点登录的三种实现方式","published":1,"updated":"2020-12-13T13:47:15.669Z","_id":"cl270y8rs002cxwrluqpmhz7u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。单点登录在大型网站里使用得非常频繁，例如像阿里巴巴这样的网站，在网站的背后是成百上千的子系统，用户一次操作或交易可能涉及到几十个子系统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯掉。实现单点登录说到底就是要解决如何产生和存储那个信任，再就是其他系统如何验证这个信任的有效性，因此要点也就以下两个：</p>\n<ul>\n<li>存储信任</li>\n<li>验证信任</li>\n</ul>\n<p>如果一个系统做到了开头所讲的效果，也就算单点登录，单点登录有不同的实现方式，本文就罗列我开发中所遇见过的实现方式。</p>\n<h2 id=\"以Cookie作为凭证媒介\"><a href=\"#以Cookie作为凭证媒介\" class=\"headerlink\" title=\"以Cookie作为凭证媒介\"></a>以Cookie作为凭证媒介</h2><p>最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。<br>用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie并进行校验，校验通过则登录当前用户。</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/79702-b33138a8d24fc12b.jpg\" alt=\"Auth via cookie\"></p>\n<p>不难发现以上方式把信任存储在客户端的Cookie中，这种方式很容易令人质疑：</p>\n<ul>\n<li>Cookie不安全</li>\n<li>不能跨域实现免登</li>\n</ul>\n<p>对于第一个问题，通过加密Cookie可以保证安全性，当然这是在源代码不泄露的前提下。如果Cookie的加密算法泄露，攻击者通过伪造Cookie则可以伪造特定用户身份，这是很危险的。<br>对于第二个问题，更是硬伤。</p>\n<h2 id=\"通过JSONP实现\"><a href=\"#通过JSONP实现\" class=\"headerlink\" title=\"通过JSONP实现\"></a>通过JSONP实现</h2><p>对于跨域问题，可以使用JSONP实现。<br>用户在父应用中登录后，跟Session匹配的Cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的Cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/79702-7ddba46df098374b.jpg\" alt=\"Auth via jsonp\"></p>\n<p>这种方式虽然能解决跨域问题，但是安全性其实跟把信任存储到Cookie是差不多的。如果一旦加密算法泄露了，攻击者可以在本地建立一个实现了登录接口的假冒父应用，通过绑定Host来把子应用发起的请求指向本地的假冒父应用，并作出回应。<br>因为攻击者完全可以按照加密算法来伪造响应请求，子应用接收到这个响应之后一样可以通过验证，并且登录特定用户。</p>\n<h2 id=\"通过页面重定向的方式\"><a href=\"#通过页面重定向的方式\" class=\"headerlink\" title=\"通过页面重定向的方式\"></a>通过页面重定向的方式</h2><p>最后一种介绍的方式，是通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。<br>父应用提供一个GET方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。如果用户已经登录了，则生成加密的Token，并且重定向到子应用提供的验证Token的接口，通过解密和校验之后，子应用登录当前用户。</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/79702-6409eeef6e923407.jpg\" alt=\"Auth via redirect\"></p>\n<p>这种方式较前面两种方式，接解决了上面两种方法暴露出来的安全性问题和跨域的问题，但是并没有前面两种方式方便。<br>安全与方便，本来就是一对矛盾。</p>\n<h2 id=\"使用独立登录系统\"><a href=\"#使用独立登录系统\" class=\"headerlink\" title=\"使用独立登录系统\"></a>使用独立登录系统</h2><p>一般说来，大型应用会把授权的逻辑与用户信息的相关逻辑独立成一个应用，称为用户中心。<br>用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。</p>\n","excerpt":"","more":"<p>单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。单点登录在大型网站里使用得非常频繁，例如像阿里巴巴这样的网站，在网站的背后是成百上千的子系统，用户一次操作或交易可能涉及到几十个子系统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯掉。实现单点登录说到底就是要解决如何产生和存储那个信任，再就是其他系统如何验证这个信任的有效性，因此要点也就以下两个：</p>\n<ul>\n<li>存储信任</li>\n<li>验证信任</li>\n</ul>\n<p>如果一个系统做到了开头所讲的效果，也就算单点登录，单点登录有不同的实现方式，本文就罗列我开发中所遇见过的实现方式。</p>\n<h2 id=\"以Cookie作为凭证媒介\"><a href=\"#以Cookie作为凭证媒介\" class=\"headerlink\" title=\"以Cookie作为凭证媒介\"></a>以Cookie作为凭证媒介</h2><p>最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。<br>用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie并进行校验，校验通过则登录当前用户。</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/79702-b33138a8d24fc12b.jpg\" alt=\"Auth via cookie\"></p>\n<p>不难发现以上方式把信任存储在客户端的Cookie中，这种方式很容易令人质疑：</p>\n<ul>\n<li>Cookie不安全</li>\n<li>不能跨域实现免登</li>\n</ul>\n<p>对于第一个问题，通过加密Cookie可以保证安全性，当然这是在源代码不泄露的前提下。如果Cookie的加密算法泄露，攻击者通过伪造Cookie则可以伪造特定用户身份，这是很危险的。<br>对于第二个问题，更是硬伤。</p>\n<h2 id=\"通过JSONP实现\"><a href=\"#通过JSONP实现\" class=\"headerlink\" title=\"通过JSONP实现\"></a>通过JSONP实现</h2><p>对于跨域问题，可以使用JSONP实现。<br>用户在父应用中登录后，跟Session匹配的Cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的Cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/79702-7ddba46df098374b.jpg\" alt=\"Auth via jsonp\"></p>\n<p>这种方式虽然能解决跨域问题，但是安全性其实跟把信任存储到Cookie是差不多的。如果一旦加密算法泄露了，攻击者可以在本地建立一个实现了登录接口的假冒父应用，通过绑定Host来把子应用发起的请求指向本地的假冒父应用，并作出回应。<br>因为攻击者完全可以按照加密算法来伪造响应请求，子应用接收到这个响应之后一样可以通过验证，并且登录特定用户。</p>\n<h2 id=\"通过页面重定向的方式\"><a href=\"#通过页面重定向的方式\" class=\"headerlink\" title=\"通过页面重定向的方式\"></a>通过页面重定向的方式</h2><p>最后一种介绍的方式，是通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。<br>父应用提供一个GET方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。如果用户已经登录了，则生成加密的Token，并且重定向到子应用提供的验证Token的接口，通过解密和校验之后，子应用登录当前用户。</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/79702-6409eeef6e923407.jpg\" alt=\"Auth via redirect\"></p>\n<p>这种方式较前面两种方式，接解决了上面两种方法暴露出来的安全性问题和跨域的问题，但是并没有前面两种方式方便。<br>安全与方便，本来就是一对矛盾。</p>\n<h2 id=\"使用独立登录系统\"><a href=\"#使用独立登录系统\" class=\"headerlink\" title=\"使用独立登录系统\"></a>使用独立登录系统</h2><p>一般说来，大型应用会把授权的逻辑与用户信息的相关逻辑独立成一个应用，称为用户中心。<br>用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。</p>\n"},{"title":"何为语法树","date":"2016-03-14T16:04:49.000Z","_content":"\n## 什么是语法树？\n\n> 你是否曾想过，这个世界存在这么多语言的意义。\n\n假如现在你面前有一个物体，它是一个不规则的圆体，整个身体通红，头部还有一根细长稍微弯曲偏右呈棕色的圆柱体。    \n在中文我们称之为「苹果」，    \n在英文我们称之为「Apple」，    \n在日文中我们称之为「アップル」，    \n在法语中我们称之为「pomme」，    \n在德语中我们称之为「Apfel」，    \n无论用不同的语言，针对这个物体在文字上、发音上都完全不一样，但这个物体确确实实的存在这个时空上，颜色、气味、形状都不曾因为语言而改变过。    \n\n> 无论这个世界存在多少语言，它们所描述的真理都不曾改变过。\n\n或者说，真理就存在那里，可以用不同的语言的不同表达方式描述出来。那么计算机的世界，这么多编程的语言，C、C++、Java、C#、JavaScript、Python、Go、Ruby等等等，它们共同所描述的真理是什么？\n\n我们知道人类语言上，无论什么语种，都会有「主语」「动词」「宾语」「标点符号」来描述一个现实世界所发生的事件。\n而在计算机编程语言上，无论什么语种，都会有「类型」「运算符」「流程语句」「函数」「对象」等概念来表达计算机中存在内存中的0和1，以及背后运算与逻辑。\n\n> 语法树，计算机描述世界真理的树状结构。\n\n不同的语言，都会配之不同的语法分析器，而语法分析器是把源代码作为字符串读入、解析，并建立语法树的程序。语法的设计和语法分析器的实现是决定语言外在表现的重要因素。    \n什么是语法树？摘自Wiki一段：\n\n> 在计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。\n\n## 一则简单的例子\n如果我们需要让计算机帮忙算一下 「1加2再乘以3」 的结果，该怎么表达呢？    \n现在我们大多数的现代编程语言，都是使用「中缀表达式」的方式来编写运算，比如JavaScript：\n\n```\n(1 + 2) * 3\n```\n\n而FORTH语言则使用「后缀表达式」，这基本上与日语中的语序是一致的：\n\n```\n1 2 + 3 *\n```\n\nLISP语言使用的「前缀表达式」：\n\n```\n( * (+ 1 2) 3)\n```\n\n我们再看一下这三种表达式的语法树：\n\n![表达式语法树比较](/image/blog/whatisAST/表达式语法树比较.png)\n\n可以看出，对于这三种简单的语言，它们只是在这个语法树上按不同的规则遍历而已。三者的代码看起来差别很大，但实际上所用的树结构是相同的。\n\n## 先来看看Python的语法树\n通过Python语言自带的库文件ast，我们可以查看特定的代码被转换成怎样的语法树。\n\n```\n>>> import ast\n>>> ast.dump(ast.parse(\"(1 + 2) * 3\"))\n'Module(\n\tbody=[\n\t\tExpr(\n\t\t\tvalue=BinOp(\n\t\t\t\tleft=BinOp(\n\t\t\t\t\tleft=Num(n=1), \n\t\t\t\t\top=Add(), \n\t\t\t\t\tright=Num(n=2)\n\t\t\t\t), \n\t\t\t\top=Mult(), \n\t\t\t\tright=Num(n=3)\n\t\t\t)\n\t\t)\n\t]\n)'\n```\n\n\n`BinOp op = Mult()`表示乘法运算，与`*`相对应；    \n`BinOp op = Add()`表示加法运算，与`+`相对应；    \n`Num n = 1`既为数值1。\n\n![Python语法树](/image/blog/whatisAST/Python语法树.png)\n\n\n## 再窥视一下JavaScript的语法树\n> 在语法复杂的语言中，语法树是包含很多细节的语法结果表达式，我们需要靠语法树把这种形式以更简洁的形式表达出来。\n\nJavascript 有不少工具可以把代码构造出清晰的语法树，比如 [esprima](http://esprima.org/ )、[v8](https://code.google.com/p/v8/source/browse/branches/bleeding_edge/src/ast.h)、[SpiderMonkey](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API)、[UglifyJS](http://lisperator.net/uglifyjs/)、[AST explorer](http://astexplorer.net/)等。\n\n这里，我使用「esprima」来探讨一下JavaScript运算`(1 + 2) * 3`的语法树。\n\njavascript code: \n\n```\n(1 + 2)* 3;\n```\n\nast for json:\n\n```\n{\n    \"type\": \"Program\",\n    \"body\": [\n        {\n            \"type\": \"ExpressionStatement\",\n            \"expression\": {\n                \"type\": \"BinaryExpression\",\n                \"operator\": \"*\",\n                \"left\": {\n                    \"type\": \"BinaryExpression\",\n                    \"operator\": \"+\",\n                    \"left\": {\n                        \"type\": \"Literal\",\n                        \"value\": 1,\n                        \"raw\": \"1\"\n                    },\n                    \"right\": {\n                        \"type\": \"Literal\",\n                        \"value\": 2,\n                        \"raw\": \"2\"\n                    }\n                },\n                \"right\": {\n                    \"type\": \"Literal\",\n                    \"value\": 3,\n                    \"raw\": \"3\"\n                }\n            }\n        }\n    ],\n    \"sourceType\": \"script\"\n}\n```\n\n`body`表示程序体，而程序体中包含了一则表达式`ExpressionStatement`, 表达式体里包含了操作符 `*`,以及左右两边表达式，其中右边是数字`3`,而左边表达式还包含一层表达式，里面是一个`+` 操作符，以及左右两边分别为`1`和`2`的数字。\n\n![javascript语法树](/image/blog/whatisAST/javascript语法树.png)\n\n\n如果还没有看懂，你可以到这里看一下这段代码所生成的语法树：[AST for (1 + 2)* 3;](http://esprima.org/demo/parse.html?code=%2F%2F%20Life%2C%20Universe%2C%20and%20Everything%0A(1%20%2B%202)*%203%0A)\n\n\n## 我们可以利用语法树做些什么？\n看到这里你可能会问，知道语法是又有什么用呢？跟我日常编写代码貌似半毛钱关系都没有。其实语法树还是很有用的，想一下如果想做「语法高亮」、「关键字匹配」、「作用域判断」、以及「代码压缩」等等，都是最好把代码解构成语法树之后再去各种操作，当然仅仅解构还不够，还需要提供各种函数去遍历与修改语法树。\n\n另一方面，去研究、去探讨计算机真实的世界不是一个很精彩很刺激的过程么？\n\n\n\n","source":"_posts/何为语法树.md","raw":"---\ntitle: 何为语法树\ncategory: 搬砖码农\ndate: 2016-3-15 00:04:49\ntags:\n- 语法树\n---\n\n## 什么是语法树？\n\n> 你是否曾想过，这个世界存在这么多语言的意义。\n\n假如现在你面前有一个物体，它是一个不规则的圆体，整个身体通红，头部还有一根细长稍微弯曲偏右呈棕色的圆柱体。    \n在中文我们称之为「苹果」，    \n在英文我们称之为「Apple」，    \n在日文中我们称之为「アップル」，    \n在法语中我们称之为「pomme」，    \n在德语中我们称之为「Apfel」，    \n无论用不同的语言，针对这个物体在文字上、发音上都完全不一样，但这个物体确确实实的存在这个时空上，颜色、气味、形状都不曾因为语言而改变过。    \n\n> 无论这个世界存在多少语言，它们所描述的真理都不曾改变过。\n\n或者说，真理就存在那里，可以用不同的语言的不同表达方式描述出来。那么计算机的世界，这么多编程的语言，C、C++、Java、C#、JavaScript、Python、Go、Ruby等等等，它们共同所描述的真理是什么？\n\n我们知道人类语言上，无论什么语种，都会有「主语」「动词」「宾语」「标点符号」来描述一个现实世界所发生的事件。\n而在计算机编程语言上，无论什么语种，都会有「类型」「运算符」「流程语句」「函数」「对象」等概念来表达计算机中存在内存中的0和1，以及背后运算与逻辑。\n\n> 语法树，计算机描述世界真理的树状结构。\n\n不同的语言，都会配之不同的语法分析器，而语法分析器是把源代码作为字符串读入、解析，并建立语法树的程序。语法的设计和语法分析器的实现是决定语言外在表现的重要因素。    \n什么是语法树？摘自Wiki一段：\n\n> 在计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。\n\n## 一则简单的例子\n如果我们需要让计算机帮忙算一下 「1加2再乘以3」 的结果，该怎么表达呢？    \n现在我们大多数的现代编程语言，都是使用「中缀表达式」的方式来编写运算，比如JavaScript：\n\n```\n(1 + 2) * 3\n```\n\n而FORTH语言则使用「后缀表达式」，这基本上与日语中的语序是一致的：\n\n```\n1 2 + 3 *\n```\n\nLISP语言使用的「前缀表达式」：\n\n```\n( * (+ 1 2) 3)\n```\n\n我们再看一下这三种表达式的语法树：\n\n![表达式语法树比较](/image/blog/whatisAST/表达式语法树比较.png)\n\n可以看出，对于这三种简单的语言，它们只是在这个语法树上按不同的规则遍历而已。三者的代码看起来差别很大，但实际上所用的树结构是相同的。\n\n## 先来看看Python的语法树\n通过Python语言自带的库文件ast，我们可以查看特定的代码被转换成怎样的语法树。\n\n```\n>>> import ast\n>>> ast.dump(ast.parse(\"(1 + 2) * 3\"))\n'Module(\n\tbody=[\n\t\tExpr(\n\t\t\tvalue=BinOp(\n\t\t\t\tleft=BinOp(\n\t\t\t\t\tleft=Num(n=1), \n\t\t\t\t\top=Add(), \n\t\t\t\t\tright=Num(n=2)\n\t\t\t\t), \n\t\t\t\top=Mult(), \n\t\t\t\tright=Num(n=3)\n\t\t\t)\n\t\t)\n\t]\n)'\n```\n\n\n`BinOp op = Mult()`表示乘法运算，与`*`相对应；    \n`BinOp op = Add()`表示加法运算，与`+`相对应；    \n`Num n = 1`既为数值1。\n\n![Python语法树](/image/blog/whatisAST/Python语法树.png)\n\n\n## 再窥视一下JavaScript的语法树\n> 在语法复杂的语言中，语法树是包含很多细节的语法结果表达式，我们需要靠语法树把这种形式以更简洁的形式表达出来。\n\nJavascript 有不少工具可以把代码构造出清晰的语法树，比如 [esprima](http://esprima.org/ )、[v8](https://code.google.com/p/v8/source/browse/branches/bleeding_edge/src/ast.h)、[SpiderMonkey](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API)、[UglifyJS](http://lisperator.net/uglifyjs/)、[AST explorer](http://astexplorer.net/)等。\n\n这里，我使用「esprima」来探讨一下JavaScript运算`(1 + 2) * 3`的语法树。\n\njavascript code: \n\n```\n(1 + 2)* 3;\n```\n\nast for json:\n\n```\n{\n    \"type\": \"Program\",\n    \"body\": [\n        {\n            \"type\": \"ExpressionStatement\",\n            \"expression\": {\n                \"type\": \"BinaryExpression\",\n                \"operator\": \"*\",\n                \"left\": {\n                    \"type\": \"BinaryExpression\",\n                    \"operator\": \"+\",\n                    \"left\": {\n                        \"type\": \"Literal\",\n                        \"value\": 1,\n                        \"raw\": \"1\"\n                    },\n                    \"right\": {\n                        \"type\": \"Literal\",\n                        \"value\": 2,\n                        \"raw\": \"2\"\n                    }\n                },\n                \"right\": {\n                    \"type\": \"Literal\",\n                    \"value\": 3,\n                    \"raw\": \"3\"\n                }\n            }\n        }\n    ],\n    \"sourceType\": \"script\"\n}\n```\n\n`body`表示程序体，而程序体中包含了一则表达式`ExpressionStatement`, 表达式体里包含了操作符 `*`,以及左右两边表达式，其中右边是数字`3`,而左边表达式还包含一层表达式，里面是一个`+` 操作符，以及左右两边分别为`1`和`2`的数字。\n\n![javascript语法树](/image/blog/whatisAST/javascript语法树.png)\n\n\n如果还没有看懂，你可以到这里看一下这段代码所生成的语法树：[AST for (1 + 2)* 3;](http://esprima.org/demo/parse.html?code=%2F%2F%20Life%2C%20Universe%2C%20and%20Everything%0A(1%20%2B%202)*%203%0A)\n\n\n## 我们可以利用语法树做些什么？\n看到这里你可能会问，知道语法是又有什么用呢？跟我日常编写代码貌似半毛钱关系都没有。其实语法树还是很有用的，想一下如果想做「语法高亮」、「关键字匹配」、「作用域判断」、以及「代码压缩」等等，都是最好把代码解构成语法树之后再去各种操作，当然仅仅解构还不够，还需要提供各种函数去遍历与修改语法树。\n\n另一方面，去研究、去探讨计算机真实的世界不是一个很精彩很刺激的过程么？\n\n\n\n","slug":"何为语法树","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8rv002ixwrlzgdwwine","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"什么是语法树？\"><a href=\"#什么是语法树？\" class=\"headerlink\" title=\"什么是语法树？\"></a>什么是语法树？</h2><blockquote>\n<p>你是否曾想过，这个世界存在这么多语言的意义。</p>\n</blockquote>\n<p>假如现在你面前有一个物体，它是一个不规则的圆体，整个身体通红，头部还有一根细长稍微弯曲偏右呈棕色的圆柱体。<br>在中文我们称之为「苹果」，<br>在英文我们称之为「Apple」，<br>在日文中我们称之为「アップル」，<br>在法语中我们称之为「pomme」，<br>在德语中我们称之为「Apfel」，<br>无论用不同的语言，针对这个物体在文字上、发音上都完全不一样，但这个物体确确实实的存在这个时空上，颜色、气味、形状都不曾因为语言而改变过。    </p>\n<blockquote>\n<p>无论这个世界存在多少语言，它们所描述的真理都不曾改变过。</p>\n</blockquote>\n<p>或者说，真理就存在那里，可以用不同的语言的不同表达方式描述出来。那么计算机的世界，这么多编程的语言，C、C++、Java、C#、JavaScript、Python、Go、Ruby等等等，它们共同所描述的真理是什么？</p>\n<p>我们知道人类语言上，无论什么语种，都会有「主语」「动词」「宾语」「标点符号」来描述一个现实世界所发生的事件。<br>而在计算机编程语言上，无论什么语种，都会有「类型」「运算符」「流程语句」「函数」「对象」等概念来表达计算机中存在内存中的0和1，以及背后运算与逻辑。</p>\n<blockquote>\n<p>语法树，计算机描述世界真理的树状结构。</p>\n</blockquote>\n<p>不同的语言，都会配之不同的语法分析器，而语法分析器是把源代码作为字符串读入、解析，并建立语法树的程序。语法的设计和语法分析器的实现是决定语言外在表现的重要因素。<br>什么是语法树？摘自Wiki一段：</p>\n<blockquote>\n<p>在计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p>\n</blockquote>\n<h2 id=\"一则简单的例子\"><a href=\"#一则简单的例子\" class=\"headerlink\" title=\"一则简单的例子\"></a>一则简单的例子</h2><p>如果我们需要让计算机帮忙算一下 「1加2再乘以3」 的结果，该怎么表达呢？<br>现在我们大多数的现代编程语言，都是使用「中缀表达式」的方式来编写运算，比如JavaScript：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1 + 2) * 3</span><br></pre></td></tr></table></figure>\n<p>而FORTH语言则使用「后缀表达式」，这基本上与日语中的语序是一致的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 + 3 *</span><br></pre></td></tr></table></figure>\n<p>LISP语言使用的「前缀表达式」：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">( * (+ 1 2) 3)</span><br></pre></td></tr></table></figure>\n<p>我们再看一下这三种表达式的语法树：</p>\n<p><img src=\"/image/blog/whatisAST/表达式语法树比较.png\" alt=\"表达式语法树比较\"></p>\n<p>可以看出，对于这三种简单的语言，它们只是在这个语法树上按不同的规则遍历而已。三者的代码看起来差别很大，但实际上所用的树结构是相同的。</p>\n<h2 id=\"先来看看Python的语法树\"><a href=\"#先来看看Python的语法树\" class=\"headerlink\" title=\"先来看看Python的语法树\"></a>先来看看Python的语法树</h2><p>通过Python语言自带的库文件ast，我们可以查看特定的代码被转换成怎样的语法树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; import ast</span><br><span class=\"line\">&gt;&gt;&gt; ast.dump(ast.parse(&quot;(1 + 2) * 3&quot;))</span><br><span class=\"line\">&apos;Module(</span><br><span class=\"line\">\tbody=[</span><br><span class=\"line\">\t\tExpr(</span><br><span class=\"line\">\t\t\tvalue=BinOp(</span><br><span class=\"line\">\t\t\t\tleft=BinOp(</span><br><span class=\"line\">\t\t\t\t\tleft=Num(n=1), </span><br><span class=\"line\">\t\t\t\t\top=Add(), </span><br><span class=\"line\">\t\t\t\t\tright=Num(n=2)</span><br><span class=\"line\">\t\t\t\t), </span><br><span class=\"line\">\t\t\t\top=Mult(), </span><br><span class=\"line\">\t\t\t\tright=Num(n=3)</span><br><span class=\"line\">\t\t\t)</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t]</span><br><span class=\"line\">)&apos;</span><br></pre></td></tr></table></figure>\n<p><code>BinOp op = Mult()</code>表示乘法运算，与<code>*</code>相对应；<br><code>BinOp op = Add()</code>表示加法运算，与<code>+</code>相对应；<br><code>Num n = 1</code>既为数值1。</p>\n<p><img src=\"/image/blog/whatisAST/Python语法树.png\" alt=\"Python语法树\"></p>\n<h2 id=\"再窥视一下JavaScript的语法树\"><a href=\"#再窥视一下JavaScript的语法树\" class=\"headerlink\" title=\"再窥视一下JavaScript的语法树\"></a>再窥视一下JavaScript的语法树</h2><blockquote>\n<p>在语法复杂的语言中，语法树是包含很多细节的语法结果表达式，我们需要靠语法树把这种形式以更简洁的形式表达出来。</p>\n</blockquote>\n<p>Javascript 有不少工具可以把代码构造出清晰的语法树，比如 <a href=\"http://esprima.org/\" target=\"_blank\" rel=\"external\">esprima</a>、<a href=\"https://code.google.com/p/v8/source/browse/branches/bleeding_edge/src/ast.h\" target=\"_blank\" rel=\"external\">v8</a>、<a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API\" target=\"_blank\" rel=\"external\">SpiderMonkey</a>、<a href=\"http://lisperator.net/uglifyjs/\" target=\"_blank\" rel=\"external\">UglifyJS</a>、<a href=\"http://astexplorer.net/\" target=\"_blank\" rel=\"external\">AST explorer</a>等。</p>\n<p>这里，我使用「esprima」来探讨一下JavaScript运算<code>(1 + 2) * 3</code>的语法树。</p>\n<p>javascript code: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1 + 2)* 3;</span><br></pre></td></tr></table></figure>\n<p>ast for json:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class=\"line\">    &quot;body&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;type&quot;: &quot;ExpressionStatement&quot;,</span><br><span class=\"line\">            &quot;expression&quot;: &#123;</span><br><span class=\"line\">                &quot;type&quot;: &quot;BinaryExpression&quot;,</span><br><span class=\"line\">                &quot;operator&quot;: &quot;*&quot;,</span><br><span class=\"line\">                &quot;left&quot;: &#123;</span><br><span class=\"line\">                    &quot;type&quot;: &quot;BinaryExpression&quot;,</span><br><span class=\"line\">                    &quot;operator&quot;: &quot;+&quot;,</span><br><span class=\"line\">                    &quot;left&quot;: &#123;</span><br><span class=\"line\">                        &quot;type&quot;: &quot;Literal&quot;,</span><br><span class=\"line\">                        &quot;value&quot;: 1,</span><br><span class=\"line\">                        &quot;raw&quot;: &quot;1&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;right&quot;: &#123;</span><br><span class=\"line\">                        &quot;type&quot;: &quot;Literal&quot;,</span><br><span class=\"line\">                        &quot;value&quot;: 2,</span><br><span class=\"line\">                        &quot;raw&quot;: &quot;2&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &quot;right&quot;: &#123;</span><br><span class=\"line\">                    &quot;type&quot;: &quot;Literal&quot;,</span><br><span class=\"line\">                    &quot;value&quot;: 3,</span><br><span class=\"line\">                    &quot;raw&quot;: &quot;3&quot;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;sourceType&quot;: &quot;script&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>body</code>表示程序体，而程序体中包含了一则表达式<code>ExpressionStatement</code>, 表达式体里包含了操作符 <code>*</code>,以及左右两边表达式，其中右边是数字<code>3</code>,而左边表达式还包含一层表达式，里面是一个<code>+</code> 操作符，以及左右两边分别为<code>1</code>和<code>2</code>的数字。</p>\n<p><img src=\"/image/blog/whatisAST/javascript语法树.png\" alt=\"javascript语法树\"></p>\n<p>如果还没有看懂，你可以到这里看一下这段代码所生成的语法树：<a href=\"http://esprima.org/demo/parse.html?code=%2F%2F%20Life%2C%20Universe%2C%20and%20Everything%0A(1%20%2B%202\" target=\"_blank\" rel=\"external\">AST for (1 + 2)* 3;</a>*%203%0A)</p>\n<h2 id=\"我们可以利用语法树做些什么？\"><a href=\"#我们可以利用语法树做些什么？\" class=\"headerlink\" title=\"我们可以利用语法树做些什么？\"></a>我们可以利用语法树做些什么？</h2><p>看到这里你可能会问，知道语法是又有什么用呢？跟我日常编写代码貌似半毛钱关系都没有。其实语法树还是很有用的，想一下如果想做「语法高亮」、「关键字匹配」、「作用域判断」、以及「代码压缩」等等，都是最好把代码解构成语法树之后再去各种操作，当然仅仅解构还不够，还需要提供各种函数去遍历与修改语法树。</p>\n<p>另一方面，去研究、去探讨计算机真实的世界不是一个很精彩很刺激的过程么？</p>\n","excerpt":"","more":"<h2 id=\"什么是语法树？\"><a href=\"#什么是语法树？\" class=\"headerlink\" title=\"什么是语法树？\"></a>什么是语法树？</h2><blockquote>\n<p>你是否曾想过，这个世界存在这么多语言的意义。</p>\n</blockquote>\n<p>假如现在你面前有一个物体，它是一个不规则的圆体，整个身体通红，头部还有一根细长稍微弯曲偏右呈棕色的圆柱体。<br>在中文我们称之为「苹果」，<br>在英文我们称之为「Apple」，<br>在日文中我们称之为「アップル」，<br>在法语中我们称之为「pomme」，<br>在德语中我们称之为「Apfel」，<br>无论用不同的语言，针对这个物体在文字上、发音上都完全不一样，但这个物体确确实实的存在这个时空上，颜色、气味、形状都不曾因为语言而改变过。    </p>\n<blockquote>\n<p>无论这个世界存在多少语言，它们所描述的真理都不曾改变过。</p>\n</blockquote>\n<p>或者说，真理就存在那里，可以用不同的语言的不同表达方式描述出来。那么计算机的世界，这么多编程的语言，C、C++、Java、C#、JavaScript、Python、Go、Ruby等等等，它们共同所描述的真理是什么？</p>\n<p>我们知道人类语言上，无论什么语种，都会有「主语」「动词」「宾语」「标点符号」来描述一个现实世界所发生的事件。<br>而在计算机编程语言上，无论什么语种，都会有「类型」「运算符」「流程语句」「函数」「对象」等概念来表达计算机中存在内存中的0和1，以及背后运算与逻辑。</p>\n<blockquote>\n<p>语法树，计算机描述世界真理的树状结构。</p>\n</blockquote>\n<p>不同的语言，都会配之不同的语法分析器，而语法分析器是把源代码作为字符串读入、解析，并建立语法树的程序。语法的设计和语法分析器的实现是决定语言外在表现的重要因素。<br>什么是语法树？摘自Wiki一段：</p>\n<blockquote>\n<p>在计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p>\n</blockquote>\n<h2 id=\"一则简单的例子\"><a href=\"#一则简单的例子\" class=\"headerlink\" title=\"一则简单的例子\"></a>一则简单的例子</h2><p>如果我们需要让计算机帮忙算一下 「1加2再乘以3」 的结果，该怎么表达呢？<br>现在我们大多数的现代编程语言，都是使用「中缀表达式」的方式来编写运算，比如JavaScript：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1 + 2) * 3</span><br></pre></td></tr></table></figure>\n<p>而FORTH语言则使用「后缀表达式」，这基本上与日语中的语序是一致的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 + 3 *</span><br></pre></td></tr></table></figure>\n<p>LISP语言使用的「前缀表达式」：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">( * (+ 1 2) 3)</span><br></pre></td></tr></table></figure>\n<p>我们再看一下这三种表达式的语法树：</p>\n<p><img src=\"/image/blog/whatisAST/表达式语法树比较.png\" alt=\"表达式语法树比较\"></p>\n<p>可以看出，对于这三种简单的语言，它们只是在这个语法树上按不同的规则遍历而已。三者的代码看起来差别很大，但实际上所用的树结构是相同的。</p>\n<h2 id=\"先来看看Python的语法树\"><a href=\"#先来看看Python的语法树\" class=\"headerlink\" title=\"先来看看Python的语法树\"></a>先来看看Python的语法树</h2><p>通过Python语言自带的库文件ast，我们可以查看特定的代码被转换成怎样的语法树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; import ast</span><br><span class=\"line\">&gt;&gt;&gt; ast.dump(ast.parse(&quot;(1 + 2) * 3&quot;))</span><br><span class=\"line\">&apos;Module(</span><br><span class=\"line\">\tbody=[</span><br><span class=\"line\">\t\tExpr(</span><br><span class=\"line\">\t\t\tvalue=BinOp(</span><br><span class=\"line\">\t\t\t\tleft=BinOp(</span><br><span class=\"line\">\t\t\t\t\tleft=Num(n=1), </span><br><span class=\"line\">\t\t\t\t\top=Add(), </span><br><span class=\"line\">\t\t\t\t\tright=Num(n=2)</span><br><span class=\"line\">\t\t\t\t), </span><br><span class=\"line\">\t\t\t\top=Mult(), </span><br><span class=\"line\">\t\t\t\tright=Num(n=3)</span><br><span class=\"line\">\t\t\t)</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t]</span><br><span class=\"line\">)&apos;</span><br></pre></td></tr></table></figure>\n<p><code>BinOp op = Mult()</code>表示乘法运算，与<code>*</code>相对应；<br><code>BinOp op = Add()</code>表示加法运算，与<code>+</code>相对应；<br><code>Num n = 1</code>既为数值1。</p>\n<p><img src=\"/image/blog/whatisAST/Python语法树.png\" alt=\"Python语法树\"></p>\n<h2 id=\"再窥视一下JavaScript的语法树\"><a href=\"#再窥视一下JavaScript的语法树\" class=\"headerlink\" title=\"再窥视一下JavaScript的语法树\"></a>再窥视一下JavaScript的语法树</h2><blockquote>\n<p>在语法复杂的语言中，语法树是包含很多细节的语法结果表达式，我们需要靠语法树把这种形式以更简洁的形式表达出来。</p>\n</blockquote>\n<p>Javascript 有不少工具可以把代码构造出清晰的语法树，比如 <a href=\"http://esprima.org/\">esprima</a>、<a href=\"https://code.google.com/p/v8/source/browse/branches/bleeding_edge/src/ast.h\">v8</a>、<a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API\">SpiderMonkey</a>、<a href=\"http://lisperator.net/uglifyjs/\">UglifyJS</a>、<a href=\"http://astexplorer.net/\">AST explorer</a>等。</p>\n<p>这里，我使用「esprima」来探讨一下JavaScript运算<code>(1 + 2) * 3</code>的语法树。</p>\n<p>javascript code: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1 + 2)* 3;</span><br></pre></td></tr></table></figure>\n<p>ast for json:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class=\"line\">    &quot;body&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;type&quot;: &quot;ExpressionStatement&quot;,</span><br><span class=\"line\">            &quot;expression&quot;: &#123;</span><br><span class=\"line\">                &quot;type&quot;: &quot;BinaryExpression&quot;,</span><br><span class=\"line\">                &quot;operator&quot;: &quot;*&quot;,</span><br><span class=\"line\">                &quot;left&quot;: &#123;</span><br><span class=\"line\">                    &quot;type&quot;: &quot;BinaryExpression&quot;,</span><br><span class=\"line\">                    &quot;operator&quot;: &quot;+&quot;,</span><br><span class=\"line\">                    &quot;left&quot;: &#123;</span><br><span class=\"line\">                        &quot;type&quot;: &quot;Literal&quot;,</span><br><span class=\"line\">                        &quot;value&quot;: 1,</span><br><span class=\"line\">                        &quot;raw&quot;: &quot;1&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;right&quot;: &#123;</span><br><span class=\"line\">                        &quot;type&quot;: &quot;Literal&quot;,</span><br><span class=\"line\">                        &quot;value&quot;: 2,</span><br><span class=\"line\">                        &quot;raw&quot;: &quot;2&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &quot;right&quot;: &#123;</span><br><span class=\"line\">                    &quot;type&quot;: &quot;Literal&quot;,</span><br><span class=\"line\">                    &quot;value&quot;: 3,</span><br><span class=\"line\">                    &quot;raw&quot;: &quot;3&quot;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;sourceType&quot;: &quot;script&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>body</code>表示程序体，而程序体中包含了一则表达式<code>ExpressionStatement</code>, 表达式体里包含了操作符 <code>*</code>,以及左右两边表达式，其中右边是数字<code>3</code>,而左边表达式还包含一层表达式，里面是一个<code>+</code> 操作符，以及左右两边分别为<code>1</code>和<code>2</code>的数字。</p>\n<p><img src=\"/image/blog/whatisAST/javascript语法树.png\" alt=\"javascript语法树\"></p>\n<p>如果还没有看懂，你可以到这里看一下这段代码所生成的语法树：<a href=\"http://esprima.org/demo/parse.html?code=%2F%2F%20Life%2C%20Universe%2C%20and%20Everything%0A(1%20%2B%202\">AST for (1 + 2)* 3;</a>*%203%0A)</p>\n<h2 id=\"我们可以利用语法树做些什么？\"><a href=\"#我们可以利用语法树做些什么？\" class=\"headerlink\" title=\"我们可以利用语法树做些什么？\"></a>我们可以利用语法树做些什么？</h2><p>看到这里你可能会问，知道语法是又有什么用呢？跟我日常编写代码貌似半毛钱关系都没有。其实语法树还是很有用的，想一下如果想做「语法高亮」、「关键字匹配」、「作用域判断」、以及「代码压缩」等等，都是最好把代码解构成语法树之后再去各种操作，当然仅仅解构还不够，还需要提供各种函数去遍历与修改语法树。</p>\n<p>另一方面，去研究、去探讨计算机真实的世界不是一个很精彩很刺激的过程么？</p>\n"},{"title":"何为技术人的核心竞争力","date":"2016-08-30T15:05:25.000Z","_content":"\n在寂静的夜晚上，独自一人在书房中，望着窗外，一片灯火阑珊，一条车水马龙。\n不禁让我抬头四十五度，望着那轮朦胧泛黄的新月，又开始思考起自己的人生。\n\n最初接触编程的是高中碰到的谭浩强的那本《C程序设计》，是不是一本好书，我不想做评价。\n可能是因为我天资愚钝，没能通过自学看懂这本书。\n如果说从大学开始真正拥有编程技能，到现在，已经过去五年光阴，毕业也已经有一年有余。\n虽然自小对计算机(或者说是电脑)感兴趣，但是也因为自身贪玩，兴趣泛滥，好奇心爆棚的个人属性，以致并没有把大部分时间投入这个编程兴趣中。\n要说我编程的功底，也就只有两年的功力。\n\n在一件事情上投入的越多，就会让我更加思考自己正在做的，正在走的方向。\n在高速发展，日新月异的技术圈子中，到底哪些是不变的，或可沉淀的东西。\n渐渐的会想到这样的一个问题：\n**技术人的核心竞争力到底是什么？**\n\n今天受**刘未鹏**先生在书中《暗时间》的介绍，阅读了**孟岩**老师的「[技术路线的选择重要但不具有决定性](http://blog.csdn.net/myan/article/details/3247071)」，这篇文章正好给最近被这个问题困扰的我拨开了一些迷雾。\n这是一篇2008年发表的旧文，文中的观点给了我很多启发，但我也不会有相见恨晚的感觉。就算很早遇到这篇文章，也不会有经历过的事情以及思考过的问题作为基础，故也不能理解体会其中的意思。现在时机正好。\n\n文中把技术人大致的分了四类：\n\n1. 把命运寄托在**事业**上的人\n2. 把命运寄托在**组织**上的人\n3. 把命运寄托在**技术**上的人\n4. 仍然处于出卖劳动力的人\n\n# 做技术的几类人\n\n**第一类是把自己的命运寄托在一项事业上。**\n他们会想着改变一些东西，而技术只是作为其中的手段，他们有能力通过技术实现自己的想法和事业。事业并不是指的创业做老板，而是一件他们认可的事情。比如促进人们交流和言论自由，带给大家更多娱乐，提升大众身心健康水平，增强国家国防实力，或者提升某个行业的信息化水平，能够以技术为手段，在这个事情上做出成绩。他们往往可以终其一生投入到自己的事业中去，在短短的人生中实现价值。到两鬓斑白时，能够回首往事而悠然自得。\n\n**第二类是把自己的命运寄托在组织和团队上**\n他们技术水平出色，综合素质突出，勇于变化，以团队的目标为目标，依据团队的需求而转型或者坚持，跟团队一起干出一番成绩。这些人往往拥有高薪厚禄，以及舒适生活。\n但是中年以后会经常自问到底做了什么自己想做的事情，为自己过于风平浪静的人生感到惆怅。\n\n**第三类是把命运寄托在技术上。**\n他们有能力成为技术的专家，希望把技能当做商品出售，从而谋求富足人生。不想把自己命运跟企业和组织绑定在一起，也不愿意做什么改变，只是满足于技术高手的层面，寄希望于其技术专长能够长期值钱。\n\n**第四种就是处于出卖劳动力的阶段**\n他们往往疲于做业务，单纯积极完成上级或产经下达的任务，鲜有思考需求合理性，或者在大局上关注项目及其进度。他们往往加班成自然，表面上形成勤奋工作的现象，最终却只是为了业绩好些，年终奖多些。\n\n第一类，是做技术的最高层次，终其一生投入到一项事业中，为人类和社会创造价值，这并不是一般人能够做到。而第二类总的来说，层次还是比较高的。在自己的专业领域中颇有建树，并且利用技术给团队带来生产力提高和经济的效益，是真正为团队创造价值的人。而第三类人，却是最危险的。技术的发展与变迁是必然发生的事情，年轻的时候还有能力追逐新技术，但当老了追不动了，很容易就被淘汰了。**被淘汰只是时间问题。如果你认为某个软件技术的兴起或者衰落对你个人的职业生涯构成了决定性的影响，那么你可能正走在错误的路线上，应当尽快改弦更张。**\n\n# 核心竞争力\n\n关于核心竞争力，孟岩先生有这样一段话：\n\n那么核心竞争力是什么？我观察圈子里很多成功和不成功的技术人，提出一个观点，那就是个人的核心竞争力是他**独特的个性知识经验组合**。这个行业里拥挤着上百万聪明人，彼此之间真正的不同在哪里？不在于你学的是什么技术，学得多深，IQ多少，而在于你身上有别人没有的独特的个性、背景、知识和经验的组合。如果这种组合，**1，绝无仅有；2，在实践中有价值，3，具有可持续发展性**，那你就具备核心竞争力。因此，当设计自己的发展路线时，应当最大限度地加强和发挥自己独特的组合，而不是寻求单项的超越。而构建自己独特组合的方式，主要是通过实践，其次是要有意识地构造。关于这个观点，话题太大，我不打算赘述。\n\n个人核心竞争力，并不是对某技术、框架、平台的熟烂于心，也不是什么样的开发思想，更加不是所谓的个人智商问题。而是**独特的个性、知识、经验之间的组合**。\n\n# 不可替代性\n\n孟岩先生在文中并没有对这个问题展开来描述，那么到底什么样的知识技能组合符合下面几种条件的：\n**1. 绝无仅有**\n**2. 在实践中有价值**\n**3. 具有可持续发展性**\n\n**刘未鹏**先生在书中《暗时间》给出了他对这个问题的补充：\n\n我相信以下的知识技能组合是具有相当程度的不可替代性的：\n**1. 专业领域技能。**\n成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。\n**2. 跨领域的技能。**\n解决问题的能力，创新思维，判断与决策能力，批判性思维，表达沟通能力，等等。\n**3. 学习能力。**\n严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是**持续学习**和**思考知识**。\n**4. 性格要素。**\n严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的），等等。\n\n除了**刘未鹏**先生上面的四点，我需要补充的还有一点：\n**5. 学历与背景**\n虽然在技术圈子不太看重学历，学历并不是能代表一切，但「受教育程度高的人能力也高」是一个高概率事件，这也是各大公司招聘都会以学历来筛选简历的原因之一。而背景就更加重要了，一个人经历了什么，做过什么，都会对个人的价值观、世界观等造成一定量的影响。一个优秀的学历和丰富的背景，并不是别人能轻而易举复制的。\n\n# 最后\n\n我一直很庆幸能接触到计算机领域，然后学会了编程，对其燃起兴趣，并且刚好这门兴趣能成为我的职业，在我享受其带来的乐趣之余，可以提供给我一些物质上的条件。\n**我喜欢的东西变成了我的工作乃至事业**，这比起很多人，已经很幸福了。\n这种幸福来自于：\n发现新的好玩的东西所带来的新鲜感，\n写博客分享知识所带来的认同感，\n做的产品被很多人使用并且创造价值的自豪感，\n还有是对知识的不满足感。\n\n而思考与探索以后是否可以继续让兴趣支持事业成为可能，也是我这个多虑症患者一直在思考的事情。","source":"_posts/何为技术人的核心竞争力.md","raw":"---\ntitle: 何为技术人的核心竞争力\ncategory: 三省吾身\ndate: 2016-08-30 23:05:25\ntags:\n---\n\n在寂静的夜晚上，独自一人在书房中，望着窗外，一片灯火阑珊，一条车水马龙。\n不禁让我抬头四十五度，望着那轮朦胧泛黄的新月，又开始思考起自己的人生。\n\n最初接触编程的是高中碰到的谭浩强的那本《C程序设计》，是不是一本好书，我不想做评价。\n可能是因为我天资愚钝，没能通过自学看懂这本书。\n如果说从大学开始真正拥有编程技能，到现在，已经过去五年光阴，毕业也已经有一年有余。\n虽然自小对计算机(或者说是电脑)感兴趣，但是也因为自身贪玩，兴趣泛滥，好奇心爆棚的个人属性，以致并没有把大部分时间投入这个编程兴趣中。\n要说我编程的功底，也就只有两年的功力。\n\n在一件事情上投入的越多，就会让我更加思考自己正在做的，正在走的方向。\n在高速发展，日新月异的技术圈子中，到底哪些是不变的，或可沉淀的东西。\n渐渐的会想到这样的一个问题：\n**技术人的核心竞争力到底是什么？**\n\n今天受**刘未鹏**先生在书中《暗时间》的介绍，阅读了**孟岩**老师的「[技术路线的选择重要但不具有决定性](http://blog.csdn.net/myan/article/details/3247071)」，这篇文章正好给最近被这个问题困扰的我拨开了一些迷雾。\n这是一篇2008年发表的旧文，文中的观点给了我很多启发，但我也不会有相见恨晚的感觉。就算很早遇到这篇文章，也不会有经历过的事情以及思考过的问题作为基础，故也不能理解体会其中的意思。现在时机正好。\n\n文中把技术人大致的分了四类：\n\n1. 把命运寄托在**事业**上的人\n2. 把命运寄托在**组织**上的人\n3. 把命运寄托在**技术**上的人\n4. 仍然处于出卖劳动力的人\n\n# 做技术的几类人\n\n**第一类是把自己的命运寄托在一项事业上。**\n他们会想着改变一些东西，而技术只是作为其中的手段，他们有能力通过技术实现自己的想法和事业。事业并不是指的创业做老板，而是一件他们认可的事情。比如促进人们交流和言论自由，带给大家更多娱乐，提升大众身心健康水平，增强国家国防实力，或者提升某个行业的信息化水平，能够以技术为手段，在这个事情上做出成绩。他们往往可以终其一生投入到自己的事业中去，在短短的人生中实现价值。到两鬓斑白时，能够回首往事而悠然自得。\n\n**第二类是把自己的命运寄托在组织和团队上**\n他们技术水平出色，综合素质突出，勇于变化，以团队的目标为目标，依据团队的需求而转型或者坚持，跟团队一起干出一番成绩。这些人往往拥有高薪厚禄，以及舒适生活。\n但是中年以后会经常自问到底做了什么自己想做的事情，为自己过于风平浪静的人生感到惆怅。\n\n**第三类是把命运寄托在技术上。**\n他们有能力成为技术的专家，希望把技能当做商品出售，从而谋求富足人生。不想把自己命运跟企业和组织绑定在一起，也不愿意做什么改变，只是满足于技术高手的层面，寄希望于其技术专长能够长期值钱。\n\n**第四种就是处于出卖劳动力的阶段**\n他们往往疲于做业务，单纯积极完成上级或产经下达的任务，鲜有思考需求合理性，或者在大局上关注项目及其进度。他们往往加班成自然，表面上形成勤奋工作的现象，最终却只是为了业绩好些，年终奖多些。\n\n第一类，是做技术的最高层次，终其一生投入到一项事业中，为人类和社会创造价值，这并不是一般人能够做到。而第二类总的来说，层次还是比较高的。在自己的专业领域中颇有建树，并且利用技术给团队带来生产力提高和经济的效益，是真正为团队创造价值的人。而第三类人，却是最危险的。技术的发展与变迁是必然发生的事情，年轻的时候还有能力追逐新技术，但当老了追不动了，很容易就被淘汰了。**被淘汰只是时间问题。如果你认为某个软件技术的兴起或者衰落对你个人的职业生涯构成了决定性的影响，那么你可能正走在错误的路线上，应当尽快改弦更张。**\n\n# 核心竞争力\n\n关于核心竞争力，孟岩先生有这样一段话：\n\n那么核心竞争力是什么？我观察圈子里很多成功和不成功的技术人，提出一个观点，那就是个人的核心竞争力是他**独特的个性知识经验组合**。这个行业里拥挤着上百万聪明人，彼此之间真正的不同在哪里？不在于你学的是什么技术，学得多深，IQ多少，而在于你身上有别人没有的独特的个性、背景、知识和经验的组合。如果这种组合，**1，绝无仅有；2，在实践中有价值，3，具有可持续发展性**，那你就具备核心竞争力。因此，当设计自己的发展路线时，应当最大限度地加强和发挥自己独特的组合，而不是寻求单项的超越。而构建自己独特组合的方式，主要是通过实践，其次是要有意识地构造。关于这个观点，话题太大，我不打算赘述。\n\n个人核心竞争力，并不是对某技术、框架、平台的熟烂于心，也不是什么样的开发思想，更加不是所谓的个人智商问题。而是**独特的个性、知识、经验之间的组合**。\n\n# 不可替代性\n\n孟岩先生在文中并没有对这个问题展开来描述，那么到底什么样的知识技能组合符合下面几种条件的：\n**1. 绝无仅有**\n**2. 在实践中有价值**\n**3. 具有可持续发展性**\n\n**刘未鹏**先生在书中《暗时间》给出了他对这个问题的补充：\n\n我相信以下的知识技能组合是具有相当程度的不可替代性的：\n**1. 专业领域技能。**\n成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。\n**2. 跨领域的技能。**\n解决问题的能力，创新思维，判断与决策能力，批判性思维，表达沟通能力，等等。\n**3. 学习能力。**\n严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是**持续学习**和**思考知识**。\n**4. 性格要素。**\n严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的），等等。\n\n除了**刘未鹏**先生上面的四点，我需要补充的还有一点：\n**5. 学历与背景**\n虽然在技术圈子不太看重学历，学历并不是能代表一切，但「受教育程度高的人能力也高」是一个高概率事件，这也是各大公司招聘都会以学历来筛选简历的原因之一。而背景就更加重要了，一个人经历了什么，做过什么，都会对个人的价值观、世界观等造成一定量的影响。一个优秀的学历和丰富的背景，并不是别人能轻而易举复制的。\n\n# 最后\n\n我一直很庆幸能接触到计算机领域，然后学会了编程，对其燃起兴趣，并且刚好这门兴趣能成为我的职业，在我享受其带来的乐趣之余，可以提供给我一些物质上的条件。\n**我喜欢的东西变成了我的工作乃至事业**，这比起很多人，已经很幸福了。\n这种幸福来自于：\n发现新的好玩的东西所带来的新鲜感，\n写博客分享知识所带来的认同感，\n做的产品被很多人使用并且创造价值的自豪感，\n还有是对知识的不满足感。\n\n而思考与探索以后是否可以继续让兴趣支持事业成为可能，也是我这个多虑症患者一直在思考的事情。","slug":"何为技术人的核心竞争力","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8rx002mxwrls7tr3cr8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在寂静的夜晚上，独自一人在书房中，望着窗外，一片灯火阑珊，一条车水马龙。<br>不禁让我抬头四十五度，望着那轮朦胧泛黄的新月，又开始思考起自己的人生。</p>\n<p>最初接触编程的是高中碰到的谭浩强的那本《C程序设计》，是不是一本好书，我不想做评价。<br>可能是因为我天资愚钝，没能通过自学看懂这本书。<br>如果说从大学开始真正拥有编程技能，到现在，已经过去五年光阴，毕业也已经有一年有余。<br>虽然自小对计算机(或者说是电脑)感兴趣，但是也因为自身贪玩，兴趣泛滥，好奇心爆棚的个人属性，以致并没有把大部分时间投入这个编程兴趣中。<br>要说我编程的功底，也就只有两年的功力。</p>\n<p>在一件事情上投入的越多，就会让我更加思考自己正在做的，正在走的方向。<br>在高速发展，日新月异的技术圈子中，到底哪些是不变的，或可沉淀的东西。<br>渐渐的会想到这样的一个问题：<br><strong>技术人的核心竞争力到底是什么？</strong></p>\n<p>今天受<strong>刘未鹏</strong>先生在书中《暗时间》的介绍，阅读了<strong>孟岩</strong>老师的「<a href=\"http://blog.csdn.net/myan/article/details/3247071\" target=\"_blank\" rel=\"external\">技术路线的选择重要但不具有决定性</a>」，这篇文章正好给最近被这个问题困扰的我拨开了一些迷雾。<br>这是一篇2008年发表的旧文，文中的观点给了我很多启发，但我也不会有相见恨晚的感觉。就算很早遇到这篇文章，也不会有经历过的事情以及思考过的问题作为基础，故也不能理解体会其中的意思。现在时机正好。</p>\n<p>文中把技术人大致的分了四类：</p>\n<ol>\n<li>把命运寄托在<strong>事业</strong>上的人</li>\n<li>把命运寄托在<strong>组织</strong>上的人</li>\n<li>把命运寄托在<strong>技术</strong>上的人</li>\n<li>仍然处于出卖劳动力的人</li>\n</ol>\n<h1 id=\"做技术的几类人\"><a href=\"#做技术的几类人\" class=\"headerlink\" title=\"做技术的几类人\"></a>做技术的几类人</h1><p><strong>第一类是把自己的命运寄托在一项事业上。</strong><br>他们会想着改变一些东西，而技术只是作为其中的手段，他们有能力通过技术实现自己的想法和事业。事业并不是指的创业做老板，而是一件他们认可的事情。比如促进人们交流和言论自由，带给大家更多娱乐，提升大众身心健康水平，增强国家国防实力，或者提升某个行业的信息化水平，能够以技术为手段，在这个事情上做出成绩。他们往往可以终其一生投入到自己的事业中去，在短短的人生中实现价值。到两鬓斑白时，能够回首往事而悠然自得。</p>\n<p><strong>第二类是把自己的命运寄托在组织和团队上</strong><br>他们技术水平出色，综合素质突出，勇于变化，以团队的目标为目标，依据团队的需求而转型或者坚持，跟团队一起干出一番成绩。这些人往往拥有高薪厚禄，以及舒适生活。<br>但是中年以后会经常自问到底做了什么自己想做的事情，为自己过于风平浪静的人生感到惆怅。</p>\n<p><strong>第三类是把命运寄托在技术上。</strong><br>他们有能力成为技术的专家，希望把技能当做商品出售，从而谋求富足人生。不想把自己命运跟企业和组织绑定在一起，也不愿意做什么改变，只是满足于技术高手的层面，寄希望于其技术专长能够长期值钱。</p>\n<p><strong>第四种就是处于出卖劳动力的阶段</strong><br>他们往往疲于做业务，单纯积极完成上级或产经下达的任务，鲜有思考需求合理性，或者在大局上关注项目及其进度。他们往往加班成自然，表面上形成勤奋工作的现象，最终却只是为了业绩好些，年终奖多些。</p>\n<p>第一类，是做技术的最高层次，终其一生投入到一项事业中，为人类和社会创造价值，这并不是一般人能够做到。而第二类总的来说，层次还是比较高的。在自己的专业领域中颇有建树，并且利用技术给团队带来生产力提高和经济的效益，是真正为团队创造价值的人。而第三类人，却是最危险的。技术的发展与变迁是必然发生的事情，年轻的时候还有能力追逐新技术，但当老了追不动了，很容易就被淘汰了。<strong>被淘汰只是时间问题。如果你认为某个软件技术的兴起或者衰落对你个人的职业生涯构成了决定性的影响，那么你可能正走在错误的路线上，应当尽快改弦更张。</strong></p>\n<h1 id=\"核心竞争力\"><a href=\"#核心竞争力\" class=\"headerlink\" title=\"核心竞争力\"></a>核心竞争力</h1><p>关于核心竞争力，孟岩先生有这样一段话：</p>\n<p>那么核心竞争力是什么？我观察圈子里很多成功和不成功的技术人，提出一个观点，那就是个人的核心竞争力是他<strong>独特的个性知识经验组合</strong>。这个行业里拥挤着上百万聪明人，彼此之间真正的不同在哪里？不在于你学的是什么技术，学得多深，IQ多少，而在于你身上有别人没有的独特的个性、背景、知识和经验的组合。如果这种组合，<strong>1，绝无仅有；2，在实践中有价值，3，具有可持续发展性</strong>，那你就具备核心竞争力。因此，当设计自己的发展路线时，应当最大限度地加强和发挥自己独特的组合，而不是寻求单项的超越。而构建自己独特组合的方式，主要是通过实践，其次是要有意识地构造。关于这个观点，话题太大，我不打算赘述。</p>\n<p>个人核心竞争力，并不是对某技术、框架、平台的熟烂于心，也不是什么样的开发思想，更加不是所谓的个人智商问题。而是<strong>独特的个性、知识、经验之间的组合</strong>。</p>\n<h1 id=\"不可替代性\"><a href=\"#不可替代性\" class=\"headerlink\" title=\"不可替代性\"></a>不可替代性</h1><p>孟岩先生在文中并没有对这个问题展开来描述，那么到底什么样的知识技能组合符合下面几种条件的：<br><strong>1. 绝无仅有</strong><br><strong>2. 在实践中有价值</strong><br><strong>3. 具有可持续发展性</strong></p>\n<p><strong>刘未鹏</strong>先生在书中《暗时间》给出了他对这个问题的补充：</p>\n<p>我相信以下的知识技能组合是具有相当程度的不可替代性的：<br><strong>1. 专业领域技能。</strong><br>成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。<br><strong>2. 跨领域的技能。</strong><br>解决问题的能力，创新思维，判断与决策能力，批判性思维，表达沟通能力，等等。<br><strong>3. 学习能力。</strong><br>严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是<strong>持续学习</strong>和<strong>思考知识</strong>。<br><strong>4. 性格要素。</strong><br>严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的），等等。</p>\n<p>除了<strong>刘未鹏</strong>先生上面的四点，我需要补充的还有一点：<br><strong>5. 学历与背景</strong><br>虽然在技术圈子不太看重学历，学历并不是能代表一切，但「受教育程度高的人能力也高」是一个高概率事件，这也是各大公司招聘都会以学历来筛选简历的原因之一。而背景就更加重要了，一个人经历了什么，做过什么，都会对个人的价值观、世界观等造成一定量的影响。一个优秀的学历和丰富的背景，并不是别人能轻而易举复制的。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>我一直很庆幸能接触到计算机领域，然后学会了编程，对其燃起兴趣，并且刚好这门兴趣能成为我的职业，在我享受其带来的乐趣之余，可以提供给我一些物质上的条件。<br><strong>我喜欢的东西变成了我的工作乃至事业</strong>，这比起很多人，已经很幸福了。<br>这种幸福来自于：<br>发现新的好玩的东西所带来的新鲜感，<br>写博客分享知识所带来的认同感，<br>做的产品被很多人使用并且创造价值的自豪感，<br>还有是对知识的不满足感。</p>\n<p>而思考与探索以后是否可以继续让兴趣支持事业成为可能，也是我这个多虑症患者一直在思考的事情。</p>\n","excerpt":"","more":"<p>在寂静的夜晚上，独自一人在书房中，望着窗外，一片灯火阑珊，一条车水马龙。<br>不禁让我抬头四十五度，望着那轮朦胧泛黄的新月，又开始思考起自己的人生。</p>\n<p>最初接触编程的是高中碰到的谭浩强的那本《C程序设计》，是不是一本好书，我不想做评价。<br>可能是因为我天资愚钝，没能通过自学看懂这本书。<br>如果说从大学开始真正拥有编程技能，到现在，已经过去五年光阴，毕业也已经有一年有余。<br>虽然自小对计算机(或者说是电脑)感兴趣，但是也因为自身贪玩，兴趣泛滥，好奇心爆棚的个人属性，以致并没有把大部分时间投入这个编程兴趣中。<br>要说我编程的功底，也就只有两年的功力。</p>\n<p>在一件事情上投入的越多，就会让我更加思考自己正在做的，正在走的方向。<br>在高速发展，日新月异的技术圈子中，到底哪些是不变的，或可沉淀的东西。<br>渐渐的会想到这样的一个问题：<br><strong>技术人的核心竞争力到底是什么？</strong></p>\n<p>今天受<strong>刘未鹏</strong>先生在书中《暗时间》的介绍，阅读了<strong>孟岩</strong>老师的「<a href=\"http://blog.csdn.net/myan/article/details/3247071\">技术路线的选择重要但不具有决定性</a>」，这篇文章正好给最近被这个问题困扰的我拨开了一些迷雾。<br>这是一篇2008年发表的旧文，文中的观点给了我很多启发，但我也不会有相见恨晚的感觉。就算很早遇到这篇文章，也不会有经历过的事情以及思考过的问题作为基础，故也不能理解体会其中的意思。现在时机正好。</p>\n<p>文中把技术人大致的分了四类：</p>\n<ol>\n<li>把命运寄托在<strong>事业</strong>上的人</li>\n<li>把命运寄托在<strong>组织</strong>上的人</li>\n<li>把命运寄托在<strong>技术</strong>上的人</li>\n<li>仍然处于出卖劳动力的人</li>\n</ol>\n<h1 id=\"做技术的几类人\"><a href=\"#做技术的几类人\" class=\"headerlink\" title=\"做技术的几类人\"></a>做技术的几类人</h1><p><strong>第一类是把自己的命运寄托在一项事业上。</strong><br>他们会想着改变一些东西，而技术只是作为其中的手段，他们有能力通过技术实现自己的想法和事业。事业并不是指的创业做老板，而是一件他们认可的事情。比如促进人们交流和言论自由，带给大家更多娱乐，提升大众身心健康水平，增强国家国防实力，或者提升某个行业的信息化水平，能够以技术为手段，在这个事情上做出成绩。他们往往可以终其一生投入到自己的事业中去，在短短的人生中实现价值。到两鬓斑白时，能够回首往事而悠然自得。</p>\n<p><strong>第二类是把自己的命运寄托在组织和团队上</strong><br>他们技术水平出色，综合素质突出，勇于变化，以团队的目标为目标，依据团队的需求而转型或者坚持，跟团队一起干出一番成绩。这些人往往拥有高薪厚禄，以及舒适生活。<br>但是中年以后会经常自问到底做了什么自己想做的事情，为自己过于风平浪静的人生感到惆怅。</p>\n<p><strong>第三类是把命运寄托在技术上。</strong><br>他们有能力成为技术的专家，希望把技能当做商品出售，从而谋求富足人生。不想把自己命运跟企业和组织绑定在一起，也不愿意做什么改变，只是满足于技术高手的层面，寄希望于其技术专长能够长期值钱。</p>\n<p><strong>第四种就是处于出卖劳动力的阶段</strong><br>他们往往疲于做业务，单纯积极完成上级或产经下达的任务，鲜有思考需求合理性，或者在大局上关注项目及其进度。他们往往加班成自然，表面上形成勤奋工作的现象，最终却只是为了业绩好些，年终奖多些。</p>\n<p>第一类，是做技术的最高层次，终其一生投入到一项事业中，为人类和社会创造价值，这并不是一般人能够做到。而第二类总的来说，层次还是比较高的。在自己的专业领域中颇有建树，并且利用技术给团队带来生产力提高和经济的效益，是真正为团队创造价值的人。而第三类人，却是最危险的。技术的发展与变迁是必然发生的事情，年轻的时候还有能力追逐新技术，但当老了追不动了，很容易就被淘汰了。<strong>被淘汰只是时间问题。如果你认为某个软件技术的兴起或者衰落对你个人的职业生涯构成了决定性的影响，那么你可能正走在错误的路线上，应当尽快改弦更张。</strong></p>\n<h1 id=\"核心竞争力\"><a href=\"#核心竞争力\" class=\"headerlink\" title=\"核心竞争力\"></a>核心竞争力</h1><p>关于核心竞争力，孟岩先生有这样一段话：</p>\n<p>那么核心竞争力是什么？我观察圈子里很多成功和不成功的技术人，提出一个观点，那就是个人的核心竞争力是他<strong>独特的个性知识经验组合</strong>。这个行业里拥挤着上百万聪明人，彼此之间真正的不同在哪里？不在于你学的是什么技术，学得多深，IQ多少，而在于你身上有别人没有的独特的个性、背景、知识和经验的组合。如果这种组合，<strong>1，绝无仅有；2，在实践中有价值，3，具有可持续发展性</strong>，那你就具备核心竞争力。因此，当设计自己的发展路线时，应当最大限度地加强和发挥自己独特的组合，而不是寻求单项的超越。而构建自己独特组合的方式，主要是通过实践，其次是要有意识地构造。关于这个观点，话题太大，我不打算赘述。</p>\n<p>个人核心竞争力，并不是对某技术、框架、平台的熟烂于心，也不是什么样的开发思想，更加不是所谓的个人智商问题。而是<strong>独特的个性、知识、经验之间的组合</strong>。</p>\n<h1 id=\"不可替代性\"><a href=\"#不可替代性\" class=\"headerlink\" title=\"不可替代性\"></a>不可替代性</h1><p>孟岩先生在文中并没有对这个问题展开来描述，那么到底什么样的知识技能组合符合下面几种条件的：<br><strong>1. 绝无仅有</strong><br><strong>2. 在实践中有价值</strong><br><strong>3. 具有可持续发展性</strong></p>\n<p><strong>刘未鹏</strong>先生在书中《暗时间》给出了他对这个问题的补充：</p>\n<p>我相信以下的知识技能组合是具有相当程度的不可替代性的：<br><strong>1. 专业领域技能。</strong><br>成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。<br><strong>2. 跨领域的技能。</strong><br>解决问题的能力，创新思维，判断与决策能力，批判性思维，表达沟通能力，等等。<br><strong>3. 学习能力。</strong><br>严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是<strong>持续学习</strong>和<strong>思考知识</strong>。<br><strong>4. 性格要素。</strong><br>严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的），等等。</p>\n<p>除了<strong>刘未鹏</strong>先生上面的四点，我需要补充的还有一点：<br><strong>5. 学历与背景</strong><br>虽然在技术圈子不太看重学历，学历并不是能代表一切，但「受教育程度高的人能力也高」是一个高概率事件，这也是各大公司招聘都会以学历来筛选简历的原因之一。而背景就更加重要了，一个人经历了什么，做过什么，都会对个人的价值观、世界观等造成一定量的影响。一个优秀的学历和丰富的背景，并不是别人能轻而易举复制的。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>我一直很庆幸能接触到计算机领域，然后学会了编程，对其燃起兴趣，并且刚好这门兴趣能成为我的职业，在我享受其带来的乐趣之余，可以提供给我一些物质上的条件。<br><strong>我喜欢的东西变成了我的工作乃至事业</strong>，这比起很多人，已经很幸福了。<br>这种幸福来自于：<br>发现新的好玩的东西所带来的新鲜感，<br>写博客分享知识所带来的认同感，<br>做的产品被很多人使用并且创造价值的自豪感，<br>还有是对知识的不满足感。</p>\n<p>而思考与探索以后是否可以继续让兴趣支持事业成为可能，也是我这个多虑症患者一直在思考的事情。</p>\n"},{"title":"二零一六年一月二十八日，于珠海","date":"2016-01-28T07:40:25.000Z","_content":"\n> 从什么时候开始，我开始迷茫了。\n\n在这里做了一年多的Node.js后端，但是现在业界都是把这门语言归并到前端技术中。    \n我知道自己的前端技术水平很烂，基本功一开始没有练好，在后续也没有继续去锻炼。    \n今天看了由「阿当」发起的前端届撕逼大战。\n\n在有过一年多的后端以及一年多的前端经验的我，是否能更好的跟进这个前端工程化的时代呢。如果除开基本的CSS、HTML之外，我应该对比那些从ccser和设计师转型过来的前端，有着更不一样的思维。\n\n如果我自己进行前端的技能修炼的话，是否可以当一个小全栈呢。\n\n现在的我，处在一个高不成低不就的地步。如果继续往后端发展，明显Node.js是还不够的，要做真正的大项目，大Project的后端的时候，还需要成熟的技术与框架。只是继续Node.js的修炼下去的话，很快就能看到天花板了。\n\n> 回过头来思考，自己并不能限定在一个方向中，应该往一个更广的范畴发展，但我还有很多缺点。\n\n我现在最大的缺点，就是基础不扎实，这在日常工作中，很多情况都能感受的到。    \n书到用时方恨少，当需要用到的时候，总觉得有些乏力。例如在要写一些查询数据库的语句，例如在写算法的时候，写加密解密的时候，缺少了专业的知识做支撑。    \n还有英文能力不太好，在读一些英文的文献的时候，经常感觉到乏力，与效率缓慢。    \n还有自己在知识的广度上，也还不够，没法把握技术的动态。没有足够的关注。\n\n> 忙碌的时期过后，迎来了平静的夜晚，我停下急躁的脚步，思考自己的人生。\n\n今年刚毕业，却已经24岁了，比起很多同龄人，我读书晚了几年，还有6年，就是30岁了。    \n我想要在28岁(2020)时候，能有自己的房子，老婆、车子，在一个城市稳定下来。从现在开始算，剩下给我的只有不到四年的时间。\n今年(2016)可能会买车，然后成了车奴，\n两年后(2018)就可能是结婚了，虽然可能还没有房子，但是我会有一个爱我以及我爱的人。\n然后我们一起努力，在四年后(2020)在一个城市拥有我们的家，然后我们开始生个娃娃。\n\n梦想很丰满，实现很露骨，实现这一切，我要思考该怎么去创造财富。\n从职业上，干几年，以现在自己的状况来说，可能是干到一个leader，领导项目。在这个行业，在这个弱肉强食，优胜劣汰的社会，你负责的项目垮了，就可能面临被裁员的危险。\n\n或者干到几年，在圈子中，有些名气，有些地位，出一两本书。    \n又或者，转型，转到产品岗、项目经理岗、架构师、技术顾问等等。    \n又或者，去读研，考取研究生，提高自己的学历，出国深造等等。    \n又或者，从草根干起，自学成才，厚积薄发。    \n\n其实，这些从现在看来，都未必不可实现，关键还是自己是否有这样的决心和勇气，以及坚持下去的毅力。\n\n> 现在我没有很清晰长远的计划，但我知道一定不要停止前进，至少大方向上，我知道是对还是错的。\n\n2016年，给自己定下要实现的目标：\n\n1. 积累技术的基础，包括但不限于：Nodejs、JS、CSS、HTML5、前端工程化、软件工程化、设计模式、数据库、算法、密码学等等。\n2. 积累阅读量，不单单限于技术书籍，各种书籍都需要接触，提高自己的文笔，以及语言表达能力。\n3. 积累创作文章，勤思考，然后把自己的东西写下来，分享给别人。\n4. 锻炼英语能力，勤于阅读英文类文章、杂志、原版技术书籍。\n5. 关注技术的动态，整理圈子的人物，关注他们。\n\n全部坚持下来的话，是一个艰巨的任务，但是我愿意为了以后的梦想而奋斗，我适应不了无所事事的日子。\n这些积累，不是一朝一日就可以的，是要长年累月，不单单是2016年这一年，而是我要养成这样的习惯，并长期的执行下去。\n相信，积累下去了，在未来的某个时候，我会感谢以前的我是多么的远见。","source":"_posts/二零一六年一月二十八日，于珠海.md","raw":"---\ntitle: 二零一六年一月二十八日，于珠海\ncategory: 三省吾身\ndate: 2016-01-28 15:40:25\ntags:\n---\n\n> 从什么时候开始，我开始迷茫了。\n\n在这里做了一年多的Node.js后端，但是现在业界都是把这门语言归并到前端技术中。    \n我知道自己的前端技术水平很烂，基本功一开始没有练好，在后续也没有继续去锻炼。    \n今天看了由「阿当」发起的前端届撕逼大战。\n\n在有过一年多的后端以及一年多的前端经验的我，是否能更好的跟进这个前端工程化的时代呢。如果除开基本的CSS、HTML之外，我应该对比那些从ccser和设计师转型过来的前端，有着更不一样的思维。\n\n如果我自己进行前端的技能修炼的话，是否可以当一个小全栈呢。\n\n现在的我，处在一个高不成低不就的地步。如果继续往后端发展，明显Node.js是还不够的，要做真正的大项目，大Project的后端的时候，还需要成熟的技术与框架。只是继续Node.js的修炼下去的话，很快就能看到天花板了。\n\n> 回过头来思考，自己并不能限定在一个方向中，应该往一个更广的范畴发展，但我还有很多缺点。\n\n我现在最大的缺点，就是基础不扎实，这在日常工作中，很多情况都能感受的到。    \n书到用时方恨少，当需要用到的时候，总觉得有些乏力。例如在要写一些查询数据库的语句，例如在写算法的时候，写加密解密的时候，缺少了专业的知识做支撑。    \n还有英文能力不太好，在读一些英文的文献的时候，经常感觉到乏力，与效率缓慢。    \n还有自己在知识的广度上，也还不够，没法把握技术的动态。没有足够的关注。\n\n> 忙碌的时期过后，迎来了平静的夜晚，我停下急躁的脚步，思考自己的人生。\n\n今年刚毕业，却已经24岁了，比起很多同龄人，我读书晚了几年，还有6年，就是30岁了。    \n我想要在28岁(2020)时候，能有自己的房子，老婆、车子，在一个城市稳定下来。从现在开始算，剩下给我的只有不到四年的时间。\n今年(2016)可能会买车，然后成了车奴，\n两年后(2018)就可能是结婚了，虽然可能还没有房子，但是我会有一个爱我以及我爱的人。\n然后我们一起努力，在四年后(2020)在一个城市拥有我们的家，然后我们开始生个娃娃。\n\n梦想很丰满，实现很露骨，实现这一切，我要思考该怎么去创造财富。\n从职业上，干几年，以现在自己的状况来说，可能是干到一个leader，领导项目。在这个行业，在这个弱肉强食，优胜劣汰的社会，你负责的项目垮了，就可能面临被裁员的危险。\n\n或者干到几年，在圈子中，有些名气，有些地位，出一两本书。    \n又或者，转型，转到产品岗、项目经理岗、架构师、技术顾问等等。    \n又或者，去读研，考取研究生，提高自己的学历，出国深造等等。    \n又或者，从草根干起，自学成才，厚积薄发。    \n\n其实，这些从现在看来，都未必不可实现，关键还是自己是否有这样的决心和勇气，以及坚持下去的毅力。\n\n> 现在我没有很清晰长远的计划，但我知道一定不要停止前进，至少大方向上，我知道是对还是错的。\n\n2016年，给自己定下要实现的目标：\n\n1. 积累技术的基础，包括但不限于：Nodejs、JS、CSS、HTML5、前端工程化、软件工程化、设计模式、数据库、算法、密码学等等。\n2. 积累阅读量，不单单限于技术书籍，各种书籍都需要接触，提高自己的文笔，以及语言表达能力。\n3. 积累创作文章，勤思考，然后把自己的东西写下来，分享给别人。\n4. 锻炼英语能力，勤于阅读英文类文章、杂志、原版技术书籍。\n5. 关注技术的动态，整理圈子的人物，关注他们。\n\n全部坚持下来的话，是一个艰巨的任务，但是我愿意为了以后的梦想而奋斗，我适应不了无所事事的日子。\n这些积累，不是一朝一日就可以的，是要长年累月，不单单是2016年这一年，而是我要养成这样的习惯，并长期的执行下去。\n相信，积累下去了，在未来的某个时候，我会感谢以前的我是多么的远见。","slug":"二零一六年一月二十八日，于珠海","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8ry002oxwrlesug2ttl","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>从什么时候开始，我开始迷茫了。</p>\n</blockquote>\n<p>在这里做了一年多的Node.js后端，但是现在业界都是把这门语言归并到前端技术中。<br>我知道自己的前端技术水平很烂，基本功一开始没有练好，在后续也没有继续去锻炼。<br>今天看了由「阿当」发起的前端届撕逼大战。</p>\n<p>在有过一年多的后端以及一年多的前端经验的我，是否能更好的跟进这个前端工程化的时代呢。如果除开基本的CSS、HTML之外，我应该对比那些从ccser和设计师转型过来的前端，有着更不一样的思维。</p>\n<p>如果我自己进行前端的技能修炼的话，是否可以当一个小全栈呢。</p>\n<p>现在的我，处在一个高不成低不就的地步。如果继续往后端发展，明显Node.js是还不够的，要做真正的大项目，大Project的后端的时候，还需要成熟的技术与框架。只是继续Node.js的修炼下去的话，很快就能看到天花板了。</p>\n<blockquote>\n<p>回过头来思考，自己并不能限定在一个方向中，应该往一个更广的范畴发展，但我还有很多缺点。</p>\n</blockquote>\n<p>我现在最大的缺点，就是基础不扎实，这在日常工作中，很多情况都能感受的到。<br>书到用时方恨少，当需要用到的时候，总觉得有些乏力。例如在要写一些查询数据库的语句，例如在写算法的时候，写加密解密的时候，缺少了专业的知识做支撑。<br>还有英文能力不太好，在读一些英文的文献的时候，经常感觉到乏力，与效率缓慢。<br>还有自己在知识的广度上，也还不够，没法把握技术的动态。没有足够的关注。</p>\n<blockquote>\n<p>忙碌的时期过后，迎来了平静的夜晚，我停下急躁的脚步，思考自己的人生。</p>\n</blockquote>\n<p>今年刚毕业，却已经24岁了，比起很多同龄人，我读书晚了几年，还有6年，就是30岁了。<br>我想要在28岁(2020)时候，能有自己的房子，老婆、车子，在一个城市稳定下来。从现在开始算，剩下给我的只有不到四年的时间。<br>今年(2016)可能会买车，然后成了车奴，<br>两年后(2018)就可能是结婚了，虽然可能还没有房子，但是我会有一个爱我以及我爱的人。<br>然后我们一起努力，在四年后(2020)在一个城市拥有我们的家，然后我们开始生个娃娃。</p>\n<p>梦想很丰满，实现很露骨，实现这一切，我要思考该怎么去创造财富。<br>从职业上，干几年，以现在自己的状况来说，可能是干到一个leader，领导项目。在这个行业，在这个弱肉强食，优胜劣汰的社会，你负责的项目垮了，就可能面临被裁员的危险。</p>\n<p>或者干到几年，在圈子中，有些名气，有些地位，出一两本书。<br>又或者，转型，转到产品岗、项目经理岗、架构师、技术顾问等等。<br>又或者，去读研，考取研究生，提高自己的学历，出国深造等等。<br>又或者，从草根干起，自学成才，厚积薄发。    </p>\n<p>其实，这些从现在看来，都未必不可实现，关键还是自己是否有这样的决心和勇气，以及坚持下去的毅力。</p>\n<blockquote>\n<p>现在我没有很清晰长远的计划，但我知道一定不要停止前进，至少大方向上，我知道是对还是错的。</p>\n</blockquote>\n<p>2016年，给自己定下要实现的目标：</p>\n<ol>\n<li>积累技术的基础，包括但不限于：Nodejs、JS、CSS、HTML5、前端工程化、软件工程化、设计模式、数据库、算法、密码学等等。</li>\n<li>积累阅读量，不单单限于技术书籍，各种书籍都需要接触，提高自己的文笔，以及语言表达能力。</li>\n<li>积累创作文章，勤思考，然后把自己的东西写下来，分享给别人。</li>\n<li>锻炼英语能力，勤于阅读英文类文章、杂志、原版技术书籍。</li>\n<li>关注技术的动态，整理圈子的人物，关注他们。</li>\n</ol>\n<p>全部坚持下来的话，是一个艰巨的任务，但是我愿意为了以后的梦想而奋斗，我适应不了无所事事的日子。<br>这些积累，不是一朝一日就可以的，是要长年累月，不单单是2016年这一年，而是我要养成这样的习惯，并长期的执行下去。<br>相信，积累下去了，在未来的某个时候，我会感谢以前的我是多么的远见。</p>\n","excerpt":"","more":"<blockquote>\n<p>从什么时候开始，我开始迷茫了。</p>\n</blockquote>\n<p>在这里做了一年多的Node.js后端，但是现在业界都是把这门语言归并到前端技术中。<br>我知道自己的前端技术水平很烂，基本功一开始没有练好，在后续也没有继续去锻炼。<br>今天看了由「阿当」发起的前端届撕逼大战。</p>\n<p>在有过一年多的后端以及一年多的前端经验的我，是否能更好的跟进这个前端工程化的时代呢。如果除开基本的CSS、HTML之外，我应该对比那些从ccser和设计师转型过来的前端，有着更不一样的思维。</p>\n<p>如果我自己进行前端的技能修炼的话，是否可以当一个小全栈呢。</p>\n<p>现在的我，处在一个高不成低不就的地步。如果继续往后端发展，明显Node.js是还不够的，要做真正的大项目，大Project的后端的时候，还需要成熟的技术与框架。只是继续Node.js的修炼下去的话，很快就能看到天花板了。</p>\n<blockquote>\n<p>回过头来思考，自己并不能限定在一个方向中，应该往一个更广的范畴发展，但我还有很多缺点。</p>\n</blockquote>\n<p>我现在最大的缺点，就是基础不扎实，这在日常工作中，很多情况都能感受的到。<br>书到用时方恨少，当需要用到的时候，总觉得有些乏力。例如在要写一些查询数据库的语句，例如在写算法的时候，写加密解密的时候，缺少了专业的知识做支撑。<br>还有英文能力不太好，在读一些英文的文献的时候，经常感觉到乏力，与效率缓慢。<br>还有自己在知识的广度上，也还不够，没法把握技术的动态。没有足够的关注。</p>\n<blockquote>\n<p>忙碌的时期过后，迎来了平静的夜晚，我停下急躁的脚步，思考自己的人生。</p>\n</blockquote>\n<p>今年刚毕业，却已经24岁了，比起很多同龄人，我读书晚了几年，还有6年，就是30岁了。<br>我想要在28岁(2020)时候，能有自己的房子，老婆、车子，在一个城市稳定下来。从现在开始算，剩下给我的只有不到四年的时间。<br>今年(2016)可能会买车，然后成了车奴，<br>两年后(2018)就可能是结婚了，虽然可能还没有房子，但是我会有一个爱我以及我爱的人。<br>然后我们一起努力，在四年后(2020)在一个城市拥有我们的家，然后我们开始生个娃娃。</p>\n<p>梦想很丰满，实现很露骨，实现这一切，我要思考该怎么去创造财富。<br>从职业上，干几年，以现在自己的状况来说，可能是干到一个leader，领导项目。在这个行业，在这个弱肉强食，优胜劣汰的社会，你负责的项目垮了，就可能面临被裁员的危险。</p>\n<p>或者干到几年，在圈子中，有些名气，有些地位，出一两本书。<br>又或者，转型，转到产品岗、项目经理岗、架构师、技术顾问等等。<br>又或者，去读研，考取研究生，提高自己的学历，出国深造等等。<br>又或者，从草根干起，自学成才，厚积薄发。    </p>\n<p>其实，这些从现在看来，都未必不可实现，关键还是自己是否有这样的决心和勇气，以及坚持下去的毅力。</p>\n<blockquote>\n<p>现在我没有很清晰长远的计划，但我知道一定不要停止前进，至少大方向上，我知道是对还是错的。</p>\n</blockquote>\n<p>2016年，给自己定下要实现的目标：</p>\n<ol>\n<li>积累技术的基础，包括但不限于：Nodejs、JS、CSS、HTML5、前端工程化、软件工程化、设计模式、数据库、算法、密码学等等。</li>\n<li>积累阅读量，不单单限于技术书籍，各种书籍都需要接触，提高自己的文笔，以及语言表达能力。</li>\n<li>积累创作文章，勤思考，然后把自己的东西写下来，分享给别人。</li>\n<li>锻炼英语能力，勤于阅读英文类文章、杂志、原版技术书籍。</li>\n<li>关注技术的动态，整理圈子的人物，关注他们。</li>\n</ol>\n<p>全部坚持下来的话，是一个艰巨的任务，但是我愿意为了以后的梦想而奋斗，我适应不了无所事事的日子。<br>这些积累，不是一朝一日就可以的，是要长年累月，不单单是2016年这一年，而是我要养成这样的习惯，并长期的执行下去。<br>相信，积累下去了，在未来的某个时候，我会感谢以前的我是多么的远见。</p>\n"},{"title":"了解 Nginx 的基本概念","date":"2016-10-14T09:39:00.000Z","_content":"\n# 前言\n本篇是我学习Nginx的一些笔记，主要内容讲述了一些了解Nginx需要的基本概念。\n然后探讨一下Nginx的模块化的组织架构，以及各个模块的分类、工作方式、职责和提供的相关指令。\n主要达到以下目的：\n1. 了解Nginx的大概运行原理\n2. 了解Nginx的基本概念\n3. 知道怎么看官方文档。\n\n# 关于Nginx\nNginx是一款面向性能设计的HTTP服务器，能反向代理HTTP，HTTPS和邮件相关(SMTP，POP3，IMAP)的协议链接。并且提供了负载均衡以及HTTP缓存。\n它的设计充分使用异步事件模型，削减上下文调度的开销，提高服务器并发能力。\n采用了模块化设计，提供了丰富模块的第三方模块。\n所以关于Nginx，有这些标签：「异步」「事件」「模块化」「高性能」「高并发」「反向代理」「负载均衡」\n \n# 基本概念\n\n## 进程模型\nNginx的进程是使用经典的「Master-Worker」模型。\nNginx在启动后，会有一个master进程和多个worker进程。\nmaster进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。\nworker进程主要处理基本的网络事件，多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。需要注意的是，每个Worker只有主线程，即所谓的「单线程」。\n一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。\nworker进程的个数是可以设置的，一般会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的。nginx为了更好的利用多核特性，提供了cpu亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。更多的worker数，只会导致进程来竞争cpu资源。\n\n![Nginx 进程模型.png](/image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png)\n\n## 事件模型\nNginx对于事件，以「异步非阻塞」方式来实现。\n异步和非异步，阻塞和非阻塞是两组不同的概念，前者更多对于应用程序而言，而后者更多对于CPU来说：\n1. 异步：执行一个动作之后，可以去操作别的操作，然后等待通知再回来执行刚才没执行完的操作。\n2. 非异步(同步)：执行一个操作之后，等待结果，然后才继续执行下面的操作。\n3. 阻塞：给CPU传达任务之后，一直等待CPU处理完毕(即使会产生I/O)，然后才执行下面操作。\n4. 非阻塞：给CPU传达任务之后，继续处理后面的操作，隔段时间再来询问之前的操作是否完成。这样的及过程也叫「轮询」\n\nNginx的「异步非阻塞」方式，具体到系统调用的话，就是像select/poll/epoll/kqueue这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。\n\nepoll是在Linux上关于事件的实现，而kqueue是OpenBSD或FreeBSD操作系统上采用类似epoll的事件模型。\n所以重点讲解一下epoll的模型：\n\n![epoll事件模型.png](/image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png)\n\n\n该方案给是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进入休眠，直到事件将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。\n\n## 反向代理\n要了解「反向代理」，首先需要知道什么是「代理服务器」和「正向代理」\n\n### 代理服务器\n在网络中，客户端发起一个请求，获取服务器端的资源。它们之间并不是建立一条直接的通道，而是被代理服务器所转发。\n代理服务器作为网络中的媒介将互联网上获取的资源返回给相关的客户端。\n我们通常所说的代理，一般都指的是「正向代理」，是相对于客户端来说的。\n比方说我链接了一个VPN，我访问Google的时候，客户端发起的请求到了VPN，VPN帮忙转发请求Google的服务器，然后把Google响应返回给客户端。这个过程，VPN就充当了「正向代理服务器」的角色。\n\n![代理服务器.png](/image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png)\n\n### 反向代理\n和「正向代理」不同，「反向代理」的说法面向于服务器端。一个客户端请求来到代理服务器，代理服务器根据客户端的请求的不同而把请求转发到不同的服务器，这个过程在「负载均衡」中，也会发生两个一样的请求，会转发到完全不一样的服务器中的情况。\n「反向代理」是「负载均衡」实现的前提，正因为代理服务器有了解析请求，分发请求的能力，才能实现负载均衡，降低每一台服务器的负荷。\n利用「反向代理」，除了实现负载均衡，还可以实现诸如：SSL加密，静态内容缓存，gzip压缩，减速上传，安全等功能\n\n![反向代理.png](/image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png)\n\n## 负载均衡\n负载均衡（Load balancing）是一种计算机网络技术，用来在多个服务器中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。\n使用带有负载均衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务的实现可以通过软件和硬件来实现。\n负载均衡的分发，一般都会有多套算法来处理分发问题。\n\n## 连接 Connection  \n在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件。利用nginx封装的connection，我们可以很方便的使用nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。\n而nginx中的http请求的处理就是建立在connection之上的，所以nginx不仅可以作为一个web服务器，也可以作为邮件服务器。\n当然，利用nginx提供的connection，我们可以与任何后端服务打交道。\n\n### 最大连接数\n在nginx中，每个进程会有一个连接数的最大上限，这个上限与系统对fd的限制不一样。\n在操作系统中，通过ulimit -n，我们可以得到一个进程所能够打开的fd的最大数，即nofile，因为每个socket连接会占用掉一个fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当fd用完后，再创建socket时，就会失败。\nnginx通过设置`worker_connectons`来设置每个进程支持的最大连接数。如果该值大于nofile，那么实际的最大连接数是nofile，nginx会有警告。\nnginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是`worker_connections`。这里的连接池里面保存的其实不是真实的连接，它只是一个`worker_connections`大小的一个`ngx_connection_t`结构的数组。并且，nginx会通过一个链表`free_connections`来保存所有的空闲`ngx_connection_t`，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。\n\n所以，一个nginx能建立的最大连接数：`worker_connections * worker_processes`，\n如果当nginx作为反向代理的话，因为一个请求nginx要建立客户端和服务器的请求，所以最大连接数是：`worker_connections * worker_processes / 2`\n\n## 请求 Request\n在nginx中我们指http请求，具体到nginx中的数据结构是`ngx_http_request_t`。\n它是对一个http请求的封装，nginx通过`ngx_http_request_t`来保存解析请求与输出响应相关的数据。\n一个http请求，包含请求行、请求头、请求体、响应行、响应头、响应体。\n\n一般性的网络请求处理过程是：\n1. 客户端会发送请求过来。\n2. 然后我们读取一行数据，分析出请求行中包含的method、uri、http_version信息。\n3. 然后再一行一行处理请求头，并根据请求method与请求头的信息来决定是否有请求体以及请求体的长度，然后再去读取请求体。\n4. 得到请求后，我们处理请求产生需要输出的数据，然后再生成响应行，响应头以及响应体。\n5. 在将响应发送给客户端之后，一个完整的请求就处理完了。\n\n而nginx处理请求的时候会有一些小小的区别，比如，当请求头读取完成后，就开始进行请求的处理了。\n\n### Nginx处理请求过程\n\nnginx处理一个请求的抽象概念过程：\n1. request 请求进来\n2. 初始化HTTP Request， 生成 HTTP Request对象\n3. 处理请求头\n4. 处理请求体\n5. 调用与此请求关联的handler（根据你URL或者Location配置）\n6. 依次调用各phase handler进行处理\n\t1. 获取location配置\n\t2. 产生适当的响应\n\t3. 发送response header\n\t4. 发送response body\n\t\n\n# 基本数据结构\nnginx的作者为追求极致的高效，自己实现了很多颇具特色的nginx风格的数据结构以及公共函数。比如，nginx提供了带长度的字符串，根据编译器选项优化过的字符串拷贝函数ngx_copy等。\n*ps: 下横线分割是C语言的变量名风格*\n\n| Data Structure | Description |\n| -------------  | ----------- |\n| ngx_str_t | 字符串封装 |\n| ngx_pool_t | 提供一种机制，帮助管理一系列的资源（内存，文件）|\n| ngx_array_t | 数组结构 |\n| ngx_chain_t | 主要用于模块之间数据传递的链表实现 |\n| ngx_buf_t | 就是ngx_chain_t链表的每个节点的实际实现，代表某种具体的数据。|\n| ngx_list_t | list数据结构的实现，以及增强 |\n| ngx_queue_t | 实现的双向链表 |\n| ngx_hash_t | hash表的实现 |\n| ngx_hash_wildcard_t | 为处理带有通配符域名的匹配问题实现的hash表结构 |\n| ngx_combinded_t | 在于提供一个方便的容器包含三个类型的hash表 |\n| ngx_hash_keys_arrays_t | 用于构建其他类型的hash的辅助类 |\n\n# 配置\nnginx的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于nginx安装目录下的conf目录下。\n指令由nginx的各个模块提供，不同的模块会提供不同的指令来实现配置。\n指令除了Key-Value的形式，还有作用域指令。\nnginx.conf中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。\n\n下面的这些上下文指令是用的比较多：\n\n| Directive | Description | Contains Directive |\n| --------  | ----------- | ------------------ |\n| main | nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。| user, worker_processes, error_log, events, http, mail |\n| http | 与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。| server |\n| server | http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server.每个server通过监听的地址来区分。 | listen, server_name, access_log, location, protocol, proxy, smtp_auth, xclient |\n| location | http服务中，某些特定的URL对应的一系列配置项。| index, root |\n| mail | 实现email相关的SMTP/IMAP/POP3代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。| server, http, imap_capabilities |\n\n# 模块\nnginx将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。例如，实现对请求解压缩的模块，实现SSI的模块，实现与上游服务器进行通讯的模块，实现与FastCGI服务进行通讯的模块。\n模块分三类：\n1. 核心模块\n2. 辅助模块\n3. 第三方模块\n\n根据官方文档排版，辅助模块还分了以下几类：\n1. http\n2. mail\n3. stream\n\n而根据其功能可以分成这几大类：\n1. **handler模块**\n  此类型的模块也被直接称为handler模块。主要负责处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。\n2. **filter模块**\n  过滤响应头和内容的模块，可以对回复的头和内容进行处理。它的处理时间在获取回复内容之后，向用户发送响应之前。\n3. **upstream模块**\n  upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream模块是一种特殊的handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。\n4. **load balance模块**\n  负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器\n\n\n\n# 结尾\n\n本文讲述了Nginx的一些基本概念。\nNginx是线程模型是Master-Worker模式的，每个worker是单线程的，也就是处理请求是单线程处理的。而单线程并发的事件模型是「异步非阻塞I/O」模型。\n并且讲述了「反向代理」「负载均衡」的概念，这是nginx能高性能处理高并发的原因之一。\nNginx对于网络请求是有Connection和Request的概念和封装的。\nNginx的源码组织架构是模块化的，不同的模块实现不一样的职责，然后它们被连接起来一起干一件大事，知道模块有哪些分类，可以让我们知道怎么查找官方文档。\n在没有看过有哪些指令，哪些指令有什么功能之前，是不能完全知道nginx提供什么样的功能的，那就抱着，那就抱着「能想到的别人都想到并实现了」的想法来使用nginx吧。Nginx作为一个代理服务，在中间想做什么都可以啦。\n\n# 参考\n[Nginx开发从入门到精通](http://tengine.taobao.org/book/chapter_04.html#id2)\n[Nginx官方网站](http://nginx.org/)\n[《计算机操作系统》]()\n[《深入浅出Node.js》]()","source":"_posts/了解 Nginx 的基本概念.md","raw":"---\ntitle: 了解 Nginx 的基本概念\ncategory: 搬砖码农\ndate: 2016-10-14 17:39:00\ntags:\n- Nginx\n---\n\n# 前言\n本篇是我学习Nginx的一些笔记，主要内容讲述了一些了解Nginx需要的基本概念。\n然后探讨一下Nginx的模块化的组织架构，以及各个模块的分类、工作方式、职责和提供的相关指令。\n主要达到以下目的：\n1. 了解Nginx的大概运行原理\n2. 了解Nginx的基本概念\n3. 知道怎么看官方文档。\n\n# 关于Nginx\nNginx是一款面向性能设计的HTTP服务器，能反向代理HTTP，HTTPS和邮件相关(SMTP，POP3，IMAP)的协议链接。并且提供了负载均衡以及HTTP缓存。\n它的设计充分使用异步事件模型，削减上下文调度的开销，提高服务器并发能力。\n采用了模块化设计，提供了丰富模块的第三方模块。\n所以关于Nginx，有这些标签：「异步」「事件」「模块化」「高性能」「高并发」「反向代理」「负载均衡」\n \n# 基本概念\n\n## 进程模型\nNginx的进程是使用经典的「Master-Worker」模型。\nNginx在启动后，会有一个master进程和多个worker进程。\nmaster进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。\nworker进程主要处理基本的网络事件，多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。需要注意的是，每个Worker只有主线程，即所谓的「单线程」。\n一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。\nworker进程的个数是可以设置的，一般会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的。nginx为了更好的利用多核特性，提供了cpu亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。更多的worker数，只会导致进程来竞争cpu资源。\n\n![Nginx 进程模型.png](/image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png)\n\n## 事件模型\nNginx对于事件，以「异步非阻塞」方式来实现。\n异步和非异步，阻塞和非阻塞是两组不同的概念，前者更多对于应用程序而言，而后者更多对于CPU来说：\n1. 异步：执行一个动作之后，可以去操作别的操作，然后等待通知再回来执行刚才没执行完的操作。\n2. 非异步(同步)：执行一个操作之后，等待结果，然后才继续执行下面的操作。\n3. 阻塞：给CPU传达任务之后，一直等待CPU处理完毕(即使会产生I/O)，然后才执行下面操作。\n4. 非阻塞：给CPU传达任务之后，继续处理后面的操作，隔段时间再来询问之前的操作是否完成。这样的及过程也叫「轮询」\n\nNginx的「异步非阻塞」方式，具体到系统调用的话，就是像select/poll/epoll/kqueue这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。\n\nepoll是在Linux上关于事件的实现，而kqueue是OpenBSD或FreeBSD操作系统上采用类似epoll的事件模型。\n所以重点讲解一下epoll的模型：\n\n![epoll事件模型.png](/image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png)\n\n\n该方案给是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进入休眠，直到事件将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。\n\n## 反向代理\n要了解「反向代理」，首先需要知道什么是「代理服务器」和「正向代理」\n\n### 代理服务器\n在网络中，客户端发起一个请求，获取服务器端的资源。它们之间并不是建立一条直接的通道，而是被代理服务器所转发。\n代理服务器作为网络中的媒介将互联网上获取的资源返回给相关的客户端。\n我们通常所说的代理，一般都指的是「正向代理」，是相对于客户端来说的。\n比方说我链接了一个VPN，我访问Google的时候，客户端发起的请求到了VPN，VPN帮忙转发请求Google的服务器，然后把Google响应返回给客户端。这个过程，VPN就充当了「正向代理服务器」的角色。\n\n![代理服务器.png](/image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png)\n\n### 反向代理\n和「正向代理」不同，「反向代理」的说法面向于服务器端。一个客户端请求来到代理服务器，代理服务器根据客户端的请求的不同而把请求转发到不同的服务器，这个过程在「负载均衡」中，也会发生两个一样的请求，会转发到完全不一样的服务器中的情况。\n「反向代理」是「负载均衡」实现的前提，正因为代理服务器有了解析请求，分发请求的能力，才能实现负载均衡，降低每一台服务器的负荷。\n利用「反向代理」，除了实现负载均衡，还可以实现诸如：SSL加密，静态内容缓存，gzip压缩，减速上传，安全等功能\n\n![反向代理.png](/image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png)\n\n## 负载均衡\n负载均衡（Load balancing）是一种计算机网络技术，用来在多个服务器中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。\n使用带有负载均衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务的实现可以通过软件和硬件来实现。\n负载均衡的分发，一般都会有多套算法来处理分发问题。\n\n## 连接 Connection  \n在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件。利用nginx封装的connection，我们可以很方便的使用nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。\n而nginx中的http请求的处理就是建立在connection之上的，所以nginx不仅可以作为一个web服务器，也可以作为邮件服务器。\n当然，利用nginx提供的connection，我们可以与任何后端服务打交道。\n\n### 最大连接数\n在nginx中，每个进程会有一个连接数的最大上限，这个上限与系统对fd的限制不一样。\n在操作系统中，通过ulimit -n，我们可以得到一个进程所能够打开的fd的最大数，即nofile，因为每个socket连接会占用掉一个fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当fd用完后，再创建socket时，就会失败。\nnginx通过设置`worker_connectons`来设置每个进程支持的最大连接数。如果该值大于nofile，那么实际的最大连接数是nofile，nginx会有警告。\nnginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是`worker_connections`。这里的连接池里面保存的其实不是真实的连接，它只是一个`worker_connections`大小的一个`ngx_connection_t`结构的数组。并且，nginx会通过一个链表`free_connections`来保存所有的空闲`ngx_connection_t`，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。\n\n所以，一个nginx能建立的最大连接数：`worker_connections * worker_processes`，\n如果当nginx作为反向代理的话，因为一个请求nginx要建立客户端和服务器的请求，所以最大连接数是：`worker_connections * worker_processes / 2`\n\n## 请求 Request\n在nginx中我们指http请求，具体到nginx中的数据结构是`ngx_http_request_t`。\n它是对一个http请求的封装，nginx通过`ngx_http_request_t`来保存解析请求与输出响应相关的数据。\n一个http请求，包含请求行、请求头、请求体、响应行、响应头、响应体。\n\n一般性的网络请求处理过程是：\n1. 客户端会发送请求过来。\n2. 然后我们读取一行数据，分析出请求行中包含的method、uri、http_version信息。\n3. 然后再一行一行处理请求头，并根据请求method与请求头的信息来决定是否有请求体以及请求体的长度，然后再去读取请求体。\n4. 得到请求后，我们处理请求产生需要输出的数据，然后再生成响应行，响应头以及响应体。\n5. 在将响应发送给客户端之后，一个完整的请求就处理完了。\n\n而nginx处理请求的时候会有一些小小的区别，比如，当请求头读取完成后，就开始进行请求的处理了。\n\n### Nginx处理请求过程\n\nnginx处理一个请求的抽象概念过程：\n1. request 请求进来\n2. 初始化HTTP Request， 生成 HTTP Request对象\n3. 处理请求头\n4. 处理请求体\n5. 调用与此请求关联的handler（根据你URL或者Location配置）\n6. 依次调用各phase handler进行处理\n\t1. 获取location配置\n\t2. 产生适当的响应\n\t3. 发送response header\n\t4. 发送response body\n\t\n\n# 基本数据结构\nnginx的作者为追求极致的高效，自己实现了很多颇具特色的nginx风格的数据结构以及公共函数。比如，nginx提供了带长度的字符串，根据编译器选项优化过的字符串拷贝函数ngx_copy等。\n*ps: 下横线分割是C语言的变量名风格*\n\n| Data Structure | Description |\n| -------------  | ----------- |\n| ngx_str_t | 字符串封装 |\n| ngx_pool_t | 提供一种机制，帮助管理一系列的资源（内存，文件）|\n| ngx_array_t | 数组结构 |\n| ngx_chain_t | 主要用于模块之间数据传递的链表实现 |\n| ngx_buf_t | 就是ngx_chain_t链表的每个节点的实际实现，代表某种具体的数据。|\n| ngx_list_t | list数据结构的实现，以及增强 |\n| ngx_queue_t | 实现的双向链表 |\n| ngx_hash_t | hash表的实现 |\n| ngx_hash_wildcard_t | 为处理带有通配符域名的匹配问题实现的hash表结构 |\n| ngx_combinded_t | 在于提供一个方便的容器包含三个类型的hash表 |\n| ngx_hash_keys_arrays_t | 用于构建其他类型的hash的辅助类 |\n\n# 配置\nnginx的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于nginx安装目录下的conf目录下。\n指令由nginx的各个模块提供，不同的模块会提供不同的指令来实现配置。\n指令除了Key-Value的形式，还有作用域指令。\nnginx.conf中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。\n\n下面的这些上下文指令是用的比较多：\n\n| Directive | Description | Contains Directive |\n| --------  | ----------- | ------------------ |\n| main | nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。| user, worker_processes, error_log, events, http, mail |\n| http | 与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。| server |\n| server | http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server.每个server通过监听的地址来区分。 | listen, server_name, access_log, location, protocol, proxy, smtp_auth, xclient |\n| location | http服务中，某些特定的URL对应的一系列配置项。| index, root |\n| mail | 实现email相关的SMTP/IMAP/POP3代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。| server, http, imap_capabilities |\n\n# 模块\nnginx将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。例如，实现对请求解压缩的模块，实现SSI的模块，实现与上游服务器进行通讯的模块，实现与FastCGI服务进行通讯的模块。\n模块分三类：\n1. 核心模块\n2. 辅助模块\n3. 第三方模块\n\n根据官方文档排版，辅助模块还分了以下几类：\n1. http\n2. mail\n3. stream\n\n而根据其功能可以分成这几大类：\n1. **handler模块**\n  此类型的模块也被直接称为handler模块。主要负责处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。\n2. **filter模块**\n  过滤响应头和内容的模块，可以对回复的头和内容进行处理。它的处理时间在获取回复内容之后，向用户发送响应之前。\n3. **upstream模块**\n  upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream模块是一种特殊的handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。\n4. **load balance模块**\n  负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器\n\n\n\n# 结尾\n\n本文讲述了Nginx的一些基本概念。\nNginx是线程模型是Master-Worker模式的，每个worker是单线程的，也就是处理请求是单线程处理的。而单线程并发的事件模型是「异步非阻塞I/O」模型。\n并且讲述了「反向代理」「负载均衡」的概念，这是nginx能高性能处理高并发的原因之一。\nNginx对于网络请求是有Connection和Request的概念和封装的。\nNginx的源码组织架构是模块化的，不同的模块实现不一样的职责，然后它们被连接起来一起干一件大事，知道模块有哪些分类，可以让我们知道怎么查找官方文档。\n在没有看过有哪些指令，哪些指令有什么功能之前，是不能完全知道nginx提供什么样的功能的，那就抱着，那就抱着「能想到的别人都想到并实现了」的想法来使用nginx吧。Nginx作为一个代理服务，在中间想做什么都可以啦。\n\n# 参考\n[Nginx开发从入门到精通](http://tengine.taobao.org/book/chapter_04.html#id2)\n[Nginx官方网站](http://nginx.org/)\n[《计算机操作系统》]()\n[《深入浅出Node.js》]()","slug":"了解 Nginx 的基本概念","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8s4002qxwrl6dvx3g43","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本篇是我学习Nginx的一些笔记，主要内容讲述了一些了解Nginx需要的基本概念。<br>然后探讨一下Nginx的模块化的组织架构，以及各个模块的分类、工作方式、职责和提供的相关指令。<br>主要达到以下目的：</p>\n<ol>\n<li>了解Nginx的大概运行原理</li>\n<li>了解Nginx的基本概念</li>\n<li>知道怎么看官方文档。</li>\n</ol>\n<h1 id=\"关于Nginx\"><a href=\"#关于Nginx\" class=\"headerlink\" title=\"关于Nginx\"></a>关于Nginx</h1><p>Nginx是一款面向性能设计的HTTP服务器，能反向代理HTTP，HTTPS和邮件相关(SMTP，POP3，IMAP)的协议链接。并且提供了负载均衡以及HTTP缓存。<br>它的设计充分使用异步事件模型，削减上下文调度的开销，提高服务器并发能力。<br>采用了模块化设计，提供了丰富模块的第三方模块。<br>所以关于Nginx，有这些标签：「异步」「事件」「模块化」「高性能」「高并发」「反向代理」「负载均衡」</p>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><h2 id=\"进程模型\"><a href=\"#进程模型\" class=\"headerlink\" title=\"进程模型\"></a>进程模型</h2><p>Nginx的进程是使用经典的「Master-Worker」模型。<br>Nginx在启动后，会有一个master进程和多个worker进程。<br>master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。<br>worker进程主要处理基本的网络事件，多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。需要注意的是，每个Worker只有主线程，即所谓的「单线程」。<br>一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。<br>worker进程的个数是可以设置的，一般会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的。nginx为了更好的利用多核特性，提供了cpu亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。更多的worker数，只会导致进程来竞争cpu资源。</p>\n<p><img src=\"/image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png\" alt=\"Nginx 进程模型.png\"></p>\n<h2 id=\"事件模型\"><a href=\"#事件模型\" class=\"headerlink\" title=\"事件模型\"></a>事件模型</h2><p>Nginx对于事件，以「异步非阻塞」方式来实现。<br>异步和非异步，阻塞和非阻塞是两组不同的概念，前者更多对于应用程序而言，而后者更多对于CPU来说：</p>\n<ol>\n<li>异步：执行一个动作之后，可以去操作别的操作，然后等待通知再回来执行刚才没执行完的操作。</li>\n<li>非异步(同步)：执行一个操作之后，等待结果，然后才继续执行下面的操作。</li>\n<li>阻塞：给CPU传达任务之后，一直等待CPU处理完毕(即使会产生I/O)，然后才执行下面操作。</li>\n<li>非阻塞：给CPU传达任务之后，继续处理后面的操作，隔段时间再来询问之前的操作是否完成。这样的及过程也叫「轮询」</li>\n</ol>\n<p>Nginx的「异步非阻塞」方式，具体到系统调用的话，就是像select/poll/epoll/kqueue这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。</p>\n<p>epoll是在Linux上关于事件的实现，而kqueue是OpenBSD或FreeBSD操作系统上采用类似epoll的事件模型。<br>所以重点讲解一下epoll的模型：</p>\n<p><img src=\"/image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png\" alt=\"epoll事件模型.png\"></p>\n<p>该方案给是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进入休眠，直到事件将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。</p>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>要了解「反向代理」，首先需要知道什么是「代理服务器」和「正向代理」</p>\n<h3 id=\"代理服务器\"><a href=\"#代理服务器\" class=\"headerlink\" title=\"代理服务器\"></a>代理服务器</h3><p>在网络中，客户端发起一个请求，获取服务器端的资源。它们之间并不是建立一条直接的通道，而是被代理服务器所转发。<br>代理服务器作为网络中的媒介将互联网上获取的资源返回给相关的客户端。<br>我们通常所说的代理，一般都指的是「正向代理」，是相对于客户端来说的。<br>比方说我链接了一个VPN，我访问Google的时候，客户端发起的请求到了VPN，VPN帮忙转发请求Google的服务器，然后把Google响应返回给客户端。这个过程，VPN就充当了「正向代理服务器」的角色。</p>\n<p><img src=\"/image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png\" alt=\"代理服务器.png\"></p>\n<h3 id=\"反向代理-1\"><a href=\"#反向代理-1\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><p>和「正向代理」不同，「反向代理」的说法面向于服务器端。一个客户端请求来到代理服务器，代理服务器根据客户端的请求的不同而把请求转发到不同的服务器，这个过程在「负载均衡」中，也会发生两个一样的请求，会转发到完全不一样的服务器中的情况。<br>「反向代理」是「负载均衡」实现的前提，正因为代理服务器有了解析请求，分发请求的能力，才能实现负载均衡，降低每一台服务器的负荷。<br>利用「反向代理」，除了实现负载均衡，还可以实现诸如：SSL加密，静态内容缓存，gzip压缩，减速上传，安全等功能</p>\n<p><img src=\"/image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png\" alt=\"反向代理.png\"></p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>负载均衡（Load balancing）是一种计算机网络技术，用来在多个服务器中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。<br>使用带有负载均衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务的实现可以通过软件和硬件来实现。<br>负载均衡的分发，一般都会有多套算法来处理分发问题。</p>\n<h2 id=\"连接-Connection\"><a href=\"#连接-Connection\" class=\"headerlink\" title=\"连接 Connection\"></a>连接 Connection</h2><p>在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件。利用nginx封装的connection，我们可以很方便的使用nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。<br>而nginx中的http请求的处理就是建立在connection之上的，所以nginx不仅可以作为一个web服务器，也可以作为邮件服务器。<br>当然，利用nginx提供的connection，我们可以与任何后端服务打交道。</p>\n<h3 id=\"最大连接数\"><a href=\"#最大连接数\" class=\"headerlink\" title=\"最大连接数\"></a>最大连接数</h3><p>在nginx中，每个进程会有一个连接数的最大上限，这个上限与系统对fd的限制不一样。<br>在操作系统中，通过ulimit -n，我们可以得到一个进程所能够打开的fd的最大数，即nofile，因为每个socket连接会占用掉一个fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当fd用完后，再创建socket时，就会失败。<br>nginx通过设置<code>worker_connectons</code>来设置每个进程支持的最大连接数。如果该值大于nofile，那么实际的最大连接数是nofile，nginx会有警告。<br>nginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是<code>worker_connections</code>。这里的连接池里面保存的其实不是真实的连接，它只是一个<code>worker_connections</code>大小的一个<code>ngx_connection_t</code>结构的数组。并且，nginx会通过一个链表<code>free_connections</code>来保存所有的空闲<code>ngx_connection_t</code>，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。</p>\n<p>所以，一个nginx能建立的最大连接数：<code>worker_connections * worker_processes</code>，<br>如果当nginx作为反向代理的话，因为一个请求nginx要建立客户端和服务器的请求，所以最大连接数是：<code>worker_connections * worker_processes / 2</code></p>\n<h2 id=\"请求-Request\"><a href=\"#请求-Request\" class=\"headerlink\" title=\"请求 Request\"></a>请求 Request</h2><p>在nginx中我们指http请求，具体到nginx中的数据结构是<code>ngx_http_request_t</code>。<br>它是对一个http请求的封装，nginx通过<code>ngx_http_request_t</code>来保存解析请求与输出响应相关的数据。<br>一个http请求，包含请求行、请求头、请求体、响应行、响应头、响应体。</p>\n<p>一般性的网络请求处理过程是：</p>\n<ol>\n<li>客户端会发送请求过来。</li>\n<li>然后我们读取一行数据，分析出请求行中包含的method、uri、http_version信息。</li>\n<li>然后再一行一行处理请求头，并根据请求method与请求头的信息来决定是否有请求体以及请求体的长度，然后再去读取请求体。</li>\n<li>得到请求后，我们处理请求产生需要输出的数据，然后再生成响应行，响应头以及响应体。</li>\n<li>在将响应发送给客户端之后，一个完整的请求就处理完了。</li>\n</ol>\n<p>而nginx处理请求的时候会有一些小小的区别，比如，当请求头读取完成后，就开始进行请求的处理了。</p>\n<h3 id=\"Nginx处理请求过程\"><a href=\"#Nginx处理请求过程\" class=\"headerlink\" title=\"Nginx处理请求过程\"></a>Nginx处理请求过程</h3><p>nginx处理一个请求的抽象概念过程：</p>\n<ol>\n<li>request 请求进来</li>\n<li>初始化HTTP Request， 生成 HTTP Request对象</li>\n<li>处理请求头</li>\n<li>处理请求体</li>\n<li>调用与此请求关联的handler（根据你URL或者Location配置）</li>\n<li>依次调用各phase handler进行处理<ol>\n<li>获取location配置</li>\n<li>产生适当的响应</li>\n<li>发送response header</li>\n<li>发送response body</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"基本数据结构\"><a href=\"#基本数据结构\" class=\"headerlink\" title=\"基本数据结构\"></a>基本数据结构</h1><p>nginx的作者为追求极致的高效，自己实现了很多颇具特色的nginx风格的数据结构以及公共函数。比如，nginx提供了带长度的字符串，根据编译器选项优化过的字符串拷贝函数ngx_copy等。<br><em>ps: 下横线分割是C语言的变量名风格</em></p>\n<table>\n<thead>\n<tr>\n<th>Data Structure</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ngx_str_t</td>\n<td>字符串封装</td>\n</tr>\n<tr>\n<td>ngx_pool_t</td>\n<td>提供一种机制，帮助管理一系列的资源（内存，文件）</td>\n</tr>\n<tr>\n<td>ngx_array_t</td>\n<td>数组结构</td>\n</tr>\n<tr>\n<td>ngx_chain_t</td>\n<td>主要用于模块之间数据传递的链表实现</td>\n</tr>\n<tr>\n<td>ngx_buf_t</td>\n<td>就是ngx_chain_t链表的每个节点的实际实现，代表某种具体的数据。</td>\n</tr>\n<tr>\n<td>ngx_list_t</td>\n<td>list数据结构的实现，以及增强</td>\n</tr>\n<tr>\n<td>ngx_queue_t</td>\n<td>实现的双向链表</td>\n</tr>\n<tr>\n<td>ngx_hash_t</td>\n<td>hash表的实现</td>\n</tr>\n<tr>\n<td>ngx_hash_wildcard_t</td>\n<td>为处理带有通配符域名的匹配问题实现的hash表结构</td>\n</tr>\n<tr>\n<td>ngx_combinded_t</td>\n<td>在于提供一个方便的容器包含三个类型的hash表</td>\n</tr>\n<tr>\n<td>ngx_hash_keys_arrays_t</td>\n<td>用于构建其他类型的hash的辅助类</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>nginx的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于nginx安装目录下的conf目录下。<br>指令由nginx的各个模块提供，不同的模块会提供不同的指令来实现配置。<br>指令除了Key-Value的形式，还有作用域指令。<br>nginx.conf中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。</p>\n<p>下面的这些上下文指令是用的比较多：</p>\n<table>\n<thead>\n<tr>\n<th>Directive</th>\n<th>Description</th>\n<th>Contains Directive</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>main</td>\n<td>nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。</td>\n<td>user, worker_processes, error_log, events, http, mail</td>\n</tr>\n<tr>\n<td>http</td>\n<td>与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。</td>\n<td>server</td>\n</tr>\n<tr>\n<td>server</td>\n<td>http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server.每个server通过监听的地址来区分。</td>\n<td>listen, server_name, access_log, location, protocol, proxy, smtp_auth, xclient</td>\n</tr>\n<tr>\n<td>location</td>\n<td>http服务中，某些特定的URL对应的一系列配置项。</td>\n<td>index, root</td>\n</tr>\n<tr>\n<td>mail</td>\n<td>实现email相关的SMTP/IMAP/POP3代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。</td>\n<td>server, http, imap_capabilities</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1><p>nginx将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。例如，实现对请求解压缩的模块，实现SSI的模块，实现与上游服务器进行通讯的模块，实现与FastCGI服务进行通讯的模块。<br>模块分三类：</p>\n<ol>\n<li>核心模块</li>\n<li>辅助模块</li>\n<li>第三方模块</li>\n</ol>\n<p>根据官方文档排版，辅助模块还分了以下几类：</p>\n<ol>\n<li>http</li>\n<li>mail</li>\n<li>stream</li>\n</ol>\n<p>而根据其功能可以分成这几大类：</p>\n<ol>\n<li><strong>handler模块</strong><br>此类型的模块也被直接称为handler模块。主要负责处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。</li>\n<li><strong>filter模块</strong><br>过滤响应头和内容的模块，可以对回复的头和内容进行处理。它的处理时间在获取回复内容之后，向用户发送响应之前。</li>\n<li><strong>upstream模块</strong><br>upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream模块是一种特殊的handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。</li>\n<li><strong>load balance模块</strong><br>负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器</li>\n</ol>\n<h1 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h1><p>本文讲述了Nginx的一些基本概念。<br>Nginx是线程模型是Master-Worker模式的，每个worker是单线程的，也就是处理请求是单线程处理的。而单线程并发的事件模型是「异步非阻塞I/O」模型。<br>并且讲述了「反向代理」「负载均衡」的概念，这是nginx能高性能处理高并发的原因之一。<br>Nginx对于网络请求是有Connection和Request的概念和封装的。<br>Nginx的源码组织架构是模块化的，不同的模块实现不一样的职责，然后它们被连接起来一起干一件大事，知道模块有哪些分类，可以让我们知道怎么查找官方文档。<br>在没有看过有哪些指令，哪些指令有什么功能之前，是不能完全知道nginx提供什么样的功能的，那就抱着，那就抱着「能想到的别人都想到并实现了」的想法来使用nginx吧。Nginx作为一个代理服务，在中间想做什么都可以啦。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://tengine.taobao.org/book/chapter_04.html#id2\" target=\"_blank\" rel=\"external\">Nginx开发从入门到精通</a><br><a href=\"http://nginx.org/\" target=\"_blank\" rel=\"external\">Nginx官方网站</a><br><a href>《计算机操作系统》</a><br><a href>《深入浅出Node.js》</a></p>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本篇是我学习Nginx的一些笔记，主要内容讲述了一些了解Nginx需要的基本概念。<br>然后探讨一下Nginx的模块化的组织架构，以及各个模块的分类、工作方式、职责和提供的相关指令。<br>主要达到以下目的：</p>\n<ol>\n<li>了解Nginx的大概运行原理</li>\n<li>了解Nginx的基本概念</li>\n<li>知道怎么看官方文档。</li>\n</ol>\n<h1 id=\"关于Nginx\"><a href=\"#关于Nginx\" class=\"headerlink\" title=\"关于Nginx\"></a>关于Nginx</h1><p>Nginx是一款面向性能设计的HTTP服务器，能反向代理HTTP，HTTPS和邮件相关(SMTP，POP3，IMAP)的协议链接。并且提供了负载均衡以及HTTP缓存。<br>它的设计充分使用异步事件模型，削减上下文调度的开销，提高服务器并发能力。<br>采用了模块化设计，提供了丰富模块的第三方模块。<br>所以关于Nginx，有这些标签：「异步」「事件」「模块化」「高性能」「高并发」「反向代理」「负载均衡」</p>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><h2 id=\"进程模型\"><a href=\"#进程模型\" class=\"headerlink\" title=\"进程模型\"></a>进程模型</h2><p>Nginx的进程是使用经典的「Master-Worker」模型。<br>Nginx在启动后，会有一个master进程和多个worker进程。<br>master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。<br>worker进程主要处理基本的网络事件，多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。需要注意的是，每个Worker只有主线程，即所谓的「单线程」。<br>一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。<br>worker进程的个数是可以设置的，一般会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的。nginx为了更好的利用多核特性，提供了cpu亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。更多的worker数，只会导致进程来竞争cpu资源。</p>\n<p><img src=\"/image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png\" alt=\"Nginx 进程模型.png\"></p>\n<h2 id=\"事件模型\"><a href=\"#事件模型\" class=\"headerlink\" title=\"事件模型\"></a>事件模型</h2><p>Nginx对于事件，以「异步非阻塞」方式来实现。<br>异步和非异步，阻塞和非阻塞是两组不同的概念，前者更多对于应用程序而言，而后者更多对于CPU来说：</p>\n<ol>\n<li>异步：执行一个动作之后，可以去操作别的操作，然后等待通知再回来执行刚才没执行完的操作。</li>\n<li>非异步(同步)：执行一个操作之后，等待结果，然后才继续执行下面的操作。</li>\n<li>阻塞：给CPU传达任务之后，一直等待CPU处理完毕(即使会产生I/O)，然后才执行下面操作。</li>\n<li>非阻塞：给CPU传达任务之后，继续处理后面的操作，隔段时间再来询问之前的操作是否完成。这样的及过程也叫「轮询」</li>\n</ol>\n<p>Nginx的「异步非阻塞」方式，具体到系统调用的话，就是像select/poll/epoll/kqueue这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。</p>\n<p>epoll是在Linux上关于事件的实现，而kqueue是OpenBSD或FreeBSD操作系统上采用类似epoll的事件模型。<br>所以重点讲解一下epoll的模型：</p>\n<p><img src=\"/image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png\" alt=\"epoll事件模型.png\"></p>\n<p>该方案给是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进入休眠，直到事件将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。</p>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>要了解「反向代理」，首先需要知道什么是「代理服务器」和「正向代理」</p>\n<h3 id=\"代理服务器\"><a href=\"#代理服务器\" class=\"headerlink\" title=\"代理服务器\"></a>代理服务器</h3><p>在网络中，客户端发起一个请求，获取服务器端的资源。它们之间并不是建立一条直接的通道，而是被代理服务器所转发。<br>代理服务器作为网络中的媒介将互联网上获取的资源返回给相关的客户端。<br>我们通常所说的代理，一般都指的是「正向代理」，是相对于客户端来说的。<br>比方说我链接了一个VPN，我访问Google的时候，客户端发起的请求到了VPN，VPN帮忙转发请求Google的服务器，然后把Google响应返回给客户端。这个过程，VPN就充当了「正向代理服务器」的角色。</p>\n<p><img src=\"/image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png\" alt=\"代理服务器.png\"></p>\n<h3 id=\"反向代理-1\"><a href=\"#反向代理-1\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><p>和「正向代理」不同，「反向代理」的说法面向于服务器端。一个客户端请求来到代理服务器，代理服务器根据客户端的请求的不同而把请求转发到不同的服务器，这个过程在「负载均衡」中，也会发生两个一样的请求，会转发到完全不一样的服务器中的情况。<br>「反向代理」是「负载均衡」实现的前提，正因为代理服务器有了解析请求，分发请求的能力，才能实现负载均衡，降低每一台服务器的负荷。<br>利用「反向代理」，除了实现负载均衡，还可以实现诸如：SSL加密，静态内容缓存，gzip压缩，减速上传，安全等功能</p>\n<p><img src=\"/image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png\" alt=\"反向代理.png\"></p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>负载均衡（Load balancing）是一种计算机网络技术，用来在多个服务器中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。<br>使用带有负载均衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务的实现可以通过软件和硬件来实现。<br>负载均衡的分发，一般都会有多套算法来处理分发问题。</p>\n<h2 id=\"连接-Connection\"><a href=\"#连接-Connection\" class=\"headerlink\" title=\"连接 Connection\"></a>连接 Connection</h2><p>在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件。利用nginx封装的connection，我们可以很方便的使用nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。<br>而nginx中的http请求的处理就是建立在connection之上的，所以nginx不仅可以作为一个web服务器，也可以作为邮件服务器。<br>当然，利用nginx提供的connection，我们可以与任何后端服务打交道。</p>\n<h3 id=\"最大连接数\"><a href=\"#最大连接数\" class=\"headerlink\" title=\"最大连接数\"></a>最大连接数</h3><p>在nginx中，每个进程会有一个连接数的最大上限，这个上限与系统对fd的限制不一样。<br>在操作系统中，通过ulimit -n，我们可以得到一个进程所能够打开的fd的最大数，即nofile，因为每个socket连接会占用掉一个fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当fd用完后，再创建socket时，就会失败。<br>nginx通过设置<code>worker_connectons</code>来设置每个进程支持的最大连接数。如果该值大于nofile，那么实际的最大连接数是nofile，nginx会有警告。<br>nginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是<code>worker_connections</code>。这里的连接池里面保存的其实不是真实的连接，它只是一个<code>worker_connections</code>大小的一个<code>ngx_connection_t</code>结构的数组。并且，nginx会通过一个链表<code>free_connections</code>来保存所有的空闲<code>ngx_connection_t</code>，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。</p>\n<p>所以，一个nginx能建立的最大连接数：<code>worker_connections * worker_processes</code>，<br>如果当nginx作为反向代理的话，因为一个请求nginx要建立客户端和服务器的请求，所以最大连接数是：<code>worker_connections * worker_processes / 2</code></p>\n<h2 id=\"请求-Request\"><a href=\"#请求-Request\" class=\"headerlink\" title=\"请求 Request\"></a>请求 Request</h2><p>在nginx中我们指http请求，具体到nginx中的数据结构是<code>ngx_http_request_t</code>。<br>它是对一个http请求的封装，nginx通过<code>ngx_http_request_t</code>来保存解析请求与输出响应相关的数据。<br>一个http请求，包含请求行、请求头、请求体、响应行、响应头、响应体。</p>\n<p>一般性的网络请求处理过程是：</p>\n<ol>\n<li>客户端会发送请求过来。</li>\n<li>然后我们读取一行数据，分析出请求行中包含的method、uri、http_version信息。</li>\n<li>然后再一行一行处理请求头，并根据请求method与请求头的信息来决定是否有请求体以及请求体的长度，然后再去读取请求体。</li>\n<li>得到请求后，我们处理请求产生需要输出的数据，然后再生成响应行，响应头以及响应体。</li>\n<li>在将响应发送给客户端之后，一个完整的请求就处理完了。</li>\n</ol>\n<p>而nginx处理请求的时候会有一些小小的区别，比如，当请求头读取完成后，就开始进行请求的处理了。</p>\n<h3 id=\"Nginx处理请求过程\"><a href=\"#Nginx处理请求过程\" class=\"headerlink\" title=\"Nginx处理请求过程\"></a>Nginx处理请求过程</h3><p>nginx处理一个请求的抽象概念过程：</p>\n<ol>\n<li>request 请求进来</li>\n<li>初始化HTTP Request， 生成 HTTP Request对象</li>\n<li>处理请求头</li>\n<li>处理请求体</li>\n<li>调用与此请求关联的handler（根据你URL或者Location配置）</li>\n<li>依次调用各phase handler进行处理<ol>\n<li>获取location配置</li>\n<li>产生适当的响应</li>\n<li>发送response header</li>\n<li>发送response body</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"基本数据结构\"><a href=\"#基本数据结构\" class=\"headerlink\" title=\"基本数据结构\"></a>基本数据结构</h1><p>nginx的作者为追求极致的高效，自己实现了很多颇具特色的nginx风格的数据结构以及公共函数。比如，nginx提供了带长度的字符串，根据编译器选项优化过的字符串拷贝函数ngx_copy等。<br><em>ps: 下横线分割是C语言的变量名风格</em></p>\n<table>\n<thead>\n<tr>\n<th>Data Structure</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ngx_str_t</td>\n<td>字符串封装</td>\n</tr>\n<tr>\n<td>ngx_pool_t</td>\n<td>提供一种机制，帮助管理一系列的资源（内存，文件）</td>\n</tr>\n<tr>\n<td>ngx_array_t</td>\n<td>数组结构</td>\n</tr>\n<tr>\n<td>ngx_chain_t</td>\n<td>主要用于模块之间数据传递的链表实现</td>\n</tr>\n<tr>\n<td>ngx_buf_t</td>\n<td>就是ngx_chain_t链表的每个节点的实际实现，代表某种具体的数据。</td>\n</tr>\n<tr>\n<td>ngx_list_t</td>\n<td>list数据结构的实现，以及增强</td>\n</tr>\n<tr>\n<td>ngx_queue_t</td>\n<td>实现的双向链表</td>\n</tr>\n<tr>\n<td>ngx_hash_t</td>\n<td>hash表的实现</td>\n</tr>\n<tr>\n<td>ngx_hash_wildcard_t</td>\n<td>为处理带有通配符域名的匹配问题实现的hash表结构</td>\n</tr>\n<tr>\n<td>ngx_combinded_t</td>\n<td>在于提供一个方便的容器包含三个类型的hash表</td>\n</tr>\n<tr>\n<td>ngx_hash_keys_arrays_t</td>\n<td>用于构建其他类型的hash的辅助类</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>nginx的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于nginx安装目录下的conf目录下。<br>指令由nginx的各个模块提供，不同的模块会提供不同的指令来实现配置。<br>指令除了Key-Value的形式，还有作用域指令。<br>nginx.conf中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。</p>\n<p>下面的这些上下文指令是用的比较多：</p>\n<table>\n<thead>\n<tr>\n<th>Directive</th>\n<th>Description</th>\n<th>Contains Directive</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>main</td>\n<td>nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。</td>\n<td>user, worker_processes, error_log, events, http, mail</td>\n</tr>\n<tr>\n<td>http</td>\n<td>与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。</td>\n<td>server</td>\n</tr>\n<tr>\n<td>server</td>\n<td>http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server.每个server通过监听的地址来区分。</td>\n<td>listen, server_name, access_log, location, protocol, proxy, smtp_auth, xclient</td>\n</tr>\n<tr>\n<td>location</td>\n<td>http服务中，某些特定的URL对应的一系列配置项。</td>\n<td>index, root</td>\n</tr>\n<tr>\n<td>mail</td>\n<td>实现email相关的SMTP/IMAP/POP3代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。</td>\n<td>server, http, imap_capabilities</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1><p>nginx将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。例如，实现对请求解压缩的模块，实现SSI的模块，实现与上游服务器进行通讯的模块，实现与FastCGI服务进行通讯的模块。<br>模块分三类：</p>\n<ol>\n<li>核心模块</li>\n<li>辅助模块</li>\n<li>第三方模块</li>\n</ol>\n<p>根据官方文档排版，辅助模块还分了以下几类：</p>\n<ol>\n<li>http</li>\n<li>mail</li>\n<li>stream</li>\n</ol>\n<p>而根据其功能可以分成这几大类：</p>\n<ol>\n<li><strong>handler模块</strong><br>此类型的模块也被直接称为handler模块。主要负责处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。</li>\n<li><strong>filter模块</strong><br>过滤响应头和内容的模块，可以对回复的头和内容进行处理。它的处理时间在获取回复内容之后，向用户发送响应之前。</li>\n<li><strong>upstream模块</strong><br>upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream模块是一种特殊的handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。</li>\n<li><strong>load balance模块</strong><br>负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器</li>\n</ol>\n<h1 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h1><p>本文讲述了Nginx的一些基本概念。<br>Nginx是线程模型是Master-Worker模式的，每个worker是单线程的，也就是处理请求是单线程处理的。而单线程并发的事件模型是「异步非阻塞I/O」模型。<br>并且讲述了「反向代理」「负载均衡」的概念，这是nginx能高性能处理高并发的原因之一。<br>Nginx对于网络请求是有Connection和Request的概念和封装的。<br>Nginx的源码组织架构是模块化的，不同的模块实现不一样的职责，然后它们被连接起来一起干一件大事，知道模块有哪些分类，可以让我们知道怎么查找官方文档。<br>在没有看过有哪些指令，哪些指令有什么功能之前，是不能完全知道nginx提供什么样的功能的，那就抱着，那就抱着「能想到的别人都想到并实现了」的想法来使用nginx吧。Nginx作为一个代理服务，在中间想做什么都可以啦。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://tengine.taobao.org/book/chapter_04.html#id2\">Nginx开发从入门到精通</a><br><a href=\"http://nginx.org/\">Nginx官方网站</a><br><a href=\"\">《计算机操作系统》</a><br><a href=\"\">《深入浅出Node.js》</a></p>\n"},{"title":"为什么使用Sails","date":"2015-04-25T08:35:04.000Z","_content":"\n## 前言\n入手Node.js半年，从用Express开发自己的博客到用Sails开发公司项目，深深被Sails震撼了。Sails是Balderdash团队的产品，快速的项目构建、优秀的框架结构还有众多的扩展，让我有种相见恨晚的感觉。在Koa流行之前，个人认为Sails的用户量还是挺可观的。今天，我想写一写Sails那些让我感动的地方，顺便理顺一下Sails的架构。\n\n#### 目录\n\n> * 一步搭建项目\n> * 项目架构\n> * ORM\n> * MVC的实现\n> * 路由\n> * 安全\n> * 日志\n> * 单元测试\n> * WebSocket\n\n## 一步搭建项目\n> 在安装了Node.js 和 Sails的环境下，只需要一条命令，就能够搭建一个拥有完整架构的项目，尽管这很简单，我还是觉得有必要说一下。\n\n在已经安装了Node.js和npm的前提下，首先你需要全局下安装Sails\n`$ sudo npm install sails -g`\n\n其次在一个空路径下，新建一个项目\n`$ sails new newApp`\n\n最后，只需要前往项目路径，把项目运行起来\n`$ cd testProject`\n`$ sails lift`\n\n访问 `http://localhost:1337`就能看到一个新的项目\n\n![new app](http://xia-dev.b0.upaiyun.com/64f9a65d-294f-43e6-984a-77dc2818ecc4.png)\n\n## 项目架构\n```\n.\n├── api\n│   ├── controllers\n│   ├── models\n│   ├── policies\n│   ├── responses\n│   └── services\n├── views\n├── assets\n├── config\n├── tasks\n├── node_modules\n├── package.json\n├── Gruntfile.js\n├── README.md\n└── app.js\n```\n\n### `api/`\n`api` 目录下是你要构建应用的核心所在，常说的MVC的设计结构就体现在这里\n`api/controllers` ：控制层，该层是Http请求的入口。Sails官方建议该层只处理请求的转发和页面的渲染，具体的逻辑实现应该交给Service层。\n`api/models`：模型层，在Sails中，对于Model采用的是充血模型，除了可以在模型中定于属性之外，还可以定义包含逻辑处理的函数。在Sails中，所有Model都可以全局性访问。\n`api/policies`：过滤层，该层在Controller层之前对Http请求做处理，在这一层中，可以定于一些规则来过滤Http请求，比如身份认证什么的。\n`api/responses`：http响应的方法都放这里，例如服务器错误、请求错误、404错误等，定义在responses文件夹里面的方法，都会赋值到controller层的req对象中。\n`api/services`：服务层，该层包含逻辑处理的方法，在Sails中，所有Service都可以全局性访问。\n\n### `views/`\n视图层，存放视图模版文件的地方，Sails默认是提供ejs模版引擎的，如果你愿意，你可以换成jade、handlebars或者任何你喜欢的模版引擎。\n\n### `assets/`\n资源文件夹，在Sails启动的时候，会启动某一个Grunt任务，把assets文件夹里的内容或压缩或编译或复制到根目录下的`.tmp`目录，这是前端可以直接通过路由访问的资源，HTML、JS、CSS以及图片等静态资源都放在这里了。\n\n### `config/`\n配置文件夹，在Sails启动的时候，会加载该文件夹里的文件，并赋值在全局对象`sails.config`中，所以能够在任何一个地方都能用到。在用Sails开发，会经常跟这个文件夹里的文件打交道，从config的构成很容易知道Sails都提供哪方面的功能。\n\n### `tasks/`\nSails自带的项目自动化工具是`Grunt`，而Grunt的配置和任务注册都放在这个文件夹里了。这里已经提供了通常会用到的CSS编译、JS压缩、文件合并，更改检测等等任务，当然如果没有自己需要的，还能扩展。\n\n### `app.js`\nSails的启动文件，无论是`$ sails lift`命令或者`$ npm start`命令都会运行该文件。\n\n## ORM\n开发了Sails的团队Balderdash，还开发了一套ORM框架：Waterline。    \nWaterline在Sails主要的舞台是在`/api/models`目录里，在这里定义的模型文件，在Sails启动的时候，都要经由Waterline的洗礼。    \nWaterline 是通过Adapter关联数据库的，不同的Adapter关联不同的数据库。    \nWaterline 能适配绝对部分数据库，大致分类两类，一类是官方团队开发的 Adapter适配的，一类是民间开发者开发的Adapter适配的：    \n官方支持的:    \n* PostgreSQL    \n* MySQL    \n* MongoDB    \n* Redis    \n* Disk    \n* Memory    \n\n民间开发的：    \n* SQLServer    \n* OrientDB  \n* Oracle    \n* Cassandra    \n\n关于Waterline的更多信息可以关注：    \n[github:waterline](https://github.com/balderdashy/waterline)    \n[github:waterline-docs](https://github.com/balderdashy/waterline)\n\n## MVC的实现\n在这一段我想不仅仅要谈论到Model层、View层和Controller层，我认为还有必要谈到Service层、和Policy层。\n\n##### Model层\n模型文件定义到`/api/models`中，由Waterline驱动，所有model都能全局访问。Sails提供命令行创建model的命令：`$ sails generate model MODEL_NAME`\n##### View层\n实现在`/views`中，除了默认提供的ejs模版引擎之外，还能更换成jade、handlebars等模版引擎\n##### Controller层\n在`/api/controller`目录里，Sails中提供创建controller的命令：`$ sails generate controller CONTROLLER_NAME`。Sails也提供同时创建model和对应的Controller的命令：`$ sails generate api API_NAME`。\n##### Service层\n在`/api/services`目录里，存放自定义的服务，所有service都能够全局访问，Sails官方的建议是把逻辑处理都放在该层中，Controller层只做路由的分发和轻逻辑的处理。\n##### Policy层\n在`/api/policies`目录里，存放自定义的过滤器。该层是一条请求在到达Controller之前根据需求过滤请求的中间层。在`/api/policies`目录中定义的文件，还需要在`config/policies.js`文件中为需求应用到某一过滤器的Action配置。\n\n\n## 路由\nSails中要理解路由，首先要记得这个名词`blueprint`，中文翻译为：蓝图。我不知道官方是否解释过为什么要用个单词，但以我的理解，Sails的blueprint是负责指挥每一条客户端请求应该分配到服务器端的哪个Action去，所以叫蓝图吧。\nblueprint主要分为三种：`RESTful routes`、`Shortcut routes`、`Action routes`。\n\n##### RESTful routes\n当路径诸如：`/:modelIdentity` 或者 `/:modelIdentity/:id`的时候，blueprint会根据HTTP的动作（GET、POST、DELETE、PUT等）来分配到相应的Controller下相应的Action来处理。例如一个POST请求`/user`会创建一个用户，一个DELETE请求`/user/123`会删除`id`为123的用户。\n\n##### Shortcut routes\n这种路由主要是方便开发，请求的参数可以直接写在请求路径中，例如`/user/create?name=joe`会创建一个新的用户，`/user/update/1?name=mike`会更新`id`为1的用户的名字。shortcut routes在开发环境很便利，但是在生产环境下需要关闭。\n\n##### Action routes\n这种路由会自动的为Controller层的每一个Action创建一个路由，例如你的Controller层有一个`FooController.js`，里面有一个Action`bar`，那么请求`/foo/bar`就会分配到`bar`Action。\n\n当然Sails也会提供自定义的路由，用户可以在`config/routes.js`和`config/polices.js`这两个配置文件中选择关闭或者打开blueprint提供的路由，和定义自己的路由。\n\n## 安全\n要确保产品的安全性，要对几种常见的攻击和安全策略了如指掌，诸如CORS、CSRF、DDOS、XSS等。Sails对于常见的安全策略都有提供支持，且只需要通过相关的配置文件就可以控制安全策略的等级。深入探讨Web的安全策略，并不在本文的范畴内，日后我会以这个为题写一篇文章聊聊Web的安全。\n想要了解更多Sails的安全策略可以看看这里：[sails: security](http://sailsjs.org/#!/documentation/concepts/Security)\n## 日志\nSails提供了一个全局对象`sails.log`用来处理日志信息的输出，日志是分level的，在`config/log.js`中配置日志输出的level，而level的作用看下表：\n\n| Priority              | level                  | Log fns visible |\n| :------------- |:-------------:| :-----:|\n| 0\t|silent\t|N/A |\n|1\t|error\t|.error()|\n|2\t|warn\t|.warn(), .error()|\n|3\t|debug\t|.debug(), .warn(), .error()|\n|4\t|info         |.info(), .debug(), .warn(), .error()|\n|5\t|verbose\t|.verbose(), .info(), .debug(), .warn(), .error()|\n|6\t|silly\t        |.silly(), .verbose(), .info(), .debug(), .warn(), .error()|\n\nSails的日志管理默认是info层的，既会输出.info(), .debug(), .warn(), .error()的信息。\n\n## 单元测试\nSails使用了mocha进行单元测试，在新建Sails项目的时候，没有创建单元测试的文件夹，需要自己手动构造单元测试目录，官方建议的目录是这样的：\n\n```\n.\n├── api\n├── assets\n├── ...\n├── test\n│  ├── unit\n│  │  ├── controllers\n│  │  │  └── UsersController.test.js\n│  │  ├── models\n│  │  │  └── Users.test.js\n│  │  └── ...\n│  ├── fixtures\n│  ├── ...\n│  ├── bootstrap.test.js\n│  └── mocha.opts\n└── views\n```\n而我在单元测试常用的组合是：[mocha](https://github.com/mochajs/mocha)、[should](https://github.com/tj/should.js)、[supertest](https://github.com/visionmedia/supertest)、 [istanbul](https://github.com/gotwarlost/istanbul) \n其中should是提供断言，supertest是用于测试Controller层的时候伪造http请求的，而istanbul则是提供测试代码覆盖率的。\n关于怎么在Sails中编写测试代码，可以参考 [sails:testing](http://sailsjs.org/#!/documentation/concepts/Testing)\n\n## WebSocket\n对于有即时性通讯需求的Web应用，我们会用Socket，Sails也为这方面提供了支持。在客户端提供js文件：`sails.io.js`，而在服务器端提供全局对象：`sails.sockets`。通过这两个对象，就可以进行客户端和服务器端即时性通讯的开发了。\nSails默认会启动WebSocket功能，在客户端访问服务器端的时候，会自动尝试在同域名下连接socket。\n值得注意的是，这样会对AngularJS、EmberJS等前端MVVC开发产生一些障碍。\n比如进行AngularJS开发的时候，我们在`http://localhost:9000`跑AngularJS项目，而服务器端却跑在`http://localhost:1337`。\n当访问`http://localhost:9000`的时候，`sails.io.js`会尝试于当前路径下进行socket连接，也就是`http://localhost:9000`，这时会出错，因为服务器是跑在`http://localhost:1337`的。\n在开发的时候要解决这样的问题的时候，我们只需要在AngularJS这边引入`sails.io.js`之后定义连接路径就行了：\n\n``` javascript\n<script src=\"scripts/lib/sails.io.js\"></script>\n<script>io.sails.url = \"http://localhost:1337\";</script>\n```\n\n## 结语\n可以说Sails涵盖了Web开发中会遇到的绝大部分需求和问题，如果深入研究Sails的话，是受益匪浅的。\n\n","source":"_posts/为什么使用Sails.md","raw":"---\ntitle: 为什么使用Sails\ncategory: 搬砖码农\ndate: 2015-04-25 16:35:04\ntags: \n- SailsJS\n- Nodejs\n---\n\n## 前言\n入手Node.js半年，从用Express开发自己的博客到用Sails开发公司项目，深深被Sails震撼了。Sails是Balderdash团队的产品，快速的项目构建、优秀的框架结构还有众多的扩展，让我有种相见恨晚的感觉。在Koa流行之前，个人认为Sails的用户量还是挺可观的。今天，我想写一写Sails那些让我感动的地方，顺便理顺一下Sails的架构。\n\n#### 目录\n\n> * 一步搭建项目\n> * 项目架构\n> * ORM\n> * MVC的实现\n> * 路由\n> * 安全\n> * 日志\n> * 单元测试\n> * WebSocket\n\n## 一步搭建项目\n> 在安装了Node.js 和 Sails的环境下，只需要一条命令，就能够搭建一个拥有完整架构的项目，尽管这很简单，我还是觉得有必要说一下。\n\n在已经安装了Node.js和npm的前提下，首先你需要全局下安装Sails\n`$ sudo npm install sails -g`\n\n其次在一个空路径下，新建一个项目\n`$ sails new newApp`\n\n最后，只需要前往项目路径，把项目运行起来\n`$ cd testProject`\n`$ sails lift`\n\n访问 `http://localhost:1337`就能看到一个新的项目\n\n![new app](http://xia-dev.b0.upaiyun.com/64f9a65d-294f-43e6-984a-77dc2818ecc4.png)\n\n## 项目架构\n```\n.\n├── api\n│   ├── controllers\n│   ├── models\n│   ├── policies\n│   ├── responses\n│   └── services\n├── views\n├── assets\n├── config\n├── tasks\n├── node_modules\n├── package.json\n├── Gruntfile.js\n├── README.md\n└── app.js\n```\n\n### `api/`\n`api` 目录下是你要构建应用的核心所在，常说的MVC的设计结构就体现在这里\n`api/controllers` ：控制层，该层是Http请求的入口。Sails官方建议该层只处理请求的转发和页面的渲染，具体的逻辑实现应该交给Service层。\n`api/models`：模型层，在Sails中，对于Model采用的是充血模型，除了可以在模型中定于属性之外，还可以定义包含逻辑处理的函数。在Sails中，所有Model都可以全局性访问。\n`api/policies`：过滤层，该层在Controller层之前对Http请求做处理，在这一层中，可以定于一些规则来过滤Http请求，比如身份认证什么的。\n`api/responses`：http响应的方法都放这里，例如服务器错误、请求错误、404错误等，定义在responses文件夹里面的方法，都会赋值到controller层的req对象中。\n`api/services`：服务层，该层包含逻辑处理的方法，在Sails中，所有Service都可以全局性访问。\n\n### `views/`\n视图层，存放视图模版文件的地方，Sails默认是提供ejs模版引擎的，如果你愿意，你可以换成jade、handlebars或者任何你喜欢的模版引擎。\n\n### `assets/`\n资源文件夹，在Sails启动的时候，会启动某一个Grunt任务，把assets文件夹里的内容或压缩或编译或复制到根目录下的`.tmp`目录，这是前端可以直接通过路由访问的资源，HTML、JS、CSS以及图片等静态资源都放在这里了。\n\n### `config/`\n配置文件夹，在Sails启动的时候，会加载该文件夹里的文件，并赋值在全局对象`sails.config`中，所以能够在任何一个地方都能用到。在用Sails开发，会经常跟这个文件夹里的文件打交道，从config的构成很容易知道Sails都提供哪方面的功能。\n\n### `tasks/`\nSails自带的项目自动化工具是`Grunt`，而Grunt的配置和任务注册都放在这个文件夹里了。这里已经提供了通常会用到的CSS编译、JS压缩、文件合并，更改检测等等任务，当然如果没有自己需要的，还能扩展。\n\n### `app.js`\nSails的启动文件，无论是`$ sails lift`命令或者`$ npm start`命令都会运行该文件。\n\n## ORM\n开发了Sails的团队Balderdash，还开发了一套ORM框架：Waterline。    \nWaterline在Sails主要的舞台是在`/api/models`目录里，在这里定义的模型文件，在Sails启动的时候，都要经由Waterline的洗礼。    \nWaterline 是通过Adapter关联数据库的，不同的Adapter关联不同的数据库。    \nWaterline 能适配绝对部分数据库，大致分类两类，一类是官方团队开发的 Adapter适配的，一类是民间开发者开发的Adapter适配的：    \n官方支持的:    \n* PostgreSQL    \n* MySQL    \n* MongoDB    \n* Redis    \n* Disk    \n* Memory    \n\n民间开发的：    \n* SQLServer    \n* OrientDB  \n* Oracle    \n* Cassandra    \n\n关于Waterline的更多信息可以关注：    \n[github:waterline](https://github.com/balderdashy/waterline)    \n[github:waterline-docs](https://github.com/balderdashy/waterline)\n\n## MVC的实现\n在这一段我想不仅仅要谈论到Model层、View层和Controller层，我认为还有必要谈到Service层、和Policy层。\n\n##### Model层\n模型文件定义到`/api/models`中，由Waterline驱动，所有model都能全局访问。Sails提供命令行创建model的命令：`$ sails generate model MODEL_NAME`\n##### View层\n实现在`/views`中，除了默认提供的ejs模版引擎之外，还能更换成jade、handlebars等模版引擎\n##### Controller层\n在`/api/controller`目录里，Sails中提供创建controller的命令：`$ sails generate controller CONTROLLER_NAME`。Sails也提供同时创建model和对应的Controller的命令：`$ sails generate api API_NAME`。\n##### Service层\n在`/api/services`目录里，存放自定义的服务，所有service都能够全局访问，Sails官方的建议是把逻辑处理都放在该层中，Controller层只做路由的分发和轻逻辑的处理。\n##### Policy层\n在`/api/policies`目录里，存放自定义的过滤器。该层是一条请求在到达Controller之前根据需求过滤请求的中间层。在`/api/policies`目录中定义的文件，还需要在`config/policies.js`文件中为需求应用到某一过滤器的Action配置。\n\n\n## 路由\nSails中要理解路由，首先要记得这个名词`blueprint`，中文翻译为：蓝图。我不知道官方是否解释过为什么要用个单词，但以我的理解，Sails的blueprint是负责指挥每一条客户端请求应该分配到服务器端的哪个Action去，所以叫蓝图吧。\nblueprint主要分为三种：`RESTful routes`、`Shortcut routes`、`Action routes`。\n\n##### RESTful routes\n当路径诸如：`/:modelIdentity` 或者 `/:modelIdentity/:id`的时候，blueprint会根据HTTP的动作（GET、POST、DELETE、PUT等）来分配到相应的Controller下相应的Action来处理。例如一个POST请求`/user`会创建一个用户，一个DELETE请求`/user/123`会删除`id`为123的用户。\n\n##### Shortcut routes\n这种路由主要是方便开发，请求的参数可以直接写在请求路径中，例如`/user/create?name=joe`会创建一个新的用户，`/user/update/1?name=mike`会更新`id`为1的用户的名字。shortcut routes在开发环境很便利，但是在生产环境下需要关闭。\n\n##### Action routes\n这种路由会自动的为Controller层的每一个Action创建一个路由，例如你的Controller层有一个`FooController.js`，里面有一个Action`bar`，那么请求`/foo/bar`就会分配到`bar`Action。\n\n当然Sails也会提供自定义的路由，用户可以在`config/routes.js`和`config/polices.js`这两个配置文件中选择关闭或者打开blueprint提供的路由，和定义自己的路由。\n\n## 安全\n要确保产品的安全性，要对几种常见的攻击和安全策略了如指掌，诸如CORS、CSRF、DDOS、XSS等。Sails对于常见的安全策略都有提供支持，且只需要通过相关的配置文件就可以控制安全策略的等级。深入探讨Web的安全策略，并不在本文的范畴内，日后我会以这个为题写一篇文章聊聊Web的安全。\n想要了解更多Sails的安全策略可以看看这里：[sails: security](http://sailsjs.org/#!/documentation/concepts/Security)\n## 日志\nSails提供了一个全局对象`sails.log`用来处理日志信息的输出，日志是分level的，在`config/log.js`中配置日志输出的level，而level的作用看下表：\n\n| Priority              | level                  | Log fns visible |\n| :------------- |:-------------:| :-----:|\n| 0\t|silent\t|N/A |\n|1\t|error\t|.error()|\n|2\t|warn\t|.warn(), .error()|\n|3\t|debug\t|.debug(), .warn(), .error()|\n|4\t|info         |.info(), .debug(), .warn(), .error()|\n|5\t|verbose\t|.verbose(), .info(), .debug(), .warn(), .error()|\n|6\t|silly\t        |.silly(), .verbose(), .info(), .debug(), .warn(), .error()|\n\nSails的日志管理默认是info层的，既会输出.info(), .debug(), .warn(), .error()的信息。\n\n## 单元测试\nSails使用了mocha进行单元测试，在新建Sails项目的时候，没有创建单元测试的文件夹，需要自己手动构造单元测试目录，官方建议的目录是这样的：\n\n```\n.\n├── api\n├── assets\n├── ...\n├── test\n│  ├── unit\n│  │  ├── controllers\n│  │  │  └── UsersController.test.js\n│  │  ├── models\n│  │  │  └── Users.test.js\n│  │  └── ...\n│  ├── fixtures\n│  ├── ...\n│  ├── bootstrap.test.js\n│  └── mocha.opts\n└── views\n```\n而我在单元测试常用的组合是：[mocha](https://github.com/mochajs/mocha)、[should](https://github.com/tj/should.js)、[supertest](https://github.com/visionmedia/supertest)、 [istanbul](https://github.com/gotwarlost/istanbul) \n其中should是提供断言，supertest是用于测试Controller层的时候伪造http请求的，而istanbul则是提供测试代码覆盖率的。\n关于怎么在Sails中编写测试代码，可以参考 [sails:testing](http://sailsjs.org/#!/documentation/concepts/Testing)\n\n## WebSocket\n对于有即时性通讯需求的Web应用，我们会用Socket，Sails也为这方面提供了支持。在客户端提供js文件：`sails.io.js`，而在服务器端提供全局对象：`sails.sockets`。通过这两个对象，就可以进行客户端和服务器端即时性通讯的开发了。\nSails默认会启动WebSocket功能，在客户端访问服务器端的时候，会自动尝试在同域名下连接socket。\n值得注意的是，这样会对AngularJS、EmberJS等前端MVVC开发产生一些障碍。\n比如进行AngularJS开发的时候，我们在`http://localhost:9000`跑AngularJS项目，而服务器端却跑在`http://localhost:1337`。\n当访问`http://localhost:9000`的时候，`sails.io.js`会尝试于当前路径下进行socket连接，也就是`http://localhost:9000`，这时会出错，因为服务器是跑在`http://localhost:1337`的。\n在开发的时候要解决这样的问题的时候，我们只需要在AngularJS这边引入`sails.io.js`之后定义连接路径就行了：\n\n``` javascript\n<script src=\"scripts/lib/sails.io.js\"></script>\n<script>io.sails.url = \"http://localhost:1337\";</script>\n```\n\n## 结语\n可以说Sails涵盖了Web开发中会遇到的绝大部分需求和问题，如果深入研究Sails的话，是受益匪浅的。\n\n","slug":"为什么使用Sails","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8s6002uxwrll10yi4hg","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>入手Node.js半年，从用Express开发自己的博客到用Sails开发公司项目，深深被Sails震撼了。Sails是Balderdash团队的产品，快速的项目构建、优秀的框架结构还有众多的扩展，让我有种相见恨晚的感觉。在Koa流行之前，个人认为Sails的用户量还是挺可观的。今天，我想写一写Sails那些让我感动的地方，顺便理顺一下Sails的架构。</p>\n<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<ul>\n<li>一步搭建项目</li>\n<li>项目架构</li>\n<li>ORM</li>\n<li>MVC的实现</li>\n<li>路由</li>\n<li>安全</li>\n<li>日志</li>\n<li>单元测试</li>\n<li>WebSocket</li>\n</ul>\n</blockquote>\n<h2 id=\"一步搭建项目\"><a href=\"#一步搭建项目\" class=\"headerlink\" title=\"一步搭建项目\"></a>一步搭建项目</h2><blockquote>\n<p>在安装了Node.js 和 Sails的环境下，只需要一条命令，就能够搭建一个拥有完整架构的项目，尽管这很简单，我还是觉得有必要说一下。</p>\n</blockquote>\n<p>在已经安装了Node.js和npm的前提下，首先你需要全局下安装Sails<br><code>$ sudo npm install sails -g</code></p>\n<p>其次在一个空路径下，新建一个项目<br><code>$ sails new newApp</code></p>\n<p>最后，只需要前往项目路径，把项目运行起来<br><code>$ cd testProject</code><br><code>$ sails lift</code></p>\n<p>访问 <code>http://localhost:1337</code>就能看到一个新的项目</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/64f9a65d-294f-43e6-984a-77dc2818ecc4.png\" alt=\"new app\"></p>\n<h2 id=\"项目架构\"><a href=\"#项目架构\" class=\"headerlink\" title=\"项目架构\"></a>项目架构</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── api</span><br><span class=\"line\">│   ├── controllers</span><br><span class=\"line\">│   ├── models</span><br><span class=\"line\">│   ├── policies</span><br><span class=\"line\">│   ├── responses</span><br><span class=\"line\">│   └── services</span><br><span class=\"line\">├── views</span><br><span class=\"line\">├── assets</span><br><span class=\"line\">├── config</span><br><span class=\"line\">├── tasks</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── Gruntfile.js</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">└── app.js</span><br></pre></td></tr></table></figure>\n<h3 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api/\"></a><code>api/</code></h3><p><code>api</code> 目录下是你要构建应用的核心所在，常说的MVC的设计结构就体现在这里<br><code>api/controllers</code> ：控制层，该层是Http请求的入口。Sails官方建议该层只处理请求的转发和页面的渲染，具体的逻辑实现应该交给Service层。<br><code>api/models</code>：模型层，在Sails中，对于Model采用的是充血模型，除了可以在模型中定于属性之外，还可以定义包含逻辑处理的函数。在Sails中，所有Model都可以全局性访问。<br><code>api/policies</code>：过滤层，该层在Controller层之前对Http请求做处理，在这一层中，可以定于一些规则来过滤Http请求，比如身份认证什么的。<br><code>api/responses</code>：http响应的方法都放这里，例如服务器错误、请求错误、404错误等，定义在responses文件夹里面的方法，都会赋值到controller层的req对象中。<br><code>api/services</code>：服务层，该层包含逻辑处理的方法，在Sails中，所有Service都可以全局性访问。</p>\n<h3 id=\"views\"><a href=\"#views\" class=\"headerlink\" title=\"views/\"></a><code>views/</code></h3><p>视图层，存放视图模版文件的地方，Sails默认是提供ejs模版引擎的，如果你愿意，你可以换成jade、handlebars或者任何你喜欢的模版引擎。</p>\n<h3 id=\"assets\"><a href=\"#assets\" class=\"headerlink\" title=\"assets/\"></a><code>assets/</code></h3><p>资源文件夹，在Sails启动的时候，会启动某一个Grunt任务，把assets文件夹里的内容或压缩或编译或复制到根目录下的<code>.tmp</code>目录，这是前端可以直接通过路由访问的资源，HTML、JS、CSS以及图片等静态资源都放在这里了。</p>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config/\"></a><code>config/</code></h3><p>配置文件夹，在Sails启动的时候，会加载该文件夹里的文件，并赋值在全局对象<code>sails.config</code>中，所以能够在任何一个地方都能用到。在用Sails开发，会经常跟这个文件夹里的文件打交道，从config的构成很容易知道Sails都提供哪方面的功能。</p>\n<h3 id=\"tasks\"><a href=\"#tasks\" class=\"headerlink\" title=\"tasks/\"></a><code>tasks/</code></h3><p>Sails自带的项目自动化工具是<code>Grunt</code>，而Grunt的配置和任务注册都放在这个文件夹里了。这里已经提供了通常会用到的CSS编译、JS压缩、文件合并，更改检测等等任务，当然如果没有自己需要的，还能扩展。</p>\n<h3 id=\"app-js\"><a href=\"#app-js\" class=\"headerlink\" title=\"app.js\"></a><code>app.js</code></h3><p>Sails的启动文件，无论是<code>$ sails lift</code>命令或者<code>$ npm start</code>命令都会运行该文件。</p>\n<h2 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a>ORM</h2><p>开发了Sails的团队Balderdash，还开发了一套ORM框架：Waterline。<br>Waterline在Sails主要的舞台是在<code>/api/models</code>目录里，在这里定义的模型文件，在Sails启动的时候，都要经由Waterline的洗礼。<br>Waterline 是通过Adapter关联数据库的，不同的Adapter关联不同的数据库。<br>Waterline 能适配绝对部分数据库，大致分类两类，一类是官方团队开发的 Adapter适配的，一类是民间开发者开发的Adapter适配的：<br>官方支持的:    </p>\n<ul>\n<li>PostgreSQL    </li>\n<li>MySQL    </li>\n<li>MongoDB    </li>\n<li>Redis    </li>\n<li>Disk    </li>\n<li>Memory    </li>\n</ul>\n<p>民间开发的：    </p>\n<ul>\n<li>SQLServer    </li>\n<li>OrientDB  </li>\n<li>Oracle    </li>\n<li>Cassandra    </li>\n</ul>\n<p>关于Waterline的更多信息可以关注：<br><a href=\"https://github.com/balderdashy/waterline\" target=\"_blank\" rel=\"external\">github:waterline</a><br><a href=\"https://github.com/balderdashy/waterline\" target=\"_blank\" rel=\"external\">github:waterline-docs</a></p>\n<h2 id=\"MVC的实现\"><a href=\"#MVC的实现\" class=\"headerlink\" title=\"MVC的实现\"></a>MVC的实现</h2><p>在这一段我想不仅仅要谈论到Model层、View层和Controller层，我认为还有必要谈到Service层、和Policy层。</p>\n<h5 id=\"Model层\"><a href=\"#Model层\" class=\"headerlink\" title=\"Model层\"></a>Model层</h5><p>模型文件定义到<code>/api/models</code>中，由Waterline驱动，所有model都能全局访问。Sails提供命令行创建model的命令：<code>$ sails generate model MODEL_NAME</code></p>\n<h5 id=\"View层\"><a href=\"#View层\" class=\"headerlink\" title=\"View层\"></a>View层</h5><p>实现在<code>/views</code>中，除了默认提供的ejs模版引擎之外，还能更换成jade、handlebars等模版引擎</p>\n<h5 id=\"Controller层\"><a href=\"#Controller层\" class=\"headerlink\" title=\"Controller层\"></a>Controller层</h5><p>在<code>/api/controller</code>目录里，Sails中提供创建controller的命令：<code>$ sails generate controller CONTROLLER_NAME</code>。Sails也提供同时创建model和对应的Controller的命令：<code>$ sails generate api API_NAME</code>。</p>\n<h5 id=\"Service层\"><a href=\"#Service层\" class=\"headerlink\" title=\"Service层\"></a>Service层</h5><p>在<code>/api/services</code>目录里，存放自定义的服务，所有service都能够全局访问，Sails官方的建议是把逻辑处理都放在该层中，Controller层只做路由的分发和轻逻辑的处理。</p>\n<h5 id=\"Policy层\"><a href=\"#Policy层\" class=\"headerlink\" title=\"Policy层\"></a>Policy层</h5><p>在<code>/api/policies</code>目录里，存放自定义的过滤器。该层是一条请求在到达Controller之前根据需求过滤请求的中间层。在<code>/api/policies</code>目录中定义的文件，还需要在<code>config/policies.js</code>文件中为需求应用到某一过滤器的Action配置。</p>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>Sails中要理解路由，首先要记得这个名词<code>blueprint</code>，中文翻译为：蓝图。我不知道官方是否解释过为什么要用个单词，但以我的理解，Sails的blueprint是负责指挥每一条客户端请求应该分配到服务器端的哪个Action去，所以叫蓝图吧。<br>blueprint主要分为三种：<code>RESTful routes</code>、<code>Shortcut routes</code>、<code>Action routes</code>。</p>\n<h5 id=\"RESTful-routes\"><a href=\"#RESTful-routes\" class=\"headerlink\" title=\"RESTful routes\"></a>RESTful routes</h5><p>当路径诸如：<code>/:modelIdentity</code> 或者 <code>/:modelIdentity/:id</code>的时候，blueprint会根据HTTP的动作（GET、POST、DELETE、PUT等）来分配到相应的Controller下相应的Action来处理。例如一个POST请求<code>/user</code>会创建一个用户，一个DELETE请求<code>/user/123</code>会删除<code>id</code>为123的用户。</p>\n<h5 id=\"Shortcut-routes\"><a href=\"#Shortcut-routes\" class=\"headerlink\" title=\"Shortcut routes\"></a>Shortcut routes</h5><p>这种路由主要是方便开发，请求的参数可以直接写在请求路径中，例如<code>/user/create?name=joe</code>会创建一个新的用户，<code>/user/update/1?name=mike</code>会更新<code>id</code>为1的用户的名字。shortcut routes在开发环境很便利，但是在生产环境下需要关闭。</p>\n<h5 id=\"Action-routes\"><a href=\"#Action-routes\" class=\"headerlink\" title=\"Action routes\"></a>Action routes</h5><p>这种路由会自动的为Controller层的每一个Action创建一个路由，例如你的Controller层有一个<code>FooController.js</code>，里面有一个Action<code>bar</code>，那么请求<code>/foo/bar</code>就会分配到<code>bar</code>Action。</p>\n<p>当然Sails也会提供自定义的路由，用户可以在<code>config/routes.js</code>和<code>config/polices.js</code>这两个配置文件中选择关闭或者打开blueprint提供的路由，和定义自己的路由。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p>要确保产品的安全性，要对几种常见的攻击和安全策略了如指掌，诸如CORS、CSRF、DDOS、XSS等。Sails对于常见的安全策略都有提供支持，且只需要通过相关的配置文件就可以控制安全策略的等级。深入探讨Web的安全策略，并不在本文的范畴内，日后我会以这个为题写一篇文章聊聊Web的安全。<br>想要了解更多Sails的安全策略可以看看这里：<a href=\"http://sailsjs.org/#!/documentation/concepts/Security\" target=\"_blank\" rel=\"external\">sails: security</a></p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><p>Sails提供了一个全局对象<code>sails.log</code>用来处理日志信息的输出，日志是分level的，在<code>config/log.js</code>中配置日志输出的level，而level的作用看下表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Priority</th>\n<th style=\"text-align:center\">level</th>\n<th style=\"text-align:center\">Log fns visible</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:center\">silent</td>\n<td style=\"text-align:center\">N/A</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:center\">error</td>\n<td style=\"text-align:center\">.error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:center\">warn</td>\n<td style=\"text-align:center\">.warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:center\">debug</td>\n<td style=\"text-align:center\">.debug(), .warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:center\">info</td>\n<td style=\"text-align:center\">.info(), .debug(), .warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:center\">verbose</td>\n<td style=\"text-align:center\">.verbose(), .info(), .debug(), .warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:center\">silly</td>\n<td style=\"text-align:center\">.silly(), .verbose(), .info(), .debug(), .warn(), .error()</td>\n</tr>\n</tbody>\n</table>\n<p>Sails的日志管理默认是info层的，既会输出.info(), .debug(), .warn(), .error()的信息。</p>\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><p>Sails使用了mocha进行单元测试，在新建Sails项目的时候，没有创建单元测试的文件夹，需要自己手动构造单元测试目录，官方建议的目录是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── api</span><br><span class=\"line\">├── assets</span><br><span class=\"line\">├── ...</span><br><span class=\"line\">├── test</span><br><span class=\"line\">│  ├── unit</span><br><span class=\"line\">│  │  ├── controllers</span><br><span class=\"line\">│  │  │  └── UsersController.test.js</span><br><span class=\"line\">│  │  ├── models</span><br><span class=\"line\">│  │  │  └── Users.test.js</span><br><span class=\"line\">│  │  └── ...</span><br><span class=\"line\">│  ├── fixtures</span><br><span class=\"line\">│  ├── ...</span><br><span class=\"line\">│  ├── bootstrap.test.js</span><br><span class=\"line\">│  └── mocha.opts</span><br><span class=\"line\">└── views</span><br></pre></td></tr></table></figure>\n<p>而我在单元测试常用的组合是：<a href=\"https://github.com/mochajs/mocha\" target=\"_blank\" rel=\"external\">mocha</a>、<a href=\"https://github.com/tj/should.js\" target=\"_blank\" rel=\"external\">should</a>、<a href=\"https://github.com/visionmedia/supertest\" target=\"_blank\" rel=\"external\">supertest</a>、 <a href=\"https://github.com/gotwarlost/istanbul\" target=\"_blank\" rel=\"external\">istanbul</a><br>其中should是提供断言，supertest是用于测试Controller层的时候伪造http请求的，而istanbul则是提供测试代码覆盖率的。<br>关于怎么在Sails中编写测试代码，可以参考 <a href=\"http://sailsjs.org/#!/documentation/concepts/Testing\" target=\"_blank\" rel=\"external\">sails:testing</a></p>\n<h2 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h2><p>对于有即时性通讯需求的Web应用，我们会用Socket，Sails也为这方面提供了支持。在客户端提供js文件：<code>sails.io.js</code>，而在服务器端提供全局对象：<code>sails.sockets</code>。通过这两个对象，就可以进行客户端和服务器端即时性通讯的开发了。<br>Sails默认会启动WebSocket功能，在客户端访问服务器端的时候，会自动尝试在同域名下连接socket。<br>值得注意的是，这样会对AngularJS、EmberJS等前端MVVC开发产生一些障碍。<br>比如进行AngularJS开发的时候，我们在<code>http://localhost:9000</code>跑AngularJS项目，而服务器端却跑在<code>http://localhost:1337</code>。<br>当访问<code>http://localhost:9000</code>的时候，<code>sails.io.js</code>会尝试于当前路径下进行socket连接，也就是<code>http://localhost:9000</code>，这时会出错，因为服务器是跑在<code>http://localhost:1337</code>的。<br>在开发的时候要解决这样的问题的时候，我们只需要在AngularJS这边引入<code>sails.io.js</code>之后定义连接路径就行了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"scripts/lib/sails.io.js\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\">&lt;script&gt;io.sails.url = <span class=\"string\">\"http://localhost:1337\"</span>;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>可以说Sails涵盖了Web开发中会遇到的绝大部分需求和问题，如果深入研究Sails的话，是受益匪浅的。</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>入手Node.js半年，从用Express开发自己的博客到用Sails开发公司项目，深深被Sails震撼了。Sails是Balderdash团队的产品，快速的项目构建、优秀的框架结构还有众多的扩展，让我有种相见恨晚的感觉。在Koa流行之前，个人认为Sails的用户量还是挺可观的。今天，我想写一写Sails那些让我感动的地方，顺便理顺一下Sails的架构。</p>\n<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<ul>\n<li>一步搭建项目</li>\n<li>项目架构</li>\n<li>ORM</li>\n<li>MVC的实现</li>\n<li>路由</li>\n<li>安全</li>\n<li>日志</li>\n<li>单元测试</li>\n<li>WebSocket</li>\n</ul>\n</blockquote>\n<h2 id=\"一步搭建项目\"><a href=\"#一步搭建项目\" class=\"headerlink\" title=\"一步搭建项目\"></a>一步搭建项目</h2><blockquote>\n<p>在安装了Node.js 和 Sails的环境下，只需要一条命令，就能够搭建一个拥有完整架构的项目，尽管这很简单，我还是觉得有必要说一下。</p>\n</blockquote>\n<p>在已经安装了Node.js和npm的前提下，首先你需要全局下安装Sails<br><code>$ sudo npm install sails -g</code></p>\n<p>其次在一个空路径下，新建一个项目<br><code>$ sails new newApp</code></p>\n<p>最后，只需要前往项目路径，把项目运行起来<br><code>$ cd testProject</code><br><code>$ sails lift</code></p>\n<p>访问 <code>http://localhost:1337</code>就能看到一个新的项目</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/64f9a65d-294f-43e6-984a-77dc2818ecc4.png\" alt=\"new app\"></p>\n<h2 id=\"项目架构\"><a href=\"#项目架构\" class=\"headerlink\" title=\"项目架构\"></a>项目架构</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── api</span><br><span class=\"line\">│   ├── controllers</span><br><span class=\"line\">│   ├── models</span><br><span class=\"line\">│   ├── policies</span><br><span class=\"line\">│   ├── responses</span><br><span class=\"line\">│   └── services</span><br><span class=\"line\">├── views</span><br><span class=\"line\">├── assets</span><br><span class=\"line\">├── config</span><br><span class=\"line\">├── tasks</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── Gruntfile.js</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">└── app.js</span><br></pre></td></tr></table></figure>\n<h3 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api/\"></a><code>api/</code></h3><p><code>api</code> 目录下是你要构建应用的核心所在，常说的MVC的设计结构就体现在这里<br><code>api/controllers</code> ：控制层，该层是Http请求的入口。Sails官方建议该层只处理请求的转发和页面的渲染，具体的逻辑实现应该交给Service层。<br><code>api/models</code>：模型层，在Sails中，对于Model采用的是充血模型，除了可以在模型中定于属性之外，还可以定义包含逻辑处理的函数。在Sails中，所有Model都可以全局性访问。<br><code>api/policies</code>：过滤层，该层在Controller层之前对Http请求做处理，在这一层中，可以定于一些规则来过滤Http请求，比如身份认证什么的。<br><code>api/responses</code>：http响应的方法都放这里，例如服务器错误、请求错误、404错误等，定义在responses文件夹里面的方法，都会赋值到controller层的req对象中。<br><code>api/services</code>：服务层，该层包含逻辑处理的方法，在Sails中，所有Service都可以全局性访问。</p>\n<h3 id=\"views\"><a href=\"#views\" class=\"headerlink\" title=\"views/\"></a><code>views/</code></h3><p>视图层，存放视图模版文件的地方，Sails默认是提供ejs模版引擎的，如果你愿意，你可以换成jade、handlebars或者任何你喜欢的模版引擎。</p>\n<h3 id=\"assets\"><a href=\"#assets\" class=\"headerlink\" title=\"assets/\"></a><code>assets/</code></h3><p>资源文件夹，在Sails启动的时候，会启动某一个Grunt任务，把assets文件夹里的内容或压缩或编译或复制到根目录下的<code>.tmp</code>目录，这是前端可以直接通过路由访问的资源，HTML、JS、CSS以及图片等静态资源都放在这里了。</p>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config/\"></a><code>config/</code></h3><p>配置文件夹，在Sails启动的时候，会加载该文件夹里的文件，并赋值在全局对象<code>sails.config</code>中，所以能够在任何一个地方都能用到。在用Sails开发，会经常跟这个文件夹里的文件打交道，从config的构成很容易知道Sails都提供哪方面的功能。</p>\n<h3 id=\"tasks\"><a href=\"#tasks\" class=\"headerlink\" title=\"tasks/\"></a><code>tasks/</code></h3><p>Sails自带的项目自动化工具是<code>Grunt</code>，而Grunt的配置和任务注册都放在这个文件夹里了。这里已经提供了通常会用到的CSS编译、JS压缩、文件合并，更改检测等等任务，当然如果没有自己需要的，还能扩展。</p>\n<h3 id=\"app-js\"><a href=\"#app-js\" class=\"headerlink\" title=\"app.js\"></a><code>app.js</code></h3><p>Sails的启动文件，无论是<code>$ sails lift</code>命令或者<code>$ npm start</code>命令都会运行该文件。</p>\n<h2 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a>ORM</h2><p>开发了Sails的团队Balderdash，还开发了一套ORM框架：Waterline。<br>Waterline在Sails主要的舞台是在<code>/api/models</code>目录里，在这里定义的模型文件，在Sails启动的时候，都要经由Waterline的洗礼。<br>Waterline 是通过Adapter关联数据库的，不同的Adapter关联不同的数据库。<br>Waterline 能适配绝对部分数据库，大致分类两类，一类是官方团队开发的 Adapter适配的，一类是民间开发者开发的Adapter适配的：<br>官方支持的:    </p>\n<ul>\n<li>PostgreSQL    </li>\n<li>MySQL    </li>\n<li>MongoDB    </li>\n<li>Redis    </li>\n<li>Disk    </li>\n<li>Memory    </li>\n</ul>\n<p>民间开发的：    </p>\n<ul>\n<li>SQLServer    </li>\n<li>OrientDB  </li>\n<li>Oracle    </li>\n<li>Cassandra    </li>\n</ul>\n<p>关于Waterline的更多信息可以关注：<br><a href=\"https://github.com/balderdashy/waterline\">github:waterline</a><br><a href=\"https://github.com/balderdashy/waterline\">github:waterline-docs</a></p>\n<h2 id=\"MVC的实现\"><a href=\"#MVC的实现\" class=\"headerlink\" title=\"MVC的实现\"></a>MVC的实现</h2><p>在这一段我想不仅仅要谈论到Model层、View层和Controller层，我认为还有必要谈到Service层、和Policy层。</p>\n<h5 id=\"Model层\"><a href=\"#Model层\" class=\"headerlink\" title=\"Model层\"></a>Model层</h5><p>模型文件定义到<code>/api/models</code>中，由Waterline驱动，所有model都能全局访问。Sails提供命令行创建model的命令：<code>$ sails generate model MODEL_NAME</code></p>\n<h5 id=\"View层\"><a href=\"#View层\" class=\"headerlink\" title=\"View层\"></a>View层</h5><p>实现在<code>/views</code>中，除了默认提供的ejs模版引擎之外，还能更换成jade、handlebars等模版引擎</p>\n<h5 id=\"Controller层\"><a href=\"#Controller层\" class=\"headerlink\" title=\"Controller层\"></a>Controller层</h5><p>在<code>/api/controller</code>目录里，Sails中提供创建controller的命令：<code>$ sails generate controller CONTROLLER_NAME</code>。Sails也提供同时创建model和对应的Controller的命令：<code>$ sails generate api API_NAME</code>。</p>\n<h5 id=\"Service层\"><a href=\"#Service层\" class=\"headerlink\" title=\"Service层\"></a>Service层</h5><p>在<code>/api/services</code>目录里，存放自定义的服务，所有service都能够全局访问，Sails官方的建议是把逻辑处理都放在该层中，Controller层只做路由的分发和轻逻辑的处理。</p>\n<h5 id=\"Policy层\"><a href=\"#Policy层\" class=\"headerlink\" title=\"Policy层\"></a>Policy层</h5><p>在<code>/api/policies</code>目录里，存放自定义的过滤器。该层是一条请求在到达Controller之前根据需求过滤请求的中间层。在<code>/api/policies</code>目录中定义的文件，还需要在<code>config/policies.js</code>文件中为需求应用到某一过滤器的Action配置。</p>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>Sails中要理解路由，首先要记得这个名词<code>blueprint</code>，中文翻译为：蓝图。我不知道官方是否解释过为什么要用个单词，但以我的理解，Sails的blueprint是负责指挥每一条客户端请求应该分配到服务器端的哪个Action去，所以叫蓝图吧。<br>blueprint主要分为三种：<code>RESTful routes</code>、<code>Shortcut routes</code>、<code>Action routes</code>。</p>\n<h5 id=\"RESTful-routes\"><a href=\"#RESTful-routes\" class=\"headerlink\" title=\"RESTful routes\"></a>RESTful routes</h5><p>当路径诸如：<code>/:modelIdentity</code> 或者 <code>/:modelIdentity/:id</code>的时候，blueprint会根据HTTP的动作（GET、POST、DELETE、PUT等）来分配到相应的Controller下相应的Action来处理。例如一个POST请求<code>/user</code>会创建一个用户，一个DELETE请求<code>/user/123</code>会删除<code>id</code>为123的用户。</p>\n<h5 id=\"Shortcut-routes\"><a href=\"#Shortcut-routes\" class=\"headerlink\" title=\"Shortcut routes\"></a>Shortcut routes</h5><p>这种路由主要是方便开发，请求的参数可以直接写在请求路径中，例如<code>/user/create?name=joe</code>会创建一个新的用户，<code>/user/update/1?name=mike</code>会更新<code>id</code>为1的用户的名字。shortcut routes在开发环境很便利，但是在生产环境下需要关闭。</p>\n<h5 id=\"Action-routes\"><a href=\"#Action-routes\" class=\"headerlink\" title=\"Action routes\"></a>Action routes</h5><p>这种路由会自动的为Controller层的每一个Action创建一个路由，例如你的Controller层有一个<code>FooController.js</code>，里面有一个Action<code>bar</code>，那么请求<code>/foo/bar</code>就会分配到<code>bar</code>Action。</p>\n<p>当然Sails也会提供自定义的路由，用户可以在<code>config/routes.js</code>和<code>config/polices.js</code>这两个配置文件中选择关闭或者打开blueprint提供的路由，和定义自己的路由。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p>要确保产品的安全性，要对几种常见的攻击和安全策略了如指掌，诸如CORS、CSRF、DDOS、XSS等。Sails对于常见的安全策略都有提供支持，且只需要通过相关的配置文件就可以控制安全策略的等级。深入探讨Web的安全策略，并不在本文的范畴内，日后我会以这个为题写一篇文章聊聊Web的安全。<br>想要了解更多Sails的安全策略可以看看这里：<a href=\"http://sailsjs.org/#!/documentation/concepts/Security\">sails: security</a></p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><p>Sails提供了一个全局对象<code>sails.log</code>用来处理日志信息的输出，日志是分level的，在<code>config/log.js</code>中配置日志输出的level，而level的作用看下表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Priority</th>\n<th style=\"text-align:center\">level</th>\n<th style=\"text-align:center\">Log fns visible</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:center\">silent</td>\n<td style=\"text-align:center\">N/A</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:center\">error</td>\n<td style=\"text-align:center\">.error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:center\">warn</td>\n<td style=\"text-align:center\">.warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:center\">debug</td>\n<td style=\"text-align:center\">.debug(), .warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:center\">info</td>\n<td style=\"text-align:center\">.info(), .debug(), .warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:center\">verbose</td>\n<td style=\"text-align:center\">.verbose(), .info(), .debug(), .warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:center\">silly</td>\n<td style=\"text-align:center\">.silly(), .verbose(), .info(), .debug(), .warn(), .error()</td>\n</tr>\n</tbody>\n</table>\n<p>Sails的日志管理默认是info层的，既会输出.info(), .debug(), .warn(), .error()的信息。</p>\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><p>Sails使用了mocha进行单元测试，在新建Sails项目的时候，没有创建单元测试的文件夹，需要自己手动构造单元测试目录，官方建议的目录是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── api</span><br><span class=\"line\">├── assets</span><br><span class=\"line\">├── ...</span><br><span class=\"line\">├── test</span><br><span class=\"line\">│  ├── unit</span><br><span class=\"line\">│  │  ├── controllers</span><br><span class=\"line\">│  │  │  └── UsersController.test.js</span><br><span class=\"line\">│  │  ├── models</span><br><span class=\"line\">│  │  │  └── Users.test.js</span><br><span class=\"line\">│  │  └── ...</span><br><span class=\"line\">│  ├── fixtures</span><br><span class=\"line\">│  ├── ...</span><br><span class=\"line\">│  ├── bootstrap.test.js</span><br><span class=\"line\">│  └── mocha.opts</span><br><span class=\"line\">└── views</span><br></pre></td></tr></table></figure>\n<p>而我在单元测试常用的组合是：<a href=\"https://github.com/mochajs/mocha\">mocha</a>、<a href=\"https://github.com/tj/should.js\">should</a>、<a href=\"https://github.com/visionmedia/supertest\">supertest</a>、 <a href=\"https://github.com/gotwarlost/istanbul\">istanbul</a><br>其中should是提供断言，supertest是用于测试Controller层的时候伪造http请求的，而istanbul则是提供测试代码覆盖率的。<br>关于怎么在Sails中编写测试代码，可以参考 <a href=\"http://sailsjs.org/#!/documentation/concepts/Testing\">sails:testing</a></p>\n<h2 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h2><p>对于有即时性通讯需求的Web应用，我们会用Socket，Sails也为这方面提供了支持。在客户端提供js文件：<code>sails.io.js</code>，而在服务器端提供全局对象：<code>sails.sockets</code>。通过这两个对象，就可以进行客户端和服务器端即时性通讯的开发了。<br>Sails默认会启动WebSocket功能，在客户端访问服务器端的时候，会自动尝试在同域名下连接socket。<br>值得注意的是，这样会对AngularJS、EmberJS等前端MVVC开发产生一些障碍。<br>比如进行AngularJS开发的时候，我们在<code>http://localhost:9000</code>跑AngularJS项目，而服务器端却跑在<code>http://localhost:1337</code>。<br>当访问<code>http://localhost:9000</code>的时候，<code>sails.io.js</code>会尝试于当前路径下进行socket连接，也就是<code>http://localhost:9000</code>，这时会出错，因为服务器是跑在<code>http://localhost:1337</code>的。<br>在开发的时候要解决这样的问题的时候，我们只需要在AngularJS这边引入<code>sails.io.js</code>之后定义连接路径就行了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"scripts/lib/sails.io.js\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\">&lt;script&gt;io.sails.url = <span class=\"string\">\"http://localhost:1337\"</span>;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>可以说Sails涵盖了Web开发中会遇到的绝大部分需求和问题，如果深入研究Sails的话，是受益匪浅的。</p>\n"},{"title":"下雨天的夜晚，特别容易失眠","date":"2016-05-28T14:22:25.000Z","_content":"\n陷入迷茫期已经有差不多2个月了，\n这一次比以往的迷茫都更长一些。\n\n我应该庆幸，一些事情一杆棒打醒了我，明白了自己的懒惰以及安逸。我过去，并不是没有认真的工作，但那单单只是工作，虽然最后是能不错的完成。但那只是仅仅不错，离优秀甚远。自己并没有去主动的接触新的东西，寻找新的事物，主动且持续的保持学习。而是沉浸在那些已过去的虚荣感中。\n\n最近，想了很多，渐渐得到一些释怀。\n一是因为开始锻炼身体了，\n二是因为开始好好读一本书了。\n这两个加起来就是一剂神奇的药方。\n内心平静了许多，才会平心静气的坐下来，泡杯铁观音，好好想想自己真正想要的是什么？\n\n**事业 or 工作 or 兴趣**\n我一直很庆幸，我喜欢的东西变成了我的工作乃至事业。\n这比起很多人，已经很幸福了。\n我是真的享受作为一个技术人的快乐，\n这种快乐来自于\n发现新的好玩的东西所带来新鲜感，\n写博客分享知识所带来的认同感，\n做的产品被很多人使用并且创造价值的自豪感，\n还有是对知识的满足感。\n\n**生活**\n做为一个人，除了工作，你还有生活。\n你还有你爱以及爱你的人，这是泛指，包括父母，伴侣，朋友。\n活着，也并不是为了自己一个人而活，\n每一个年轻人，在年轻气盛的时候，都会拥抱着一个梦想，也许它是清晰可见，但更多只是一个模糊不清，你往往用它来给你的任性寻找借口。\n也许在将来，某个机会出现的时候，我会考虑去追逐那个朦胧的梦想，但并不是在抛弃那些我应当背起责任的前提下。\n\n在这个寂静的夜晚，\n窗外的雨不知不觉停了，\n多少因为不能抱着雨睡觉，而有些许失望。\n想要的比较庸俗，只是想事业更顺利，生活更美好。\n而如果这两者出现冲突了，那就和相关者商量好，取个平衡点，修改好了，再commit。\n\n此时，忽然想起一句TVB经典的台词\n「呐！做人最紧要就系开心」","source":"_posts/下雨天的夜晚，特别容易失眠.md","raw":"---\ntitle: 下雨天的夜晚，特别容易失眠\ncategory: 三省吾身\ndate: 2016-05-28 22:22:25\n---\n\n陷入迷茫期已经有差不多2个月了，\n这一次比以往的迷茫都更长一些。\n\n我应该庆幸，一些事情一杆棒打醒了我，明白了自己的懒惰以及安逸。我过去，并不是没有认真的工作，但那单单只是工作，虽然最后是能不错的完成。但那只是仅仅不错，离优秀甚远。自己并没有去主动的接触新的东西，寻找新的事物，主动且持续的保持学习。而是沉浸在那些已过去的虚荣感中。\n\n最近，想了很多，渐渐得到一些释怀。\n一是因为开始锻炼身体了，\n二是因为开始好好读一本书了。\n这两个加起来就是一剂神奇的药方。\n内心平静了许多，才会平心静气的坐下来，泡杯铁观音，好好想想自己真正想要的是什么？\n\n**事业 or 工作 or 兴趣**\n我一直很庆幸，我喜欢的东西变成了我的工作乃至事业。\n这比起很多人，已经很幸福了。\n我是真的享受作为一个技术人的快乐，\n这种快乐来自于\n发现新的好玩的东西所带来新鲜感，\n写博客分享知识所带来的认同感，\n做的产品被很多人使用并且创造价值的自豪感，\n还有是对知识的满足感。\n\n**生活**\n做为一个人，除了工作，你还有生活。\n你还有你爱以及爱你的人，这是泛指，包括父母，伴侣，朋友。\n活着，也并不是为了自己一个人而活，\n每一个年轻人，在年轻气盛的时候，都会拥抱着一个梦想，也许它是清晰可见，但更多只是一个模糊不清，你往往用它来给你的任性寻找借口。\n也许在将来，某个机会出现的时候，我会考虑去追逐那个朦胧的梦想，但并不是在抛弃那些我应当背起责任的前提下。\n\n在这个寂静的夜晚，\n窗外的雨不知不觉停了，\n多少因为不能抱着雨睡觉，而有些许失望。\n想要的比较庸俗，只是想事业更顺利，生活更美好。\n而如果这两者出现冲突了，那就和相关者商量好，取个平衡点，修改好了，再commit。\n\n此时，忽然想起一句TVB经典的台词\n「呐！做人最紧要就系开心」","slug":"下雨天的夜晚，特别容易失眠","published":1,"updated":"2017-02-04T13:36:16.000Z","_id":"cl270y8s7002zxwrl2sat7uf8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>陷入迷茫期已经有差不多2个月了，<br>这一次比以往的迷茫都更长一些。</p>\n<p>我应该庆幸，一些事情一杆棒打醒了我，明白了自己的懒惰以及安逸。我过去，并不是没有认真的工作，但那单单只是工作，虽然最后是能不错的完成。但那只是仅仅不错，离优秀甚远。自己并没有去主动的接触新的东西，寻找新的事物，主动且持续的保持学习。而是沉浸在那些已过去的虚荣感中。</p>\n<p>最近，想了很多，渐渐得到一些释怀。<br>一是因为开始锻炼身体了，<br>二是因为开始好好读一本书了。<br>这两个加起来就是一剂神奇的药方。<br>内心平静了许多，才会平心静气的坐下来，泡杯铁观音，好好想想自己真正想要的是什么？</p>\n<p><strong>事业 or 工作 or 兴趣</strong><br>我一直很庆幸，我喜欢的东西变成了我的工作乃至事业。<br>这比起很多人，已经很幸福了。<br>我是真的享受作为一个技术人的快乐，<br>这种快乐来自于<br>发现新的好玩的东西所带来新鲜感，<br>写博客分享知识所带来的认同感，<br>做的产品被很多人使用并且创造价值的自豪感，<br>还有是对知识的满足感。</p>\n<p><strong>生活</strong><br>做为一个人，除了工作，你还有生活。<br>你还有你爱以及爱你的人，这是泛指，包括父母，伴侣，朋友。<br>活着，也并不是为了自己一个人而活，<br>每一个年轻人，在年轻气盛的时候，都会拥抱着一个梦想，也许它是清晰可见，但更多只是一个模糊不清，你往往用它来给你的任性寻找借口。<br>也许在将来，某个机会出现的时候，我会考虑去追逐那个朦胧的梦想，但并不是在抛弃那些我应当背起责任的前提下。</p>\n<p>在这个寂静的夜晚，<br>窗外的雨不知不觉停了，<br>多少因为不能抱着雨睡觉，而有些许失望。<br>想要的比较庸俗，只是想事业更顺利，生活更美好。<br>而如果这两者出现冲突了，那就和相关者商量好，取个平衡点，修改好了，再commit。</p>\n<p>此时，忽然想起一句TVB经典的台词<br>「呐！做人最紧要就系开心」</p>\n","excerpt":"","more":"<p>陷入迷茫期已经有差不多2个月了，<br>这一次比以往的迷茫都更长一些。</p>\n<p>我应该庆幸，一些事情一杆棒打醒了我，明白了自己的懒惰以及安逸。我过去，并不是没有认真的工作，但那单单只是工作，虽然最后是能不错的完成。但那只是仅仅不错，离优秀甚远。自己并没有去主动的接触新的东西，寻找新的事物，主动且持续的保持学习。而是沉浸在那些已过去的虚荣感中。</p>\n<p>最近，想了很多，渐渐得到一些释怀。<br>一是因为开始锻炼身体了，<br>二是因为开始好好读一本书了。<br>这两个加起来就是一剂神奇的药方。<br>内心平静了许多，才会平心静气的坐下来，泡杯铁观音，好好想想自己真正想要的是什么？</p>\n<p><strong>事业 or 工作 or 兴趣</strong><br>我一直很庆幸，我喜欢的东西变成了我的工作乃至事业。<br>这比起很多人，已经很幸福了。<br>我是真的享受作为一个技术人的快乐，<br>这种快乐来自于<br>发现新的好玩的东西所带来新鲜感，<br>写博客分享知识所带来的认同感，<br>做的产品被很多人使用并且创造价值的自豪感，<br>还有是对知识的满足感。</p>\n<p><strong>生活</strong><br>做为一个人，除了工作，你还有生活。<br>你还有你爱以及爱你的人，这是泛指，包括父母，伴侣，朋友。<br>活着，也并不是为了自己一个人而活，<br>每一个年轻人，在年轻气盛的时候，都会拥抱着一个梦想，也许它是清晰可见，但更多只是一个模糊不清，你往往用它来给你的任性寻找借口。<br>也许在将来，某个机会出现的时候，我会考虑去追逐那个朦胧的梦想，但并不是在抛弃那些我应当背起责任的前提下。</p>\n<p>在这个寂静的夜晚，<br>窗外的雨不知不觉停了，<br>多少因为不能抱着雨睡觉，而有些许失望。<br>想要的比较庸俗，只是想事业更顺利，生活更美好。<br>而如果这两者出现冲突了，那就和相关者商量好，取个平衡点，修改好了，再commit。</p>\n<p>此时，忽然想起一句TVB经典的台词<br>「呐！做人最紧要就系开心」</p>\n"},{"title":"「理解HTTP」之常见的状态码","date":"2016-05-22T14:22:25.000Z","_content":"\n状态码的职责是当客户端向服务器端发送请求时，描述返回请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了什么错误。\n\n[RFC2616](http://pretty-rfc.herokuapp.com/RFC2616)定义的状态码，由3位数字和原因短信组成。\n数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种：\n\n| Type | Reason-phrase | Note |\n| ---  | -----| ------------- |\n| 1XX  | Informational | 信息性状态码，表示接受的请求正在处理 |\n| 2XX  | Success | 成功状态码，表示请求正常处理完毕 |\n| 3XX  | Redirection | 重定向状态码，表示需要客户端需要进行附加操作 |\n| 4XX  | Client Error | 客户端错误状态码，表示服务器无法处理请求 |\n| 5XX  | Server Error | 服务器错误状态码，表示服务器处理请求出错 |\n\nRFC2616记录的HTTP状态码有37种，再加上「WebDAV」([RFC4918](https://datatracker.ietf.org/doc/rfc4918/)、[5842](https://datatracker.ietf.org/doc/rfc5842/))和「Additional HTTP Status Codes」([RFC6585](https://datatracker.ietf.org/doc/rfc6585/))，数量就达到60多种。\n然并卵，这么多种HTTP状态码，其实常用的大概只有14种，本文就讲讲这14种状态码。\n\n## 2XX Success\n> This class of status code indicates that the client's request was successfully received, understood, and accepted.\n\n2xx 响应结果表示从客户端发来的请求在服务器端被正常处理了。\n\n### 200 OK\n请求被成功处理，服务器会根据不同的请求方法返回结果：\n**GET**：请求的对应资源会作为响应返回。\n**HEAD**：请求的对应资源的响应头(entity-header)会作为响应返回,不包括响应体(message-body)。\n**POST**：返回处理对应请求的结果。\n\n### 204 No Content\n该状态码表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体.\n比如，客户端是浏览器的话，发出的请求返回204响应，那么浏览器显示的页面不会发生更新。\n\n### 206 Partial Content\n该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。\n客户端发起的请求，必须在请求头中包含[`Range`](http://pretty-rfc.herokuapp.com/RFC2616#header.range)字段。服务端响应报文中，必须包含由`Content-Range`指定范围的实体内容(entity-bodies )\n\n## 3XX Redirection\n> This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.\n\n3XX 响应结果表明浏览器需要执行某些特殊的处理以完成请求。\n\n### 301 Moved Permanently\n永久性重定向。该状态码表示请求的资源已经被分配了新的URI，并且以后使用资源现在所指的URI。并且根据请求的方法有不同的处理方式：\n**HEAD**：必须在响应头部`Location`字段中指明新的永久性的URI。\n**GET**：除了有`Location`字段以外，还需要在响应体中附上永久性URI的超链接文本。\n**POST**：客户端在发送POST请求，受到301响应之后，不应该自动跳转URI，应当让用户确认跳转。\n\n比如，如果一个URI已经在浏览器中被收藏为书签，这时应该按照`Location`首部字段提示的URI重新保存。\n例如建立一个收藏的书签：\n```\nhttp://wan.bigertech.com\n```\n当访问这个书签的时候，请求会被重定向到\n```\nhttp://wan.meizu.com\n```\n并且对应的书签会被改变，指向`http://wan.meizu.com`\n不信？Try yourself.\n\n### 302 Found\n临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问。\n和301 Moved Permanently 状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。\n如果，用户把一个URI收藏为书签，302响应是不会像301那样去更新书签。\n\n### 303 See Other\n该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。\n但是有一点是需要注意的，许多HTTP/1.1版以前的浏览器不能正确理解303状态码，很多现存的浏览器讲302响应视为303响应，并且使用GET方式访问`Location`中规定的的URI，而无视原先请求的方法。\n在RFC2616中有相关的这样一段原文：\n> Note: Many pre-HTTP/1.1 user agents do not understand the 303 status. When interoperability with such clients is a concern, the 302 status code may be used instead, since most user agents react to a 302 response as described here for 303.\n\n### 304 Not Modified\n该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主题部分。附带条件的请求指的是采用GET方法的请求头中包含：[`If-Match`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-match)、[`If-Modified-Since`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-modified-since)、[`If-None-Match`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-none-match)、[`If-Range`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-range)、[`If-Unmodified-Since`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-unmodified-since)中任一首部。\n\n### 307 Temporary Redirect\n临时重定向。该状态码与302和303的有着类似的含义，不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。(302指定使用原有请求方法，303指定使用GET方法)\n\n## 4XX Client Error\n> The 4xx class of status code is intended for cases in which the client seems to have erred.\n\n4XX 的响应结果表明客户端是发生错误的原因所在\n\n### 400 Bad Request\n表示该请求报文中存在语法错误，导致服务器无法理解该请求。客户端需要修改请求的内容后再次发送请求。\n\n### 401 Unauthorized\n该状态码表示发送的请求需要有通过HTTP认证(Basic认证，Digest认证)的认证信息。返回含有401的响应，必须在头部包含[`WWW-Authenticate`](http://pretty-rfc.herokuapp.com/RFC2616#header.www-authenticate)以指明服务器需要哪种方式的认证。\n当客户端再次请求该资源的时候，需要在请求头中的[`Authorization`](http://pretty-rfc.herokuapp.com/RFC2616#header.authorization)包含认证信息。\n更多关于认证授权的信息关注[RFC2617](http://pretty-rfc.herokuapp.com/RFC2617)\n\n### 403 Forbidden\n该状态码表明对请求资源的访问被服务器拒绝了。服务器没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分原因进行描述，这样就能让用户看到了。\n未获得文件系统的访问权限，访问权限出现某些问题，从未授权的发送源IP地址试图访问等情况都可能发生403响应。\n\n### 404 Not Found\n该状态码表明服务器上无法找到指定的资源。通常被用于服务器不想透露拒绝请求的原因，或者没有其他的响应可提供。\n\n## 5XX Server Error\n> Response status codes beginning with the digit \"5\" indicate cases in which the server is aware that it has erred or is incapable of performing the request. \n\n5XX 的响应结果表明服务器本身发生错误，或者没有足够的能力来处理请求。\n\n### 500 Internal Server Error\n该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的BUG或某些临时的故障。\n\n### 503 Service Unavailable\n该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上需要的时间，最好写入`Retry-After`首部字段再返回给客户端。\n\n","source":"_posts/「理解HTTP」之常见的状态码.md","raw":"---\ntitle: 「理解HTTP」之常见的状态码\ncategory: 搬砖码农\ndate: 2016-05-22 22:22:25\ntags: \n- http\n---\n\n状态码的职责是当客户端向服务器端发送请求时，描述返回请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了什么错误。\n\n[RFC2616](http://pretty-rfc.herokuapp.com/RFC2616)定义的状态码，由3位数字和原因短信组成。\n数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种：\n\n| Type | Reason-phrase | Note |\n| ---  | -----| ------------- |\n| 1XX  | Informational | 信息性状态码，表示接受的请求正在处理 |\n| 2XX  | Success | 成功状态码，表示请求正常处理完毕 |\n| 3XX  | Redirection | 重定向状态码，表示需要客户端需要进行附加操作 |\n| 4XX  | Client Error | 客户端错误状态码，表示服务器无法处理请求 |\n| 5XX  | Server Error | 服务器错误状态码，表示服务器处理请求出错 |\n\nRFC2616记录的HTTP状态码有37种，再加上「WebDAV」([RFC4918](https://datatracker.ietf.org/doc/rfc4918/)、[5842](https://datatracker.ietf.org/doc/rfc5842/))和「Additional HTTP Status Codes」([RFC6585](https://datatracker.ietf.org/doc/rfc6585/))，数量就达到60多种。\n然并卵，这么多种HTTP状态码，其实常用的大概只有14种，本文就讲讲这14种状态码。\n\n## 2XX Success\n> This class of status code indicates that the client's request was successfully received, understood, and accepted.\n\n2xx 响应结果表示从客户端发来的请求在服务器端被正常处理了。\n\n### 200 OK\n请求被成功处理，服务器会根据不同的请求方法返回结果：\n**GET**：请求的对应资源会作为响应返回。\n**HEAD**：请求的对应资源的响应头(entity-header)会作为响应返回,不包括响应体(message-body)。\n**POST**：返回处理对应请求的结果。\n\n### 204 No Content\n该状态码表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体.\n比如，客户端是浏览器的话，发出的请求返回204响应，那么浏览器显示的页面不会发生更新。\n\n### 206 Partial Content\n该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。\n客户端发起的请求，必须在请求头中包含[`Range`](http://pretty-rfc.herokuapp.com/RFC2616#header.range)字段。服务端响应报文中，必须包含由`Content-Range`指定范围的实体内容(entity-bodies )\n\n## 3XX Redirection\n> This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.\n\n3XX 响应结果表明浏览器需要执行某些特殊的处理以完成请求。\n\n### 301 Moved Permanently\n永久性重定向。该状态码表示请求的资源已经被分配了新的URI，并且以后使用资源现在所指的URI。并且根据请求的方法有不同的处理方式：\n**HEAD**：必须在响应头部`Location`字段中指明新的永久性的URI。\n**GET**：除了有`Location`字段以外，还需要在响应体中附上永久性URI的超链接文本。\n**POST**：客户端在发送POST请求，受到301响应之后，不应该自动跳转URI，应当让用户确认跳转。\n\n比如，如果一个URI已经在浏览器中被收藏为书签，这时应该按照`Location`首部字段提示的URI重新保存。\n例如建立一个收藏的书签：\n```\nhttp://wan.bigertech.com\n```\n当访问这个书签的时候，请求会被重定向到\n```\nhttp://wan.meizu.com\n```\n并且对应的书签会被改变，指向`http://wan.meizu.com`\n不信？Try yourself.\n\n### 302 Found\n临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问。\n和301 Moved Permanently 状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。\n如果，用户把一个URI收藏为书签，302响应是不会像301那样去更新书签。\n\n### 303 See Other\n该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。\n但是有一点是需要注意的，许多HTTP/1.1版以前的浏览器不能正确理解303状态码，很多现存的浏览器讲302响应视为303响应，并且使用GET方式访问`Location`中规定的的URI，而无视原先请求的方法。\n在RFC2616中有相关的这样一段原文：\n> Note: Many pre-HTTP/1.1 user agents do not understand the 303 status. When interoperability with such clients is a concern, the 302 status code may be used instead, since most user agents react to a 302 response as described here for 303.\n\n### 304 Not Modified\n该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主题部分。附带条件的请求指的是采用GET方法的请求头中包含：[`If-Match`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-match)、[`If-Modified-Since`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-modified-since)、[`If-None-Match`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-none-match)、[`If-Range`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-range)、[`If-Unmodified-Since`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-unmodified-since)中任一首部。\n\n### 307 Temporary Redirect\n临时重定向。该状态码与302和303的有着类似的含义，不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。(302指定使用原有请求方法，303指定使用GET方法)\n\n## 4XX Client Error\n> The 4xx class of status code is intended for cases in which the client seems to have erred.\n\n4XX 的响应结果表明客户端是发生错误的原因所在\n\n### 400 Bad Request\n表示该请求报文中存在语法错误，导致服务器无法理解该请求。客户端需要修改请求的内容后再次发送请求。\n\n### 401 Unauthorized\n该状态码表示发送的请求需要有通过HTTP认证(Basic认证，Digest认证)的认证信息。返回含有401的响应，必须在头部包含[`WWW-Authenticate`](http://pretty-rfc.herokuapp.com/RFC2616#header.www-authenticate)以指明服务器需要哪种方式的认证。\n当客户端再次请求该资源的时候，需要在请求头中的[`Authorization`](http://pretty-rfc.herokuapp.com/RFC2616#header.authorization)包含认证信息。\n更多关于认证授权的信息关注[RFC2617](http://pretty-rfc.herokuapp.com/RFC2617)\n\n### 403 Forbidden\n该状态码表明对请求资源的访问被服务器拒绝了。服务器没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分原因进行描述，这样就能让用户看到了。\n未获得文件系统的访问权限，访问权限出现某些问题，从未授权的发送源IP地址试图访问等情况都可能发生403响应。\n\n### 404 Not Found\n该状态码表明服务器上无法找到指定的资源。通常被用于服务器不想透露拒绝请求的原因，或者没有其他的响应可提供。\n\n## 5XX Server Error\n> Response status codes beginning with the digit \"5\" indicate cases in which the server is aware that it has erred or is incapable of performing the request. \n\n5XX 的响应结果表明服务器本身发生错误，或者没有足够的能力来处理请求。\n\n### 500 Internal Server Error\n该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的BUG或某些临时的故障。\n\n### 503 Service Unavailable\n该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上需要的时间，最好写入`Retry-After`首部字段再返回给客户端。\n\n","slug":"「理解HTTP」之常见的状态码","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8s80031xwrlfameaw29","comments":1,"layout":"post","photos":[],"link":"","content":"<p>状态码的职责是当客户端向服务器端发送请求时，描述返回请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了什么错误。</p>\n<p><a href=\"http://pretty-rfc.herokuapp.com/RFC2616\" target=\"_blank\" rel=\"external\">RFC2616</a>定义的状态码，由3位数字和原因短信组成。<br>数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种：</p>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Reason-phrase</th>\n<th>Note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td>Informational</td>\n<td>信息性状态码，表示接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success</td>\n<td>成功状态码，表示请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection</td>\n<td>重定向状态码，表示需要客户端需要进行附加操作</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error</td>\n<td>客户端错误状态码，表示服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error</td>\n<td>服务器错误状态码，表示服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<p>RFC2616记录的HTTP状态码有37种，再加上「WebDAV」(<a href=\"https://datatracker.ietf.org/doc/rfc4918/\" target=\"_blank\" rel=\"external\">RFC4918</a>、<a href=\"https://datatracker.ietf.org/doc/rfc5842/\" target=\"_blank\" rel=\"external\">5842</a>)和「Additional HTTP Status Codes」(<a href=\"https://datatracker.ietf.org/doc/rfc6585/\" target=\"_blank\" rel=\"external\">RFC6585</a>)，数量就达到60多种。<br>然并卵，这么多种HTTP状态码，其实常用的大概只有14种，本文就讲讲这14种状态码。</p>\n<h2 id=\"2XX-Success\"><a href=\"#2XX-Success\" class=\"headerlink\" title=\"2XX Success\"></a>2XX Success</h2><blockquote>\n<p>This class of status code indicates that the client’s request was successfully received, understood, and accepted.</p>\n</blockquote>\n<p>2xx 响应结果表示从客户端发来的请求在服务器端被正常处理了。</p>\n<h3 id=\"200-OK\"><a href=\"#200-OK\" class=\"headerlink\" title=\"200 OK\"></a>200 OK</h3><p>请求被成功处理，服务器会根据不同的请求方法返回结果：<br><strong>GET</strong>：请求的对应资源会作为响应返回。<br><strong>HEAD</strong>：请求的对应资源的响应头(entity-header)会作为响应返回,不包括响应体(message-body)。<br><strong>POST</strong>：返回处理对应请求的结果。</p>\n<h3 id=\"204-No-Content\"><a href=\"#204-No-Content\" class=\"headerlink\" title=\"204 No Content\"></a>204 No Content</h3><p>该状态码表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体.<br>比如，客户端是浏览器的话，发出的请求返回204响应，那么浏览器显示的页面不会发生更新。</p>\n<h3 id=\"206-Partial-Content\"><a href=\"#206-Partial-Content\" class=\"headerlink\" title=\"206 Partial Content\"></a>206 Partial Content</h3><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。<br>客户端发起的请求，必须在请求头中包含<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.range\" target=\"_blank\" rel=\"external\"><code>Range</code></a>字段。服务端响应报文中，必须包含由<code>Content-Range</code>指定范围的实体内容(entity-bodies )</p>\n<h2 id=\"3XX-Redirection\"><a href=\"#3XX-Redirection\" class=\"headerlink\" title=\"3XX Redirection\"></a>3XX Redirection</h2><blockquote>\n<p>This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.</p>\n</blockquote>\n<p>3XX 响应结果表明浏览器需要执行某些特殊的处理以完成请求。</p>\n<h3 id=\"301-Moved-Permanently\"><a href=\"#301-Moved-Permanently\" class=\"headerlink\" title=\"301 Moved Permanently\"></a>301 Moved Permanently</h3><p>永久性重定向。该状态码表示请求的资源已经被分配了新的URI，并且以后使用资源现在所指的URI。并且根据请求的方法有不同的处理方式：<br><strong>HEAD</strong>：必须在响应头部<code>Location</code>字段中指明新的永久性的URI。<br><strong>GET</strong>：除了有<code>Location</code>字段以外，还需要在响应体中附上永久性URI的超链接文本。<br><strong>POST</strong>：客户端在发送POST请求，受到301响应之后，不应该自动跳转URI，应当让用户确认跳转。</p>\n<p>比如，如果一个URI已经在浏览器中被收藏为书签，这时应该按照<code>Location</code>首部字段提示的URI重新保存。<br>例如建立一个收藏的书签：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://wan.bigertech.com</span><br></pre></td></tr></table></figure></p>\n<p>当访问这个书签的时候，请求会被重定向到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://wan.meizu.com</span><br></pre></td></tr></table></figure></p>\n<p>并且对应的书签会被改变，指向<code>http://wan.meizu.com</code><br>不信？Try yourself.</p>\n<h3 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a>302 Found</h3><p>临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问。<br>和301 Moved Permanently 状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。<br>如果，用户把一个URI收藏为书签，302响应是不会像301那样去更新书签。</p>\n<h3 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h3><p>该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。<br>但是有一点是需要注意的，许多HTTP/1.1版以前的浏览器不能正确理解303状态码，很多现存的浏览器讲302响应视为303响应，并且使用GET方式访问<code>Location</code>中规定的的URI，而无视原先请求的方法。<br>在RFC2616中有相关的这样一段原文：</p>\n<blockquote>\n<p>Note: Many pre-HTTP/1.1 user agents do not understand the 303 status. When interoperability with such clients is a concern, the 302 status code may be used instead, since most user agents react to a 302 response as described here for 303.</p>\n</blockquote>\n<h3 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a>304 Not Modified</h3><p>该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主题部分。附带条件的请求指的是采用GET方法的请求头中包含：<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-match\" target=\"_blank\" rel=\"external\"><code>If-Match</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-modified-since\" target=\"_blank\" rel=\"external\"><code>If-Modified-Since</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-none-match\" target=\"_blank\" rel=\"external\"><code>If-None-Match</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-range\" target=\"_blank\" rel=\"external\"><code>If-Range</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-unmodified-since\" target=\"_blank\" rel=\"external\"><code>If-Unmodified-Since</code></a>中任一首部。</p>\n<h3 id=\"307-Temporary-Redirect\"><a href=\"#307-Temporary-Redirect\" class=\"headerlink\" title=\"307 Temporary Redirect\"></a>307 Temporary Redirect</h3><p>临时重定向。该状态码与302和303的有着类似的含义，不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。(302指定使用原有请求方法，303指定使用GET方法)</p>\n<h2 id=\"4XX-Client-Error\"><a href=\"#4XX-Client-Error\" class=\"headerlink\" title=\"4XX Client Error\"></a>4XX Client Error</h2><blockquote>\n<p>The 4xx class of status code is intended for cases in which the client seems to have erred.</p>\n</blockquote>\n<p>4XX 的响应结果表明客户端是发生错误的原因所在</p>\n<h3 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h3><p>表示该请求报文中存在语法错误，导致服务器无法理解该请求。客户端需要修改请求的内容后再次发送请求。</p>\n<h3 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h3><p>该状态码表示发送的请求需要有通过HTTP认证(Basic认证，Digest认证)的认证信息。返回含有401的响应，必须在头部包含<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.www-authenticate\" target=\"_blank\" rel=\"external\"><code>WWW-Authenticate</code></a>以指明服务器需要哪种方式的认证。<br>当客户端再次请求该资源的时候，需要在请求头中的<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.authorization\" target=\"_blank\" rel=\"external\"><code>Authorization</code></a>包含认证信息。<br>更多关于认证授权的信息关注<a href=\"http://pretty-rfc.herokuapp.com/RFC2617\" target=\"_blank\" rel=\"external\">RFC2617</a></p>\n<h3 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a>403 Forbidden</h3><p>该状态码表明对请求资源的访问被服务器拒绝了。服务器没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分原因进行描述，这样就能让用户看到了。<br>未获得文件系统的访问权限，访问权限出现某些问题，从未授权的发送源IP地址试图访问等情况都可能发生403响应。</p>\n<h3 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h3><p>该状态码表明服务器上无法找到指定的资源。通常被用于服务器不想透露拒绝请求的原因，或者没有其他的响应可提供。</p>\n<h2 id=\"5XX-Server-Error\"><a href=\"#5XX-Server-Error\" class=\"headerlink\" title=\"5XX Server Error\"></a>5XX Server Error</h2><blockquote>\n<p>Response status codes beginning with the digit “5” indicate cases in which the server is aware that it has erred or is incapable of performing the request. </p>\n</blockquote>\n<p>5XX 的响应结果表明服务器本身发生错误，或者没有足够的能力来处理请求。</p>\n<h3 id=\"500-Internal-Server-Error\"><a href=\"#500-Internal-Server-Error\" class=\"headerlink\" title=\"500 Internal Server Error\"></a>500 Internal Server Error</h3><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的BUG或某些临时的故障。</p>\n<h3 id=\"503-Service-Unavailable\"><a href=\"#503-Service-Unavailable\" class=\"headerlink\" title=\"503 Service Unavailable\"></a>503 Service Unavailable</h3><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上需要的时间，最好写入<code>Retry-After</code>首部字段再返回给客户端。</p>\n","excerpt":"","more":"<p>状态码的职责是当客户端向服务器端发送请求时，描述返回请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了什么错误。</p>\n<p><a href=\"http://pretty-rfc.herokuapp.com/RFC2616\">RFC2616</a>定义的状态码，由3位数字和原因短信组成。<br>数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种：</p>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Reason-phrase</th>\n<th>Note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td>Informational</td>\n<td>信息性状态码，表示接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success</td>\n<td>成功状态码，表示请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection</td>\n<td>重定向状态码，表示需要客户端需要进行附加操作</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error</td>\n<td>客户端错误状态码，表示服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error</td>\n<td>服务器错误状态码，表示服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<p>RFC2616记录的HTTP状态码有37种，再加上「WebDAV」(<a href=\"https://datatracker.ietf.org/doc/rfc4918/\">RFC4918</a>、<a href=\"https://datatracker.ietf.org/doc/rfc5842/\">5842</a>)和「Additional HTTP Status Codes」(<a href=\"https://datatracker.ietf.org/doc/rfc6585/\">RFC6585</a>)，数量就达到60多种。<br>然并卵，这么多种HTTP状态码，其实常用的大概只有14种，本文就讲讲这14种状态码。</p>\n<h2 id=\"2XX-Success\"><a href=\"#2XX-Success\" class=\"headerlink\" title=\"2XX Success\"></a>2XX Success</h2><blockquote>\n<p>This class of status code indicates that the client’s request was successfully received, understood, and accepted.</p>\n</blockquote>\n<p>2xx 响应结果表示从客户端发来的请求在服务器端被正常处理了。</p>\n<h3 id=\"200-OK\"><a href=\"#200-OK\" class=\"headerlink\" title=\"200 OK\"></a>200 OK</h3><p>请求被成功处理，服务器会根据不同的请求方法返回结果：<br><strong>GET</strong>：请求的对应资源会作为响应返回。<br><strong>HEAD</strong>：请求的对应资源的响应头(entity-header)会作为响应返回,不包括响应体(message-body)。<br><strong>POST</strong>：返回处理对应请求的结果。</p>\n<h3 id=\"204-No-Content\"><a href=\"#204-No-Content\" class=\"headerlink\" title=\"204 No Content\"></a>204 No Content</h3><p>该状态码表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体.<br>比如，客户端是浏览器的话，发出的请求返回204响应，那么浏览器显示的页面不会发生更新。</p>\n<h3 id=\"206-Partial-Content\"><a href=\"#206-Partial-Content\" class=\"headerlink\" title=\"206 Partial Content\"></a>206 Partial Content</h3><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。<br>客户端发起的请求，必须在请求头中包含<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.range\"><code>Range</code></a>字段。服务端响应报文中，必须包含由<code>Content-Range</code>指定范围的实体内容(entity-bodies )</p>\n<h2 id=\"3XX-Redirection\"><a href=\"#3XX-Redirection\" class=\"headerlink\" title=\"3XX Redirection\"></a>3XX Redirection</h2><blockquote>\n<p>This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.</p>\n</blockquote>\n<p>3XX 响应结果表明浏览器需要执行某些特殊的处理以完成请求。</p>\n<h3 id=\"301-Moved-Permanently\"><a href=\"#301-Moved-Permanently\" class=\"headerlink\" title=\"301 Moved Permanently\"></a>301 Moved Permanently</h3><p>永久性重定向。该状态码表示请求的资源已经被分配了新的URI，并且以后使用资源现在所指的URI。并且根据请求的方法有不同的处理方式：<br><strong>HEAD</strong>：必须在响应头部<code>Location</code>字段中指明新的永久性的URI。<br><strong>GET</strong>：除了有<code>Location</code>字段以外，还需要在响应体中附上永久性URI的超链接文本。<br><strong>POST</strong>：客户端在发送POST请求，受到301响应之后，不应该自动跳转URI，应当让用户确认跳转。</p>\n<p>比如，如果一个URI已经在浏览器中被收藏为书签，这时应该按照<code>Location</code>首部字段提示的URI重新保存。<br>例如建立一个收藏的书签：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://wan.bigertech.com</span><br></pre></td></tr></table></figure></p>\n<p>当访问这个书签的时候，请求会被重定向到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://wan.meizu.com</span><br></pre></td></tr></table></figure></p>\n<p>并且对应的书签会被改变，指向<code>http://wan.meizu.com</code><br>不信？Try yourself.</p>\n<h3 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a>302 Found</h3><p>临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问。<br>和301 Moved Permanently 状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。<br>如果，用户把一个URI收藏为书签，302响应是不会像301那样去更新书签。</p>\n<h3 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h3><p>该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。<br>但是有一点是需要注意的，许多HTTP/1.1版以前的浏览器不能正确理解303状态码，很多现存的浏览器讲302响应视为303响应，并且使用GET方式访问<code>Location</code>中规定的的URI，而无视原先请求的方法。<br>在RFC2616中有相关的这样一段原文：</p>\n<blockquote>\n<p>Note: Many pre-HTTP/1.1 user agents do not understand the 303 status. When interoperability with such clients is a concern, the 302 status code may be used instead, since most user agents react to a 302 response as described here for 303.</p>\n</blockquote>\n<h3 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a>304 Not Modified</h3><p>该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主题部分。附带条件的请求指的是采用GET方法的请求头中包含：<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-match\"><code>If-Match</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-modified-since\"><code>If-Modified-Since</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-none-match\"><code>If-None-Match</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-range\"><code>If-Range</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-unmodified-since\"><code>If-Unmodified-Since</code></a>中任一首部。</p>\n<h3 id=\"307-Temporary-Redirect\"><a href=\"#307-Temporary-Redirect\" class=\"headerlink\" title=\"307 Temporary Redirect\"></a>307 Temporary Redirect</h3><p>临时重定向。该状态码与302和303的有着类似的含义，不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。(302指定使用原有请求方法，303指定使用GET方法)</p>\n<h2 id=\"4XX-Client-Error\"><a href=\"#4XX-Client-Error\" class=\"headerlink\" title=\"4XX Client Error\"></a>4XX Client Error</h2><blockquote>\n<p>The 4xx class of status code is intended for cases in which the client seems to have erred.</p>\n</blockquote>\n<p>4XX 的响应结果表明客户端是发生错误的原因所在</p>\n<h3 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h3><p>表示该请求报文中存在语法错误，导致服务器无法理解该请求。客户端需要修改请求的内容后再次发送请求。</p>\n<h3 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h3><p>该状态码表示发送的请求需要有通过HTTP认证(Basic认证，Digest认证)的认证信息。返回含有401的响应，必须在头部包含<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.www-authenticate\"><code>WWW-Authenticate</code></a>以指明服务器需要哪种方式的认证。<br>当客户端再次请求该资源的时候，需要在请求头中的<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.authorization\"><code>Authorization</code></a>包含认证信息。<br>更多关于认证授权的信息关注<a href=\"http://pretty-rfc.herokuapp.com/RFC2617\">RFC2617</a></p>\n<h3 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a>403 Forbidden</h3><p>该状态码表明对请求资源的访问被服务器拒绝了。服务器没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分原因进行描述，这样就能让用户看到了。<br>未获得文件系统的访问权限，访问权限出现某些问题，从未授权的发送源IP地址试图访问等情况都可能发生403响应。</p>\n<h3 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h3><p>该状态码表明服务器上无法找到指定的资源。通常被用于服务器不想透露拒绝请求的原因，或者没有其他的响应可提供。</p>\n<h2 id=\"5XX-Server-Error\"><a href=\"#5XX-Server-Error\" class=\"headerlink\" title=\"5XX Server Error\"></a>5XX Server Error</h2><blockquote>\n<p>Response status codes beginning with the digit “5” indicate cases in which the server is aware that it has erred or is incapable of performing the request. </p>\n</blockquote>\n<p>5XX 的响应结果表明服务器本身发生错误，或者没有足够的能力来处理请求。</p>\n<h3 id=\"500-Internal-Server-Error\"><a href=\"#500-Internal-Server-Error\" class=\"headerlink\" title=\"500 Internal Server Error\"></a>500 Internal Server Error</h3><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的BUG或某些临时的故障。</p>\n<h3 id=\"503-Service-Unavailable\"><a href=\"#503-Service-Unavailable\" class=\"headerlink\" title=\"503 Service Unavailable\"></a>503 Service Unavailable</h3><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上需要的时间，最好写入<code>Retry-After</code>首部字段再返回给客户端。</p>\n"},{"title":"「ES6笔记」Babel","date":"2016-06-19T15:09:40.000Z","_content":"\n# .babelrc\nBabel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。\n规则如下：\n```\n{\n  \"presets\": [],\n  \"plugins\": []\n}\n```\n\n`presets`字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。\n```\n# ES2015转码规则\n$ npm install --save-dev babel-preset-es2015\n\n# react转码规则\n$ npm install --save-dev babel-preset-react\n\n# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个\n$ npm install --save-dev babel-preset-stage-0\n$ npm install --save-dev babel-preset-stage-1\n$ npm install --save-dev babel-preset-stage-2\n$ npm install --save-dev babel-preset-stage-3\n```\n然后讲这些规则加入`.babelrc`\n```\n  {\n    \"presets\": [\n      \"es2015\",\n      \"react\",\n      \"stage-2\"\n    ],\n    \"plugins\": []\n  }\n```\n\n# babel-cli\n`npm install babel-cli --save-dev`\n该工具用于命令行转码\n基本用法：\n```\n# 转码结果输出到标准输出\n$ babel example.js\n\n# 转码结果写入一个文件\n# --out-file 或 -o 参数指定输出文件\n$ babel example.js --out-file compiled.js\n# 或者\n$ babel example.js -o compiled.js\n\n# 整个目录转码\n# --out-dir 或 -d 参数指定输出目录\n$ babel src --out-dir lib\n# 或者\n$ babel src -d lib\n\n# -s 参数生成source map文件\n$ babel src -d lib -s\n```\n\n## 使用npm script 构建\n把`node-cli`安装在项目中，然后改写`package.json`\n```\n{\n  // ...\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.0.0\"\n  },\n  \"scripts\": {\n    \"build\": \"babel src -d lib\"\n  },\n}\n```\n\n# babel-node\n`babel-node`给`node`包上一层外衣，使得可以像使用`node`那样执行js文件，这个过程是运行时编译。\n```\nbabel-node index.js\n```\n`babel-node`随着`babel-cli`安装。\n\n# babel-register\n```\nnpm install babel-register --save-dev\n```\n`babel-register`模块改写`require`命令，为它加上一个钩子。此后，每当使用`require`加载`.js、.jsx、.es、.es6`后缀名的文件，就会先用Babel进行转码。\n然后，在`require`之前，引入`babel-register`\n```\nrequire(\"babel-register\");\nrequire(\"./index.js\");\n```\n这个过程是运行时编译，只适用于开发环境中\n\n# babel-core\n`npm install --save-dev babel-core`\n`babel-core`可以使在代码中使用`babel`的API\n```\nvar babel = require('babel-core');\n\n// 字符串转码\nbabel.transform('code();', options);\n// => { code, map, ast }\n\n// 文件转码（异步）\nbabel.transformFile('filename.js', options, function(err, result) {\n  result; // => { code, map, ast }\n});\n\n// 文件转码（同步）\nbabel.transformFileSync('filename.js', options);\n// => { code, map, ast }\n\n// Babel AST转码\nbabel.transformFromAst(ast, code, options);\n// => { code, map, ast }\n```\n\n# babel-polyfill\n由于`babel`默认转换的是语法，而一些ES6环境扩展的API，却没有转换。像`Array.from`、`String.padStart`并不会转换，如果要使用到这部分API，那就需要在文件中引入`babel-polyfill`\n```\n// script.js\nrequire(\"babel-polyfill\");\nconst name = 'jc';\nconsole.log(name.padStart(10));\n```\n以上脚本会被转换成\n```\n// complied.js\n\"use strict\";\nrequire(\"babel-polyfill\");\nvar name = 'jc';\nconsole.log(name.padStart(10));\n```\n直接在低版本Node环境中执行转换后的脚本，会正常运行。\n注意的是，`babel-node script.js`会报`only one instance of babel-polyfill is allowed`错误\n\n# babel-browser\n在浏览器中运行时编译，可以引入`babel-core@5` 文件中的 `browser.min.js`文件\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js\"></script>\n```\n注意的是，在Babel6.0之后中，babel-core不会再提供`browser.min.js`\n\n# babel-standalone\n`babel-standalone`是给那些非Node.js环境中使用最新的JavaScript而服务的。\n这部分描述见于[babel-standalone](https://github.com/Daniel15/babel-standalone);\n\n使用`babel-standalone`可以取代`babel-browser`的方案，在脚本中引入\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js\"></script>\n<script type=\"text/babel\">\n// Your ES6 code\n</script>\n```\n\n# babel in mocha\n在使用mocha的时候，除了可以使用`babel-register`，也可以使用以下方式\n在`package.json`中添加：\n```\n\"scripts\": {\n  \"test\": \"mocha --ui qunit --compilers js:babel-core/register\"\n}\n```\n上面命令中，`--compilers`参数指定脚本的转码器，规定后缀名为js的文件，都需要使用`babel-core/register`先转码。\n\n# babel with webpack\n使用`babel-loader`可以在webpack打包过程中编译ES2015的代码。\n安装以下依赖\n```\nnpm install babel-core babel-loader babel-preset-2015 webpack --save-dev\n```\n然后在项目中新建`webpack.config.js`\n```\nmodule.exports = {\n  entry: \"./src/app.js\",\n  output: {\n    path: './bin',\n    filename: 'app.bunble.js'\n  },\n  module: {\n    loaders: [{\n      loader: 'babel-loader',\n      test: /.js$/,\n      exclude: /node_modules/\n    }]\n  }\n}\n```\n通过配置`loaders`，把所用`.js`后缀的文件通过babel编译。\n在这里为了避免编译依赖模块的代码，剔除`node_modules`文件夹。","source":"_posts/「ES6笔记」 Babel.md","raw":"---\ntitle: 「ES6笔记」Babel\ncategory: 搬砖码农\ndate: 2016-6-19 23:09:40\ntags:\n- babel\n- ES6\n---\n\n# .babelrc\nBabel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。\n规则如下：\n```\n{\n  \"presets\": [],\n  \"plugins\": []\n}\n```\n\n`presets`字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。\n```\n# ES2015转码规则\n$ npm install --save-dev babel-preset-es2015\n\n# react转码规则\n$ npm install --save-dev babel-preset-react\n\n# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个\n$ npm install --save-dev babel-preset-stage-0\n$ npm install --save-dev babel-preset-stage-1\n$ npm install --save-dev babel-preset-stage-2\n$ npm install --save-dev babel-preset-stage-3\n```\n然后讲这些规则加入`.babelrc`\n```\n  {\n    \"presets\": [\n      \"es2015\",\n      \"react\",\n      \"stage-2\"\n    ],\n    \"plugins\": []\n  }\n```\n\n# babel-cli\n`npm install babel-cli --save-dev`\n该工具用于命令行转码\n基本用法：\n```\n# 转码结果输出到标准输出\n$ babel example.js\n\n# 转码结果写入一个文件\n# --out-file 或 -o 参数指定输出文件\n$ babel example.js --out-file compiled.js\n# 或者\n$ babel example.js -o compiled.js\n\n# 整个目录转码\n# --out-dir 或 -d 参数指定输出目录\n$ babel src --out-dir lib\n# 或者\n$ babel src -d lib\n\n# -s 参数生成source map文件\n$ babel src -d lib -s\n```\n\n## 使用npm script 构建\n把`node-cli`安装在项目中，然后改写`package.json`\n```\n{\n  // ...\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.0.0\"\n  },\n  \"scripts\": {\n    \"build\": \"babel src -d lib\"\n  },\n}\n```\n\n# babel-node\n`babel-node`给`node`包上一层外衣，使得可以像使用`node`那样执行js文件，这个过程是运行时编译。\n```\nbabel-node index.js\n```\n`babel-node`随着`babel-cli`安装。\n\n# babel-register\n```\nnpm install babel-register --save-dev\n```\n`babel-register`模块改写`require`命令，为它加上一个钩子。此后，每当使用`require`加载`.js、.jsx、.es、.es6`后缀名的文件，就会先用Babel进行转码。\n然后，在`require`之前，引入`babel-register`\n```\nrequire(\"babel-register\");\nrequire(\"./index.js\");\n```\n这个过程是运行时编译，只适用于开发环境中\n\n# babel-core\n`npm install --save-dev babel-core`\n`babel-core`可以使在代码中使用`babel`的API\n```\nvar babel = require('babel-core');\n\n// 字符串转码\nbabel.transform('code();', options);\n// => { code, map, ast }\n\n// 文件转码（异步）\nbabel.transformFile('filename.js', options, function(err, result) {\n  result; // => { code, map, ast }\n});\n\n// 文件转码（同步）\nbabel.transformFileSync('filename.js', options);\n// => { code, map, ast }\n\n// Babel AST转码\nbabel.transformFromAst(ast, code, options);\n// => { code, map, ast }\n```\n\n# babel-polyfill\n由于`babel`默认转换的是语法，而一些ES6环境扩展的API，却没有转换。像`Array.from`、`String.padStart`并不会转换，如果要使用到这部分API，那就需要在文件中引入`babel-polyfill`\n```\n// script.js\nrequire(\"babel-polyfill\");\nconst name = 'jc';\nconsole.log(name.padStart(10));\n```\n以上脚本会被转换成\n```\n// complied.js\n\"use strict\";\nrequire(\"babel-polyfill\");\nvar name = 'jc';\nconsole.log(name.padStart(10));\n```\n直接在低版本Node环境中执行转换后的脚本，会正常运行。\n注意的是，`babel-node script.js`会报`only one instance of babel-polyfill is allowed`错误\n\n# babel-browser\n在浏览器中运行时编译，可以引入`babel-core@5` 文件中的 `browser.min.js`文件\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js\"></script>\n```\n注意的是，在Babel6.0之后中，babel-core不会再提供`browser.min.js`\n\n# babel-standalone\n`babel-standalone`是给那些非Node.js环境中使用最新的JavaScript而服务的。\n这部分描述见于[babel-standalone](https://github.com/Daniel15/babel-standalone);\n\n使用`babel-standalone`可以取代`babel-browser`的方案，在脚本中引入\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js\"></script>\n<script type=\"text/babel\">\n// Your ES6 code\n</script>\n```\n\n# babel in mocha\n在使用mocha的时候，除了可以使用`babel-register`，也可以使用以下方式\n在`package.json`中添加：\n```\n\"scripts\": {\n  \"test\": \"mocha --ui qunit --compilers js:babel-core/register\"\n}\n```\n上面命令中，`--compilers`参数指定脚本的转码器，规定后缀名为js的文件，都需要使用`babel-core/register`先转码。\n\n# babel with webpack\n使用`babel-loader`可以在webpack打包过程中编译ES2015的代码。\n安装以下依赖\n```\nnpm install babel-core babel-loader babel-preset-2015 webpack --save-dev\n```\n然后在项目中新建`webpack.config.js`\n```\nmodule.exports = {\n  entry: \"./src/app.js\",\n  output: {\n    path: './bin',\n    filename: 'app.bunble.js'\n  },\n  module: {\n    loaders: [{\n      loader: 'babel-loader',\n      test: /.js$/,\n      exclude: /node_modules/\n    }]\n  }\n}\n```\n通过配置`loaders`，把所用`.js`后缀的文件通过babel编译。\n在这里为了避免编译依赖模块的代码，剔除`node_modules`文件夹。","slug":"「ES6笔记」 Babel","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8s80034xwrl1yke7u26","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"babelrc\"><a href=\"#babelrc\" class=\"headerlink\" title=\".babelrc\"></a>.babelrc</h1><p>Babel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。<br>规则如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [],</span><br><span class=\"line\">  &quot;plugins&quot;: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>presets</code>字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ES2015转码规则</span><br><span class=\"line\">$ npm install --save-dev babel-preset-es2015</span><br><span class=\"line\"></span><br><span class=\"line\"># react转码规则</span><br><span class=\"line\">$ npm install --save-dev babel-preset-react</span><br><span class=\"line\"></span><br><span class=\"line\"># ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个</span><br><span class=\"line\">$ npm install --save-dev babel-preset-stage-0</span><br><span class=\"line\">$ npm install --save-dev babel-preset-stage-1</span><br><span class=\"line\">$ npm install --save-dev babel-preset-stage-2</span><br><span class=\"line\">$ npm install --save-dev babel-preset-stage-3</span><br></pre></td></tr></table></figure></p>\n<p>然后讲这些规则加入<code>.babelrc</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    &quot;es2015&quot;,</span><br><span class=\"line\">    &quot;react&quot;,</span><br><span class=\"line\">    &quot;stage-2&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;plugins&quot;: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"babel-cli\"><a href=\"#babel-cli\" class=\"headerlink\" title=\"babel-cli\"></a>babel-cli</h1><p><code>npm install babel-cli --save-dev</code><br>该工具用于命令行转码<br>基本用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 转码结果输出到标准输出</span><br><span class=\"line\">$ babel example.js</span><br><span class=\"line\"></span><br><span class=\"line\"># 转码结果写入一个文件</span><br><span class=\"line\"># --out-file 或 -o 参数指定输出文件</span><br><span class=\"line\">$ babel example.js --out-file compiled.js</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ babel example.js -o compiled.js</span><br><span class=\"line\"></span><br><span class=\"line\"># 整个目录转码</span><br><span class=\"line\"># --out-dir 或 -d 参数指定输出目录</span><br><span class=\"line\">$ babel src --out-dir lib</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ babel src -d lib</span><br><span class=\"line\"></span><br><span class=\"line\"># -s 参数生成source map文件</span><br><span class=\"line\">$ babel src -d lib -s</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用npm-script-构建\"><a href=\"#使用npm-script-构建\" class=\"headerlink\" title=\"使用npm script 构建\"></a>使用npm script 构建</h2><p>把<code>node-cli</code>安装在项目中，然后改写<code>package.json</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  &quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;babel-cli&quot;: &quot;^6.0.0&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build&quot;: &quot;babel src -d lib&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"babel-node\"><a href=\"#babel-node\" class=\"headerlink\" title=\"babel-node\"></a>babel-node</h1><p><code>babel-node</code>给<code>node</code>包上一层外衣，使得可以像使用<code>node</code>那样执行js文件，这个过程是运行时编译。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">babel-node index.js</span><br></pre></td></tr></table></figure></p>\n<p><code>babel-node</code>随着<code>babel-cli</code>安装。</p>\n<h1 id=\"babel-register\"><a href=\"#babel-register\" class=\"headerlink\" title=\"babel-register\"></a>babel-register</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-register --save-dev</span><br></pre></td></tr></table></figure>\n<p><code>babel-register</code>模块改写<code>require</code>命令，为它加上一个钩子。此后，每当使用<code>require</code>加载<code>.js、.jsx、.es、.es6</code>后缀名的文件，就会先用Babel进行转码。<br>然后，在<code>require</code>之前，引入<code>babel-register</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&quot;babel-register&quot;);</span><br><span class=\"line\">require(&quot;./index.js&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>这个过程是运行时编译，只适用于开发环境中</p>\n<h1 id=\"babel-core\"><a href=\"#babel-core\" class=\"headerlink\" title=\"babel-core\"></a>babel-core</h1><p><code>npm install --save-dev babel-core</code><br><code>babel-core</code>可以使在代码中使用<code>babel</code>的API<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var babel = require(&apos;babel-core&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 字符串转码</span><br><span class=\"line\">babel.transform(&apos;code();&apos;, options);</span><br><span class=\"line\">// =&gt; &#123; code, map, ast &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件转码（异步）</span><br><span class=\"line\">babel.transformFile(&apos;filename.js&apos;, options, function(err, result) &#123;</span><br><span class=\"line\">  result; // =&gt; &#123; code, map, ast &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件转码（同步）</span><br><span class=\"line\">babel.transformFileSync(&apos;filename.js&apos;, options);</span><br><span class=\"line\">// =&gt; &#123; code, map, ast &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Babel AST转码</span><br><span class=\"line\">babel.transformFromAst(ast, code, options);</span><br><span class=\"line\">// =&gt; &#123; code, map, ast &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"babel-polyfill\"><a href=\"#babel-polyfill\" class=\"headerlink\" title=\"babel-polyfill\"></a>babel-polyfill</h1><p>由于<code>babel</code>默认转换的是语法，而一些ES6环境扩展的API，却没有转换。像<code>Array.from</code>、<code>String.padStart</code>并不会转换，如果要使用到这部分API，那就需要在文件中引入<code>babel-polyfill</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// script.js</span><br><span class=\"line\">require(&quot;babel-polyfill&quot;);</span><br><span class=\"line\">const name = &apos;jc&apos;;</span><br><span class=\"line\">console.log(name.padStart(10));</span><br></pre></td></tr></table></figure></p>\n<p>以上脚本会被转换成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// complied.js</span><br><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">require(&quot;babel-polyfill&quot;);</span><br><span class=\"line\">var name = &apos;jc&apos;;</span><br><span class=\"line\">console.log(name.padStart(10));</span><br></pre></td></tr></table></figure></p>\n<p>直接在低版本Node环境中执行转换后的脚本，会正常运行。<br>注意的是，<code>babel-node script.js</code>会报<code>only one instance of babel-polyfill is allowed</code>错误</p>\n<h1 id=\"babel-browser\"><a href=\"#babel-browser\" class=\"headerlink\" title=\"babel-browser\"></a>babel-browser</h1><p>在浏览器中运行时编译，可以引入<code>babel-core@5</code> 文件中的 <code>browser.min.js</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>注意的是，在Babel6.0之后中，babel-core不会再提供<code>browser.min.js</code></p>\n<h1 id=\"babel-standalone\"><a href=\"#babel-standalone\" class=\"headerlink\" title=\"babel-standalone\"></a>babel-standalone</h1><p><code>babel-standalone</code>是给那些非Node.js环境中使用最新的JavaScript而服务的。<br>这部分描述见于<a href=\"https://github.com/Daniel15/babel-standalone\" target=\"_blank\" rel=\"external\">babel-standalone</a>;</p>\n<p>使用<code>babel-standalone</code>可以取代<code>babel-browser</code>的方案，在脚本中引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class=\"line\">// Your ES6 code</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"babel-in-mocha\"><a href=\"#babel-in-mocha\" class=\"headerlink\" title=\"babel in mocha\"></a>babel in mocha</h1><p>在使用mocha的时候，除了可以使用<code>babel-register</code>，也可以使用以下方式<br>在<code>package.json</code>中添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;test&quot;: &quot;mocha --ui qunit --compilers js:babel-core/register&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面命令中，<code>--compilers</code>参数指定脚本的转码器，规定后缀名为js的文件，都需要使用<code>babel-core/register</code>先转码。</p>\n<h1 id=\"babel-with-webpack\"><a href=\"#babel-with-webpack\" class=\"headerlink\" title=\"babel with webpack\"></a>babel with webpack</h1><p>使用<code>babel-loader</code>可以在webpack打包过程中编译ES2015的代码。<br>安装以下依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-core babel-loader babel-preset-2015 webpack --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>然后在项目中新建<code>webpack.config.js</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  entry: &quot;./src/app.js&quot;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: &apos;./bin&apos;,</span><br><span class=\"line\">    filename: &apos;app.bunble.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    loaders: [&#123;</span><br><span class=\"line\">      loader: &apos;babel-loader&apos;,</span><br><span class=\"line\">      test: /.js$/,</span><br><span class=\"line\">      exclude: /node_modules/</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过配置<code>loaders</code>，把所用<code>.js</code>后缀的文件通过babel编译。<br>在这里为了避免编译依赖模块的代码，剔除<code>node_modules</code>文件夹。</p>\n","excerpt":"","more":"<h1 id=\"babelrc\"><a href=\"#babelrc\" class=\"headerlink\" title=\".babelrc\"></a>.babelrc</h1><p>Babel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。<br>规则如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [],</span><br><span class=\"line\">  &quot;plugins&quot;: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>presets</code>字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ES2015转码规则</span><br><span class=\"line\">$ npm install --save-dev babel-preset-es2015</span><br><span class=\"line\"></span><br><span class=\"line\"># react转码规则</span><br><span class=\"line\">$ npm install --save-dev babel-preset-react</span><br><span class=\"line\"></span><br><span class=\"line\"># ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个</span><br><span class=\"line\">$ npm install --save-dev babel-preset-stage-0</span><br><span class=\"line\">$ npm install --save-dev babel-preset-stage-1</span><br><span class=\"line\">$ npm install --save-dev babel-preset-stage-2</span><br><span class=\"line\">$ npm install --save-dev babel-preset-stage-3</span><br></pre></td></tr></table></figure></p>\n<p>然后讲这些规则加入<code>.babelrc</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    &quot;es2015&quot;,</span><br><span class=\"line\">    &quot;react&quot;,</span><br><span class=\"line\">    &quot;stage-2&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;plugins&quot;: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"babel-cli\"><a href=\"#babel-cli\" class=\"headerlink\" title=\"babel-cli\"></a>babel-cli</h1><p><code>npm install babel-cli --save-dev</code><br>该工具用于命令行转码<br>基本用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 转码结果输出到标准输出</span><br><span class=\"line\">$ babel example.js</span><br><span class=\"line\"></span><br><span class=\"line\"># 转码结果写入一个文件</span><br><span class=\"line\"># --out-file 或 -o 参数指定输出文件</span><br><span class=\"line\">$ babel example.js --out-file compiled.js</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ babel example.js -o compiled.js</span><br><span class=\"line\"></span><br><span class=\"line\"># 整个目录转码</span><br><span class=\"line\"># --out-dir 或 -d 参数指定输出目录</span><br><span class=\"line\">$ babel src --out-dir lib</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ babel src -d lib</span><br><span class=\"line\"></span><br><span class=\"line\"># -s 参数生成source map文件</span><br><span class=\"line\">$ babel src -d lib -s</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用npm-script-构建\"><a href=\"#使用npm-script-构建\" class=\"headerlink\" title=\"使用npm script 构建\"></a>使用npm script 构建</h2><p>把<code>node-cli</code>安装在项目中，然后改写<code>package.json</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  &quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;babel-cli&quot;: &quot;^6.0.0&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build&quot;: &quot;babel src -d lib&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"babel-node\"><a href=\"#babel-node\" class=\"headerlink\" title=\"babel-node\"></a>babel-node</h1><p><code>babel-node</code>给<code>node</code>包上一层外衣，使得可以像使用<code>node</code>那样执行js文件，这个过程是运行时编译。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">babel-node index.js</span><br></pre></td></tr></table></figure></p>\n<p><code>babel-node</code>随着<code>babel-cli</code>安装。</p>\n<h1 id=\"babel-register\"><a href=\"#babel-register\" class=\"headerlink\" title=\"babel-register\"></a>babel-register</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-register --save-dev</span><br></pre></td></tr></table></figure>\n<p><code>babel-register</code>模块改写<code>require</code>命令，为它加上一个钩子。此后，每当使用<code>require</code>加载<code>.js、.jsx、.es、.es6</code>后缀名的文件，就会先用Babel进行转码。<br>然后，在<code>require</code>之前，引入<code>babel-register</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&quot;babel-register&quot;);</span><br><span class=\"line\">require(&quot;./index.js&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>这个过程是运行时编译，只适用于开发环境中</p>\n<h1 id=\"babel-core\"><a href=\"#babel-core\" class=\"headerlink\" title=\"babel-core\"></a>babel-core</h1><p><code>npm install --save-dev babel-core</code><br><code>babel-core</code>可以使在代码中使用<code>babel</code>的API<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var babel = require(&apos;babel-core&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 字符串转码</span><br><span class=\"line\">babel.transform(&apos;code();&apos;, options);</span><br><span class=\"line\">// =&gt; &#123; code, map, ast &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件转码（异步）</span><br><span class=\"line\">babel.transformFile(&apos;filename.js&apos;, options, function(err, result) &#123;</span><br><span class=\"line\">  result; // =&gt; &#123; code, map, ast &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件转码（同步）</span><br><span class=\"line\">babel.transformFileSync(&apos;filename.js&apos;, options);</span><br><span class=\"line\">// =&gt; &#123; code, map, ast &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Babel AST转码</span><br><span class=\"line\">babel.transformFromAst(ast, code, options);</span><br><span class=\"line\">// =&gt; &#123; code, map, ast &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"babel-polyfill\"><a href=\"#babel-polyfill\" class=\"headerlink\" title=\"babel-polyfill\"></a>babel-polyfill</h1><p>由于<code>babel</code>默认转换的是语法，而一些ES6环境扩展的API，却没有转换。像<code>Array.from</code>、<code>String.padStart</code>并不会转换，如果要使用到这部分API，那就需要在文件中引入<code>babel-polyfill</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// script.js</span><br><span class=\"line\">require(&quot;babel-polyfill&quot;);</span><br><span class=\"line\">const name = &apos;jc&apos;;</span><br><span class=\"line\">console.log(name.padStart(10));</span><br></pre></td></tr></table></figure></p>\n<p>以上脚本会被转换成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// complied.js</span><br><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">require(&quot;babel-polyfill&quot;);</span><br><span class=\"line\">var name = &apos;jc&apos;;</span><br><span class=\"line\">console.log(name.padStart(10));</span><br></pre></td></tr></table></figure></p>\n<p>直接在低版本Node环境中执行转换后的脚本，会正常运行。<br>注意的是，<code>babel-node script.js</code>会报<code>only one instance of babel-polyfill is allowed</code>错误</p>\n<h1 id=\"babel-browser\"><a href=\"#babel-browser\" class=\"headerlink\" title=\"babel-browser\"></a>babel-browser</h1><p>在浏览器中运行时编译，可以引入<code>babel-core@5</code> 文件中的 <code>browser.min.js</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>注意的是，在Babel6.0之后中，babel-core不会再提供<code>browser.min.js</code></p>\n<h1 id=\"babel-standalone\"><a href=\"#babel-standalone\" class=\"headerlink\" title=\"babel-standalone\"></a>babel-standalone</h1><p><code>babel-standalone</code>是给那些非Node.js环境中使用最新的JavaScript而服务的。<br>这部分描述见于<a href=\"https://github.com/Daniel15/babel-standalone\">babel-standalone</a>;</p>\n<p>使用<code>babel-standalone</code>可以取代<code>babel-browser</code>的方案，在脚本中引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class=\"line\">// Your ES6 code</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"babel-in-mocha\"><a href=\"#babel-in-mocha\" class=\"headerlink\" title=\"babel in mocha\"></a>babel in mocha</h1><p>在使用mocha的时候，除了可以使用<code>babel-register</code>，也可以使用以下方式<br>在<code>package.json</code>中添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;test&quot;: &quot;mocha --ui qunit --compilers js:babel-core/register&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面命令中，<code>--compilers</code>参数指定脚本的转码器，规定后缀名为js的文件，都需要使用<code>babel-core/register</code>先转码。</p>\n<h1 id=\"babel-with-webpack\"><a href=\"#babel-with-webpack\" class=\"headerlink\" title=\"babel with webpack\"></a>babel with webpack</h1><p>使用<code>babel-loader</code>可以在webpack打包过程中编译ES2015的代码。<br>安装以下依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-core babel-loader babel-preset-2015 webpack --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>然后在项目中新建<code>webpack.config.js</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  entry: &quot;./src/app.js&quot;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: &apos;./bin&apos;,</span><br><span class=\"line\">    filename: &apos;app.bunble.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    loaders: [&#123;</span><br><span class=\"line\">      loader: &apos;babel-loader&apos;,</span><br><span class=\"line\">      test: /.js$/,</span><br><span class=\"line\">      exclude: /node_modules/</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过配置<code>loaders</code>，把所用<code>.js</code>后缀的文件通过babel编译。<br>在这里为了避免编译依赖模块的代码，剔除<code>node_modules</code>文件夹。</p>\n"},{"title":"有赞微信小程序分享 — 概念篇","date":"2017-08-31T05:15:02.000Z","_content":"\n在 2016 年 9 月 23 日 微信小程序内测开始以来，有赞的产品与技术一直紧跟着小程序的步伐。并且在 2017年1月9日 微信小程序发布的同时上线了有赞微商城小程序和有赞精选小程序。并且紧跟着开源了小程序的 UI 库：[zanui-weapp](https://github.com/youzan/zanui-weapp)\n\n在我加入有赞不久后，就参与了微信小程序产品线的开发。\n随着今年微信官方大力推广和迭代，微信小程序可谓渐渐形成一个新重量级现象，对于自身来说，除了单纯的掌握技术上的开发姿势以外，还需对整个小程序生态以及未来的动向有足够的认识和了解。\n于是乎本着研究与学习，有了这一次内部分享。\n趁着课余时间，整理成文，与君分享。\n\n# 微信开发体系\n微信开发，是一个体系。\n无论是开发移动应用，网站应用，都可以接入微信生态，例如实现微信账号登录，实现 APP 分享到微信朋友圈和联系人。\n除了自有的应用，还可以在公众号内进行应用开发，为订阅号或者服务号提供更强大的功能和交互。\n现在又有了小程序，除了开发工具类应用更简单以外，连接线上线下的场景更丰富。\n在我认为，国内的互联网产品中，多多少少都会接触到微信的开发体系。\n因为这是一个庞大的流量入口啊。\n\n## 三个平台\n![三个平台](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/F0C87F9DD75168C4C99AC1BDB4C7AAD4.jpg)\n\n在接触微信的开发体系中，接触最多的是这三个平台。\n我们站在一个更高的维度来看，就知道小程序处于微信开发体系中的哪个位置了。\n\n### 开放平台\n开放平台下提供了以下支持：\n\n* **微信账号登录**：让你的应用接入微信账号体系。\n* **微信分享与收藏功能**：这个目前在移动应用特有，可以在 APP 中掉起微信分享与收藏。\n* **微信智能接口**：支持调用微信图像、语音等智能识别接口。\n* **微信支付**：调用微信支付接口\n* **第三方平台**：拥有第三方平台资格之后，就能帮助授权用户实现公众号和小程序的代开发服务了。在公众号红利时代，通过该平台就催生了一大波微信公众账号第三方管理平台。\n\n根据目的不同，你可能要申请不同的应用：\n\n* **网站应用**\n* **移动应用**\n* **第三方平台**\n\n### 公众平台\n\n微信是 2011 年 1 月推出的，而公众平台是  2012 年 8 月推出的。\n公众平台的推出，带来了一个继微博之后的新红利时代。大量的企业、媒体、公共机构、明星名人、个人用户都纷纷进军公众平台。\n需要搞清楚的一个概念是，起初并没有「订阅号」、「服务号」、「企业号」之分。\n公众平台推出之后，在 2013 年 8 月的时候分成订阅号和服务号，然后在 2014 年 9 月的时候新增了企业号。\n所以我们所说的「公众号」统称了「订阅号」、「服务号」、「企业号」。\n\n所以我们在公众平台，根据自身情况，申请以下几类账号：\n\n* **订阅号**：偏向提供传播服务，每天可推送一条消息，但是开放的功能相对服务号来说有限。\n* **服务号**：偏向提供功能服务，每月可推送四条消息，开放出了更多高级功能。\n* **企业号**：偏向员工管理。\n* **小程序**：嗯，这就是我们今天的主题。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。\n\n### 商户平台\n\n如果你需要拥有微信支付能力，首先要注册商户平台。\n在拥有微信支付资格之后，除了可以在开发过程中通过接口调用，唤起微信支付以外。\n在线下还可以实现扫码支付、刷卡支付等场景。\n\n## 账号体系\n\n![微信账号体系](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/ADD94BAC954A36120ADB41E7A8546FCB.jpg)\n\n在接入微信账号的时候，在我们申请的应用（网站应用、移动应用、公众号、小程序），对于用户都有一个 OpenID，但是同个用户在多个应用下的 OpenID 是不一样的。\n而如果想打通多个应用的用户的话，做法就是注册开放平台账号，然后把多个应用绑定到同一个开放平台账号下，这样就能获取 UnionID。\n\n而小程序对于 UnionID 有一个特别注意的地方：\n\n![UnionID 机制](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/EB40AFD817F2807B2A1626FACF25FE7C.jpg)\n\n小程序中，在绑定同一个开放平台账号的前提下。如果其他相同主体的应用账号被用户授权过之后，在小程序中就无需再次授权，直接获取 UnionID（正常情况下，获取 UnionID 需要用户授权的）。\n\n## 相同主体\n\n那么「相同主体」是什么概念？\n在我们注册应用之后，要真正部署到线上之前，都需要进行「认证主体」的步骤。\n对于个人来说，主体就是你本人，通过身份证标记唯一性。\n而对于企业来说，主体就是企业本身，通过营业执照来标记唯一性。\n\n![相同主体](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/0ABA321D4E60DC52F7B7F9DB8D444B6C.jpg)\n\n在任何一个以上线的公众号或者小程序中的详细信息，都可以查看得到本体信息。\n\n# 微信小程序的能力\n从 2016 年底发布的小程序，在 2017 年快速推进，每个月都会有迭代，而且大部分更新发布的时间都在凌晨。\n在此心痛微信小程序团队 10 秒钟。\n然后我们从截止 8月18日 回顾将近一年的时间，小程序的更新迭代来感受小程序具备哪些能力。\n\n![小程序更新回顾](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/2EC3DDD2B7877249747FB6CADE85C9C4.png)\n\n# 数据分析\n\n![数据分析](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/1951C347D0577BA466B972987B288CAE.png)\n\n对于数据分析的需求，其实我们可以有很多选择。\n\n**【小程序后台】**\n在小程序的后台，除了可以看到常见维度的访问数据以外，还支持收集自定义事件。\n并且还提供了 API，我们就可以在内部的管理后台中收集这些数据，进行分析和展示。\n\n**【官方小程序】**\n我们可以在微信的小程序入口搜索：《小程序数据助手》\n这是官方开发的在移动端查看小程序运营数据的小程序。\n\n**【第三方平台】**\n以下是收集的一些提供数据相关服务的第三方平台 (还没有验证可用性，需要自行判断)：\n\n* [TalkingData](https://www.talkingdata.com/)\n* [阿拉丁](http://www.aldwx.com/)\n* 友盟：目前还找不到支持微信小程序的 SDK。\n\n**【数据埋点】**\n对于数据埋点需求，以下是收集的一些 Saas 服务(还没有验证可用性，需要自行判断)：\n\n* [腾讯 MTA](http://developer.qq.com/wiki/mta/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5.html)\n* [GrowingIO](https://growingio.kf5.com/hc/kb/section/1007183/)\n\n# 社区与资源\n\n![资源](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/9628CBA157FD3EBF8DA6AD6E63D574AB.png)\n\n我们需要关注小程序生态圈的动态，通过关注一些媒体、社区，是很有用的。\n\n* [awesome-wxapp](https://github.com/justjavac/awesome-wechat-weapp): justjavac 创建的 github 仓库，收集了大量有关小程序的资源。\n* 知晓程序：是爱范儿旗下专注小程序生态的品牌，会提供很多不错的小程序咨询。\n* [微信小程序联盟](http://www.wxapp-union.com/)：一个社区网站，有大量的技术教程，以及众多开发者遇到的坑。\n* [官方文档](https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=1504102317)：再者就是微信的官方文档了。讲真，这是看过微信中最良心的开发文档。","source":"_posts/yz-share-about-wxapp--cencept.md","raw":"---\ntitle: 有赞微信小程序分享 — 概念篇\ncategory: 搬砖码农\ndate: 2017-08-31 13:15:02\ntags:\n- 小程序\n---\n\n在 2016 年 9 月 23 日 微信小程序内测开始以来，有赞的产品与技术一直紧跟着小程序的步伐。并且在 2017年1月9日 微信小程序发布的同时上线了有赞微商城小程序和有赞精选小程序。并且紧跟着开源了小程序的 UI 库：[zanui-weapp](https://github.com/youzan/zanui-weapp)\n\n在我加入有赞不久后，就参与了微信小程序产品线的开发。\n随着今年微信官方大力推广和迭代，微信小程序可谓渐渐形成一个新重量级现象，对于自身来说，除了单纯的掌握技术上的开发姿势以外，还需对整个小程序生态以及未来的动向有足够的认识和了解。\n于是乎本着研究与学习，有了这一次内部分享。\n趁着课余时间，整理成文，与君分享。\n\n# 微信开发体系\n微信开发，是一个体系。\n无论是开发移动应用，网站应用，都可以接入微信生态，例如实现微信账号登录，实现 APP 分享到微信朋友圈和联系人。\n除了自有的应用，还可以在公众号内进行应用开发，为订阅号或者服务号提供更强大的功能和交互。\n现在又有了小程序，除了开发工具类应用更简单以外，连接线上线下的场景更丰富。\n在我认为，国内的互联网产品中，多多少少都会接触到微信的开发体系。\n因为这是一个庞大的流量入口啊。\n\n## 三个平台\n![三个平台](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/F0C87F9DD75168C4C99AC1BDB4C7AAD4.jpg)\n\n在接触微信的开发体系中，接触最多的是这三个平台。\n我们站在一个更高的维度来看，就知道小程序处于微信开发体系中的哪个位置了。\n\n### 开放平台\n开放平台下提供了以下支持：\n\n* **微信账号登录**：让你的应用接入微信账号体系。\n* **微信分享与收藏功能**：这个目前在移动应用特有，可以在 APP 中掉起微信分享与收藏。\n* **微信智能接口**：支持调用微信图像、语音等智能识别接口。\n* **微信支付**：调用微信支付接口\n* **第三方平台**：拥有第三方平台资格之后，就能帮助授权用户实现公众号和小程序的代开发服务了。在公众号红利时代，通过该平台就催生了一大波微信公众账号第三方管理平台。\n\n根据目的不同，你可能要申请不同的应用：\n\n* **网站应用**\n* **移动应用**\n* **第三方平台**\n\n### 公众平台\n\n微信是 2011 年 1 月推出的，而公众平台是  2012 年 8 月推出的。\n公众平台的推出，带来了一个继微博之后的新红利时代。大量的企业、媒体、公共机构、明星名人、个人用户都纷纷进军公众平台。\n需要搞清楚的一个概念是，起初并没有「订阅号」、「服务号」、「企业号」之分。\n公众平台推出之后，在 2013 年 8 月的时候分成订阅号和服务号，然后在 2014 年 9 月的时候新增了企业号。\n所以我们所说的「公众号」统称了「订阅号」、「服务号」、「企业号」。\n\n所以我们在公众平台，根据自身情况，申请以下几类账号：\n\n* **订阅号**：偏向提供传播服务，每天可推送一条消息，但是开放的功能相对服务号来说有限。\n* **服务号**：偏向提供功能服务，每月可推送四条消息，开放出了更多高级功能。\n* **企业号**：偏向员工管理。\n* **小程序**：嗯，这就是我们今天的主题。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。\n\n### 商户平台\n\n如果你需要拥有微信支付能力，首先要注册商户平台。\n在拥有微信支付资格之后，除了可以在开发过程中通过接口调用，唤起微信支付以外。\n在线下还可以实现扫码支付、刷卡支付等场景。\n\n## 账号体系\n\n![微信账号体系](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/ADD94BAC954A36120ADB41E7A8546FCB.jpg)\n\n在接入微信账号的时候，在我们申请的应用（网站应用、移动应用、公众号、小程序），对于用户都有一个 OpenID，但是同个用户在多个应用下的 OpenID 是不一样的。\n而如果想打通多个应用的用户的话，做法就是注册开放平台账号，然后把多个应用绑定到同一个开放平台账号下，这样就能获取 UnionID。\n\n而小程序对于 UnionID 有一个特别注意的地方：\n\n![UnionID 机制](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/EB40AFD817F2807B2A1626FACF25FE7C.jpg)\n\n小程序中，在绑定同一个开放平台账号的前提下。如果其他相同主体的应用账号被用户授权过之后，在小程序中就无需再次授权，直接获取 UnionID（正常情况下，获取 UnionID 需要用户授权的）。\n\n## 相同主体\n\n那么「相同主体」是什么概念？\n在我们注册应用之后，要真正部署到线上之前，都需要进行「认证主体」的步骤。\n对于个人来说，主体就是你本人，通过身份证标记唯一性。\n而对于企业来说，主体就是企业本身，通过营业执照来标记唯一性。\n\n![相同主体](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/0ABA321D4E60DC52F7B7F9DB8D444B6C.jpg)\n\n在任何一个以上线的公众号或者小程序中的详细信息，都可以查看得到本体信息。\n\n# 微信小程序的能力\n从 2016 年底发布的小程序，在 2017 年快速推进，每个月都会有迭代，而且大部分更新发布的时间都在凌晨。\n在此心痛微信小程序团队 10 秒钟。\n然后我们从截止 8月18日 回顾将近一年的时间，小程序的更新迭代来感受小程序具备哪些能力。\n\n![小程序更新回顾](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/2EC3DDD2B7877249747FB6CADE85C9C4.png)\n\n# 数据分析\n\n![数据分析](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/1951C347D0577BA466B972987B288CAE.png)\n\n对于数据分析的需求，其实我们可以有很多选择。\n\n**【小程序后台】**\n在小程序的后台，除了可以看到常见维度的访问数据以外，还支持收集自定义事件。\n并且还提供了 API，我们就可以在内部的管理后台中收集这些数据，进行分析和展示。\n\n**【官方小程序】**\n我们可以在微信的小程序入口搜索：《小程序数据助手》\n这是官方开发的在移动端查看小程序运营数据的小程序。\n\n**【第三方平台】**\n以下是收集的一些提供数据相关服务的第三方平台 (还没有验证可用性，需要自行判断)：\n\n* [TalkingData](https://www.talkingdata.com/)\n* [阿拉丁](http://www.aldwx.com/)\n* 友盟：目前还找不到支持微信小程序的 SDK。\n\n**【数据埋点】**\n对于数据埋点需求，以下是收集的一些 Saas 服务(还没有验证可用性，需要自行判断)：\n\n* [腾讯 MTA](http://developer.qq.com/wiki/mta/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5.html)\n* [GrowingIO](https://growingio.kf5.com/hc/kb/section/1007183/)\n\n# 社区与资源\n\n![资源](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/9628CBA157FD3EBF8DA6AD6E63D574AB.png)\n\n我们需要关注小程序生态圈的动态，通过关注一些媒体、社区，是很有用的。\n\n* [awesome-wxapp](https://github.com/justjavac/awesome-wechat-weapp): justjavac 创建的 github 仓库，收集了大量有关小程序的资源。\n* 知晓程序：是爱范儿旗下专注小程序生态的品牌，会提供很多不错的小程序咨询。\n* [微信小程序联盟](http://www.wxapp-union.com/)：一个社区网站，有大量的技术教程，以及众多开发者遇到的坑。\n* [官方文档](https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=1504102317)：再者就是微信的官方文档了。讲真，这是看过微信中最良心的开发文档。","slug":"yz-share-about-wxapp--cencept","published":1,"updated":"2020-12-13T13:47:15.668Z","_id":"cl270y8s9003axwrl18jx28tb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在 2016 年 9 月 23 日 微信小程序内测开始以来，有赞的产品与技术一直紧跟着小程序的步伐。并且在 2017年1月9日 微信小程序发布的同时上线了有赞微商城小程序和有赞精选小程序。并且紧跟着开源了小程序的 UI 库：<a href=\"https://github.com/youzan/zanui-weapp\" target=\"_blank\" rel=\"external\">zanui-weapp</a></p>\n<p>在我加入有赞不久后，就参与了微信小程序产品线的开发。<br>随着今年微信官方大力推广和迭代，微信小程序可谓渐渐形成一个新重量级现象，对于自身来说，除了单纯的掌握技术上的开发姿势以外，还需对整个小程序生态以及未来的动向有足够的认识和了解。<br>于是乎本着研究与学习，有了这一次内部分享。<br>趁着课余时间，整理成文，与君分享。</p>\n<h1 id=\"微信开发体系\"><a href=\"#微信开发体系\" class=\"headerlink\" title=\"微信开发体系\"></a>微信开发体系</h1><p>微信开发，是一个体系。<br>无论是开发移动应用，网站应用，都可以接入微信生态，例如实现微信账号登录，实现 APP 分享到微信朋友圈和联系人。<br>除了自有的应用，还可以在公众号内进行应用开发，为订阅号或者服务号提供更强大的功能和交互。<br>现在又有了小程序，除了开发工具类应用更简单以外，连接线上线下的场景更丰富。<br>在我认为，国内的互联网产品中，多多少少都会接触到微信的开发体系。<br>因为这是一个庞大的流量入口啊。</p>\n<h2 id=\"三个平台\"><a href=\"#三个平台\" class=\"headerlink\" title=\"三个平台\"></a>三个平台</h2><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/F0C87F9DD75168C4C99AC1BDB4C7AAD4.jpg\" alt=\"三个平台\"></p>\n<p>在接触微信的开发体系中，接触最多的是这三个平台。<br>我们站在一个更高的维度来看，就知道小程序处于微信开发体系中的哪个位置了。</p>\n<h3 id=\"开放平台\"><a href=\"#开放平台\" class=\"headerlink\" title=\"开放平台\"></a>开放平台</h3><p>开放平台下提供了以下支持：</p>\n<ul>\n<li><strong>微信账号登录</strong>：让你的应用接入微信账号体系。</li>\n<li><strong>微信分享与收藏功能</strong>：这个目前在移动应用特有，可以在 APP 中掉起微信分享与收藏。</li>\n<li><strong>微信智能接口</strong>：支持调用微信图像、语音等智能识别接口。</li>\n<li><strong>微信支付</strong>：调用微信支付接口</li>\n<li><strong>第三方平台</strong>：拥有第三方平台资格之后，就能帮助授权用户实现公众号和小程序的代开发服务了。在公众号红利时代，通过该平台就催生了一大波微信公众账号第三方管理平台。</li>\n</ul>\n<p>根据目的不同，你可能要申请不同的应用：</p>\n<ul>\n<li><strong>网站应用</strong></li>\n<li><strong>移动应用</strong></li>\n<li><strong>第三方平台</strong></li>\n</ul>\n<h3 id=\"公众平台\"><a href=\"#公众平台\" class=\"headerlink\" title=\"公众平台\"></a>公众平台</h3><p>微信是 2011 年 1 月推出的，而公众平台是  2012 年 8 月推出的。<br>公众平台的推出，带来了一个继微博之后的新红利时代。大量的企业、媒体、公共机构、明星名人、个人用户都纷纷进军公众平台。<br>需要搞清楚的一个概念是，起初并没有「订阅号」、「服务号」、「企业号」之分。<br>公众平台推出之后，在 2013 年 8 月的时候分成订阅号和服务号，然后在 2014 年 9 月的时候新增了企业号。<br>所以我们所说的「公众号」统称了「订阅号」、「服务号」、「企业号」。</p>\n<p>所以我们在公众平台，根据自身情况，申请以下几类账号：</p>\n<ul>\n<li><strong>订阅号</strong>：偏向提供传播服务，每天可推送一条消息，但是开放的功能相对服务号来说有限。</li>\n<li><strong>服务号</strong>：偏向提供功能服务，每月可推送四条消息，开放出了更多高级功能。</li>\n<li><strong>企业号</strong>：偏向员工管理。</li>\n<li><strong>小程序</strong>：嗯，这就是我们今天的主题。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</li>\n</ul>\n<h3 id=\"商户平台\"><a href=\"#商户平台\" class=\"headerlink\" title=\"商户平台\"></a>商户平台</h3><p>如果你需要拥有微信支付能力，首先要注册商户平台。<br>在拥有微信支付资格之后，除了可以在开发过程中通过接口调用，唤起微信支付以外。<br>在线下还可以实现扫码支付、刷卡支付等场景。</p>\n<h2 id=\"账号体系\"><a href=\"#账号体系\" class=\"headerlink\" title=\"账号体系\"></a>账号体系</h2><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/ADD94BAC954A36120ADB41E7A8546FCB.jpg\" alt=\"微信账号体系\"></p>\n<p>在接入微信账号的时候，在我们申请的应用（网站应用、移动应用、公众号、小程序），对于用户都有一个 OpenID，但是同个用户在多个应用下的 OpenID 是不一样的。<br>而如果想打通多个应用的用户的话，做法就是注册开放平台账号，然后把多个应用绑定到同一个开放平台账号下，这样就能获取 UnionID。</p>\n<p>而小程序对于 UnionID 有一个特别注意的地方：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/EB40AFD817F2807B2A1626FACF25FE7C.jpg\" alt=\"UnionID 机制\"></p>\n<p>小程序中，在绑定同一个开放平台账号的前提下。如果其他相同主体的应用账号被用户授权过之后，在小程序中就无需再次授权，直接获取 UnionID（正常情况下，获取 UnionID 需要用户授权的）。</p>\n<h2 id=\"相同主体\"><a href=\"#相同主体\" class=\"headerlink\" title=\"相同主体\"></a>相同主体</h2><p>那么「相同主体」是什么概念？<br>在我们注册应用之后，要真正部署到线上之前，都需要进行「认证主体」的步骤。<br>对于个人来说，主体就是你本人，通过身份证标记唯一性。<br>而对于企业来说，主体就是企业本身，通过营业执照来标记唯一性。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/0ABA321D4E60DC52F7B7F9DB8D444B6C.jpg\" alt=\"相同主体\"></p>\n<p>在任何一个以上线的公众号或者小程序中的详细信息，都可以查看得到本体信息。</p>\n<h1 id=\"微信小程序的能力\"><a href=\"#微信小程序的能力\" class=\"headerlink\" title=\"微信小程序的能力\"></a>微信小程序的能力</h1><p>从 2016 年底发布的小程序，在 2017 年快速推进，每个月都会有迭代，而且大部分更新发布的时间都在凌晨。<br>在此心痛微信小程序团队 10 秒钟。<br>然后我们从截止 8月18日 回顾将近一年的时间，小程序的更新迭代来感受小程序具备哪些能力。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/2EC3DDD2B7877249747FB6CADE85C9C4.png\" alt=\"小程序更新回顾\"></p>\n<h1 id=\"数据分析\"><a href=\"#数据分析\" class=\"headerlink\" title=\"数据分析\"></a>数据分析</h1><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/1951C347D0577BA466B972987B288CAE.png\" alt=\"数据分析\"></p>\n<p>对于数据分析的需求，其实我们可以有很多选择。</p>\n<p><strong>【小程序后台】</strong><br>在小程序的后台，除了可以看到常见维度的访问数据以外，还支持收集自定义事件。<br>并且还提供了 API，我们就可以在内部的管理后台中收集这些数据，进行分析和展示。</p>\n<p><strong>【官方小程序】</strong><br>我们可以在微信的小程序入口搜索：《小程序数据助手》<br>这是官方开发的在移动端查看小程序运营数据的小程序。</p>\n<p><strong>【第三方平台】</strong><br>以下是收集的一些提供数据相关服务的第三方平台 (还没有验证可用性，需要自行判断)：</p>\n<ul>\n<li><a href=\"https://www.talkingdata.com/\" target=\"_blank\" rel=\"external\">TalkingData</a></li>\n<li><a href=\"http://www.aldwx.com/\" target=\"_blank\" rel=\"external\">阿拉丁</a></li>\n<li>友盟：目前还找不到支持微信小程序的 SDK。</li>\n</ul>\n<p><strong>【数据埋点】</strong><br>对于数据埋点需求，以下是收集的一些 Saas 服务(还没有验证可用性，需要自行判断)：</p>\n<ul>\n<li><a href=\"http://developer.qq.com/wiki/mta/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5.html\" target=\"_blank\" rel=\"external\">腾讯 MTA</a></li>\n<li><a href=\"https://growingio.kf5.com/hc/kb/section/1007183/\" target=\"_blank\" rel=\"external\">GrowingIO</a></li>\n</ul>\n<h1 id=\"社区与资源\"><a href=\"#社区与资源\" class=\"headerlink\" title=\"社区与资源\"></a>社区与资源</h1><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/9628CBA157FD3EBF8DA6AD6E63D574AB.png\" alt=\"资源\"></p>\n<p>我们需要关注小程序生态圈的动态，通过关注一些媒体、社区，是很有用的。</p>\n<ul>\n<li><a href=\"https://github.com/justjavac/awesome-wechat-weapp\" target=\"_blank\" rel=\"external\">awesome-wxapp</a>: justjavac 创建的 github 仓库，收集了大量有关小程序的资源。</li>\n<li>知晓程序：是爱范儿旗下专注小程序生态的品牌，会提供很多不错的小程序咨询。</li>\n<li><a href=\"http://www.wxapp-union.com/\" target=\"_blank\" rel=\"external\">微信小程序联盟</a>：一个社区网站，有大量的技术教程，以及众多开发者遇到的坑。</li>\n<li><a href=\"https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=1504102317\" target=\"_blank\" rel=\"external\">官方文档</a>：再者就是微信的官方文档了。讲真，这是看过微信中最良心的开发文档。</li>\n</ul>\n","excerpt":"","more":"<p>在 2016 年 9 月 23 日 微信小程序内测开始以来，有赞的产品与技术一直紧跟着小程序的步伐。并且在 2017年1月9日 微信小程序发布的同时上线了有赞微商城小程序和有赞精选小程序。并且紧跟着开源了小程序的 UI 库：<a href=\"https://github.com/youzan/zanui-weapp\">zanui-weapp</a></p>\n<p>在我加入有赞不久后，就参与了微信小程序产品线的开发。<br>随着今年微信官方大力推广和迭代，微信小程序可谓渐渐形成一个新重量级现象，对于自身来说，除了单纯的掌握技术上的开发姿势以外，还需对整个小程序生态以及未来的动向有足够的认识和了解。<br>于是乎本着研究与学习，有了这一次内部分享。<br>趁着课余时间，整理成文，与君分享。</p>\n<h1 id=\"微信开发体系\"><a href=\"#微信开发体系\" class=\"headerlink\" title=\"微信开发体系\"></a>微信开发体系</h1><p>微信开发，是一个体系。<br>无论是开发移动应用，网站应用，都可以接入微信生态，例如实现微信账号登录，实现 APP 分享到微信朋友圈和联系人。<br>除了自有的应用，还可以在公众号内进行应用开发，为订阅号或者服务号提供更强大的功能和交互。<br>现在又有了小程序，除了开发工具类应用更简单以外，连接线上线下的场景更丰富。<br>在我认为，国内的互联网产品中，多多少少都会接触到微信的开发体系。<br>因为这是一个庞大的流量入口啊。</p>\n<h2 id=\"三个平台\"><a href=\"#三个平台\" class=\"headerlink\" title=\"三个平台\"></a>三个平台</h2><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/F0C87F9DD75168C4C99AC1BDB4C7AAD4.jpg\" alt=\"三个平台\"></p>\n<p>在接触微信的开发体系中，接触最多的是这三个平台。<br>我们站在一个更高的维度来看，就知道小程序处于微信开发体系中的哪个位置了。</p>\n<h3 id=\"开放平台\"><a href=\"#开放平台\" class=\"headerlink\" title=\"开放平台\"></a>开放平台</h3><p>开放平台下提供了以下支持：</p>\n<ul>\n<li><strong>微信账号登录</strong>：让你的应用接入微信账号体系。</li>\n<li><strong>微信分享与收藏功能</strong>：这个目前在移动应用特有，可以在 APP 中掉起微信分享与收藏。</li>\n<li><strong>微信智能接口</strong>：支持调用微信图像、语音等智能识别接口。</li>\n<li><strong>微信支付</strong>：调用微信支付接口</li>\n<li><strong>第三方平台</strong>：拥有第三方平台资格之后，就能帮助授权用户实现公众号和小程序的代开发服务了。在公众号红利时代，通过该平台就催生了一大波微信公众账号第三方管理平台。</li>\n</ul>\n<p>根据目的不同，你可能要申请不同的应用：</p>\n<ul>\n<li><strong>网站应用</strong></li>\n<li><strong>移动应用</strong></li>\n<li><strong>第三方平台</strong></li>\n</ul>\n<h3 id=\"公众平台\"><a href=\"#公众平台\" class=\"headerlink\" title=\"公众平台\"></a>公众平台</h3><p>微信是 2011 年 1 月推出的，而公众平台是  2012 年 8 月推出的。<br>公众平台的推出，带来了一个继微博之后的新红利时代。大量的企业、媒体、公共机构、明星名人、个人用户都纷纷进军公众平台。<br>需要搞清楚的一个概念是，起初并没有「订阅号」、「服务号」、「企业号」之分。<br>公众平台推出之后，在 2013 年 8 月的时候分成订阅号和服务号，然后在 2014 年 9 月的时候新增了企业号。<br>所以我们所说的「公众号」统称了「订阅号」、「服务号」、「企业号」。</p>\n<p>所以我们在公众平台，根据自身情况，申请以下几类账号：</p>\n<ul>\n<li><strong>订阅号</strong>：偏向提供传播服务，每天可推送一条消息，但是开放的功能相对服务号来说有限。</li>\n<li><strong>服务号</strong>：偏向提供功能服务，每月可推送四条消息，开放出了更多高级功能。</li>\n<li><strong>企业号</strong>：偏向员工管理。</li>\n<li><strong>小程序</strong>：嗯，这就是我们今天的主题。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</li>\n</ul>\n<h3 id=\"商户平台\"><a href=\"#商户平台\" class=\"headerlink\" title=\"商户平台\"></a>商户平台</h3><p>如果你需要拥有微信支付能力，首先要注册商户平台。<br>在拥有微信支付资格之后，除了可以在开发过程中通过接口调用，唤起微信支付以外。<br>在线下还可以实现扫码支付、刷卡支付等场景。</p>\n<h2 id=\"账号体系\"><a href=\"#账号体系\" class=\"headerlink\" title=\"账号体系\"></a>账号体系</h2><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/ADD94BAC954A36120ADB41E7A8546FCB.jpg\" alt=\"微信账号体系\"></p>\n<p>在接入微信账号的时候，在我们申请的应用（网站应用、移动应用、公众号、小程序），对于用户都有一个 OpenID，但是同个用户在多个应用下的 OpenID 是不一样的。<br>而如果想打通多个应用的用户的话，做法就是注册开放平台账号，然后把多个应用绑定到同一个开放平台账号下，这样就能获取 UnionID。</p>\n<p>而小程序对于 UnionID 有一个特别注意的地方：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/EB40AFD817F2807B2A1626FACF25FE7C.jpg\" alt=\"UnionID 机制\"></p>\n<p>小程序中，在绑定同一个开放平台账号的前提下。如果其他相同主体的应用账号被用户授权过之后，在小程序中就无需再次授权，直接获取 UnionID（正常情况下，获取 UnionID 需要用户授权的）。</p>\n<h2 id=\"相同主体\"><a href=\"#相同主体\" class=\"headerlink\" title=\"相同主体\"></a>相同主体</h2><p>那么「相同主体」是什么概念？<br>在我们注册应用之后，要真正部署到线上之前，都需要进行「认证主体」的步骤。<br>对于个人来说，主体就是你本人，通过身份证标记唯一性。<br>而对于企业来说，主体就是企业本身，通过营业执照来标记唯一性。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/0ABA321D4E60DC52F7B7F9DB8D444B6C.jpg\" alt=\"相同主体\"></p>\n<p>在任何一个以上线的公众号或者小程序中的详细信息，都可以查看得到本体信息。</p>\n<h1 id=\"微信小程序的能力\"><a href=\"#微信小程序的能力\" class=\"headerlink\" title=\"微信小程序的能力\"></a>微信小程序的能力</h1><p>从 2016 年底发布的小程序，在 2017 年快速推进，每个月都会有迭代，而且大部分更新发布的时间都在凌晨。<br>在此心痛微信小程序团队 10 秒钟。<br>然后我们从截止 8月18日 回顾将近一年的时间，小程序的更新迭代来感受小程序具备哪些能力。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/2EC3DDD2B7877249747FB6CADE85C9C4.png\" alt=\"小程序更新回顾\"></p>\n<h1 id=\"数据分析\"><a href=\"#数据分析\" class=\"headerlink\" title=\"数据分析\"></a>数据分析</h1><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/1951C347D0577BA466B972987B288CAE.png\" alt=\"数据分析\"></p>\n<p>对于数据分析的需求，其实我们可以有很多选择。</p>\n<p><strong>【小程序后台】</strong><br>在小程序的后台，除了可以看到常见维度的访问数据以外，还支持收集自定义事件。<br>并且还提供了 API，我们就可以在内部的管理后台中收集这些数据，进行分析和展示。</p>\n<p><strong>【官方小程序】</strong><br>我们可以在微信的小程序入口搜索：《小程序数据助手》<br>这是官方开发的在移动端查看小程序运营数据的小程序。</p>\n<p><strong>【第三方平台】</strong><br>以下是收集的一些提供数据相关服务的第三方平台 (还没有验证可用性，需要自行判断)：</p>\n<ul>\n<li><a href=\"https://www.talkingdata.com/\">TalkingData</a></li>\n<li><a href=\"http://www.aldwx.com/\">阿拉丁</a></li>\n<li>友盟：目前还找不到支持微信小程序的 SDK。</li>\n</ul>\n<p><strong>【数据埋点】</strong><br>对于数据埋点需求，以下是收集的一些 Saas 服务(还没有验证可用性，需要自行判断)：</p>\n<ul>\n<li><a href=\"http://developer.qq.com/wiki/mta/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5.html\">腾讯 MTA</a></li>\n<li><a href=\"https://growingio.kf5.com/hc/kb/section/1007183/\">GrowingIO</a></li>\n</ul>\n<h1 id=\"社区与资源\"><a href=\"#社区与资源\" class=\"headerlink\" title=\"社区与资源\"></a>社区与资源</h1><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/9628CBA157FD3EBF8DA6AD6E63D574AB.png\" alt=\"资源\"></p>\n<p>我们需要关注小程序生态圈的动态，通过关注一些媒体、社区，是很有用的。</p>\n<ul>\n<li><a href=\"https://github.com/justjavac/awesome-wechat-weapp\">awesome-wxapp</a>: justjavac 创建的 github 仓库，收集了大量有关小程序的资源。</li>\n<li>知晓程序：是爱范儿旗下专注小程序生态的品牌，会提供很多不错的小程序咨询。</li>\n<li><a href=\"http://www.wxapp-union.com/\">微信小程序联盟</a>：一个社区网站，有大量的技术教程，以及众多开发者遇到的坑。</li>\n<li><a href=\"https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=1504102317\">官方文档</a>：再者就是微信的官方文档了。讲真，这是看过微信中最良心的开发文档。</li>\n</ul>\n"},{"title":"原汁原味的配方:「微信小程序支持 NPM」","date":"2018-05-01T16:07:00.000Z","_content":"\n微信小程序本身不支持 npm 包的使用，目前市面上很多框架也有了相对应的解决方案。\n\n本文旨在为那些不愿意引入第三方框架， 想在小程序环境中写原汁原味代码的人（例如我），提供一种解决问题的思路。\n\n在现代的 Web 开发中，我们对 Webpack 已经再熟悉不过了，简单理解，它就是项目发布之前，把所有资源都打包好，然后提供一个入口文件，在入口模板中引入这个入口文件。\n\n那么我的思路，就是利用 Webpack 把我们所有的 npm 依赖打包好，提供一个入口文件，在小程序开发中，我们通过这个入口文件，进而使用 npm 的依赖。\n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181936)\n\n我们最终实现的效果应该是这样的。\n\n例如我们小程序的首页中，需要使用到 `moment`\n\npages/home/home.js：\n\n```javascript\nconst { moment } require('../npm/index');\nconst time = moment();\n```\n\n\n# Webpack 打包 npm 依赖\n\nwebpack 默认输出的 `bundle.js` ，是一个立即执行的闭包，如以下：\n\n使用 webpack.config.js 配置：\n\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  entry: './foo.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  }\n};\n```\n\n运行 `$ webpack` 生成的 `bundle.js` :\n\n```javascript\n(function(modules) { \n\n  // webpackBootstrap\n\n})([module1, module2, module3]);\n```\n\n> 示例代码：https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step1\n\n这样的代码，显然没法达到我们要的效果。\n幸好 webpack 提供了 `output.libraryTarget` 的配置项。\n\n## output.libraryTarget: \"commonjs2\"\n\n对于 `output.libraryTarget: \"commonjs2\"` 官方解释：\n> The return value of your entry point will be assigned to the module.exports.\n\n通过配置该属性，我们能保证 webpack 打包出来的 `bundle.js`，是模块化的。\n当然 `output.libraryTarget` 还有其他的选项值，可以查阅[官方文档](https://webpack.js.org/configuration/output/#output-librarytarget)。\n\n例如，使用 webpack.config.js 配置:\n\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  entry: './foo.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n    libraryTarget: 'commonjs2',\n  }\n};\n```\n\n运行 `$ webpack` 生成的 `bundle.js` :\n\n```javascript\nmodule.exports = (function(modules) { \n\n  // webpackBootstrap\n\n})([module1, module2, module3]);\n```\n\n> 示例代码：https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step2\n\n这样，我们就可以通过 `require('bundle.js')`, 来使用 npm 依赖了。\n在这个基础上，我们就可以打造一个使用 npm 依赖的入口。\n\n## 打造 npm 入口\n\n建立入口文件：npm.js\n\n```javascript\nconst momennt = require('moment');\n\nmodule.exports = {\n    momennt,\n};\n```\n\n配置文件：webpack.config.js\n\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n    entry: './entry.js',\n    output: {\n        path: path.resolve(__dirname, 'npm'),\n        filename: 'index.js'\n    },\n};\n```\n\n运行 `$ webpack`，输出 `./npm/index.js` 打包文件，对应的目录：\n\n```\n.\n├── entry.js\n├── npm\n│   └── index.js\n└── webpack.config.js\n```\n\n> 示例代码：https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step3\n\n笨拙点的方法，你只需要把 `npm/index.js` 拷贝到你的项目中，就可以使用你所引入的 npm 包的内容了。\n\n如果你的项目中使用了构建工具的话，就可以把「 webpack 打包 npm」 的这项任务加入到你的构建流程中。\n\n我是使用 gulp 来做项目构建工作的，下面提供一种基于 gulp 的实现作为参考。\n\n# 结合 Gulp 做项目工程化\n\n工程目录：\n\n```\n.\n├── dist\n│   ├── npm\n│   │   └── index.js\n│   └── pages\n│       └── home\n│           └── home.js\n├── gulpfile.js\n└── src\n    ├── npm\n    │   └── index.js\n    └── pages\n        └── home\n            └── home.js\n```\n\n而 gulpfile 负责两件事：\n1. 把 src 的 js 文件通过 babel 编译到 dist 目录（示例中忽略其他 wxml、wxss 文件）\n2. 把 `npm/index.js` 通过 webpack 打包到 `dist/npm/index.js`，并压缩。\n\ngulpfile.js:\n\n```javascript\nconst gulp = require('gulp');\nconst babel = require('gulp-babel');\nconst del = require('del');\nconst runSequence = require('run-sequence');\nconst webpack = require('webpack');\nconst webpackStream = require('webpack-stream');\n\nconst webpackConfig = {\n    module: {\n        loaders: [{\n            test: /\\.js$/,\n            loader: 'babel-loader',\n            exclude: /node_modules/,\n            options: {\n                presets: ['es2015'],\n            },\n        }],\n    },\n    output: {\n        filename: 'index.js',\n        libraryTarget: 'commonjs2',        \n    },\n    plugins: [\n        new webpack.optimize.UglifyJsPlugin(),\n    ],\n};\n\n// 清空 ./dist 目录\ngulp.task('clean', () => del(['./dist/**']));\n\n// 打包 npm 依赖\ngulp.task('npm', () => {\n    gulp.src('./src/npm/*.js')\n        .pipe(webpackStream(webpackConfig), webpack)\n        .pipe(gulp.dest('./dist/npm'));\n});\n\n// 编译 JS 文件\ngulp.task('scripts', () => {\n    gulp.src(['./src/**/*.js', '!./src/npm/*.js'])\n        .pipe(babel({\n            presets: ['stage-0', 'es2015'],\n        }))\n        .pipe(gulp.dest('./dist'));\n});\n\n// 开发模式命令\ngulp.task('build', ['clean'], () => runSequence('scripts', 'npm'));\n```\n\n> 示例代码：https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step4\n\n# 关于控制 npm 文件代码量\n\n微信限制了项目的代码量为 2M，就算使用了分包机制，最多也是 4M 的代码量。\n区区一个 moment 库的话，就算压缩过，也需要两百多 KB，这对于我们的代码量，是很不友好的。\n我们需要对 npm 的引入持非常谨慎的态度，去度量每个依赖包的大小，想尽各种办法减少依赖的代码量。\n譬如`moment` 我们可以使用 `moment-mini` 来代替，后者压缩过后只需要 51KB。\n\n而且我认为把 npm 的依赖放在一个入口文件中，会让我们可以对 npm 的依赖有一个全局的把握。","source":"_posts/use-npm-in-weapp.md","raw":"---\ntitle: 原汁原味的配方:「微信小程序支持 NPM」\ndate: 2018-05-02 00:07:00\ntags:\n- 微信小程序\ncategory: 搬砖码农\n---\n\n微信小程序本身不支持 npm 包的使用，目前市面上很多框架也有了相对应的解决方案。\n\n本文旨在为那些不愿意引入第三方框架， 想在小程序环境中写原汁原味代码的人（例如我），提供一种解决问题的思路。\n\n在现代的 Web 开发中，我们对 Webpack 已经再熟悉不过了，简单理解，它就是项目发布之前，把所有资源都打包好，然后提供一个入口文件，在入口模板中引入这个入口文件。\n\n那么我的思路，就是利用 Webpack 把我们所有的 npm 依赖打包好，提供一个入口文件，在小程序开发中，我们通过这个入口文件，进而使用 npm 的依赖。\n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181936)\n\n我们最终实现的效果应该是这样的。\n\n例如我们小程序的首页中，需要使用到 `moment`\n\npages/home/home.js：\n\n```javascript\nconst { moment } require('../npm/index');\nconst time = moment();\n```\n\n\n# Webpack 打包 npm 依赖\n\nwebpack 默认输出的 `bundle.js` ，是一个立即执行的闭包，如以下：\n\n使用 webpack.config.js 配置：\n\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  entry: './foo.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  }\n};\n```\n\n运行 `$ webpack` 生成的 `bundle.js` :\n\n```javascript\n(function(modules) { \n\n  // webpackBootstrap\n\n})([module1, module2, module3]);\n```\n\n> 示例代码：https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step1\n\n这样的代码，显然没法达到我们要的效果。\n幸好 webpack 提供了 `output.libraryTarget` 的配置项。\n\n## output.libraryTarget: \"commonjs2\"\n\n对于 `output.libraryTarget: \"commonjs2\"` 官方解释：\n> The return value of your entry point will be assigned to the module.exports.\n\n通过配置该属性，我们能保证 webpack 打包出来的 `bundle.js`，是模块化的。\n当然 `output.libraryTarget` 还有其他的选项值，可以查阅[官方文档](https://webpack.js.org/configuration/output/#output-librarytarget)。\n\n例如，使用 webpack.config.js 配置:\n\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  entry: './foo.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n    libraryTarget: 'commonjs2',\n  }\n};\n```\n\n运行 `$ webpack` 生成的 `bundle.js` :\n\n```javascript\nmodule.exports = (function(modules) { \n\n  // webpackBootstrap\n\n})([module1, module2, module3]);\n```\n\n> 示例代码：https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step2\n\n这样，我们就可以通过 `require('bundle.js')`, 来使用 npm 依赖了。\n在这个基础上，我们就可以打造一个使用 npm 依赖的入口。\n\n## 打造 npm 入口\n\n建立入口文件：npm.js\n\n```javascript\nconst momennt = require('moment');\n\nmodule.exports = {\n    momennt,\n};\n```\n\n配置文件：webpack.config.js\n\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n    entry: './entry.js',\n    output: {\n        path: path.resolve(__dirname, 'npm'),\n        filename: 'index.js'\n    },\n};\n```\n\n运行 `$ webpack`，输出 `./npm/index.js` 打包文件，对应的目录：\n\n```\n.\n├── entry.js\n├── npm\n│   └── index.js\n└── webpack.config.js\n```\n\n> 示例代码：https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step3\n\n笨拙点的方法，你只需要把 `npm/index.js` 拷贝到你的项目中，就可以使用你所引入的 npm 包的内容了。\n\n如果你的项目中使用了构建工具的话，就可以把「 webpack 打包 npm」 的这项任务加入到你的构建流程中。\n\n我是使用 gulp 来做项目构建工作的，下面提供一种基于 gulp 的实现作为参考。\n\n# 结合 Gulp 做项目工程化\n\n工程目录：\n\n```\n.\n├── dist\n│   ├── npm\n│   │   └── index.js\n│   └── pages\n│       └── home\n│           └── home.js\n├── gulpfile.js\n└── src\n    ├── npm\n    │   └── index.js\n    └── pages\n        └── home\n            └── home.js\n```\n\n而 gulpfile 负责两件事：\n1. 把 src 的 js 文件通过 babel 编译到 dist 目录（示例中忽略其他 wxml、wxss 文件）\n2. 把 `npm/index.js` 通过 webpack 打包到 `dist/npm/index.js`，并压缩。\n\ngulpfile.js:\n\n```javascript\nconst gulp = require('gulp');\nconst babel = require('gulp-babel');\nconst del = require('del');\nconst runSequence = require('run-sequence');\nconst webpack = require('webpack');\nconst webpackStream = require('webpack-stream');\n\nconst webpackConfig = {\n    module: {\n        loaders: [{\n            test: /\\.js$/,\n            loader: 'babel-loader',\n            exclude: /node_modules/,\n            options: {\n                presets: ['es2015'],\n            },\n        }],\n    },\n    output: {\n        filename: 'index.js',\n        libraryTarget: 'commonjs2',        \n    },\n    plugins: [\n        new webpack.optimize.UglifyJsPlugin(),\n    ],\n};\n\n// 清空 ./dist 目录\ngulp.task('clean', () => del(['./dist/**']));\n\n// 打包 npm 依赖\ngulp.task('npm', () => {\n    gulp.src('./src/npm/*.js')\n        .pipe(webpackStream(webpackConfig), webpack)\n        .pipe(gulp.dest('./dist/npm'));\n});\n\n// 编译 JS 文件\ngulp.task('scripts', () => {\n    gulp.src(['./src/**/*.js', '!./src/npm/*.js'])\n        .pipe(babel({\n            presets: ['stage-0', 'es2015'],\n        }))\n        .pipe(gulp.dest('./dist'));\n});\n\n// 开发模式命令\ngulp.task('build', ['clean'], () => runSequence('scripts', 'npm'));\n```\n\n> 示例代码：https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step4\n\n# 关于控制 npm 文件代码量\n\n微信限制了项目的代码量为 2M，就算使用了分包机制，最多也是 4M 的代码量。\n区区一个 moment 库的话，就算压缩过，也需要两百多 KB，这对于我们的代码量，是很不友好的。\n我们需要对 npm 的引入持非常谨慎的态度，去度量每个依赖包的大小，想尽各种办法减少依赖的代码量。\n譬如`moment` 我们可以使用 `moment-mini` 来代替，后者压缩过后只需要 51KB。\n\n而且我认为把 npm 的依赖放在一个入口文件中，会让我们可以对 npm 的依赖有一个全局的把握。","slug":"use-npm-in-weapp","published":1,"updated":"2019-07-07T10:28:45.723Z","_id":"cl270y8sd003mxwrlq03a8kw2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>微信小程序本身不支持 npm 包的使用，目前市面上很多框架也有了相对应的解决方案。</p>\n<p>本文旨在为那些不愿意引入第三方框架， 想在小程序环境中写原汁原味代码的人（例如我），提供一种解决问题的思路。</p>\n<p>在现代的 Web 开发中，我们对 Webpack 已经再熟悉不过了，简单理解，它就是项目发布之前，把所有资源都打包好，然后提供一个入口文件，在入口模板中引入这个入口文件。</p>\n<p>那么我的思路，就是利用 Webpack 把我们所有的 npm 依赖打包好，提供一个入口文件，在小程序开发中，我们通过这个入口文件，进而使用 npm 的依赖。</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181936\" alt></p>\n<p>我们最终实现的效果应该是这样的。</p>\n<p>例如我们小程序的首页中，需要使用到 <code>moment</code></p>\n<p>pages/home/home.js：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; moment &#125; <span class=\"built_in\">require</span>(<span class=\"string\">'../npm/index'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> time = moment();</span><br></pre></td></tr></table></figure>\n<h1 id=\"Webpack-打包-npm-依赖\"><a href=\"#Webpack-打包-npm-依赖\" class=\"headerlink\" title=\"Webpack 打包 npm 依赖\"></a>Webpack 打包 npm 依赖</h1><p>webpack 默认输出的 <code>bundle.js</code> ，是一个立即执行的闭包，如以下：</p>\n<p>使用 webpack.config.js 配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./foo.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>运行 <code>$ webpack</code> 生成的 <code>bundle.js</code> :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) </span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// webpackBootstrap</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)([module1, module2, module3]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>示例代码：<a href=\"https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step1\" target=\"_blank\" rel=\"external\">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step1</a></p>\n</blockquote>\n<p>这样的代码，显然没法达到我们要的效果。<br>幸好 webpack 提供了 <code>output.libraryTarget</code> 的配置项。</p>\n<h2 id=\"output-libraryTarget-“commonjs2”\"><a href=\"#output-libraryTarget-“commonjs2”\" class=\"headerlink\" title=\"output.libraryTarget: “commonjs2”\"></a>output.libraryTarget: “commonjs2”</h2><p>对于 <code>output.libraryTarget: &quot;commonjs2&quot;</code> 官方解释：</p>\n<blockquote>\n<p>The return value of your entry point will be assigned to the module.exports.</p>\n</blockquote>\n<p>通过配置该属性，我们能保证 webpack 打包出来的 <code>bundle.js</code>，是模块化的。<br>当然 <code>output.libraryTarget</code> 还有其他的选项值，可以查阅<a href=\"https://webpack.js.org/configuration/output/#output-librarytarget\" target=\"_blank\" rel=\"external\">官方文档</a>。</p>\n<p>例如，使用 webpack.config.js 配置:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./foo.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span>,</span><br><span class=\"line\">    libraryTarget: <span class=\"string\">'commonjs2'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>运行 <code>$ webpack</code> 生成的 <code>bundle.js</code> :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) </span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// webpackBootstrap</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)([module1, module2, module3]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>示例代码：<a href=\"https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step2\" target=\"_blank\" rel=\"external\">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step2</a></p>\n</blockquote>\n<p>这样，我们就可以通过 <code>require(&#39;bundle.js&#39;)</code>, 来使用 npm 依赖了。<br>在这个基础上，我们就可以打造一个使用 npm 依赖的入口。</p>\n<h2 id=\"打造-npm-入口\"><a href=\"#打造-npm-入口\" class=\"headerlink\" title=\"打造 npm 入口\"></a>打造 npm 入口</h2><p>建立入口文件：npm.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> momennt = <span class=\"built_in\">require</span>(<span class=\"string\">'moment'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    momennt,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>配置文件：webpack.config.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: <span class=\"string\">'./entry.js'</span>,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: path.resolve(__dirname, <span class=\"string\">'npm'</span>),</span><br><span class=\"line\">        filename: <span class=\"string\">'index.js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>运行 <code>$ webpack</code>，输出 <code>./npm/index.js</code> 打包文件，对应的目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── entry.js</span><br><span class=\"line\">├── npm</span><br><span class=\"line\">│   └── index.js</span><br><span class=\"line\">└── webpack.config.js</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>示例代码：<a href=\"https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step3\" target=\"_blank\" rel=\"external\">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step3</a></p>\n</blockquote>\n<p>笨拙点的方法，你只需要把 <code>npm/index.js</code> 拷贝到你的项目中，就可以使用你所引入的 npm 包的内容了。</p>\n<p>如果你的项目中使用了构建工具的话，就可以把「 webpack 打包 npm」 的这项任务加入到你的构建流程中。</p>\n<p>我是使用 gulp 来做项目构建工作的，下面提供一种基于 gulp 的实现作为参考。</p>\n<h1 id=\"结合-Gulp-做项目工程化\"><a href=\"#结合-Gulp-做项目工程化\" class=\"headerlink\" title=\"结合 Gulp 做项目工程化\"></a>结合 Gulp 做项目工程化</h1><p>工程目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── dist</span><br><span class=\"line\">│   ├── npm</span><br><span class=\"line\">│   │   └── index.js</span><br><span class=\"line\">│   └── pages</span><br><span class=\"line\">│       └── home</span><br><span class=\"line\">│           └── home.js</span><br><span class=\"line\">├── gulpfile.js</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── npm</span><br><span class=\"line\">    │   └── index.js</span><br><span class=\"line\">    └── pages</span><br><span class=\"line\">        └── home</span><br><span class=\"line\">            └── home.js</span><br></pre></td></tr></table></figure>\n<p>而 gulpfile 负责两件事：</p>\n<ol>\n<li>把 src 的 js 文件通过 babel 编译到 dist 目录（示例中忽略其他 wxml、wxss 文件）</li>\n<li>把 <code>npm/index.js</code> 通过 webpack 打包到 <code>dist/npm/index.js</code>，并压缩。</li>\n</ol>\n<p>gulpfile.js:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-babel'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> del = <span class=\"built_in\">require</span>(<span class=\"string\">'del'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> runSequence = <span class=\"built_in\">require</span>(<span class=\"string\">'run-sequence'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpackStream = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-stream'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> webpackConfig = &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [&#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">            loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">            exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                presets: [<span class=\"string\">'es2015'</span>],</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        filename: <span class=\"string\">'index.js'</span>,</span><br><span class=\"line\">        libraryTarget: <span class=\"string\">'commonjs2'</span>,        </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清空 ./dist 目录</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'clean'</span>, () =&gt; del([<span class=\"string\">'./dist/**'</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打包 npm 依赖</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'npm'</span>, () =&gt; &#123;</span><br><span class=\"line\">    gulp.src(<span class=\"string\">'./src/npm/*.js'</span>)</span><br><span class=\"line\">        .pipe(webpackStream(webpackConfig), webpack)</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'./dist/npm'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译 JS 文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'scripts'</span>, () =&gt; &#123;</span><br><span class=\"line\">    gulp.src([<span class=\"string\">'./src/**/*.js'</span>, <span class=\"string\">'!./src/npm/*.js'</span>])</span><br><span class=\"line\">        .pipe(babel(&#123;</span><br><span class=\"line\">            presets: [<span class=\"string\">'stage-0'</span>, <span class=\"string\">'es2015'</span>],</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'./dist'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开发模式命令</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'build'</span>, [<span class=\"string\">'clean'</span>], () =&gt; runSequence(<span class=\"string\">'scripts'</span>, <span class=\"string\">'npm'</span>));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>示例代码：<a href=\"https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step4\" target=\"_blank\" rel=\"external\">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step4</a></p>\n</blockquote>\n<h1 id=\"关于控制-npm-文件代码量\"><a href=\"#关于控制-npm-文件代码量\" class=\"headerlink\" title=\"关于控制 npm 文件代码量\"></a>关于控制 npm 文件代码量</h1><p>微信限制了项目的代码量为 2M，就算使用了分包机制，最多也是 4M 的代码量。<br>区区一个 moment 库的话，就算压缩过，也需要两百多 KB，这对于我们的代码量，是很不友好的。<br>我们需要对 npm 的引入持非常谨慎的态度，去度量每个依赖包的大小，想尽各种办法减少依赖的代码量。<br>譬如<code>moment</code> 我们可以使用 <code>moment-mini</code> 来代替，后者压缩过后只需要 51KB。</p>\n<p>而且我认为把 npm 的依赖放在一个入口文件中，会让我们可以对 npm 的依赖有一个全局的把握。</p>\n","excerpt":"","more":"<p>微信小程序本身不支持 npm 包的使用，目前市面上很多框架也有了相对应的解决方案。</p>\n<p>本文旨在为那些不愿意引入第三方框架， 想在小程序环境中写原汁原味代码的人（例如我），提供一种解决问题的思路。</p>\n<p>在现代的 Web 开发中，我们对 Webpack 已经再熟悉不过了，简单理解，它就是项目发布之前，把所有资源都打包好，然后提供一个入口文件，在入口模板中引入这个入口文件。</p>\n<p>那么我的思路，就是利用 Webpack 把我们所有的 npm 依赖打包好，提供一个入口文件，在小程序开发中，我们通过这个入口文件，进而使用 npm 的依赖。</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181936\" alt=\"\"></p>\n<p>我们最终实现的效果应该是这样的。</p>\n<p>例如我们小程序的首页中，需要使用到 <code>moment</code></p>\n<p>pages/home/home.js：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; moment &#125; <span class=\"built_in\">require</span>(<span class=\"string\">'../npm/index'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> time = moment();</span><br></pre></td></tr></table></figure>\n<h1 id=\"Webpack-打包-npm-依赖\"><a href=\"#Webpack-打包-npm-依赖\" class=\"headerlink\" title=\"Webpack 打包 npm 依赖\"></a>Webpack 打包 npm 依赖</h1><p>webpack 默认输出的 <code>bundle.js</code> ，是一个立即执行的闭包，如以下：</p>\n<p>使用 webpack.config.js 配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./foo.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>运行 <code>$ webpack</code> 生成的 <code>bundle.js</code> :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) </span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// webpackBootstrap</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)([module1, module2, module3]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>示例代码：<a href=\"https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step1\">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step1</a></p>\n</blockquote>\n<p>这样的代码，显然没法达到我们要的效果。<br>幸好 webpack 提供了 <code>output.libraryTarget</code> 的配置项。</p>\n<h2 id=\"output-libraryTarget-“commonjs2”\"><a href=\"#output-libraryTarget-“commonjs2”\" class=\"headerlink\" title=\"output.libraryTarget: “commonjs2”\"></a>output.libraryTarget: “commonjs2”</h2><p>对于 <code>output.libraryTarget: &quot;commonjs2&quot;</code> 官方解释：</p>\n<blockquote>\n<p>The return value of your entry point will be assigned to the module.exports.</p>\n</blockquote>\n<p>通过配置该属性，我们能保证 webpack 打包出来的 <code>bundle.js</code>，是模块化的。<br>当然 <code>output.libraryTarget</code> 还有其他的选项值，可以查阅<a href=\"https://webpack.js.org/configuration/output/#output-librarytarget\">官方文档</a>。</p>\n<p>例如，使用 webpack.config.js 配置:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./foo.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span>,</span><br><span class=\"line\">    libraryTarget: <span class=\"string\">'commonjs2'</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>运行 <code>$ webpack</code> 生成的 <code>bundle.js</code> :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) </span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// webpackBootstrap</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)([module1, module2, module3]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>示例代码：<a href=\"https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step2\">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step2</a></p>\n</blockquote>\n<p>这样，我们就可以通过 <code>require(&#39;bundle.js&#39;)</code>, 来使用 npm 依赖了。<br>在这个基础上，我们就可以打造一个使用 npm 依赖的入口。</p>\n<h2 id=\"打造-npm-入口\"><a href=\"#打造-npm-入口\" class=\"headerlink\" title=\"打造 npm 入口\"></a>打造 npm 入口</h2><p>建立入口文件：npm.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> momennt = <span class=\"built_in\">require</span>(<span class=\"string\">'moment'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    momennt,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>配置文件：webpack.config.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: <span class=\"string\">'./entry.js'</span>,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: path.resolve(__dirname, <span class=\"string\">'npm'</span>),</span><br><span class=\"line\">        filename: <span class=\"string\">'index.js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>运行 <code>$ webpack</code>，输出 <code>./npm/index.js</code> 打包文件，对应的目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── entry.js</span><br><span class=\"line\">├── npm</span><br><span class=\"line\">│   └── index.js</span><br><span class=\"line\">└── webpack.config.js</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>示例代码：<a href=\"https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step3\">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step3</a></p>\n</blockquote>\n<p>笨拙点的方法，你只需要把 <code>npm/index.js</code> 拷贝到你的项目中，就可以使用你所引入的 npm 包的内容了。</p>\n<p>如果你的项目中使用了构建工具的话，就可以把「 webpack 打包 npm」 的这项任务加入到你的构建流程中。</p>\n<p>我是使用 gulp 来做项目构建工作的，下面提供一种基于 gulp 的实现作为参考。</p>\n<h1 id=\"结合-Gulp-做项目工程化\"><a href=\"#结合-Gulp-做项目工程化\" class=\"headerlink\" title=\"结合 Gulp 做项目工程化\"></a>结合 Gulp 做项目工程化</h1><p>工程目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── dist</span><br><span class=\"line\">│   ├── npm</span><br><span class=\"line\">│   │   └── index.js</span><br><span class=\"line\">│   └── pages</span><br><span class=\"line\">│       └── home</span><br><span class=\"line\">│           └── home.js</span><br><span class=\"line\">├── gulpfile.js</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── npm</span><br><span class=\"line\">    │   └── index.js</span><br><span class=\"line\">    └── pages</span><br><span class=\"line\">        └── home</span><br><span class=\"line\">            └── home.js</span><br></pre></td></tr></table></figure>\n<p>而 gulpfile 负责两件事：</p>\n<ol>\n<li>把 src 的 js 文件通过 babel 编译到 dist 目录（示例中忽略其他 wxml、wxss 文件）</li>\n<li>把 <code>npm/index.js</code> 通过 webpack 打包到 <code>dist/npm/index.js</code>，并压缩。</li>\n</ol>\n<p>gulpfile.js:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-babel'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> del = <span class=\"built_in\">require</span>(<span class=\"string\">'del'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> runSequence = <span class=\"built_in\">require</span>(<span class=\"string\">'run-sequence'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpackStream = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-stream'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> webpackConfig = &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [&#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">            loader: <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">            exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                presets: [<span class=\"string\">'es2015'</span>],</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        filename: <span class=\"string\">'index.js'</span>,</span><br><span class=\"line\">        libraryTarget: <span class=\"string\">'commonjs2'</span>,        </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清空 ./dist 目录</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'clean'</span>, () =&gt; del([<span class=\"string\">'./dist/**'</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打包 npm 依赖</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'npm'</span>, () =&gt; &#123;</span><br><span class=\"line\">    gulp.src(<span class=\"string\">'./src/npm/*.js'</span>)</span><br><span class=\"line\">        .pipe(webpackStream(webpackConfig), webpack)</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'./dist/npm'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译 JS 文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'scripts'</span>, () =&gt; &#123;</span><br><span class=\"line\">    gulp.src([<span class=\"string\">'./src/**/*.js'</span>, <span class=\"string\">'!./src/npm/*.js'</span>])</span><br><span class=\"line\">        .pipe(babel(&#123;</span><br><span class=\"line\">            presets: [<span class=\"string\">'stage-0'</span>, <span class=\"string\">'es2015'</span>],</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'./dist'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开发模式命令</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'build'</span>, [<span class=\"string\">'clean'</span>], () =&gt; runSequence(<span class=\"string\">'scripts'</span>, <span class=\"string\">'npm'</span>));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>示例代码：<a href=\"https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step4\">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step4</a></p>\n</blockquote>\n<h1 id=\"关于控制-npm-文件代码量\"><a href=\"#关于控制-npm-文件代码量\" class=\"headerlink\" title=\"关于控制 npm 文件代码量\"></a>关于控制 npm 文件代码量</h1><p>微信限制了项目的代码量为 2M，就算使用了分包机制，最多也是 4M 的代码量。<br>区区一个 moment 库的话，就算压缩过，也需要两百多 KB，这对于我们的代码量，是很不友好的。<br>我们需要对 npm 的引入持非常谨慎的态度，去度量每个依赖包的大小，想尽各种办法减少依赖的代码量。<br>譬如<code>moment</code> 我们可以使用 <code>moment-mini</code> 来代替，后者压缩过后只需要 51KB。</p>\n<p>而且我认为把 npm 的依赖放在一个入口文件中，会让我们可以对 npm 的依赖有一个全局的把握。</p>\n"},{"title":"理解UDP","date":"2017-03-02T08:02:25.000Z","_content":"\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\n# UDP 和 TCP 的不同\nTCP 在传送数据之前必须先建立连接，数据传送结束后要释放连接。    \nTCP 不提供广播或多播服务，由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。    \n\n而 UDP 在传送数据之前不需要先建立连接。接收方收到 UDP 报文之后，不需要给出任何确认。    \n虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。    \n\n简单来说就是：\n\n**UDP：单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序；**\n\n**TCP：流式，需要建立连接，复杂，可靠 ，有序。**\n\n\n# UDP 概述\nUDP 全称 User Datagram Protocol, 与 TCP 同是在网络模型中的传输层的协议。\n\n**UDP 的主要特点是：**\n\n1. **无连接的**，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。\n2. **不保证可靠交付**，因此主机不需要为此复杂的连接状态表\n3. **面向报文的**，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。\n4. **没有阻塞控制**，因此网络出现的拥塞不会使发送方的发送速率降低。\n5. **支持一对一、一对多、多对一和多对多的交互通信**，也即是提供广播和多播的功能。\n6. **首部开销小**，首部只有 8 个字节，分为四部分。\n\n**UDP 的常用场景：**\n\n1. 名字转换（DNS）\n2. 文件传送（TFTP）\n3. 路由选择协议（RIP）\n4. IP 地址配置（BOOTP，DHTP）\n5. 网络管理（SNMP）\n6. 远程文件服务（NFS）\n7. IP 电话\n8. 流式多媒体通信\n\n# UDP 报文结构\nUDP 数据报分为数据字段和首部字段。    \n首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。    \n\n![UDP  数据报结构.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/6FCC9F4EDE80F784BD11ED9FA76FA375.png)\n\n**首部各字段意义**：\n\n1. **源端口**：源端口号，在需要对方回信时选用，不需要时可全 0.\n2. **目的端口**：目的端口号，在终点交付报文时必须要使用到。\n3. **长度**：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。\n4. **检验和**：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。\n\n# UDP 如何进行校验和\n\n## 伪首部\nUDP 数据报首部中检验和的计算方法比较特殊。        \n在计算检验和时，要在数据报之前增加 12 个字节的伪首部，用来计算校验和。    \n伪首部并不是数据报真正的首部，是为了计算校验和而临时添加在数据报前面的，在真正传输的时候并不会把伪首部一并发送。    \n\n\n![UDP 数据报结构-伪首部.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/3D9C291187835C3571A111952201B4FF.png)\n\n**伪首部个字段意义**：\n\n1. 第一字段，源 IP 地址\n2. 第二字段，目的 IP 地址\n3. 第三字段，字段全 0\n4. 第四字段，IP 首部中的协议字段的值，对于 UDP，此字段值为 17\n5. 第五字段，UDP 用户数据报的长度\n\n## 校验和计算方法\n\n校验和的计算中，频繁用到了二进制的反码求和运算，运算规则见下：    \n\n**二进制反码求和运算**\n\n```\n0 + 0 = 0\n1 + 0 = 0 + 1 = 1\n1 + 1 = 10\n```\n\n其中 10 中的 1 加到了下一列去，如果是最高列的 1 + 1 ，那么得到的 10 留下 0 , 1 移到最低列，与最低位再做一次二进制加法即可。\n\n**检验和计算过程**\n\n1. 把首部的检验和字段设置为全 0 \n2. 把伪首部以及数据段看成是许多 16 位的字串接起来。\n3. 若数据段不是偶数个字节，则填充一个全 0 字节，但是这个字节不发送。\n4. 通过二进制反码运算，计算出 16 位字的和。\n  1. 让第一行和第二行做二进制反码运算。  \n  2. 将第一行和第二行的结果与第三行做二进制反码计算，以此类推。\n5. 最后运算结果取反，得到校验和。\n6. 把计算出来的校验和值，填入首部校验和字段。\n\n接收方收到数据报之后，按照同样的方法计算校验和，如果有差错，则丢弃这个数据报。    \n\n可以看出校验和，既检查了 UDP 用户数据报的源端口号和目的端口号以及数据报的数据部分，又检查了 IP 数据报的源 IP 地址和目的地址。    \n\n**一个校验和例子**\n假设一个 UDP 数据报：\n\n![UDP 校验和.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/5DADDF7480F81837145468E2ADA6839F.png)\n\n各字段以二进制表示：\n\n```\n1001 1001 0001 0011 //伪首部源IP地址前16位，值：153.19\n0000 1000 0110 1000 //伪首部源IP地址后16位，值：8.104\n1010 1011 0000 0011 //伪首部目的IP地址前16位，值：171.3\n0000 1110 0000 1011 //伪首部目的IP地址后16位，值：14.11\n0000 0000 0001 0001 //伪首部UDP协议字段代表号，值：17\n0000 0000 0000 1111 //伪首部UDP长度字段，值：15\n0000 0100 0011 1111 //UDP头部源IP地址对应的进程端口号，值：1087\n0000 0000 0000 1101 //UDP头部目的IP地址对应的进程端口号，值：13\n0000 0000 0000 1111 //UDP头部UDP长度字段，值：15\n0000 0000 0000 0000 //UDP头部UDP检验和，值：0\n0101 0100 0100 0101 //数据字段\n0101 0011 0101 0100 //数据字段\n0100 1001 0100 1110 //数据字段\n0100 0111 0000 0000 //数据字段+填充0字段\n```\n\n按照二进制反码运算求和，结果：`10010110 11101101`    \n结果求反码得出校验和：`01101001 00010010` \n\n\n# 参考\n[二进制反码求和运算](https://jcchan23.github.io/2016/07/12/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8D%E7%A0%81%E6%B1%82%E5%92%8C%E8%BF%90%E7%AE%97/)    \n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)    ","source":"_posts/understand-udp.md","raw":"---\ntitle: 理解UDP\ncategory: 搬砖码农\ndate: 2017-03-02 16:02:25\ntags: \n- udp\n---\n\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\n# UDP 和 TCP 的不同\nTCP 在传送数据之前必须先建立连接，数据传送结束后要释放连接。    \nTCP 不提供广播或多播服务，由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。    \n\n而 UDP 在传送数据之前不需要先建立连接。接收方收到 UDP 报文之后，不需要给出任何确认。    \n虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。    \n\n简单来说就是：\n\n**UDP：单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序；**\n\n**TCP：流式，需要建立连接，复杂，可靠 ，有序。**\n\n\n# UDP 概述\nUDP 全称 User Datagram Protocol, 与 TCP 同是在网络模型中的传输层的协议。\n\n**UDP 的主要特点是：**\n\n1. **无连接的**，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。\n2. **不保证可靠交付**，因此主机不需要为此复杂的连接状态表\n3. **面向报文的**，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。\n4. **没有阻塞控制**，因此网络出现的拥塞不会使发送方的发送速率降低。\n5. **支持一对一、一对多、多对一和多对多的交互通信**，也即是提供广播和多播的功能。\n6. **首部开销小**，首部只有 8 个字节，分为四部分。\n\n**UDP 的常用场景：**\n\n1. 名字转换（DNS）\n2. 文件传送（TFTP）\n3. 路由选择协议（RIP）\n4. IP 地址配置（BOOTP，DHTP）\n5. 网络管理（SNMP）\n6. 远程文件服务（NFS）\n7. IP 电话\n8. 流式多媒体通信\n\n# UDP 报文结构\nUDP 数据报分为数据字段和首部字段。    \n首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。    \n\n![UDP  数据报结构.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/6FCC9F4EDE80F784BD11ED9FA76FA375.png)\n\n**首部各字段意义**：\n\n1. **源端口**：源端口号，在需要对方回信时选用，不需要时可全 0.\n2. **目的端口**：目的端口号，在终点交付报文时必须要使用到。\n3. **长度**：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。\n4. **检验和**：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。\n\n# UDP 如何进行校验和\n\n## 伪首部\nUDP 数据报首部中检验和的计算方法比较特殊。        \n在计算检验和时，要在数据报之前增加 12 个字节的伪首部，用来计算校验和。    \n伪首部并不是数据报真正的首部，是为了计算校验和而临时添加在数据报前面的，在真正传输的时候并不会把伪首部一并发送。    \n\n\n![UDP 数据报结构-伪首部.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/3D9C291187835C3571A111952201B4FF.png)\n\n**伪首部个字段意义**：\n\n1. 第一字段，源 IP 地址\n2. 第二字段，目的 IP 地址\n3. 第三字段，字段全 0\n4. 第四字段，IP 首部中的协议字段的值，对于 UDP，此字段值为 17\n5. 第五字段，UDP 用户数据报的长度\n\n## 校验和计算方法\n\n校验和的计算中，频繁用到了二进制的反码求和运算，运算规则见下：    \n\n**二进制反码求和运算**\n\n```\n0 + 0 = 0\n1 + 0 = 0 + 1 = 1\n1 + 1 = 10\n```\n\n其中 10 中的 1 加到了下一列去，如果是最高列的 1 + 1 ，那么得到的 10 留下 0 , 1 移到最低列，与最低位再做一次二进制加法即可。\n\n**检验和计算过程**\n\n1. 把首部的检验和字段设置为全 0 \n2. 把伪首部以及数据段看成是许多 16 位的字串接起来。\n3. 若数据段不是偶数个字节，则填充一个全 0 字节，但是这个字节不发送。\n4. 通过二进制反码运算，计算出 16 位字的和。\n  1. 让第一行和第二行做二进制反码运算。  \n  2. 将第一行和第二行的结果与第三行做二进制反码计算，以此类推。\n5. 最后运算结果取反，得到校验和。\n6. 把计算出来的校验和值，填入首部校验和字段。\n\n接收方收到数据报之后，按照同样的方法计算校验和，如果有差错，则丢弃这个数据报。    \n\n可以看出校验和，既检查了 UDP 用户数据报的源端口号和目的端口号以及数据报的数据部分，又检查了 IP 数据报的源 IP 地址和目的地址。    \n\n**一个校验和例子**\n假设一个 UDP 数据报：\n\n![UDP 校验和.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/5DADDF7480F81837145468E2ADA6839F.png)\n\n各字段以二进制表示：\n\n```\n1001 1001 0001 0011 //伪首部源IP地址前16位，值：153.19\n0000 1000 0110 1000 //伪首部源IP地址后16位，值：8.104\n1010 1011 0000 0011 //伪首部目的IP地址前16位，值：171.3\n0000 1110 0000 1011 //伪首部目的IP地址后16位，值：14.11\n0000 0000 0001 0001 //伪首部UDP协议字段代表号，值：17\n0000 0000 0000 1111 //伪首部UDP长度字段，值：15\n0000 0100 0011 1111 //UDP头部源IP地址对应的进程端口号，值：1087\n0000 0000 0000 1101 //UDP头部目的IP地址对应的进程端口号，值：13\n0000 0000 0000 1111 //UDP头部UDP长度字段，值：15\n0000 0000 0000 0000 //UDP头部UDP检验和，值：0\n0101 0100 0100 0101 //数据字段\n0101 0011 0101 0100 //数据字段\n0100 1001 0100 1110 //数据字段\n0100 0111 0000 0000 //数据字段+填充0字段\n```\n\n按照二进制反码运算求和，结果：`10010110 11101101`    \n结果求反码得出校验和：`01101001 00010010` \n\n\n# 参考\n[二进制反码求和运算](https://jcchan23.github.io/2016/07/12/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8D%E7%A0%81%E6%B1%82%E5%92%8C%E8%BF%90%E7%AE%97/)    \n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)    ","slug":"understand-udp","published":1,"updated":"2020-12-13T13:47:15.666Z","_id":"cl270y8se003pxwrlhu79a1av","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\" target=\"_blank\" rel=\"external\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<h1 id=\"UDP-和-TCP-的不同\"><a href=\"#UDP-和-TCP-的不同\" class=\"headerlink\" title=\"UDP 和 TCP 的不同\"></a>UDP 和 TCP 的不同</h1><p>TCP 在传送数据之前必须先建立连接，数据传送结束后要释放连接。<br>TCP 不提供广播或多播服务，由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。    </p>\n<p>而 UDP 在传送数据之前不需要先建立连接。接收方收到 UDP 报文之后，不需要给出任何确认。<br>虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。    </p>\n<p>简单来说就是：</p>\n<p><strong>UDP：单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序；</strong></p>\n<p><strong>TCP：流式，需要建立连接，复杂，可靠 ，有序。</strong></p>\n<h1 id=\"UDP-概述\"><a href=\"#UDP-概述\" class=\"headerlink\" title=\"UDP 概述\"></a>UDP 概述</h1><p>UDP 全称 User Datagram Protocol, 与 TCP 同是在网络模型中的传输层的协议。</p>\n<p><strong>UDP 的主要特点是：</strong></p>\n<ol>\n<li><strong>无连接的</strong>，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li>\n<li><strong>不保证可靠交付</strong>，因此主机不需要为此复杂的连接状态表</li>\n<li><strong>面向报文的</strong>，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。</li>\n<li><strong>没有阻塞控制</strong>，因此网络出现的拥塞不会使发送方的发送速率降低。</li>\n<li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>，也即是提供广播和多播的功能。</li>\n<li><strong>首部开销小</strong>，首部只有 8 个字节，分为四部分。</li>\n</ol>\n<p><strong>UDP 的常用场景：</strong></p>\n<ol>\n<li>名字转换（DNS）</li>\n<li>文件传送（TFTP）</li>\n<li>路由选择协议（RIP）</li>\n<li>IP 地址配置（BOOTP，DHTP）</li>\n<li>网络管理（SNMP）</li>\n<li>远程文件服务（NFS）</li>\n<li>IP 电话</li>\n<li>流式多媒体通信</li>\n</ol>\n<h1 id=\"UDP-报文结构\"><a href=\"#UDP-报文结构\" class=\"headerlink\" title=\"UDP 报文结构\"></a>UDP 报文结构</h1><p>UDP 数据报分为数据字段和首部字段。<br>首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/6FCC9F4EDE80F784BD11ED9FA76FA375.png\" alt=\"UDP  数据报结构.png\"></p>\n<p><strong>首部各字段意义</strong>：</p>\n<ol>\n<li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要时可全 0.</li>\n<li><strong>目的端口</strong>：目的端口号，在终点交付报文时必须要使用到。</li>\n<li><strong>长度</strong>：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。</li>\n<li><strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。</li>\n</ol>\n<h1 id=\"UDP-如何进行校验和\"><a href=\"#UDP-如何进行校验和\" class=\"headerlink\" title=\"UDP 如何进行校验和\"></a>UDP 如何进行校验和</h1><h2 id=\"伪首部\"><a href=\"#伪首部\" class=\"headerlink\" title=\"伪首部\"></a>伪首部</h2><p>UDP 数据报首部中检验和的计算方法比较特殊。<br>在计算检验和时，要在数据报之前增加 12 个字节的伪首部，用来计算校验和。<br>伪首部并不是数据报真正的首部，是为了计算校验和而临时添加在数据报前面的，在真正传输的时候并不会把伪首部一并发送。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/3D9C291187835C3571A111952201B4FF.png\" alt=\"UDP 数据报结构-伪首部.png\"></p>\n<p><strong>伪首部个字段意义</strong>：</p>\n<ol>\n<li>第一字段，源 IP 地址</li>\n<li>第二字段，目的 IP 地址</li>\n<li>第三字段，字段全 0</li>\n<li>第四字段，IP 首部中的协议字段的值，对于 UDP，此字段值为 17</li>\n<li>第五字段，UDP 用户数据报的长度</li>\n</ol>\n<h2 id=\"校验和计算方法\"><a href=\"#校验和计算方法\" class=\"headerlink\" title=\"校验和计算方法\"></a>校验和计算方法</h2><p>校验和的计算中，频繁用到了二进制的反码求和运算，运算规则见下：    </p>\n<p><strong>二进制反码求和运算</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 + 0 = 0</span><br><span class=\"line\">1 + 0 = 0 + 1 = 1</span><br><span class=\"line\">1 + 1 = 10</span><br></pre></td></tr></table></figure>\n<p>其中 10 中的 1 加到了下一列去，如果是最高列的 1 + 1 ，那么得到的 10 留下 0 , 1 移到最低列，与最低位再做一次二进制加法即可。</p>\n<p><strong>检验和计算过程</strong></p>\n<ol>\n<li>把首部的检验和字段设置为全 0 </li>\n<li>把伪首部以及数据段看成是许多 16 位的字串接起来。</li>\n<li>若数据段不是偶数个字节，则填充一个全 0 字节，但是这个字节不发送。</li>\n<li>通过二进制反码运算，计算出 16 位字的和。<ol>\n<li>让第一行和第二行做二进制反码运算。  </li>\n<li>将第一行和第二行的结果与第三行做二进制反码计算，以此类推。</li>\n</ol>\n</li>\n<li>最后运算结果取反，得到校验和。</li>\n<li>把计算出来的校验和值，填入首部校验和字段。</li>\n</ol>\n<p>接收方收到数据报之后，按照同样的方法计算校验和，如果有差错，则丢弃这个数据报。    </p>\n<p>可以看出校验和，既检查了 UDP 用户数据报的源端口号和目的端口号以及数据报的数据部分，又检查了 IP 数据报的源 IP 地址和目的地址。    </p>\n<p><strong>一个校验和例子</strong><br>假设一个 UDP 数据报：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/5DADDF7480F81837145468E2ADA6839F.png\" alt=\"UDP 校验和.png\"></p>\n<p>各字段以二进制表示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1001 1001 0001 0011 //伪首部源IP地址前16位，值：153.19</span><br><span class=\"line\">0000 1000 0110 1000 //伪首部源IP地址后16位，值：8.104</span><br><span class=\"line\">1010 1011 0000 0011 //伪首部目的IP地址前16位，值：171.3</span><br><span class=\"line\">0000 1110 0000 1011 //伪首部目的IP地址后16位，值：14.11</span><br><span class=\"line\">0000 0000 0001 0001 //伪首部UDP协议字段代表号，值：17</span><br><span class=\"line\">0000 0000 0000 1111 //伪首部UDP长度字段，值：15</span><br><span class=\"line\">0000 0100 0011 1111 //UDP头部源IP地址对应的进程端口号，值：1087</span><br><span class=\"line\">0000 0000 0000 1101 //UDP头部目的IP地址对应的进程端口号，值：13</span><br><span class=\"line\">0000 0000 0000 1111 //UDP头部UDP长度字段，值：15</span><br><span class=\"line\">0000 0000 0000 0000 //UDP头部UDP检验和，值：0</span><br><span class=\"line\">0101 0100 0100 0101 //数据字段</span><br><span class=\"line\">0101 0011 0101 0100 //数据字段</span><br><span class=\"line\">0100 1001 0100 1110 //数据字段</span><br><span class=\"line\">0100 0111 0000 0000 //数据字段+填充0字段</span><br></pre></td></tr></table></figure>\n<p>按照二进制反码运算求和，结果：<code>10010110 11101101</code><br>结果求反码得出校验和：<code>01101001 00010010</code> </p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://jcchan23.github.io/2016/07/12/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8D%E7%A0%81%E6%B1%82%E5%92%8C%E8%BF%90%E7%AE%97/\" target=\"_blank\" rel=\"external\">二进制反码求和运算</a><br><a href=\"https://book.douban.com/subject/26850616/\" target=\"_blank\" rel=\"external\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\" target=\"_blank\" rel=\"external\">《计算机网络》</a>    </p>\n","excerpt":"","more":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<h1 id=\"UDP-和-TCP-的不同\"><a href=\"#UDP-和-TCP-的不同\" class=\"headerlink\" title=\"UDP 和 TCP 的不同\"></a>UDP 和 TCP 的不同</h1><p>TCP 在传送数据之前必须先建立连接，数据传送结束后要释放连接。<br>TCP 不提供广播或多播服务，由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。    </p>\n<p>而 UDP 在传送数据之前不需要先建立连接。接收方收到 UDP 报文之后，不需要给出任何确认。<br>虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。    </p>\n<p>简单来说就是：</p>\n<p><strong>UDP：单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序；</strong></p>\n<p><strong>TCP：流式，需要建立连接，复杂，可靠 ，有序。</strong></p>\n<h1 id=\"UDP-概述\"><a href=\"#UDP-概述\" class=\"headerlink\" title=\"UDP 概述\"></a>UDP 概述</h1><p>UDP 全称 User Datagram Protocol, 与 TCP 同是在网络模型中的传输层的协议。</p>\n<p><strong>UDP 的主要特点是：</strong></p>\n<ol>\n<li><strong>无连接的</strong>，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li>\n<li><strong>不保证可靠交付</strong>，因此主机不需要为此复杂的连接状态表</li>\n<li><strong>面向报文的</strong>，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。</li>\n<li><strong>没有阻塞控制</strong>，因此网络出现的拥塞不会使发送方的发送速率降低。</li>\n<li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>，也即是提供广播和多播的功能。</li>\n<li><strong>首部开销小</strong>，首部只有 8 个字节，分为四部分。</li>\n</ol>\n<p><strong>UDP 的常用场景：</strong></p>\n<ol>\n<li>名字转换（DNS）</li>\n<li>文件传送（TFTP）</li>\n<li>路由选择协议（RIP）</li>\n<li>IP 地址配置（BOOTP，DHTP）</li>\n<li>网络管理（SNMP）</li>\n<li>远程文件服务（NFS）</li>\n<li>IP 电话</li>\n<li>流式多媒体通信</li>\n</ol>\n<h1 id=\"UDP-报文结构\"><a href=\"#UDP-报文结构\" class=\"headerlink\" title=\"UDP 报文结构\"></a>UDP 报文结构</h1><p>UDP 数据报分为数据字段和首部字段。<br>首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/6FCC9F4EDE80F784BD11ED9FA76FA375.png\" alt=\"UDP  数据报结构.png\"></p>\n<p><strong>首部各字段意义</strong>：</p>\n<ol>\n<li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要时可全 0.</li>\n<li><strong>目的端口</strong>：目的端口号，在终点交付报文时必须要使用到。</li>\n<li><strong>长度</strong>：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。</li>\n<li><strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。</li>\n</ol>\n<h1 id=\"UDP-如何进行校验和\"><a href=\"#UDP-如何进行校验和\" class=\"headerlink\" title=\"UDP 如何进行校验和\"></a>UDP 如何进行校验和</h1><h2 id=\"伪首部\"><a href=\"#伪首部\" class=\"headerlink\" title=\"伪首部\"></a>伪首部</h2><p>UDP 数据报首部中检验和的计算方法比较特殊。<br>在计算检验和时，要在数据报之前增加 12 个字节的伪首部，用来计算校验和。<br>伪首部并不是数据报真正的首部，是为了计算校验和而临时添加在数据报前面的，在真正传输的时候并不会把伪首部一并发送。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/3D9C291187835C3571A111952201B4FF.png\" alt=\"UDP 数据报结构-伪首部.png\"></p>\n<p><strong>伪首部个字段意义</strong>：</p>\n<ol>\n<li>第一字段，源 IP 地址</li>\n<li>第二字段，目的 IP 地址</li>\n<li>第三字段，字段全 0</li>\n<li>第四字段，IP 首部中的协议字段的值，对于 UDP，此字段值为 17</li>\n<li>第五字段，UDP 用户数据报的长度</li>\n</ol>\n<h2 id=\"校验和计算方法\"><a href=\"#校验和计算方法\" class=\"headerlink\" title=\"校验和计算方法\"></a>校验和计算方法</h2><p>校验和的计算中，频繁用到了二进制的反码求和运算，运算规则见下：    </p>\n<p><strong>二进制反码求和运算</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 + 0 = 0</span><br><span class=\"line\">1 + 0 = 0 + 1 = 1</span><br><span class=\"line\">1 + 1 = 10</span><br></pre></td></tr></table></figure>\n<p>其中 10 中的 1 加到了下一列去，如果是最高列的 1 + 1 ，那么得到的 10 留下 0 , 1 移到最低列，与最低位再做一次二进制加法即可。</p>\n<p><strong>检验和计算过程</strong></p>\n<ol>\n<li>把首部的检验和字段设置为全 0 </li>\n<li>把伪首部以及数据段看成是许多 16 位的字串接起来。</li>\n<li>若数据段不是偶数个字节，则填充一个全 0 字节，但是这个字节不发送。</li>\n<li>通过二进制反码运算，计算出 16 位字的和。<ol>\n<li>让第一行和第二行做二进制反码运算。  </li>\n<li>将第一行和第二行的结果与第三行做二进制反码计算，以此类推。</li>\n</ol>\n</li>\n<li>最后运算结果取反，得到校验和。</li>\n<li>把计算出来的校验和值，填入首部校验和字段。</li>\n</ol>\n<p>接收方收到数据报之后，按照同样的方法计算校验和，如果有差错，则丢弃这个数据报。    </p>\n<p>可以看出校验和，既检查了 UDP 用户数据报的源端口号和目的端口号以及数据报的数据部分，又检查了 IP 数据报的源 IP 地址和目的地址。    </p>\n<p><strong>一个校验和例子</strong><br>假设一个 UDP 数据报：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/5DADDF7480F81837145468E2ADA6839F.png\" alt=\"UDP 校验和.png\"></p>\n<p>各字段以二进制表示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1001 1001 0001 0011 //伪首部源IP地址前16位，值：153.19</span><br><span class=\"line\">0000 1000 0110 1000 //伪首部源IP地址后16位，值：8.104</span><br><span class=\"line\">1010 1011 0000 0011 //伪首部目的IP地址前16位，值：171.3</span><br><span class=\"line\">0000 1110 0000 1011 //伪首部目的IP地址后16位，值：14.11</span><br><span class=\"line\">0000 0000 0001 0001 //伪首部UDP协议字段代表号，值：17</span><br><span class=\"line\">0000 0000 0000 1111 //伪首部UDP长度字段，值：15</span><br><span class=\"line\">0000 0100 0011 1111 //UDP头部源IP地址对应的进程端口号，值：1087</span><br><span class=\"line\">0000 0000 0000 1101 //UDP头部目的IP地址对应的进程端口号，值：13</span><br><span class=\"line\">0000 0000 0000 1111 //UDP头部UDP长度字段，值：15</span><br><span class=\"line\">0000 0000 0000 0000 //UDP头部UDP检验和，值：0</span><br><span class=\"line\">0101 0100 0100 0101 //数据字段</span><br><span class=\"line\">0101 0011 0101 0100 //数据字段</span><br><span class=\"line\">0100 1001 0100 1110 //数据字段</span><br><span class=\"line\">0100 0111 0000 0000 //数据字段+填充0字段</span><br></pre></td></tr></table></figure>\n<p>按照二进制反码运算求和，结果：<code>10010110 11101101</code><br>结果求反码得出校验和：<code>01101001 00010010</code> </p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://jcchan23.github.io/2016/07/12/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8D%E7%A0%81%E6%B1%82%E5%92%8C%E8%BF%90%E7%AE%97/\">二进制反码求和运算</a><br><a href=\"https://book.douban.com/subject/26850616/\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\">《计算机网络》</a>    </p>\n"},{"title":"加深对 JavaScript This 的理解","date":"2017-07-15T02:40:00.000Z","_content":"\n我相信你已经看过很多关于 JavaScript 的 `this`  的谈论了，既然你点进来了，不妨继续看下去，看是否能帮你加深对 `this` 的理解。\n\n最近在看 [《You Dont Know JS》](https://github.com/getify/You-Dont-Know-JS) 这本书，不得感叹，就算用了 JS 很多年的老前端来看这本书，我觉得还是会有不少的收获。\n\n其中关于 `this` 的讲解，更是加深了我对 `this` 的理解，故整理知识点，再加上自身的理解，以自己的语言来描述。\n对读者来说，算是二手知识，这本书是开源的，可以到本书的 Github 项目地址学习一手的知识。\n\n首先有一句大家都明白的话，我还是要强调一遍：\n**「`this` 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。」**\n\n这句话很重要，这是理解 `this` 原理的基础。\n而在讲解 `this` 之前，先要理解一下作用域的相关概念。\n\n# 「词法作用域」与「动态作用域」\n通常来说，作用域一共有两种主要的工作模型。\n\n* 词法作用域\n* 动态作用域\n\n词法作用域是大多数编程语言所采用的模式，而动态作用域仍有一些编程语言在用，例如 Bash 脚本。\n而 JavaScript 就是采用的词法作用域，也就是在编程阶段，作用域就已经明确下来了。\n\n思考下面代码：\n\n```JavaScript\nfunction foo(){\n  console.log(a);   // 输出 2\n}\n\nfunction bar(){\n  let a = 3;\n  foo();\n}\n\nlet a = 2;\n\nbar()\n```\n\n因为 JavaScript 所用的是词法作用域，自然 `foo()` 声明的阶段，就已经确定了变量 `a` 的作用域了。\n\n倘若，JavaScript 是采用的动态作用域，`foo()` 中打印的将是 `3`\n\n```JavaScript\nfunction foo(){\n  console.log(a);   // 输出 3 （不是 2）\n}\n\nfunction bar(){\n  let a = 3;\n  foo();\n}\n\nlet a = 2;\n\nbar()\n```\n\n而 JavaScript 的 `this` 机制跟动态作用域很相似，是在运行时在被调用的地方动态绑定的。\n\n# this 的四种绑定规则\n\n在 JavaScript 中，影响 this 指向的绑定规则有四种：\n\n* 默认绑定\n* 隐式绑定\n* 显式绑定\n* new 绑定\n\n## 默认绑定\n这是最直接的一种方式，就是不加任何的修饰符直接调用函数，如：\n\n```javascript\nfunction foo() {\n  console.log(this.a)   // 输出 a\n}\n\nvar a = 2;  //  变量声明到全局对象中\n\nfoo();\n```\n\n使用 `var` 声明的变量 `a`，被绑定到全局对象中，如果是浏览器，则是在 `window` 对象。\n`foo()` 调用时，引用了默认绑定，`this` 指向了全局对象。\n\n## 隐式绑定\n这种情况会发生在调用位置存在「上下文对象」的情况，如：\n\n```javascript\nfunction foo() {\n  console.log(this.a);\n}\n\nlet obj1 = {\n  a: 1,\n  foo,\n};\n\nlet obj2 = {\n  a: 2,\n  foo,\n}\n\nobj1.foo();   // 输出 1\nobj2.foo();   // 输出 2\n```\n\n当函数调用的时候，拥有上下文对象的时候，`this` 会被绑定到该上下文对象。\n正如上面的代码，\n`obj1.foo()` 被调用时，`this` 绑定到了 `obj1`, \n而 `obj2.foo()` 被调用时，`this` 绑定到了 `obj2`。\n\n## 显式绑定\n这种就是使用 `Function.prototype` 中的三个方法 `call()`, `apply()`, `bind()` 了。\n这三个函数，都可以改变函数的 `this` 指向到指定的对象，\n不同之处在于，`call()` 和 `apply()` 是立即执行函数，并且接受的参数的形式不同：\n\n* `call(this, arg1, arg2, ...)`\n* `apply(this, [arg1, arg2, ...])`\n\n而 `bind()` 则是创建一个新的包装函数，并且返回，而不是立刻执行。\n\n* `bind(this, arg1, arg2, ...)`\n\n`apply()` 接收参数的形式，有助于函数嵌套函数的时候，把 `arguments` 变量传递到下一层函数中。\n\n思考下面代码：\n\n```javascript\nfunction foo() {\n  console.log(this.a);  // 输出 1\n  bar.apply({a: 2}, arguments);\n}\n\nfunction bar(b) {\n  console.log(this.a + b);  // 输出 5\n}\n\nvar a = 1;\nfoo(3);\n```\n\n上面代码中， `foo()` 内部的 `this` 遵循默认绑定规则，绑定到全局变量中。\n而 `bar()` 在调用的时候，调用了 `apply()` 函数，把 `this` 绑定到了一个新的对象中 `{a: 2}`，而且原封不动的接收 `foo()` 接收的函数。\n\n## new 绑定\n最后一种，则是使用 `new` 操作符会产生 `this` 的绑定。\n在理解 `new` 操作符对 `this` 的影响，首先要理解 `new` 的原理。\n在 JavaScript 中，`new` 操作符并不像其他面向对象的语言一样，而是一种模拟出来的机制。\n在 JavaScript 中，所有的函数都可以被 `new` 调用，这时候这个函数一般会被称为「构造函数」，实际上并不存在所谓「构造函数」，更确切的理解应该是对于函数的「构造调用」。\n\n使用 `new` 来调用函数，会自动执行下面操作：\n\n1. 创建一个全新的对象。\n2. 这个新对象会被执行 [[Prototype]] 连接。\n3. 这个新对象会绑定到函数调用的 this。\n4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。\n\n所以如果 `new` 是一个函数的话，会是这样子的：\n\n```javascript\nfunction New(Constructor, ...args){\n    let obj = {};   // 创建一个新对象\n    Object.setPrototypeOf(obj, Constructor.prototype);  // 连接新对象与函数的原型\n    return Constructor.apply(obj, args) || obj;   // 执行函数，改变 this 指向新的对象\n}\n\nfunction Foo(a){\n    this.a = a;\n}\n\nNew(Foo, 1);  // Foo { a: 1 }\n```\n\n所以，在使用 `new` 来调用函数时候，我们会构造一个新对象并把它绑定到函数调用中的 `this` 上。\n\n# 优先级\n\n如果一个位置发生了多条改变 this 的规则，那么优先级是如何的呢？\n\n看几段代码：\n\n```javascript\n// 显式绑定 > 隐式绑定\nfunction foo() {\n    console.log(this.a);\n}\n\nlet obj1 = {\n    a: 2,\n    foo,\n}\n\nobj1.foo();     // 输出 2\nobj1.foo.call({a: 1});      // 输出 1\n```\n\n这说明「显式绑定」的优先级大于「隐式绑定」\n\n```javascript\n// new 绑定 > 显式绑定\nfunction foo(a) {\n    this.a = a;\n}\n\nlet obj1 = {};\n\nlet bar = foo.bind(obj1);\nbar(2);\nconsole.log(obj1); // 输出 {a:2}\n\nlet obj2 = new bar(3);\nconsole.log(obj1); // 输出 {a:2}\nconsole.log(obj2); // 输出 foo { a: 3 }\n```\n\n这说明「new 绑定」的优先级大于「显式绑定」\n而「默认绑定」，毫无疑问是优先级最低的。\n所以优先级顺序为：\n\n**「new 绑定」 > 「显式绑定」 > 「隐式绑定」 > 「默认绑定。」**\n\n# 所以，this 到底是什么\n\n`this` 并不是在编写的时候绑定的，而是在运行时绑定的。它的上下文取决于函数调用时的各种条件。\n`this` 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\n当一个函数被调用时，会创建一个「执行上下文」，这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。`this` 就是这个记录的一个属性，会在函数执行的过程中用到。\n\n# 参考\n[《You Dont Know JS》- this & Object Prototypes](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes)","source":"_posts/understand-this-of-javascript.md","raw":"---\ntitle: 加深对 JavaScript This 的理解\ncategory: 搬砖码农\ndate: 2017-07-15 10:40:00\ntags: \n- javascript\n---\n\n我相信你已经看过很多关于 JavaScript 的 `this`  的谈论了，既然你点进来了，不妨继续看下去，看是否能帮你加深对 `this` 的理解。\n\n最近在看 [《You Dont Know JS》](https://github.com/getify/You-Dont-Know-JS) 这本书，不得感叹，就算用了 JS 很多年的老前端来看这本书，我觉得还是会有不少的收获。\n\n其中关于 `this` 的讲解，更是加深了我对 `this` 的理解，故整理知识点，再加上自身的理解，以自己的语言来描述。\n对读者来说，算是二手知识，这本书是开源的，可以到本书的 Github 项目地址学习一手的知识。\n\n首先有一句大家都明白的话，我还是要强调一遍：\n**「`this` 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。」**\n\n这句话很重要，这是理解 `this` 原理的基础。\n而在讲解 `this` 之前，先要理解一下作用域的相关概念。\n\n# 「词法作用域」与「动态作用域」\n通常来说，作用域一共有两种主要的工作模型。\n\n* 词法作用域\n* 动态作用域\n\n词法作用域是大多数编程语言所采用的模式，而动态作用域仍有一些编程语言在用，例如 Bash 脚本。\n而 JavaScript 就是采用的词法作用域，也就是在编程阶段，作用域就已经明确下来了。\n\n思考下面代码：\n\n```JavaScript\nfunction foo(){\n  console.log(a);   // 输出 2\n}\n\nfunction bar(){\n  let a = 3;\n  foo();\n}\n\nlet a = 2;\n\nbar()\n```\n\n因为 JavaScript 所用的是词法作用域，自然 `foo()` 声明的阶段，就已经确定了变量 `a` 的作用域了。\n\n倘若，JavaScript 是采用的动态作用域，`foo()` 中打印的将是 `3`\n\n```JavaScript\nfunction foo(){\n  console.log(a);   // 输出 3 （不是 2）\n}\n\nfunction bar(){\n  let a = 3;\n  foo();\n}\n\nlet a = 2;\n\nbar()\n```\n\n而 JavaScript 的 `this` 机制跟动态作用域很相似，是在运行时在被调用的地方动态绑定的。\n\n# this 的四种绑定规则\n\n在 JavaScript 中，影响 this 指向的绑定规则有四种：\n\n* 默认绑定\n* 隐式绑定\n* 显式绑定\n* new 绑定\n\n## 默认绑定\n这是最直接的一种方式，就是不加任何的修饰符直接调用函数，如：\n\n```javascript\nfunction foo() {\n  console.log(this.a)   // 输出 a\n}\n\nvar a = 2;  //  变量声明到全局对象中\n\nfoo();\n```\n\n使用 `var` 声明的变量 `a`，被绑定到全局对象中，如果是浏览器，则是在 `window` 对象。\n`foo()` 调用时，引用了默认绑定，`this` 指向了全局对象。\n\n## 隐式绑定\n这种情况会发生在调用位置存在「上下文对象」的情况，如：\n\n```javascript\nfunction foo() {\n  console.log(this.a);\n}\n\nlet obj1 = {\n  a: 1,\n  foo,\n};\n\nlet obj2 = {\n  a: 2,\n  foo,\n}\n\nobj1.foo();   // 输出 1\nobj2.foo();   // 输出 2\n```\n\n当函数调用的时候，拥有上下文对象的时候，`this` 会被绑定到该上下文对象。\n正如上面的代码，\n`obj1.foo()` 被调用时，`this` 绑定到了 `obj1`, \n而 `obj2.foo()` 被调用时，`this` 绑定到了 `obj2`。\n\n## 显式绑定\n这种就是使用 `Function.prototype` 中的三个方法 `call()`, `apply()`, `bind()` 了。\n这三个函数，都可以改变函数的 `this` 指向到指定的对象，\n不同之处在于，`call()` 和 `apply()` 是立即执行函数，并且接受的参数的形式不同：\n\n* `call(this, arg1, arg2, ...)`\n* `apply(this, [arg1, arg2, ...])`\n\n而 `bind()` 则是创建一个新的包装函数，并且返回，而不是立刻执行。\n\n* `bind(this, arg1, arg2, ...)`\n\n`apply()` 接收参数的形式，有助于函数嵌套函数的时候，把 `arguments` 变量传递到下一层函数中。\n\n思考下面代码：\n\n```javascript\nfunction foo() {\n  console.log(this.a);  // 输出 1\n  bar.apply({a: 2}, arguments);\n}\n\nfunction bar(b) {\n  console.log(this.a + b);  // 输出 5\n}\n\nvar a = 1;\nfoo(3);\n```\n\n上面代码中， `foo()` 内部的 `this` 遵循默认绑定规则，绑定到全局变量中。\n而 `bar()` 在调用的时候，调用了 `apply()` 函数，把 `this` 绑定到了一个新的对象中 `{a: 2}`，而且原封不动的接收 `foo()` 接收的函数。\n\n## new 绑定\n最后一种，则是使用 `new` 操作符会产生 `this` 的绑定。\n在理解 `new` 操作符对 `this` 的影响，首先要理解 `new` 的原理。\n在 JavaScript 中，`new` 操作符并不像其他面向对象的语言一样，而是一种模拟出来的机制。\n在 JavaScript 中，所有的函数都可以被 `new` 调用，这时候这个函数一般会被称为「构造函数」，实际上并不存在所谓「构造函数」，更确切的理解应该是对于函数的「构造调用」。\n\n使用 `new` 来调用函数，会自动执行下面操作：\n\n1. 创建一个全新的对象。\n2. 这个新对象会被执行 [[Prototype]] 连接。\n3. 这个新对象会绑定到函数调用的 this。\n4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。\n\n所以如果 `new` 是一个函数的话，会是这样子的：\n\n```javascript\nfunction New(Constructor, ...args){\n    let obj = {};   // 创建一个新对象\n    Object.setPrototypeOf(obj, Constructor.prototype);  // 连接新对象与函数的原型\n    return Constructor.apply(obj, args) || obj;   // 执行函数，改变 this 指向新的对象\n}\n\nfunction Foo(a){\n    this.a = a;\n}\n\nNew(Foo, 1);  // Foo { a: 1 }\n```\n\n所以，在使用 `new` 来调用函数时候，我们会构造一个新对象并把它绑定到函数调用中的 `this` 上。\n\n# 优先级\n\n如果一个位置发生了多条改变 this 的规则，那么优先级是如何的呢？\n\n看几段代码：\n\n```javascript\n// 显式绑定 > 隐式绑定\nfunction foo() {\n    console.log(this.a);\n}\n\nlet obj1 = {\n    a: 2,\n    foo,\n}\n\nobj1.foo();     // 输出 2\nobj1.foo.call({a: 1});      // 输出 1\n```\n\n这说明「显式绑定」的优先级大于「隐式绑定」\n\n```javascript\n// new 绑定 > 显式绑定\nfunction foo(a) {\n    this.a = a;\n}\n\nlet obj1 = {};\n\nlet bar = foo.bind(obj1);\nbar(2);\nconsole.log(obj1); // 输出 {a:2}\n\nlet obj2 = new bar(3);\nconsole.log(obj1); // 输出 {a:2}\nconsole.log(obj2); // 输出 foo { a: 3 }\n```\n\n这说明「new 绑定」的优先级大于「显式绑定」\n而「默认绑定」，毫无疑问是优先级最低的。\n所以优先级顺序为：\n\n**「new 绑定」 > 「显式绑定」 > 「隐式绑定」 > 「默认绑定。」**\n\n# 所以，this 到底是什么\n\n`this` 并不是在编写的时候绑定的，而是在运行时绑定的。它的上下文取决于函数调用时的各种条件。\n`this` 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\n当一个函数被调用时，会创建一个「执行上下文」，这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。`this` 就是这个记录的一个属性，会在函数执行的过程中用到。\n\n# 参考\n[《You Dont Know JS》- this & Object Prototypes](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes)","slug":"understand-this-of-javascript","published":1,"updated":"2017-07-16T03:54:29.000Z","_id":"cl270y8sf003txwrlfdjza64t","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我相信你已经看过很多关于 JavaScript 的 <code>this</code>  的谈论了，既然你点进来了，不妨继续看下去，看是否能帮你加深对 <code>this</code> 的理解。</p>\n<p>最近在看 <a href=\"https://github.com/getify/You-Dont-Know-JS\" target=\"_blank\" rel=\"external\">《You Dont Know JS》</a> 这本书，不得感叹，就算用了 JS 很多年的老前端来看这本书，我觉得还是会有不少的收获。</p>\n<p>其中关于 <code>this</code> 的讲解，更是加深了我对 <code>this</code> 的理解，故整理知识点，再加上自身的理解，以自己的语言来描述。<br>对读者来说，算是二手知识，这本书是开源的，可以到本书的 Github 项目地址学习一手的知识。</p>\n<p>首先有一句大家都明白的话，我还是要强调一遍：<br><strong>「<code>this</code> 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。」</strong></p>\n<p>这句话很重要，这是理解 <code>this</code> 原理的基础。<br>而在讲解 <code>this</code> 之前，先要理解一下作用域的相关概念。</p>\n<h1 id=\"「词法作用域」与「动态作用域」\"><a href=\"#「词法作用域」与「动态作用域」\" class=\"headerlink\" title=\"「词法作用域」与「动态作用域」\"></a>「词法作用域」与「动态作用域」</h1><p>通常来说，作用域一共有两种主要的工作模型。</p>\n<ul>\n<li>词法作用域</li>\n<li>动态作用域</li>\n</ul>\n<p>词法作用域是大多数编程语言所采用的模式，而动态作用域仍有一些编程语言在用，例如 Bash 脚本。<br>而 JavaScript 就是采用的词法作用域，也就是在编程阶段，作用域就已经明确下来了。</p>\n<p>思考下面代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);   <span class=\"comment\">// 输出 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bar()</span><br></pre></td></tr></table></figure>\n<p>因为 JavaScript 所用的是词法作用域，自然 <code>foo()</code> 声明的阶段，就已经确定了变量 <code>a</code> 的作用域了。</p>\n<p>倘若，JavaScript 是采用的动态作用域，<code>foo()</code> 中打印的将是 <code>3</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);   <span class=\"comment\">// 输出 3 （不是 2）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bar()</span><br></pre></td></tr></table></figure>\n<p>而 JavaScript 的 <code>this</code> 机制跟动态作用域很相似，是在运行时在被调用的地方动态绑定的。</p>\n<h1 id=\"this-的四种绑定规则\"><a href=\"#this-的四种绑定规则\" class=\"headerlink\" title=\"this 的四种绑定规则\"></a>this 的四种绑定规则</h1><p>在 JavaScript 中，影响 this 指向的绑定规则有四种：</p>\n<ul>\n<li>默认绑定</li>\n<li>隐式绑定</li>\n<li>显式绑定</li>\n<li>new 绑定</li>\n</ul>\n<h2 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h2><p>这是最直接的一种方式，就是不加任何的修饰符直接调用函数，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)   <span class=\"comment\">// 输出 a</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;  <span class=\"comment\">//  变量声明到全局对象中</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p>使用 <code>var</code> 声明的变量 <code>a</code>，被绑定到全局对象中，如果是浏览器，则是在 <code>window</code> 对象。<br><code>foo()</code> 调用时，引用了默认绑定，<code>this</code> 指向了全局对象。</p>\n<h2 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h2><p>这种情况会发生在调用位置存在「上下文对象」的情况，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  foo,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj1.foo();   <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\">obj2.foo();   <span class=\"comment\">// 输出 2</span></span><br></pre></td></tr></table></figure>\n<p>当函数调用的时候，拥有上下文对象的时候，<code>this</code> 会被绑定到该上下文对象。<br>正如上面的代码，<br><code>obj1.foo()</code> 被调用时，<code>this</code> 绑定到了 <code>obj1</code>,<br>而 <code>obj2.foo()</code> 被调用时，<code>this</code> 绑定到了 <code>obj2</code>。</p>\n<h2 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h2><p>这种就是使用 <code>Function.prototype</code> 中的三个方法 <code>call()</code>, <code>apply()</code>, <code>bind()</code> 了。<br>这三个函数，都可以改变函数的 <code>this</code> 指向到指定的对象，<br>不同之处在于，<code>call()</code> 和 <code>apply()</code> 是立即执行函数，并且接受的参数的形式不同：</p>\n<ul>\n<li><code>call(this, arg1, arg2, ...)</code></li>\n<li><code>apply(this, [arg1, arg2, ...])</code></li>\n</ul>\n<p>而 <code>bind()</code> 则是创建一个新的包装函数，并且返回，而不是立刻执行。</p>\n<ul>\n<li><code>bind(this, arg1, arg2, ...)</code></li>\n</ul>\n<p><code>apply()</code> 接收参数的形式，有助于函数嵌套函数的时候，把 <code>arguments</code> 变量传递到下一层函数中。</p>\n<p>思考下面代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);  <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\">  bar.apply(&#123;<span class=\"attr\">a</span>: <span class=\"number\">2</span>&#125;, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a + b);  <span class=\"comment\">// 输出 5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">foo(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码中， <code>foo()</code> 内部的 <code>this</code> 遵循默认绑定规则，绑定到全局变量中。<br>而 <code>bar()</code> 在调用的时候，调用了 <code>apply()</code> 函数，把 <code>this</code> 绑定到了一个新的对象中 <code>{a: 2}</code>，而且原封不动的接收 <code>foo()</code> 接收的函数。</p>\n<h2 id=\"new-绑定\"><a href=\"#new-绑定\" class=\"headerlink\" title=\"new 绑定\"></a>new 绑定</h2><p>最后一种，则是使用 <code>new</code> 操作符会产生 <code>this</code> 的绑定。<br>在理解 <code>new</code> 操作符对 <code>this</code> 的影响，首先要理解 <code>new</code> 的原理。<br>在 JavaScript 中，<code>new</code> 操作符并不像其他面向对象的语言一样，而是一种模拟出来的机制。<br>在 JavaScript 中，所有的函数都可以被 <code>new</code> 调用，这时候这个函数一般会被称为「构造函数」，实际上并不存在所谓「构造函数」，更确切的理解应该是对于函数的「构造调用」。</p>\n<p>使用 <code>new</code> 来调用函数，会自动执行下面操作：</p>\n<ol>\n<li>创建一个全新的对象。</li>\n<li>这个新对象会被执行 [[Prototype]] 连接。</li>\n<li>这个新对象会绑定到函数调用的 this。</li>\n<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<p>所以如果 <code>new</code> 是一个函数的话，会是这样子的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">New</span>(<span class=\"params\">Constructor, ...args</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> obj = &#123;&#125;;   <span class=\"comment\">// 创建一个新对象</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.setPrototypeOf(obj, Constructor.prototype);  <span class=\"comment\">// 连接新对象与函数的原型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Constructor.apply(obj, args) || obj;   <span class=\"comment\">// 执行函数，改变 this 指向新的对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">New(Foo, <span class=\"number\">1</span>);  <span class=\"comment\">// Foo &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>所以，在使用 <code>new</code> 来调用函数时候，我们会构造一个新对象并把它绑定到函数调用中的 <code>this</code> 上。</p>\n<h1 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h1><p>如果一个位置发生了多条改变 this 的规则，那么优先级是如何的呢？</p>\n<p>看几段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 显式绑定 &gt; 隐式绑定</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj1.foo();     <span class=\"comment\">// 输出 2</span></span><br><span class=\"line\">obj1.foo.call(&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;);      <span class=\"comment\">// 输出 1</span></span><br></pre></td></tr></table></figure>\n<p>这说明「显式绑定」的优先级大于「隐式绑定」</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new 绑定 &gt; 显式绑定</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = foo.bind(obj1);</span><br><span class=\"line\">bar(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1); <span class=\"comment\">// 输出 &#123;a:2&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = <span class=\"keyword\">new</span> bar(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1); <span class=\"comment\">// 输出 &#123;a:2&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2); <span class=\"comment\">// 输出 foo &#123; a: 3 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>这说明「new 绑定」的优先级大于「显式绑定」<br>而「默认绑定」，毫无疑问是优先级最低的。<br>所以优先级顺序为：</p>\n<p><strong>「new 绑定」 &gt; 「显式绑定」 &gt; 「隐式绑定」 &gt; 「默认绑定。」</strong></p>\n<h1 id=\"所以，this-到底是什么\"><a href=\"#所以，this-到底是什么\" class=\"headerlink\" title=\"所以，this 到底是什么\"></a>所以，this 到底是什么</h1><p><code>this</code> 并不是在编写的时候绑定的，而是在运行时绑定的。它的上下文取决于函数调用时的各种条件。<br><code>this</code> 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。<br>当一个函数被调用时，会创建一个「执行上下文」，这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。<code>this</code> 就是这个记录的一个属性，会在函数执行的过程中用到。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes\" target=\"_blank\" rel=\"external\">《You Dont Know JS》- this &amp; Object Prototypes</a></p>\n","excerpt":"","more":"<p>我相信你已经看过很多关于 JavaScript 的 <code>this</code>  的谈论了，既然你点进来了，不妨继续看下去，看是否能帮你加深对 <code>this</code> 的理解。</p>\n<p>最近在看 <a href=\"https://github.com/getify/You-Dont-Know-JS\">《You Dont Know JS》</a> 这本书，不得感叹，就算用了 JS 很多年的老前端来看这本书，我觉得还是会有不少的收获。</p>\n<p>其中关于 <code>this</code> 的讲解，更是加深了我对 <code>this</code> 的理解，故整理知识点，再加上自身的理解，以自己的语言来描述。<br>对读者来说，算是二手知识，这本书是开源的，可以到本书的 Github 项目地址学习一手的知识。</p>\n<p>首先有一句大家都明白的话，我还是要强调一遍：<br><strong>「<code>this</code> 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。」</strong></p>\n<p>这句话很重要，这是理解 <code>this</code> 原理的基础。<br>而在讲解 <code>this</code> 之前，先要理解一下作用域的相关概念。</p>\n<h1 id=\"「词法作用域」与「动态作用域」\"><a href=\"#「词法作用域」与「动态作用域」\" class=\"headerlink\" title=\"「词法作用域」与「动态作用域」\"></a>「词法作用域」与「动态作用域」</h1><p>通常来说，作用域一共有两种主要的工作模型。</p>\n<ul>\n<li>词法作用域</li>\n<li>动态作用域</li>\n</ul>\n<p>词法作用域是大多数编程语言所采用的模式，而动态作用域仍有一些编程语言在用，例如 Bash 脚本。<br>而 JavaScript 就是采用的词法作用域，也就是在编程阶段，作用域就已经明确下来了。</p>\n<p>思考下面代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);   <span class=\"comment\">// 输出 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bar()</span><br></pre></td></tr></table></figure>\n<p>因为 JavaScript 所用的是词法作用域，自然 <code>foo()</code> 声明的阶段，就已经确定了变量 <code>a</code> 的作用域了。</p>\n<p>倘若，JavaScript 是采用的动态作用域，<code>foo()</code> 中打印的将是 <code>3</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);   <span class=\"comment\">// 输出 3 （不是 2）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bar()</span><br></pre></td></tr></table></figure>\n<p>而 JavaScript 的 <code>this</code> 机制跟动态作用域很相似，是在运行时在被调用的地方动态绑定的。</p>\n<h1 id=\"this-的四种绑定规则\"><a href=\"#this-的四种绑定规则\" class=\"headerlink\" title=\"this 的四种绑定规则\"></a>this 的四种绑定规则</h1><p>在 JavaScript 中，影响 this 指向的绑定规则有四种：</p>\n<ul>\n<li>默认绑定</li>\n<li>隐式绑定</li>\n<li>显式绑定</li>\n<li>new 绑定</li>\n</ul>\n<h2 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h2><p>这是最直接的一种方式，就是不加任何的修饰符直接调用函数，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)   <span class=\"comment\">// 输出 a</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;  <span class=\"comment\">//  变量声明到全局对象中</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p>使用 <code>var</code> 声明的变量 <code>a</code>，被绑定到全局对象中，如果是浏览器，则是在 <code>window</code> 对象。<br><code>foo()</code> 调用时，引用了默认绑定，<code>this</code> 指向了全局对象。</p>\n<h2 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h2><p>这种情况会发生在调用位置存在「上下文对象」的情况，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  foo,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj1.foo();   <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\">obj2.foo();   <span class=\"comment\">// 输出 2</span></span><br></pre></td></tr></table></figure>\n<p>当函数调用的时候，拥有上下文对象的时候，<code>this</code> 会被绑定到该上下文对象。<br>正如上面的代码，<br><code>obj1.foo()</code> 被调用时，<code>this</code> 绑定到了 <code>obj1</code>,<br>而 <code>obj2.foo()</code> 被调用时，<code>this</code> 绑定到了 <code>obj2</code>。</p>\n<h2 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h2><p>这种就是使用 <code>Function.prototype</code> 中的三个方法 <code>call()</code>, <code>apply()</code>, <code>bind()</code> 了。<br>这三个函数，都可以改变函数的 <code>this</code> 指向到指定的对象，<br>不同之处在于，<code>call()</code> 和 <code>apply()</code> 是立即执行函数，并且接受的参数的形式不同：</p>\n<ul>\n<li><code>call(this, arg1, arg2, ...)</code></li>\n<li><code>apply(this, [arg1, arg2, ...])</code></li>\n</ul>\n<p>而 <code>bind()</code> 则是创建一个新的包装函数，并且返回，而不是立刻执行。</p>\n<ul>\n<li><code>bind(this, arg1, arg2, ...)</code></li>\n</ul>\n<p><code>apply()</code> 接收参数的形式，有助于函数嵌套函数的时候，把 <code>arguments</code> 变量传递到下一层函数中。</p>\n<p>思考下面代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);  <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\">  bar.apply(&#123;<span class=\"attr\">a</span>: <span class=\"number\">2</span>&#125;, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a + b);  <span class=\"comment\">// 输出 5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">foo(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码中， <code>foo()</code> 内部的 <code>this</code> 遵循默认绑定规则，绑定到全局变量中。<br>而 <code>bar()</code> 在调用的时候，调用了 <code>apply()</code> 函数，把 <code>this</code> 绑定到了一个新的对象中 <code>{a: 2}</code>，而且原封不动的接收 <code>foo()</code> 接收的函数。</p>\n<h2 id=\"new-绑定\"><a href=\"#new-绑定\" class=\"headerlink\" title=\"new 绑定\"></a>new 绑定</h2><p>最后一种，则是使用 <code>new</code> 操作符会产生 <code>this</code> 的绑定。<br>在理解 <code>new</code> 操作符对 <code>this</code> 的影响，首先要理解 <code>new</code> 的原理。<br>在 JavaScript 中，<code>new</code> 操作符并不像其他面向对象的语言一样，而是一种模拟出来的机制。<br>在 JavaScript 中，所有的函数都可以被 <code>new</code> 调用，这时候这个函数一般会被称为「构造函数」，实际上并不存在所谓「构造函数」，更确切的理解应该是对于函数的「构造调用」。</p>\n<p>使用 <code>new</code> 来调用函数，会自动执行下面操作：</p>\n<ol>\n<li>创建一个全新的对象。</li>\n<li>这个新对象会被执行 [[Prototype]] 连接。</li>\n<li>这个新对象会绑定到函数调用的 this。</li>\n<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<p>所以如果 <code>new</code> 是一个函数的话，会是这样子的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">New</span>(<span class=\"params\">Constructor, ...args</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> obj = &#123;&#125;;   <span class=\"comment\">// 创建一个新对象</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.setPrototypeOf(obj, Constructor.prototype);  <span class=\"comment\">// 连接新对象与函数的原型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Constructor.apply(obj, args) || obj;   <span class=\"comment\">// 执行函数，改变 this 指向新的对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">New(Foo, <span class=\"number\">1</span>);  <span class=\"comment\">// Foo &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>所以，在使用 <code>new</code> 来调用函数时候，我们会构造一个新对象并把它绑定到函数调用中的 <code>this</code> 上。</p>\n<h1 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h1><p>如果一个位置发生了多条改变 this 的规则，那么优先级是如何的呢？</p>\n<p>看几段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 显式绑定 &gt; 隐式绑定</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj1.foo();     <span class=\"comment\">// 输出 2</span></span><br><span class=\"line\">obj1.foo.call(&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;);      <span class=\"comment\">// 输出 1</span></span><br></pre></td></tr></table></figure>\n<p>这说明「显式绑定」的优先级大于「隐式绑定」</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new 绑定 &gt; 显式绑定</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = foo.bind(obj1);</span><br><span class=\"line\">bar(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1); <span class=\"comment\">// 输出 &#123;a:2&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = <span class=\"keyword\">new</span> bar(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1); <span class=\"comment\">// 输出 &#123;a:2&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2); <span class=\"comment\">// 输出 foo &#123; a: 3 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>这说明「new 绑定」的优先级大于「显式绑定」<br>而「默认绑定」，毫无疑问是优先级最低的。<br>所以优先级顺序为：</p>\n<p><strong>「new 绑定」 &gt; 「显式绑定」 &gt; 「隐式绑定」 &gt; 「默认绑定。」</strong></p>\n<h1 id=\"所以，this-到底是什么\"><a href=\"#所以，this-到底是什么\" class=\"headerlink\" title=\"所以，this 到底是什么\"></a>所以，this 到底是什么</h1><p><code>this</code> 并不是在编写的时候绑定的，而是在运行时绑定的。它的上下文取决于函数调用时的各种条件。<br><code>this</code> 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。<br>当一个函数被调用时，会创建一个「执行上下文」，这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。<code>this</code> 就是这个记录的一个属性，会在函数执行的过程中用到。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes\">《You Dont Know JS》- this &amp; Object Prototypes</a></p>\n"},{"title":"理解TCP（六）：网络编程接口","date":"2017-03-02T08:01:25.000Z","_content":"\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\n# 一切皆 Socket\n我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢？    \nsocket 起源于 UNIX，而 UNIX/Linux 基本哲学之一就是「一切皆文件」，都可以用「open → write/read → close」模式来操作。    \nsocket 其实就是该模式的一个实现，socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作。    \n\n使用 TCP/IP 协议的应用程序通常采用系统提供的编程接口：**UNIX BSD 的套接字接口（Socket Interfaces）**\n以此来实现网络进程之间的通信。    \n就目前而言，几乎所有的应用程序都是采用 socket，所以说现在的网络时代，网络中进程通信是无处不在，**一切皆 socket**    \n\n# 套接字接口 Socket Interfaces\n套接字接口是一组函数，由操作系统提供，用以创建网络应用。    \n大多数现代操作系统都实现了套接字接口，包括所有 Unix 变种，Windows 和 Macintosh 系统。    \n\n> **套接字接口的起源**    \n套接字接口是加州大学伯克利分校的研究人员在 20 世纪 80 年代早起提出的。    \n伯克利的研究者使得套接字接口适用于任何底层的协议，第一个实现就是针对 TCP/IP 协议，他们把它包括在 Unix 4.2 BSD 的内核里，并且分发给许多学校和实验室。    \n这在因特网的历史成为了一个重大事件。    \n—— 《深入理解计算机系统》\n\n从 Linux 内核的角度来看，一个套接字就是通信的一个端点。    \n从 Linux 程序的角度来看，套接字是一个有相应描述符的文件。    \n普通文件的打开操作返回一个文件描述字，而 socket() 用于创建一个 socket 描述符，唯一标识一个 socket。    \n这个 socket 描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些操作。    \n\n常用的函数有：\n\n- socket()\n- bind()\n- listen()\n- connect()\n- accept()\n- write()\n- read()\n- close()\n\n# Socket 的交互流程\n![socket 交互过程.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/46872611EB6C0874FE9E4C290E8F3FE9.png)\n\n图中展示了 TCP 协议的 socket 交互流程，描述如下：\n\n1. 服务器根据地址类型、socket 类型、以及协议来创建 socket。\n2. 服务器为 socket 绑定 IP 地址和端口号。\n3. 服务器 socket 监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的 socket 并没有全部打开。\n4. 客户端创建 socket。\n5. 客户端打开 socket，根据服务器 IP 地址和端口号试图连接服务器 socket。\n6. 服务器 socket 接收到客户端 socket 请求，被动打开，开始接收客户端请求，知道客户端返回连接信息。这时候 socket 进入阻塞状态，阻塞是由于 accept() 方法会一直等到客户端返回连接信息后才返回，然后开始连接下一个客户端的连接请求。\n7. 客户端连接成功，向服务器发送连接状态信息。\n8. 服务器 accept() 方法返回，连接成功。\n9. 服务器和客户端通过网络 I/O 函数进行数据的传输。\n10. 客户端关闭 socket。\n11. 服务器关闭 socket。\n\n这个过程中，服务器和客户端建立连接的部分，就体现了 TCP 三次握手的原理。    \n\n下面详细讲一下 socket 的各函数。    \n\n## Socket 接口\nsocket 是系统提供的接口，而操作系统大多数都是用 C/C++ 开发的，自然函数库也是 C/C++ 代码。    \n\n## socket 函数\n该函数会返回一个套接字描述符（socket descriptor），但是该描述符仅是部分打开的，还不能用于读写。    \n如何完成打开套接字的工作，取决于我们是客户端还是服务器。    \n\n### 函数原型\n```C++\n#include <sys/socket.h>\n\nint socket(int domain, int type, int protocol);\n```\n\n### 参数说明\n**domain**:     \n协议域，决定了 socket 的地质类型，在通信中必须采用对应的地址。    \n常用的协议族有：`AF_INET`（ipv4地址与端口号的组合）、`AF_INET6`（ipv6地址与端口号的组合）、`AF_LOCAL`（绝对路径名作为地址）。    \n该值的常量定义在 `sys/socket.h` 文件中。    \n\n**type**:    \n指定 socket 类型。    \n常用的类型有：`SOCK_STREAM`、`SOCK_DGRAM`、`SOCK_RAW`、`SOCK_PACKET`、`SOCK_SEQPACKET`等。    \n其中 `SOCK_STREAM` 表示提供面向连接的稳定数据传输，即 TCP 协议。    \n该值的常量定义在 `sys/socket.h` 文件中。    \n\n**protocol**:    \n指定协议。    \n常用的协议有：`IPPROTO_TCP`（TCP协议）、`IPPTOTO_UDP`（UDP协议）、`IPPROTO_SCTP`（STCP协议）。    \n当值位 0 时，会自动选择 `type` 类型对应的默认协议。    \n\n## bind 函数\n由服务端调用，把一个地址族中的特定地址和 socket 联系起来。\n\n### 函数原型\n```c++\n#include <sys/socket.h>\n\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n```\n\n### 参数说明\n**sockfd**:    \n即 socket 描述字，由 socket() 函数创建。    \n\n***addr**：    \n一个 `const struct sockaddr` 指针，指向要绑定给 `sockfd` 的协议地址。    \n这个地址结构根据地址创建 socket 时的地址协议族不同而不同，例如 ipv4 对应 `sockaddr_in`，ipv6 对应 `sockaddr_in6`.    \n这几个结构体在使用的时候，都可以强制转换成 `sockaddr`。    \n下面是这几个结构体对应的所在的头文件：\n\n1. `sockaddr`： `sys/socket.h`\n2. `sockaddr_in`： `netinet/in.h`\n3. `sockaddr_in6`： `netinet6/in.h`\n\n> _in 后缀意义：互联网络(internet)的缩写，而不是输入(input)的缩写。\n\n## listen 函数\n服务器调用，将 socket 从一个主动套接字转化为一个监听套接字（listening socket）, 该套接字可以接收来自客户端的连接请求。    \n在默认情况下，操作系统内核会认为 socket 函数创建的描述符对应于主动套接字（active socket）。    \n\n### 函数原型\n```C++\n#include <sys/socket.h>\nint listen(int sockfd, int backlog);\n```\n\n### 参数说明\n**sockfd**:    \n即 socket 描述字，由 socket() 函数创建。    \n\n**backlog**:    \n指定在请求队列中的最大请求数，进入的连接请求将在队列中等待 accept() 它们。    \n\n## connect 函数\n由客户端调用，与目的服务器的套接字建立一个连接。    \n\n### 函数原型\n```C++\n#include <sys/socket.h>\nint connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen);\n```\n\n### 参数说明\n**clientfd**:    \n目的服务器的 socket 描述符    \n\n***addr**:    \n一个 `const struct sockaddr` 指针，包含了目的服务器 IP 和端口。    \n\n**addrlen**：    \n协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 `sizeof(sockaddr_in)`;    \n\n## accept 函数\n服务器调用，等待来自客户端的连接请求。    \n当客户端连接，accept 函数会在 `addr` 中会填充上客户端的套接字地址，并且返回一个已连接描述符（connected descriptor），这个描述符可以用来利用 Unix I/O 函数与客户端通信。    \n\n### 函数原型\n```C++\n#indclude <sys/socket.h>\nint accept(int listenfd, struct sockaddr *addr, int *addrlen);\n```\n\n### 参数说明\n**listenfd**:    \n服务器的 socket 描述字，由 socket() 函数创建。    \n\n***addr**:    \n一个 `const struct sockaddr` 指针，用来存放提出连接请求客户端的主机的信息\n\n***addrlen**:    \n协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 `sizeof(sockaddr_in)`。    \n\n## close 函数\n在数据传输完成之后，手动关闭连接。    \n\n### 函数原型\n```C++\n#include <sys/socket.h>\n#include <unistd.h>\nint close(int fd);\n```\n\n### 参数说明\n**fd**:    \n需要关闭的连接 socket 描述符    \n\n## 网络 I/O 函数\n当客户端和服务器建立连接后，可以使用网络 I/O 进行读写操作。    \n网络 I/O 操作有下面几组：\n\n1. read()/write()\n2. recv()/send()\n3. readv()/writev()\n4. recvmsg()/sendmsg()\n5. recvfrom()/sendto()\n\n最常用的是 read()/write()    \n他们的原型是：\n\n```C++\nssize_t read(int fd, void *buf, size_t count);\nssize_t write(int fd, const void *buf, size_t count);\n```\n\n鉴于该文是侧重于描述 socket 的工作原理，就不再详细描述这些函数了。\n\n# 实现一个简单 TCP 交互\n## 服务端\n\n```C++\n// socket_server.cpp\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n\n#define MAXLINE 4096 // 4 * 1024\n\nint main(int argc, char **argv)\n{\n    int listenfd, // 监听端口的 socket 描述符\n        connfd;   // 连接端 socket 描述符\n    struct sockaddr_in servaddr;\n    char buff[MAXLINE];\n    int n;\n\n    // 创建 socket，并且进行错误处理\n    if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n    {\n        printf(\"create socket error: %s(errno: %d)\\n\", strerror(errno), errno);\n        return 0;\n    }\n\n    // 初始化 sockaddr_in 数据结构\n    memset(&servaddr, 0, sizeof(servaddr));\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n    servaddr.sin_port = htons(6666);\n\n    // 绑定 socket 和 端口\n    if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) == -1)\n    {\n        printf(\"bind socket error: %s(errno: %d)\\n\", strerror(errno), errno);\n        return 0;\n    }\n\n    // 监听连接\n    if (listen(listenfd, 10) == -1)\n    {\n        printf(\"listen socket error: %s(errno: %d)\\n\", strerror(errno), errno);\n        return 0;\n    }\n\n    printf(\"====== Waiting for client's request======\\n\");\n\n    // 持续接收客户端的连接请求\n    while (true)\n    {\n        if ((connfd = accept(listenfd, (struct sockaddr *)NULL, NULL) == -1))\n        {\n            printf(\"accept socket error: %s(errno: %d)\\n\", strerror(errno), errno);\n            continue;\n        }\n\n        n = recv(connfd, buff, MAXLINE, 0);\n        buff[n] = '\\0';\n        printf(\"recv msg from client: %s\\n\", buff);\n        close(connfd);\n    }\n\n    close(listenfd);\n    return 0;\n}\n```\n\n## 客户端\n```C++\n// socket_client.cpp\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAXLINE 4096\n\nint main(int argc, char **argv)\n{\n    int sockfd, n;\n    char recvline[4096], sendline[4096];\n    struct sockaddr_in servaddr;\n\n    if (argc != 2)\n    {\n        printf(\"usage: ./client <ipaddress>\\n\");\n        return 0;\n    }\n\n    // 创建 socket 描述符\n    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n    {\n        printf(\"create socket error: %s(errno: %d)\\n\", strerror(errno), errno);\n        return 0;\n    }\n\n    // 初始化目标服务器数据结构\n    memset(&servaddr, 0, sizeof(servaddr));\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(6666);\n    // 从参数中读取 IP 地址\n    if (inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0)\n    {\n        printf(\"inet_pton error for %s\\n\", argv[1]);\n        return 0;\n    }\n\n    // 连接目标服务器，并和 sockfd 联系起来。\n    if (connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)\n    {\n        printf(\"connect error: %s(errno: %d)\\n\", strerror(errno), errno);\n        return 0;\n    }\n\n    printf(\"send msg to server: \\n\");\n\n    // 从标准输入流中读取信息\n    fgets(sendline, 4096, stdin);\n\n    // 通过 sockfd，向目标服务器发送信息\n    if (send(sockfd, sendline, strlen(sendline), 0) < 0)\n    {\n        printf(\"send msg error: %s(errno: %d)\\n\", strerror(errno), errno);\n        return 0;\n    }\n\n    // 数据传输完毕，关闭 socket 连接\n    close(sockfd);\n    return 0;\n}\n```\n\n# Run\n首先创建 `makefile` 文件\n\n```makefile\nall:server client\nserver:socket_server.o\n\tg++ -g -o socket_server socket_server.o\nclient:socket_client.o\n\tg++ -g -o socket_client socket_client.o\nsocket_server.o:socket_server.cpp\n\tg++ -g -c socket_server.cpp\nsocket_client.o:socket_client.cpp\n\tg++ -g -c socket_client.cpp\nclean:all\n\trm all\n```\n\n然后使用命令:\n\n```\n$ make\n```\n\n会生成两个可执行文件：\n\n1. `socket_server`\n2. `socket_client`\n\n分别打开两个终端，运行：\n\n1. `./socket_server`\n2. `./socket_client 127.0.0.1`\n\n然后在 `socket_client` 中键入发送内容，可以再 `socket_server` 接收到同样的信息。\n\n# 参考\n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)","source":"_posts/understand-tcp-6.md","raw":"---\ntitle: 理解TCP（六）：网络编程接口\ncategory: 搬砖码农\ndate: 2017-03-02 16:01:25\ntags: \n- tcp\n---\n\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\n# 一切皆 Socket\n我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢？    \nsocket 起源于 UNIX，而 UNIX/Linux 基本哲学之一就是「一切皆文件」，都可以用「open → write/read → close」模式来操作。    \nsocket 其实就是该模式的一个实现，socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作。    \n\n使用 TCP/IP 协议的应用程序通常采用系统提供的编程接口：**UNIX BSD 的套接字接口（Socket Interfaces）**\n以此来实现网络进程之间的通信。    \n就目前而言，几乎所有的应用程序都是采用 socket，所以说现在的网络时代，网络中进程通信是无处不在，**一切皆 socket**    \n\n# 套接字接口 Socket Interfaces\n套接字接口是一组函数，由操作系统提供，用以创建网络应用。    \n大多数现代操作系统都实现了套接字接口，包括所有 Unix 变种，Windows 和 Macintosh 系统。    \n\n> **套接字接口的起源**    \n套接字接口是加州大学伯克利分校的研究人员在 20 世纪 80 年代早起提出的。    \n伯克利的研究者使得套接字接口适用于任何底层的协议，第一个实现就是针对 TCP/IP 协议，他们把它包括在 Unix 4.2 BSD 的内核里，并且分发给许多学校和实验室。    \n这在因特网的历史成为了一个重大事件。    \n—— 《深入理解计算机系统》\n\n从 Linux 内核的角度来看，一个套接字就是通信的一个端点。    \n从 Linux 程序的角度来看，套接字是一个有相应描述符的文件。    \n普通文件的打开操作返回一个文件描述字，而 socket() 用于创建一个 socket 描述符，唯一标识一个 socket。    \n这个 socket 描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些操作。    \n\n常用的函数有：\n\n- socket()\n- bind()\n- listen()\n- connect()\n- accept()\n- write()\n- read()\n- close()\n\n# Socket 的交互流程\n![socket 交互过程.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/46872611EB6C0874FE9E4C290E8F3FE9.png)\n\n图中展示了 TCP 协议的 socket 交互流程，描述如下：\n\n1. 服务器根据地址类型、socket 类型、以及协议来创建 socket。\n2. 服务器为 socket 绑定 IP 地址和端口号。\n3. 服务器 socket 监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的 socket 并没有全部打开。\n4. 客户端创建 socket。\n5. 客户端打开 socket，根据服务器 IP 地址和端口号试图连接服务器 socket。\n6. 服务器 socket 接收到客户端 socket 请求，被动打开，开始接收客户端请求，知道客户端返回连接信息。这时候 socket 进入阻塞状态，阻塞是由于 accept() 方法会一直等到客户端返回连接信息后才返回，然后开始连接下一个客户端的连接请求。\n7. 客户端连接成功，向服务器发送连接状态信息。\n8. 服务器 accept() 方法返回，连接成功。\n9. 服务器和客户端通过网络 I/O 函数进行数据的传输。\n10. 客户端关闭 socket。\n11. 服务器关闭 socket。\n\n这个过程中，服务器和客户端建立连接的部分，就体现了 TCP 三次握手的原理。    \n\n下面详细讲一下 socket 的各函数。    \n\n## Socket 接口\nsocket 是系统提供的接口，而操作系统大多数都是用 C/C++ 开发的，自然函数库也是 C/C++ 代码。    \n\n## socket 函数\n该函数会返回一个套接字描述符（socket descriptor），但是该描述符仅是部分打开的，还不能用于读写。    \n如何完成打开套接字的工作，取决于我们是客户端还是服务器。    \n\n### 函数原型\n```C++\n#include <sys/socket.h>\n\nint socket(int domain, int type, int protocol);\n```\n\n### 参数说明\n**domain**:     \n协议域，决定了 socket 的地质类型，在通信中必须采用对应的地址。    \n常用的协议族有：`AF_INET`（ipv4地址与端口号的组合）、`AF_INET6`（ipv6地址与端口号的组合）、`AF_LOCAL`（绝对路径名作为地址）。    \n该值的常量定义在 `sys/socket.h` 文件中。    \n\n**type**:    \n指定 socket 类型。    \n常用的类型有：`SOCK_STREAM`、`SOCK_DGRAM`、`SOCK_RAW`、`SOCK_PACKET`、`SOCK_SEQPACKET`等。    \n其中 `SOCK_STREAM` 表示提供面向连接的稳定数据传输，即 TCP 协议。    \n该值的常量定义在 `sys/socket.h` 文件中。    \n\n**protocol**:    \n指定协议。    \n常用的协议有：`IPPROTO_TCP`（TCP协议）、`IPPTOTO_UDP`（UDP协议）、`IPPROTO_SCTP`（STCP协议）。    \n当值位 0 时，会自动选择 `type` 类型对应的默认协议。    \n\n## bind 函数\n由服务端调用，把一个地址族中的特定地址和 socket 联系起来。\n\n### 函数原型\n```c++\n#include <sys/socket.h>\n\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n```\n\n### 参数说明\n**sockfd**:    \n即 socket 描述字，由 socket() 函数创建。    \n\n***addr**：    \n一个 `const struct sockaddr` 指针，指向要绑定给 `sockfd` 的协议地址。    \n这个地址结构根据地址创建 socket 时的地址协议族不同而不同，例如 ipv4 对应 `sockaddr_in`，ipv6 对应 `sockaddr_in6`.    \n这几个结构体在使用的时候，都可以强制转换成 `sockaddr`。    \n下面是这几个结构体对应的所在的头文件：\n\n1. `sockaddr`： `sys/socket.h`\n2. `sockaddr_in`： `netinet/in.h`\n3. `sockaddr_in6`： `netinet6/in.h`\n\n> _in 后缀意义：互联网络(internet)的缩写，而不是输入(input)的缩写。\n\n## listen 函数\n服务器调用，将 socket 从一个主动套接字转化为一个监听套接字（listening socket）, 该套接字可以接收来自客户端的连接请求。    \n在默认情况下，操作系统内核会认为 socket 函数创建的描述符对应于主动套接字（active socket）。    \n\n### 函数原型\n```C++\n#include <sys/socket.h>\nint listen(int sockfd, int backlog);\n```\n\n### 参数说明\n**sockfd**:    \n即 socket 描述字，由 socket() 函数创建。    \n\n**backlog**:    \n指定在请求队列中的最大请求数，进入的连接请求将在队列中等待 accept() 它们。    \n\n## connect 函数\n由客户端调用，与目的服务器的套接字建立一个连接。    \n\n### 函数原型\n```C++\n#include <sys/socket.h>\nint connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen);\n```\n\n### 参数说明\n**clientfd**:    \n目的服务器的 socket 描述符    \n\n***addr**:    \n一个 `const struct sockaddr` 指针，包含了目的服务器 IP 和端口。    \n\n**addrlen**：    \n协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 `sizeof(sockaddr_in)`;    \n\n## accept 函数\n服务器调用，等待来自客户端的连接请求。    \n当客户端连接，accept 函数会在 `addr` 中会填充上客户端的套接字地址，并且返回一个已连接描述符（connected descriptor），这个描述符可以用来利用 Unix I/O 函数与客户端通信。    \n\n### 函数原型\n```C++\n#indclude <sys/socket.h>\nint accept(int listenfd, struct sockaddr *addr, int *addrlen);\n```\n\n### 参数说明\n**listenfd**:    \n服务器的 socket 描述字，由 socket() 函数创建。    \n\n***addr**:    \n一个 `const struct sockaddr` 指针，用来存放提出连接请求客户端的主机的信息\n\n***addrlen**:    \n协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 `sizeof(sockaddr_in)`。    \n\n## close 函数\n在数据传输完成之后，手动关闭连接。    \n\n### 函数原型\n```C++\n#include <sys/socket.h>\n#include <unistd.h>\nint close(int fd);\n```\n\n### 参数说明\n**fd**:    \n需要关闭的连接 socket 描述符    \n\n## 网络 I/O 函数\n当客户端和服务器建立连接后，可以使用网络 I/O 进行读写操作。    \n网络 I/O 操作有下面几组：\n\n1. read()/write()\n2. recv()/send()\n3. readv()/writev()\n4. recvmsg()/sendmsg()\n5. recvfrom()/sendto()\n\n最常用的是 read()/write()    \n他们的原型是：\n\n```C++\nssize_t read(int fd, void *buf, size_t count);\nssize_t write(int fd, const void *buf, size_t count);\n```\n\n鉴于该文是侧重于描述 socket 的工作原理，就不再详细描述这些函数了。\n\n# 实现一个简单 TCP 交互\n## 服务端\n\n```C++\n// socket_server.cpp\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n\n#define MAXLINE 4096 // 4 * 1024\n\nint main(int argc, char **argv)\n{\n    int listenfd, // 监听端口的 socket 描述符\n        connfd;   // 连接端 socket 描述符\n    struct sockaddr_in servaddr;\n    char buff[MAXLINE];\n    int n;\n\n    // 创建 socket，并且进行错误处理\n    if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n    {\n        printf(\"create socket error: %s(errno: %d)\\n\", strerror(errno), errno);\n        return 0;\n    }\n\n    // 初始化 sockaddr_in 数据结构\n    memset(&servaddr, 0, sizeof(servaddr));\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n    servaddr.sin_port = htons(6666);\n\n    // 绑定 socket 和 端口\n    if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) == -1)\n    {\n        printf(\"bind socket error: %s(errno: %d)\\n\", strerror(errno), errno);\n        return 0;\n    }\n\n    // 监听连接\n    if (listen(listenfd, 10) == -1)\n    {\n        printf(\"listen socket error: %s(errno: %d)\\n\", strerror(errno), errno);\n        return 0;\n    }\n\n    printf(\"====== Waiting for client's request======\\n\");\n\n    // 持续接收客户端的连接请求\n    while (true)\n    {\n        if ((connfd = accept(listenfd, (struct sockaddr *)NULL, NULL) == -1))\n        {\n            printf(\"accept socket error: %s(errno: %d)\\n\", strerror(errno), errno);\n            continue;\n        }\n\n        n = recv(connfd, buff, MAXLINE, 0);\n        buff[n] = '\\0';\n        printf(\"recv msg from client: %s\\n\", buff);\n        close(connfd);\n    }\n\n    close(listenfd);\n    return 0;\n}\n```\n\n## 客户端\n```C++\n// socket_client.cpp\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAXLINE 4096\n\nint main(int argc, char **argv)\n{\n    int sockfd, n;\n    char recvline[4096], sendline[4096];\n    struct sockaddr_in servaddr;\n\n    if (argc != 2)\n    {\n        printf(\"usage: ./client <ipaddress>\\n\");\n        return 0;\n    }\n\n    // 创建 socket 描述符\n    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n    {\n        printf(\"create socket error: %s(errno: %d)\\n\", strerror(errno), errno);\n        return 0;\n    }\n\n    // 初始化目标服务器数据结构\n    memset(&servaddr, 0, sizeof(servaddr));\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(6666);\n    // 从参数中读取 IP 地址\n    if (inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0)\n    {\n        printf(\"inet_pton error for %s\\n\", argv[1]);\n        return 0;\n    }\n\n    // 连接目标服务器，并和 sockfd 联系起来。\n    if (connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)\n    {\n        printf(\"connect error: %s(errno: %d)\\n\", strerror(errno), errno);\n        return 0;\n    }\n\n    printf(\"send msg to server: \\n\");\n\n    // 从标准输入流中读取信息\n    fgets(sendline, 4096, stdin);\n\n    // 通过 sockfd，向目标服务器发送信息\n    if (send(sockfd, sendline, strlen(sendline), 0) < 0)\n    {\n        printf(\"send msg error: %s(errno: %d)\\n\", strerror(errno), errno);\n        return 0;\n    }\n\n    // 数据传输完毕，关闭 socket 连接\n    close(sockfd);\n    return 0;\n}\n```\n\n# Run\n首先创建 `makefile` 文件\n\n```makefile\nall:server client\nserver:socket_server.o\n\tg++ -g -o socket_server socket_server.o\nclient:socket_client.o\n\tg++ -g -o socket_client socket_client.o\nsocket_server.o:socket_server.cpp\n\tg++ -g -c socket_server.cpp\nsocket_client.o:socket_client.cpp\n\tg++ -g -c socket_client.cpp\nclean:all\n\trm all\n```\n\n然后使用命令:\n\n```\n$ make\n```\n\n会生成两个可执行文件：\n\n1. `socket_server`\n2. `socket_client`\n\n分别打开两个终端，运行：\n\n1. `./socket_server`\n2. `./socket_client 127.0.0.1`\n\n然后在 `socket_client` 中键入发送内容，可以再 `socket_server` 接收到同样的信息。\n\n# 参考\n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)","slug":"understand-tcp-6","published":1,"updated":"2020-12-13T13:47:15.665Z","_id":"cl270y8sf003xxwrl0puab48e","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\" target=\"_blank\" rel=\"external\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<h1 id=\"一切皆-Socket\"><a href=\"#一切皆-Socket\" class=\"headerlink\" title=\"一切皆 Socket\"></a>一切皆 Socket</h1><p>我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢？<br>socket 起源于 UNIX，而 UNIX/Linux 基本哲学之一就是「一切皆文件」，都可以用「open → write/read → close」模式来操作。<br>socket 其实就是该模式的一个实现，socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作。    </p>\n<p>使用 TCP/IP 协议的应用程序通常采用系统提供的编程接口：<strong>UNIX BSD 的套接字接口（Socket Interfaces）</strong><br>以此来实现网络进程之间的通信。<br>就目前而言，几乎所有的应用程序都是采用 socket，所以说现在的网络时代，网络中进程通信是无处不在，<strong>一切皆 socket</strong>    </p>\n<h1 id=\"套接字接口-Socket-Interfaces\"><a href=\"#套接字接口-Socket-Interfaces\" class=\"headerlink\" title=\"套接字接口 Socket Interfaces\"></a>套接字接口 Socket Interfaces</h1><p>套接字接口是一组函数，由操作系统提供，用以创建网络应用。<br>大多数现代操作系统都实现了套接字接口，包括所有 Unix 变种，Windows 和 Macintosh 系统。    </p>\n<blockquote>\n<p><strong>套接字接口的起源</strong><br>套接字接口是加州大学伯克利分校的研究人员在 20 世纪 80 年代早起提出的。<br>伯克利的研究者使得套接字接口适用于任何底层的协议，第一个实现就是针对 TCP/IP 协议，他们把它包括在 Unix 4.2 BSD 的内核里，并且分发给许多学校和实验室。<br>这在因特网的历史成为了一个重大事件。<br>—— 《深入理解计算机系统》</p>\n</blockquote>\n<p>从 Linux 内核的角度来看，一个套接字就是通信的一个端点。<br>从 Linux 程序的角度来看，套接字是一个有相应描述符的文件。<br>普通文件的打开操作返回一个文件描述字，而 socket() 用于创建一个 socket 描述符，唯一标识一个 socket。<br>这个 socket 描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些操作。    </p>\n<p>常用的函数有：</p>\n<ul>\n<li>socket()</li>\n<li>bind()</li>\n<li>listen()</li>\n<li>connect()</li>\n<li>accept()</li>\n<li>write()</li>\n<li>read()</li>\n<li>close()</li>\n</ul>\n<h1 id=\"Socket-的交互流程\"><a href=\"#Socket-的交互流程\" class=\"headerlink\" title=\"Socket 的交互流程\"></a>Socket 的交互流程</h1><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/46872611EB6C0874FE9E4C290E8F3FE9.png\" alt=\"socket 交互过程.png\"></p>\n<p>图中展示了 TCP 协议的 socket 交互流程，描述如下：</p>\n<ol>\n<li>服务器根据地址类型、socket 类型、以及协议来创建 socket。</li>\n<li>服务器为 socket 绑定 IP 地址和端口号。</li>\n<li>服务器 socket 监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的 socket 并没有全部打开。</li>\n<li>客户端创建 socket。</li>\n<li>客户端打开 socket，根据服务器 IP 地址和端口号试图连接服务器 socket。</li>\n<li>服务器 socket 接收到客户端 socket 请求，被动打开，开始接收客户端请求，知道客户端返回连接信息。这时候 socket 进入阻塞状态，阻塞是由于 accept() 方法会一直等到客户端返回连接信息后才返回，然后开始连接下一个客户端的连接请求。</li>\n<li>客户端连接成功，向服务器发送连接状态信息。</li>\n<li>服务器 accept() 方法返回，连接成功。</li>\n<li>服务器和客户端通过网络 I/O 函数进行数据的传输。</li>\n<li>客户端关闭 socket。</li>\n<li>服务器关闭 socket。</li>\n</ol>\n<p>这个过程中，服务器和客户端建立连接的部分，就体现了 TCP 三次握手的原理。    </p>\n<p>下面详细讲一下 socket 的各函数。    </p>\n<h2 id=\"Socket-接口\"><a href=\"#Socket-接口\" class=\"headerlink\" title=\"Socket 接口\"></a>Socket 接口</h2><p>socket 是系统提供的接口，而操作系统大多数都是用 C/C++ 开发的，自然函数库也是 C/C++ 代码。    </p>\n<h2 id=\"socket-函数\"><a href=\"#socket-函数\" class=\"headerlink\" title=\"socket 函数\"></a>socket 函数</h2><p>该函数会返回一个套接字描述符（socket descriptor），但是该描述符仅是部分打开的，还不能用于读写。<br>如何完成打开套接字的工作，取决于我们是客户端还是服务器。    </p>\n<h3 id=\"函数原型\"><a href=\"#函数原型\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><p><strong>domain</strong>:<br>协议域，决定了 socket 的地质类型，在通信中必须采用对应的地址。<br>常用的协议族有：<code>AF_INET</code>（ipv4地址与端口号的组合）、<code>AF_INET6</code>（ipv6地址与端口号的组合）、<code>AF_LOCAL</code>（绝对路径名作为地址）。<br>该值的常量定义在 <code>sys/socket.h</code> 文件中。    </p>\n<p><strong>type</strong>:<br>指定 socket 类型。<br>常用的类型有：<code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、<code>SOCK_RAW</code>、<code>SOCK_PACKET</code>、<code>SOCK_SEQPACKET</code>等。<br>其中 <code>SOCK_STREAM</code> 表示提供面向连接的稳定数据传输，即 TCP 协议。<br>该值的常量定义在 <code>sys/socket.h</code> 文件中。    </p>\n<p><strong>protocol</strong>:<br>指定协议。<br>常用的协议有：<code>IPPROTO_TCP</code>（TCP协议）、<code>IPPTOTO_UDP</code>（UDP协议）、<code>IPPROTO_SCTP</code>（STCP协议）。<br>当值位 0 时，会自动选择 <code>type</code> 类型对应的默认协议。    </p>\n<h2 id=\"bind-函数\"><a href=\"#bind-函数\" class=\"headerlink\" title=\"bind 函数\"></a>bind 函数</h2><p>由服务端调用，把一个地址族中的特定地址和 socket 联系起来。</p>\n<h3 id=\"函数原型-1\"><a href=\"#函数原型-1\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> struct sockaddr *addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数说明-1\"><a href=\"#参数说明-1\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><p><strong>sockfd</strong>:<br>即 socket 描述字，由 socket() 函数创建。    </p>\n<p><strong>*addr</strong>：<br>一个 <code>const struct sockaddr</code> 指针，指向要绑定给 <code>sockfd</code> 的协议地址。<br>这个地址结构根据地址创建 socket 时的地址协议族不同而不同，例如 ipv4 对应 <code>sockaddr_in</code>，ipv6 对应 <code>sockaddr_in6</code>.<br>这几个结构体在使用的时候，都可以强制转换成 <code>sockaddr</code>。<br>下面是这几个结构体对应的所在的头文件：</p>\n<ol>\n<li><code>sockaddr</code>： <code>sys/socket.h</code></li>\n<li><code>sockaddr_in</code>： <code>netinet/in.h</code></li>\n<li><code>sockaddr_in6</code>： <code>netinet6/in.h</code></li>\n</ol>\n<blockquote>\n<p>_in 后缀意义：互联网络(internet)的缩写，而不是输入(input)的缩写。</p>\n</blockquote>\n<h2 id=\"listen-函数\"><a href=\"#listen-函数\" class=\"headerlink\" title=\"listen 函数\"></a>listen 函数</h2><p>服务器调用，将 socket 从一个主动套接字转化为一个监听套接字（listening socket）, 该套接字可以接收来自客户端的连接请求。<br>在默认情况下，操作系统内核会认为 socket 函数创建的描述符对应于主动套接字（active socket）。    </p>\n<h3 id=\"函数原型-2\"><a href=\"#函数原型-2\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数说明-2\"><a href=\"#参数说明-2\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><p><strong>sockfd</strong>:<br>即 socket 描述字，由 socket() 函数创建。    </p>\n<p><strong>backlog</strong>:<br>指定在请求队列中的最大请求数，进入的连接请求将在队列中等待 accept() 它们。    </p>\n<h2 id=\"connect-函数\"><a href=\"#connect-函数\" class=\"headerlink\" title=\"connect 函数\"></a>connect 函数</h2><p>由客户端调用，与目的服务器的套接字建立一个连接。    </p>\n<h3 id=\"函数原型-3\"><a href=\"#函数原型-3\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> clientfd, <span class=\"keyword\">const</span> struct sockaddr *addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数说明-3\"><a href=\"#参数说明-3\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><p><strong>clientfd</strong>:<br>目的服务器的 socket 描述符    </p>\n<p><strong>*addr</strong>:<br>一个 <code>const struct sockaddr</code> 指针，包含了目的服务器 IP 和端口。    </p>\n<p><strong>addrlen</strong>：<br>协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 <code>sizeof(sockaddr_in)</code>;    </p>\n<h2 id=\"accept-函数\"><a href=\"#accept-函数\" class=\"headerlink\" title=\"accept 函数\"></a>accept 函数</h2><p>服务器调用，等待来自客户端的连接请求。<br>当客户端连接，accept 函数会在 <code>addr</code> 中会填充上客户端的套接字地址，并且返回一个已连接描述符（connected descriptor），这个描述符可以用来利用 Unix I/O 函数与客户端通信。    </p>\n<h3 id=\"函数原型-4\"><a href=\"#函数原型-4\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#indclude <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">accept</span><span class=\"params\">(<span class=\"keyword\">int</span> listenfd, struct sockaddr *addr, <span class=\"keyword\">int</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数说明-4\"><a href=\"#参数说明-4\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><p><strong>listenfd</strong>:<br>服务器的 socket 描述字，由 socket() 函数创建。    </p>\n<p><strong>*addr</strong>:<br>一个 <code>const struct sockaddr</code> 指针，用来存放提出连接请求客户端的主机的信息</p>\n<p><strong>*addrlen</strong>:<br>协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 <code>sizeof(sockaddr_in)</code>。    </p>\n<h2 id=\"close-函数\"><a href=\"#close-函数\" class=\"headerlink\" title=\"close 函数\"></a>close 函数</h2><p>在数据传输完成之后，手动关闭连接。    </p>\n<h3 id=\"函数原型-5\"><a href=\"#函数原型-5\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">close</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数说明-5\"><a href=\"#参数说明-5\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><p><strong>fd</strong>:<br>需要关闭的连接 socket 描述符    </p>\n<h2 id=\"网络-I-O-函数\"><a href=\"#网络-I-O-函数\" class=\"headerlink\" title=\"网络 I/O 函数\"></a>网络 I/O 函数</h2><p>当客户端和服务器建立连接后，可以使用网络 I/O 进行读写操作。<br>网络 I/O 操作有下面几组：</p>\n<ol>\n<li>read()/write()</li>\n<li>recv()/send()</li>\n<li>readv()/writev()</li>\n<li>recvmsg()/sendmsg()</li>\n<li>recvfrom()/sendto()</li>\n</ol>\n<p>最常用的是 read()/write()<br>他们的原型是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ssize_t</span> read(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> write(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> count);</span><br></pre></td></tr></table></figure>\n<p>鉴于该文是侧重于描述 socket 的工作原理，就不再详细描述这些函数了。</p>\n<h1 id=\"实现一个简单-TCP-交互\"><a href=\"#实现一个简单-TCP-交互\" class=\"headerlink\" title=\"实现一个简单 TCP 交互\"></a>实现一个简单 TCP 交互</h1><h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// socket_server.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLINE 4096 <span class=\"comment\">// 4 * 1024</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> listenfd, <span class=\"comment\">// 监听端口的 socket 描述符</span></span><br><span class=\"line\">        connfd;   <span class=\"comment\">// 连接端 socket 描述符</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">servaddr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buff[MAXLINE];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建 socket，并且进行错误处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((listenfd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>)) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"create socket error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 sockaddr_in 数据结构</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;servaddr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(servaddr));</span><br><span class=\"line\">    servaddr.sin_family = AF_INET;</span><br><span class=\"line\">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">    servaddr.sin_port = htons(<span class=\"number\">6666</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 绑定 socket 和 端口</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class=\"keyword\">sizeof</span>(servaddr)) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"bind socket error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 监听连接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listen(listenfd, <span class=\"number\">10</span>) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"listen socket error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"====== Waiting for client's request======\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 持续接收客户端的连接请求</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((connfd = accept(listenfd, (struct sockaddr *)<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>) == <span class=\"number\">-1</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"accept socket error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        n = recv(connfd, buff, MAXLINE, <span class=\"number\">0</span>);</span><br><span class=\"line\">        buff[n] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"recv msg from client: %s\\n\"</span>, buff);</span><br><span class=\"line\">        close(connfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    close(listenfd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// socket_client.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLINE 4096</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd, n;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> recvline[<span class=\"number\">4096</span>], sendline[<span class=\"number\">4096</span>];</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">servaddr</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"usage: ./client &lt;ipaddress&gt;\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建 socket 描述符</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"create socket error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化目标服务器数据结构</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;servaddr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(servaddr));</span><br><span class=\"line\">    servaddr.sin_family = AF_INET;</span><br><span class=\"line\">    servaddr.sin_port = htons(<span class=\"number\">6666</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 从参数中读取 IP 地址</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inet_pton(AF_INET, argv[<span class=\"number\">1</span>], &amp;servaddr.sin_addr) &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"inet_pton error for %s\\n\"</span>, argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 连接目标服务器，并和 sockfd 联系起来。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class=\"keyword\">sizeof</span>(servaddr)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"connect error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"send msg to server: \\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从标准输入流中读取信息</span></span><br><span class=\"line\">    fgets(sendline, <span class=\"number\">4096</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过 sockfd，向目标服务器发送信息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (send(sockfd, sendline, <span class=\"built_in\">strlen</span>(sendline), <span class=\"number\">0</span>) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"send msg error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据传输完毕，关闭 socket 连接</span></span><br><span class=\"line\">    close(sockfd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h1><p>首先创建 <code>makefile</code> 文件</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">all:server client</span></span><br><span class=\"line\"><span class=\"section\">server:socket_server.o</span></span><br><span class=\"line\">\tg++ -g -o socket_server socket_server.o</span><br><span class=\"line\"><span class=\"section\">client:socket_client.o</span></span><br><span class=\"line\">\tg++ -g -o socket_client socket_client.o</span><br><span class=\"line\"><span class=\"section\">socket_server.o:socket_server.cpp</span></span><br><span class=\"line\">\tg++ -g -c socket_server.cpp</span><br><span class=\"line\"><span class=\"section\">socket_client.o:socket_client.cpp</span></span><br><span class=\"line\">\tg++ -g -c socket_client.cpp</span><br><span class=\"line\"><span class=\"section\">clean:all</span></span><br><span class=\"line\">\trm all</span><br></pre></td></tr></table></figure>\n<p>然后使用命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make</span><br></pre></td></tr></table></figure>\n<p>会生成两个可执行文件：</p>\n<ol>\n<li><code>socket_server</code></li>\n<li><code>socket_client</code></li>\n</ol>\n<p>分别打开两个终端，运行：</p>\n<ol>\n<li><code>./socket_server</code></li>\n<li><code>./socket_client 127.0.0.1</code></li>\n</ol>\n<p>然后在 <code>socket_client</code> 中键入发送内容，可以再 <code>socket_server</code> 接收到同样的信息。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://book.douban.com/subject/26850616/\" target=\"_blank\" rel=\"external\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\" target=\"_blank\" rel=\"external\">《计算机网络》</a></p>\n","excerpt":"","more":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<h1 id=\"一切皆-Socket\"><a href=\"#一切皆-Socket\" class=\"headerlink\" title=\"一切皆 Socket\"></a>一切皆 Socket</h1><p>我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢？<br>socket 起源于 UNIX，而 UNIX/Linux 基本哲学之一就是「一切皆文件」，都可以用「open → write/read → close」模式来操作。<br>socket 其实就是该模式的一个实现，socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作。    </p>\n<p>使用 TCP/IP 协议的应用程序通常采用系统提供的编程接口：<strong>UNIX BSD 的套接字接口（Socket Interfaces）</strong><br>以此来实现网络进程之间的通信。<br>就目前而言，几乎所有的应用程序都是采用 socket，所以说现在的网络时代，网络中进程通信是无处不在，<strong>一切皆 socket</strong>    </p>\n<h1 id=\"套接字接口-Socket-Interfaces\"><a href=\"#套接字接口-Socket-Interfaces\" class=\"headerlink\" title=\"套接字接口 Socket Interfaces\"></a>套接字接口 Socket Interfaces</h1><p>套接字接口是一组函数，由操作系统提供，用以创建网络应用。<br>大多数现代操作系统都实现了套接字接口，包括所有 Unix 变种，Windows 和 Macintosh 系统。    </p>\n<blockquote>\n<p><strong>套接字接口的起源</strong><br>套接字接口是加州大学伯克利分校的研究人员在 20 世纪 80 年代早起提出的。<br>伯克利的研究者使得套接字接口适用于任何底层的协议，第一个实现就是针对 TCP/IP 协议，他们把它包括在 Unix 4.2 BSD 的内核里，并且分发给许多学校和实验室。<br>这在因特网的历史成为了一个重大事件。<br>—— 《深入理解计算机系统》</p>\n</blockquote>\n<p>从 Linux 内核的角度来看，一个套接字就是通信的一个端点。<br>从 Linux 程序的角度来看，套接字是一个有相应描述符的文件。<br>普通文件的打开操作返回一个文件描述字，而 socket() 用于创建一个 socket 描述符，唯一标识一个 socket。<br>这个 socket 描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些操作。    </p>\n<p>常用的函数有：</p>\n<ul>\n<li>socket()</li>\n<li>bind()</li>\n<li>listen()</li>\n<li>connect()</li>\n<li>accept()</li>\n<li>write()</li>\n<li>read()</li>\n<li>close()</li>\n</ul>\n<h1 id=\"Socket-的交互流程\"><a href=\"#Socket-的交互流程\" class=\"headerlink\" title=\"Socket 的交互流程\"></a>Socket 的交互流程</h1><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/46872611EB6C0874FE9E4C290E8F3FE9.png\" alt=\"socket 交互过程.png\"></p>\n<p>图中展示了 TCP 协议的 socket 交互流程，描述如下：</p>\n<ol>\n<li>服务器根据地址类型、socket 类型、以及协议来创建 socket。</li>\n<li>服务器为 socket 绑定 IP 地址和端口号。</li>\n<li>服务器 socket 监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的 socket 并没有全部打开。</li>\n<li>客户端创建 socket。</li>\n<li>客户端打开 socket，根据服务器 IP 地址和端口号试图连接服务器 socket。</li>\n<li>服务器 socket 接收到客户端 socket 请求，被动打开，开始接收客户端请求，知道客户端返回连接信息。这时候 socket 进入阻塞状态，阻塞是由于 accept() 方法会一直等到客户端返回连接信息后才返回，然后开始连接下一个客户端的连接请求。</li>\n<li>客户端连接成功，向服务器发送连接状态信息。</li>\n<li>服务器 accept() 方法返回，连接成功。</li>\n<li>服务器和客户端通过网络 I/O 函数进行数据的传输。</li>\n<li>客户端关闭 socket。</li>\n<li>服务器关闭 socket。</li>\n</ol>\n<p>这个过程中，服务器和客户端建立连接的部分，就体现了 TCP 三次握手的原理。    </p>\n<p>下面详细讲一下 socket 的各函数。    </p>\n<h2 id=\"Socket-接口\"><a href=\"#Socket-接口\" class=\"headerlink\" title=\"Socket 接口\"></a>Socket 接口</h2><p>socket 是系统提供的接口，而操作系统大多数都是用 C/C++ 开发的，自然函数库也是 C/C++ 代码。    </p>\n<h2 id=\"socket-函数\"><a href=\"#socket-函数\" class=\"headerlink\" title=\"socket 函数\"></a>socket 函数</h2><p>该函数会返回一个套接字描述符（socket descriptor），但是该描述符仅是部分打开的，还不能用于读写。<br>如何完成打开套接字的工作，取决于我们是客户端还是服务器。    </p>\n<h3 id=\"函数原型\"><a href=\"#函数原型\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><p><strong>domain</strong>:<br>协议域，决定了 socket 的地质类型，在通信中必须采用对应的地址。<br>常用的协议族有：<code>AF_INET</code>（ipv4地址与端口号的组合）、<code>AF_INET6</code>（ipv6地址与端口号的组合）、<code>AF_LOCAL</code>（绝对路径名作为地址）。<br>该值的常量定义在 <code>sys/socket.h</code> 文件中。    </p>\n<p><strong>type</strong>:<br>指定 socket 类型。<br>常用的类型有：<code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、<code>SOCK_RAW</code>、<code>SOCK_PACKET</code>、<code>SOCK_SEQPACKET</code>等。<br>其中 <code>SOCK_STREAM</code> 表示提供面向连接的稳定数据传输，即 TCP 协议。<br>该值的常量定义在 <code>sys/socket.h</code> 文件中。    </p>\n<p><strong>protocol</strong>:<br>指定协议。<br>常用的协议有：<code>IPPROTO_TCP</code>（TCP协议）、<code>IPPTOTO_UDP</code>（UDP协议）、<code>IPPROTO_SCTP</code>（STCP协议）。<br>当值位 0 时，会自动选择 <code>type</code> 类型对应的默认协议。    </p>\n<h2 id=\"bind-函数\"><a href=\"#bind-函数\" class=\"headerlink\" title=\"bind 函数\"></a>bind 函数</h2><p>由服务端调用，把一个地址族中的特定地址和 socket 联系起来。</p>\n<h3 id=\"函数原型-1\"><a href=\"#函数原型-1\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> struct sockaddr *addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数说明-1\"><a href=\"#参数说明-1\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><p><strong>sockfd</strong>:<br>即 socket 描述字，由 socket() 函数创建。    </p>\n<p><strong>*addr</strong>：<br>一个 <code>const struct sockaddr</code> 指针，指向要绑定给 <code>sockfd</code> 的协议地址。<br>这个地址结构根据地址创建 socket 时的地址协议族不同而不同，例如 ipv4 对应 <code>sockaddr_in</code>，ipv6 对应 <code>sockaddr_in6</code>.<br>这几个结构体在使用的时候，都可以强制转换成 <code>sockaddr</code>。<br>下面是这几个结构体对应的所在的头文件：</p>\n<ol>\n<li><code>sockaddr</code>： <code>sys/socket.h</code></li>\n<li><code>sockaddr_in</code>： <code>netinet/in.h</code></li>\n<li><code>sockaddr_in6</code>： <code>netinet6/in.h</code></li>\n</ol>\n<blockquote>\n<p>_in 后缀意义：互联网络(internet)的缩写，而不是输入(input)的缩写。</p>\n</blockquote>\n<h2 id=\"listen-函数\"><a href=\"#listen-函数\" class=\"headerlink\" title=\"listen 函数\"></a>listen 函数</h2><p>服务器调用，将 socket 从一个主动套接字转化为一个监听套接字（listening socket）, 该套接字可以接收来自客户端的连接请求。<br>在默认情况下，操作系统内核会认为 socket 函数创建的描述符对应于主动套接字（active socket）。    </p>\n<h3 id=\"函数原型-2\"><a href=\"#函数原型-2\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数说明-2\"><a href=\"#参数说明-2\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><p><strong>sockfd</strong>:<br>即 socket 描述字，由 socket() 函数创建。    </p>\n<p><strong>backlog</strong>:<br>指定在请求队列中的最大请求数，进入的连接请求将在队列中等待 accept() 它们。    </p>\n<h2 id=\"connect-函数\"><a href=\"#connect-函数\" class=\"headerlink\" title=\"connect 函数\"></a>connect 函数</h2><p>由客户端调用，与目的服务器的套接字建立一个连接。    </p>\n<h3 id=\"函数原型-3\"><a href=\"#函数原型-3\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> clientfd, <span class=\"keyword\">const</span> struct sockaddr *addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数说明-3\"><a href=\"#参数说明-3\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><p><strong>clientfd</strong>:<br>目的服务器的 socket 描述符    </p>\n<p><strong>*addr</strong>:<br>一个 <code>const struct sockaddr</code> 指针，包含了目的服务器 IP 和端口。    </p>\n<p><strong>addrlen</strong>：<br>协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 <code>sizeof(sockaddr_in)</code>;    </p>\n<h2 id=\"accept-函数\"><a href=\"#accept-函数\" class=\"headerlink\" title=\"accept 函数\"></a>accept 函数</h2><p>服务器调用，等待来自客户端的连接请求。<br>当客户端连接，accept 函数会在 <code>addr</code> 中会填充上客户端的套接字地址，并且返回一个已连接描述符（connected descriptor），这个描述符可以用来利用 Unix I/O 函数与客户端通信。    </p>\n<h3 id=\"函数原型-4\"><a href=\"#函数原型-4\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#indclude <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">accept</span><span class=\"params\">(<span class=\"keyword\">int</span> listenfd, struct sockaddr *addr, <span class=\"keyword\">int</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数说明-4\"><a href=\"#参数说明-4\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><p><strong>listenfd</strong>:<br>服务器的 socket 描述字，由 socket() 函数创建。    </p>\n<p><strong>*addr</strong>:<br>一个 <code>const struct sockaddr</code> 指针，用来存放提出连接请求客户端的主机的信息</p>\n<p><strong>*addrlen</strong>:<br>协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 <code>sizeof(sockaddr_in)</code>。    </p>\n<h2 id=\"close-函数\"><a href=\"#close-函数\" class=\"headerlink\" title=\"close 函数\"></a>close 函数</h2><p>在数据传输完成之后，手动关闭连接。    </p>\n<h3 id=\"函数原型-5\"><a href=\"#函数原型-5\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">close</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数说明-5\"><a href=\"#参数说明-5\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><p><strong>fd</strong>:<br>需要关闭的连接 socket 描述符    </p>\n<h2 id=\"网络-I-O-函数\"><a href=\"#网络-I-O-函数\" class=\"headerlink\" title=\"网络 I/O 函数\"></a>网络 I/O 函数</h2><p>当客户端和服务器建立连接后，可以使用网络 I/O 进行读写操作。<br>网络 I/O 操作有下面几组：</p>\n<ol>\n<li>read()/write()</li>\n<li>recv()/send()</li>\n<li>readv()/writev()</li>\n<li>recvmsg()/sendmsg()</li>\n<li>recvfrom()/sendto()</li>\n</ol>\n<p>最常用的是 read()/write()<br>他们的原型是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ssize_t</span> read(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> count);</span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> write(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> count);</span><br></pre></td></tr></table></figure>\n<p>鉴于该文是侧重于描述 socket 的工作原理，就不再详细描述这些函数了。</p>\n<h1 id=\"实现一个简单-TCP-交互\"><a href=\"#实现一个简单-TCP-交互\" class=\"headerlink\" title=\"实现一个简单 TCP 交互\"></a>实现一个简单 TCP 交互</h1><h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// socket_server.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLINE 4096 <span class=\"comment\">// 4 * 1024</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> listenfd, <span class=\"comment\">// 监听端口的 socket 描述符</span></span><br><span class=\"line\">        connfd;   <span class=\"comment\">// 连接端 socket 描述符</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">servaddr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buff[MAXLINE];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建 socket，并且进行错误处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((listenfd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>)) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"create socket error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 sockaddr_in 数据结构</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;servaddr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(servaddr));</span><br><span class=\"line\">    servaddr.sin_family = AF_INET;</span><br><span class=\"line\">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">    servaddr.sin_port = htons(<span class=\"number\">6666</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 绑定 socket 和 端口</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class=\"keyword\">sizeof</span>(servaddr)) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"bind socket error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 监听连接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listen(listenfd, <span class=\"number\">10</span>) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"listen socket error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"====== Waiting for client's request======\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 持续接收客户端的连接请求</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((connfd = accept(listenfd, (struct sockaddr *)<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>) == <span class=\"number\">-1</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"accept socket error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        n = recv(connfd, buff, MAXLINE, <span class=\"number\">0</span>);</span><br><span class=\"line\">        buff[n] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"recv msg from client: %s\\n\"</span>, buff);</span><br><span class=\"line\">        close(connfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    close(listenfd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// socket_client.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLINE 4096</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd, n;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> recvline[<span class=\"number\">4096</span>], sendline[<span class=\"number\">4096</span>];</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">servaddr</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"usage: ./client &lt;ipaddress&gt;\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建 socket 描述符</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"create socket error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化目标服务器数据结构</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;servaddr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(servaddr));</span><br><span class=\"line\">    servaddr.sin_family = AF_INET;</span><br><span class=\"line\">    servaddr.sin_port = htons(<span class=\"number\">6666</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 从参数中读取 IP 地址</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inet_pton(AF_INET, argv[<span class=\"number\">1</span>], &amp;servaddr.sin_addr) &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"inet_pton error for %s\\n\"</span>, argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 连接目标服务器，并和 sockfd 联系起来。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class=\"keyword\">sizeof</span>(servaddr)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"connect error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"send msg to server: \\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从标准输入流中读取信息</span></span><br><span class=\"line\">    fgets(sendline, <span class=\"number\">4096</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过 sockfd，向目标服务器发送信息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (send(sockfd, sendline, <span class=\"built_in\">strlen</span>(sendline), <span class=\"number\">0</span>) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"send msg error: %s(errno: %d)\\n\"</span>, strerror(errno), errno);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据传输完毕，关闭 socket 连接</span></span><br><span class=\"line\">    close(sockfd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h1><p>首先创建 <code>makefile</code> 文件</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">all:server client</span></span><br><span class=\"line\"><span class=\"section\">server:socket_server.o</span></span><br><span class=\"line\">\tg++ -g -o socket_server socket_server.o</span><br><span class=\"line\"><span class=\"section\">client:socket_client.o</span></span><br><span class=\"line\">\tg++ -g -o socket_client socket_client.o</span><br><span class=\"line\"><span class=\"section\">socket_server.o:socket_server.cpp</span></span><br><span class=\"line\">\tg++ -g -c socket_server.cpp</span><br><span class=\"line\"><span class=\"section\">socket_client.o:socket_client.cpp</span></span><br><span class=\"line\">\tg++ -g -c socket_client.cpp</span><br><span class=\"line\"><span class=\"section\">clean:all</span></span><br><span class=\"line\">\trm all</span><br></pre></td></tr></table></figure>\n<p>然后使用命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make</span><br></pre></td></tr></table></figure>\n<p>会生成两个可执行文件：</p>\n<ol>\n<li><code>socket_server</code></li>\n<li><code>socket_client</code></li>\n</ol>\n<p>分别打开两个终端，运行：</p>\n<ol>\n<li><code>./socket_server</code></li>\n<li><code>./socket_client 127.0.0.1</code></li>\n</ol>\n<p>然后在 <code>socket_client</code> 中键入发送内容，可以再 <code>socket_server</code> 接收到同样的信息。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://book.douban.com/subject/26850616/\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\">《计算机网络》</a></p>\n"},{"title":"理解TCP（五）：可靠性交付的实现","date":"2017-03-02T08:00:25.000Z","_content":"\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\nTCP 是一种提供可靠性交付的协议。    \n也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。    \n但是在网络中相连两端之间的介质，是复杂的，并不确保数据的可靠性交付，那么 TCP 是怎么样解决问题的？    \n这就需要了解 TCP 的几种技术：    \n\n1. 滑动窗口    \n2. 超时重传    \n3. 流量控制    \n4. 拥塞控制    \n\n下面来分别讲一下这几种技术的实现原理。    \n\n# 超时重传\n## 重传时机\nTCP 报文段在传输的过程中，下面的情况都是有可能发生的：\n\n1. 数据包中途丢失；\n2. 数据包顺利到达，但对方发送的 ACK 报文中途丢失；\n3. 数据包顺利到达，但对方异常未响应 ACK 或被对方丢弃；\n\n当出现这些异常情况时，TCP 就会超时重传。    \nTCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到了，但还没有收到确认，就重传这一报文段，这个就叫做「超时重传」。    \n\n## 重传算法\n\n### 先认识两个概念\n\n#### RTO ( Retransmission Time-Out ) 重传超时时间\n指发送端发送数据后、重传数据前等待接收方收到该数据 ACK 报文的时间。    \n大白话就是，需要等待多长时间还没收到确认，就重新传一次。    \n\nRTO 的设置对于重传非常重要：    \n\n1. 设长了，重发就慢，没有效率，性能差；\n2. 设短了，重发得就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。\n\n#### RTT ( Round Trip Time ) 连接往返时间\n指发送端从发送 TCP 包开始到接收它的 ACK 报文之间所耗费的时间。    \n而在实际的网络传输中，RTT 的值每次都是随机的，无法事先预预知。    \nTCP 通过测量来获得连接当前 RTT 的一个估计值，并以该 RTT 估计值为基准来设置当前的 RTO。    \n这就引入了一类算法的称呼：自适应重传算法（Adaptive Restransmission Algorithm）    \n这类算法的关键就在于对当前 RTT 的准确估计，以便适时调整 RTO。    \n\n关于自适应重传算法，经历过多次的迭代和修正。    \n从 1981 年的 [RFC793](https://tools.ietf.org/html/rfc793) 提及的经典算法，到 1987 年 Karn 提出的 Karn/Partridge 算法，再到后来的 1988 年的 Jacobson / Karels 算法。    \n最后的这个算法在被用在今天的 TCP 协议中（Linux的源代码在：[`tcp_rtt_estimator`](http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609)）。    \n\n自适应重传算法的发展读者有兴趣可以参考其他资料，在这里我拎一个现在在用的算法出来讲讲，随意感受一下。    \n\n### Jacobson / Karels 算法\n1988年，有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看[RFC6298](https://tools.ietf.org/html/rfc2988)）。    \n其计算公式：\n\n> SRTT = SRTT + α ( RTT – SRTT )  —— 计算平滑 RTT\n\n> DevRTT = ( 1-β ) * DevRTT + β * ( | RTT - SRTT | ) ——计算平滑 RTT 和真实的差距（加权移动平均）\n\n> RTO= µ * SRTT + ∂ * DevRTT \n\n其中：\n* `α`、`β`、`μ`、`∂` 是可以调整的参数，在 RFC6298 中给出了对应的参考值，而在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4；\n\n* SRTT 是 Smoothed RTT 的意思，是 RTT 的平滑计算值，即根据每次测量的 RTT 和旧的 RTT 进行运算，得出新的 RTT。SRTT 的值，会在每一次测量到 RTT 之后进行更新；\n\n* DevRTT 是 Deviation RTT 的意思，根据每次测量的 RTT 和旧的 SRTT 值进行运算，得出新的 DevRTT；\n\n由算法可以知道 RTO 的值会根据每次测量的 RTT 值变化而变化，基本要点是 TCP 监视每个连接的性能，由每一个 TCP 的连接情况推算出合适的 RTO 值，根据不同的网络情况，自动修改 RTO 值，以适应负责的网络变化。\n\n# 拥塞控制\n# 滑动窗口 Sliding Window\n滑动窗口协议比较复杂，也是 TCP 协议的精髓所在。    \n\nTCP 头里有一个字段叫 Window，叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。    \n\n滑动窗口分为「接收窗口」和「发送窗口」    \n因为 TCP 协议是全双工的，会话的双方都可以同时接收和发送，那么就需要各自维护一个「发送窗口」和「接收窗口」。    \n\n## 发送窗口\n大小取决于对端通告的接受窗口。    \n只有收到对端对于本端发送窗口内字节的 ACK 确认，才会移动发送窗口的左边界。    \n\n下图是发送窗口的示意图：\n\n![tcps-send-wwindows.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png)\n\n对于发送窗口，在缓存内的数据有四种状态：\n\n- \\#1 已发送，并得到接收方 ACK 确认；\n- \\#2 已发送，但还未收到接收方 ACK；\n- \\#3 未发送，但接收方允许发送，接收方还有空间\n- \\#4 未发送，且接收方不允许发送，接收方没有空间\n\n如果下一刻，收到了接收方对于 32-36 字节序的数据包的 ACK 确认，那么发送方的窗口就会发生「滑动」。    \n并且发送下一个 46-51 字节序的数据包。    \n\n![tcps-send-wslide.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png)\n\n滑动窗口的概念，描述了 TCP 的数据是怎么发送，以及怎么接收的。    \nTCP 的滑动窗口是动态的，我们可以想象成小学常见的一个数学题，一个水池，体积 V，每小时进水量 V1, 出水量 V2。    \n当水池满了就不允许再注入了，如果有个液压系统控制水池大小，那么就可以控制水的注入速率和量了。    \n应用程序可以根据自身的处理能力变化，通过 API 来控制本端 TCP 接收窗口的大小，来进行流量控制。    \n\n## 接收窗口\n大小取决于应用、系统、硬件的限制。    \n\n下图是接收窗口的示意图（找不到图，唯有自己画了）：    \n\n![tcps-receive-wwindows.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png)\n\n相对于发送窗口，接受窗口在缓存内的数据只有三种状态：\n\n* 已接收已确认；\n* 未接收，准备接收；\n* 未接收，并未准备接收；\n\n下一刻接收到来自发送端的 32-36 数据包，然后回送 ACK 确认报，并且移动接收窗口。    \n\n![tcps-receive-wslide.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png)\n\n另外接收端相对于发送端还有不同的一点，只有前面所有的段都确认的情况下才会移动左边界，    \n在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认，以此确保对端会对这些数据重传。    \n假如 32-36 字节不是一个报文段的，而是每个字节一个报文段的话，那么就会分成了 5 个报文段。    \n在实际的网络环境中，不能确保是按序收到的，其中会有一些早达到，一些迟到达。    \n\n![tcps-receive-disorder.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png)\n\n如图中的 34、35 字节序，先收到了，接收窗口也不会移动。    \n因为有可能 32、33 字节序会出现丢包或者超时，这时就需要发送端重发报文段了。    \n\n# 参考\n[The TCP/IP Guide](http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo.htm)    \n[TCP 的那些事儿（下）](http://coolshell.cn/articles/11609.html)    \n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)    ","source":"_posts/understand-tcp-5.md","raw":"---\ntitle: 理解TCP（五）：可靠性交付的实现\ncategory: 搬砖码农\ndate: 2017-03-02 16:00:25\ntags: \n- tcp\n---\n\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\nTCP 是一种提供可靠性交付的协议。    \n也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。    \n但是在网络中相连两端之间的介质，是复杂的，并不确保数据的可靠性交付，那么 TCP 是怎么样解决问题的？    \n这就需要了解 TCP 的几种技术：    \n\n1. 滑动窗口    \n2. 超时重传    \n3. 流量控制    \n4. 拥塞控制    \n\n下面来分别讲一下这几种技术的实现原理。    \n\n# 超时重传\n## 重传时机\nTCP 报文段在传输的过程中，下面的情况都是有可能发生的：\n\n1. 数据包中途丢失；\n2. 数据包顺利到达，但对方发送的 ACK 报文中途丢失；\n3. 数据包顺利到达，但对方异常未响应 ACK 或被对方丢弃；\n\n当出现这些异常情况时，TCP 就会超时重传。    \nTCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到了，但还没有收到确认，就重传这一报文段，这个就叫做「超时重传」。    \n\n## 重传算法\n\n### 先认识两个概念\n\n#### RTO ( Retransmission Time-Out ) 重传超时时间\n指发送端发送数据后、重传数据前等待接收方收到该数据 ACK 报文的时间。    \n大白话就是，需要等待多长时间还没收到确认，就重新传一次。    \n\nRTO 的设置对于重传非常重要：    \n\n1. 设长了，重发就慢，没有效率，性能差；\n2. 设短了，重发得就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。\n\n#### RTT ( Round Trip Time ) 连接往返时间\n指发送端从发送 TCP 包开始到接收它的 ACK 报文之间所耗费的时间。    \n而在实际的网络传输中，RTT 的值每次都是随机的，无法事先预预知。    \nTCP 通过测量来获得连接当前 RTT 的一个估计值，并以该 RTT 估计值为基准来设置当前的 RTO。    \n这就引入了一类算法的称呼：自适应重传算法（Adaptive Restransmission Algorithm）    \n这类算法的关键就在于对当前 RTT 的准确估计，以便适时调整 RTO。    \n\n关于自适应重传算法，经历过多次的迭代和修正。    \n从 1981 年的 [RFC793](https://tools.ietf.org/html/rfc793) 提及的经典算法，到 1987 年 Karn 提出的 Karn/Partridge 算法，再到后来的 1988 年的 Jacobson / Karels 算法。    \n最后的这个算法在被用在今天的 TCP 协议中（Linux的源代码在：[`tcp_rtt_estimator`](http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609)）。    \n\n自适应重传算法的发展读者有兴趣可以参考其他资料，在这里我拎一个现在在用的算法出来讲讲，随意感受一下。    \n\n### Jacobson / Karels 算法\n1988年，有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看[RFC6298](https://tools.ietf.org/html/rfc2988)）。    \n其计算公式：\n\n> SRTT = SRTT + α ( RTT – SRTT )  —— 计算平滑 RTT\n\n> DevRTT = ( 1-β ) * DevRTT + β * ( | RTT - SRTT | ) ——计算平滑 RTT 和真实的差距（加权移动平均）\n\n> RTO= µ * SRTT + ∂ * DevRTT \n\n其中：\n* `α`、`β`、`μ`、`∂` 是可以调整的参数，在 RFC6298 中给出了对应的参考值，而在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4；\n\n* SRTT 是 Smoothed RTT 的意思，是 RTT 的平滑计算值，即根据每次测量的 RTT 和旧的 RTT 进行运算，得出新的 RTT。SRTT 的值，会在每一次测量到 RTT 之后进行更新；\n\n* DevRTT 是 Deviation RTT 的意思，根据每次测量的 RTT 和旧的 SRTT 值进行运算，得出新的 DevRTT；\n\n由算法可以知道 RTO 的值会根据每次测量的 RTT 值变化而变化，基本要点是 TCP 监视每个连接的性能，由每一个 TCP 的连接情况推算出合适的 RTO 值，根据不同的网络情况，自动修改 RTO 值，以适应负责的网络变化。\n\n# 拥塞控制\n# 滑动窗口 Sliding Window\n滑动窗口协议比较复杂，也是 TCP 协议的精髓所在。    \n\nTCP 头里有一个字段叫 Window，叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。    \n\n滑动窗口分为「接收窗口」和「发送窗口」    \n因为 TCP 协议是全双工的，会话的双方都可以同时接收和发送，那么就需要各自维护一个「发送窗口」和「接收窗口」。    \n\n## 发送窗口\n大小取决于对端通告的接受窗口。    \n只有收到对端对于本端发送窗口内字节的 ACK 确认，才会移动发送窗口的左边界。    \n\n下图是发送窗口的示意图：\n\n![tcps-send-wwindows.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png)\n\n对于发送窗口，在缓存内的数据有四种状态：\n\n- \\#1 已发送，并得到接收方 ACK 确认；\n- \\#2 已发送，但还未收到接收方 ACK；\n- \\#3 未发送，但接收方允许发送，接收方还有空间\n- \\#4 未发送，且接收方不允许发送，接收方没有空间\n\n如果下一刻，收到了接收方对于 32-36 字节序的数据包的 ACK 确认，那么发送方的窗口就会发生「滑动」。    \n并且发送下一个 46-51 字节序的数据包。    \n\n![tcps-send-wslide.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png)\n\n滑动窗口的概念，描述了 TCP 的数据是怎么发送，以及怎么接收的。    \nTCP 的滑动窗口是动态的，我们可以想象成小学常见的一个数学题，一个水池，体积 V，每小时进水量 V1, 出水量 V2。    \n当水池满了就不允许再注入了，如果有个液压系统控制水池大小，那么就可以控制水的注入速率和量了。    \n应用程序可以根据自身的处理能力变化，通过 API 来控制本端 TCP 接收窗口的大小，来进行流量控制。    \n\n## 接收窗口\n大小取决于应用、系统、硬件的限制。    \n\n下图是接收窗口的示意图（找不到图，唯有自己画了）：    \n\n![tcps-receive-wwindows.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png)\n\n相对于发送窗口，接受窗口在缓存内的数据只有三种状态：\n\n* 已接收已确认；\n* 未接收，准备接收；\n* 未接收，并未准备接收；\n\n下一刻接收到来自发送端的 32-36 数据包，然后回送 ACK 确认报，并且移动接收窗口。    \n\n![tcps-receive-wslide.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png)\n\n另外接收端相对于发送端还有不同的一点，只有前面所有的段都确认的情况下才会移动左边界，    \n在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认，以此确保对端会对这些数据重传。    \n假如 32-36 字节不是一个报文段的，而是每个字节一个报文段的话，那么就会分成了 5 个报文段。    \n在实际的网络环境中，不能确保是按序收到的，其中会有一些早达到，一些迟到达。    \n\n![tcps-receive-disorder.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png)\n\n如图中的 34、35 字节序，先收到了，接收窗口也不会移动。    \n因为有可能 32、33 字节序会出现丢包或者超时，这时就需要发送端重发报文段了。    \n\n# 参考\n[The TCP/IP Guide](http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo.htm)    \n[TCP 的那些事儿（下）](http://coolshell.cn/articles/11609.html)    \n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)    ","slug":"understand-tcp-5","published":1,"updated":"2020-12-13T13:47:15.665Z","_id":"cl270y8sg0041xwrldeq4ahhe","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\" target=\"_blank\" rel=\"external\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<p>TCP 是一种提供可靠性交付的协议。<br>也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。<br>但是在网络中相连两端之间的介质，是复杂的，并不确保数据的可靠性交付，那么 TCP 是怎么样解决问题的？<br>这就需要了解 TCP 的几种技术：    </p>\n<ol>\n<li>滑动窗口    </li>\n<li>超时重传    </li>\n<li>流量控制    </li>\n<li>拥塞控制    </li>\n</ol>\n<p>下面来分别讲一下这几种技术的实现原理。    </p>\n<h1 id=\"超时重传\"><a href=\"#超时重传\" class=\"headerlink\" title=\"超时重传\"></a>超时重传</h1><h2 id=\"重传时机\"><a href=\"#重传时机\" class=\"headerlink\" title=\"重传时机\"></a>重传时机</h2><p>TCP 报文段在传输的过程中，下面的情况都是有可能发生的：</p>\n<ol>\n<li>数据包中途丢失；</li>\n<li>数据包顺利到达，但对方发送的 ACK 报文中途丢失；</li>\n<li>数据包顺利到达，但对方异常未响应 ACK 或被对方丢弃；</li>\n</ol>\n<p>当出现这些异常情况时，TCP 就会超时重传。<br>TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到了，但还没有收到确认，就重传这一报文段，这个就叫做「超时重传」。    </p>\n<h2 id=\"重传算法\"><a href=\"#重传算法\" class=\"headerlink\" title=\"重传算法\"></a>重传算法</h2><h3 id=\"先认识两个概念\"><a href=\"#先认识两个概念\" class=\"headerlink\" title=\"先认识两个概念\"></a>先认识两个概念</h3><h4 id=\"RTO-Retransmission-Time-Out-重传超时时间\"><a href=\"#RTO-Retransmission-Time-Out-重传超时时间\" class=\"headerlink\" title=\"RTO ( Retransmission Time-Out ) 重传超时时间\"></a>RTO ( Retransmission Time-Out ) 重传超时时间</h4><p>指发送端发送数据后、重传数据前等待接收方收到该数据 ACK 报文的时间。<br>大白话就是，需要等待多长时间还没收到确认，就重新传一次。    </p>\n<p>RTO 的设置对于重传非常重要：    </p>\n<ol>\n<li>设长了，重发就慢，没有效率，性能差；</li>\n<li>设短了，重发得就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>\n</ol>\n<h4 id=\"RTT-Round-Trip-Time-连接往返时间\"><a href=\"#RTT-Round-Trip-Time-连接往返时间\" class=\"headerlink\" title=\"RTT ( Round Trip Time ) 连接往返时间\"></a>RTT ( Round Trip Time ) 连接往返时间</h4><p>指发送端从发送 TCP 包开始到接收它的 ACK 报文之间所耗费的时间。<br>而在实际的网络传输中，RTT 的值每次都是随机的，无法事先预预知。<br>TCP 通过测量来获得连接当前 RTT 的一个估计值，并以该 RTT 估计值为基准来设置当前的 RTO。<br>这就引入了一类算法的称呼：自适应重传算法（Adaptive Restransmission Algorithm）<br>这类算法的关键就在于对当前 RTT 的准确估计，以便适时调整 RTO。    </p>\n<p>关于自适应重传算法，经历过多次的迭代和修正。<br>从 1981 年的 <a href=\"https://tools.ietf.org/html/rfc793\" target=\"_blank\" rel=\"external\">RFC793</a> 提及的经典算法，到 1987 年 Karn 提出的 Karn/Partridge 算法，再到后来的 1988 年的 Jacobson / Karels 算法。<br>最后的这个算法在被用在今天的 TCP 协议中（Linux的源代码在：<a href=\"http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609\" target=\"_blank\" rel=\"external\"><code>tcp_rtt_estimator</code></a>）。    </p>\n<p>自适应重传算法的发展读者有兴趣可以参考其他资料，在这里我拎一个现在在用的算法出来讲讲，随意感受一下。    </p>\n<h3 id=\"Jacobson-Karels-算法\"><a href=\"#Jacobson-Karels-算法\" class=\"headerlink\" title=\"Jacobson / Karels 算法\"></a>Jacobson / Karels 算法</h3><p>1988年，有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看<a href=\"https://tools.ietf.org/html/rfc2988\" target=\"_blank\" rel=\"external\">RFC6298</a>）。<br>其计算公式：</p>\n<blockquote>\n<p>SRTT = SRTT + α ( RTT – SRTT )  —— 计算平滑 RTT</p>\n</blockquote>\n<blockquote>\n<p>DevRTT = ( 1-β ) <em> DevRTT + β </em> ( | RTT - SRTT | ) ——计算平滑 RTT 和真实的差距（加权移动平均）</p>\n</blockquote>\n<blockquote>\n<p>RTO= µ <em> SRTT + ∂ </em> DevRTT </p>\n</blockquote>\n<p>其中：</p>\n<ul>\n<li><p><code>α</code>、<code>β</code>、<code>μ</code>、<code>∂</code> 是可以调整的参数，在 RFC6298 中给出了对应的参考值，而在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4；</p>\n</li>\n<li><p>SRTT 是 Smoothed RTT 的意思，是 RTT 的平滑计算值，即根据每次测量的 RTT 和旧的 RTT 进行运算，得出新的 RTT。SRTT 的值，会在每一次测量到 RTT 之后进行更新；</p>\n</li>\n<li><p>DevRTT 是 Deviation RTT 的意思，根据每次测量的 RTT 和旧的 SRTT 值进行运算，得出新的 DevRTT；</p>\n</li>\n</ul>\n<p>由算法可以知道 RTO 的值会根据每次测量的 RTT 值变化而变化，基本要点是 TCP 监视每个连接的性能，由每一个 TCP 的连接情况推算出合适的 RTO 值，根据不同的网络情况，自动修改 RTO 值，以适应负责的网络变化。</p>\n<h1 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h1><h1 id=\"滑动窗口-Sliding-Window\"><a href=\"#滑动窗口-Sliding-Window\" class=\"headerlink\" title=\"滑动窗口 Sliding Window\"></a>滑动窗口 Sliding Window</h1><p>滑动窗口协议比较复杂，也是 TCP 协议的精髓所在。    </p>\n<p>TCP 头里有一个字段叫 Window，叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。    </p>\n<p>滑动窗口分为「接收窗口」和「发送窗口」<br>因为 TCP 协议是全双工的，会话的双方都可以同时接收和发送，那么就需要各自维护一个「发送窗口」和「接收窗口」。    </p>\n<h2 id=\"发送窗口\"><a href=\"#发送窗口\" class=\"headerlink\" title=\"发送窗口\"></a>发送窗口</h2><p>大小取决于对端通告的接受窗口。<br>只有收到对端对于本端发送窗口内字节的 ACK 确认，才会移动发送窗口的左边界。    </p>\n<p>下图是发送窗口的示意图：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png\" alt=\"tcps-send-wwindows.png\"></p>\n<p>对于发送窗口，在缓存内的数据有四种状态：</p>\n<ul>\n<li>#1 已发送，并得到接收方 ACK 确认；</li>\n<li>#2 已发送，但还未收到接收方 ACK；</li>\n<li>#3 未发送，但接收方允许发送，接收方还有空间</li>\n<li>#4 未发送，且接收方不允许发送，接收方没有空间</li>\n</ul>\n<p>如果下一刻，收到了接收方对于 32-36 字节序的数据包的 ACK 确认，那么发送方的窗口就会发生「滑动」。<br>并且发送下一个 46-51 字节序的数据包。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png\" alt=\"tcps-send-wslide.png\"></p>\n<p>滑动窗口的概念，描述了 TCP 的数据是怎么发送，以及怎么接收的。<br>TCP 的滑动窗口是动态的，我们可以想象成小学常见的一个数学题，一个水池，体积 V，每小时进水量 V1, 出水量 V2。<br>当水池满了就不允许再注入了，如果有个液压系统控制水池大小，那么就可以控制水的注入速率和量了。<br>应用程序可以根据自身的处理能力变化，通过 API 来控制本端 TCP 接收窗口的大小，来进行流量控制。    </p>\n<h2 id=\"接收窗口\"><a href=\"#接收窗口\" class=\"headerlink\" title=\"接收窗口\"></a>接收窗口</h2><p>大小取决于应用、系统、硬件的限制。    </p>\n<p>下图是接收窗口的示意图（找不到图，唯有自己画了）：    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png\" alt=\"tcps-receive-wwindows.png\"></p>\n<p>相对于发送窗口，接受窗口在缓存内的数据只有三种状态：</p>\n<ul>\n<li>已接收已确认；</li>\n<li>未接收，准备接收；</li>\n<li>未接收，并未准备接收；</li>\n</ul>\n<p>下一刻接收到来自发送端的 32-36 数据包，然后回送 ACK 确认报，并且移动接收窗口。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png\" alt=\"tcps-receive-wslide.png\"></p>\n<p>另外接收端相对于发送端还有不同的一点，只有前面所有的段都确认的情况下才会移动左边界，<br>在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认，以此确保对端会对这些数据重传。<br>假如 32-36 字节不是一个报文段的，而是每个字节一个报文段的话，那么就会分成了 5 个报文段。<br>在实际的网络环境中，不能确保是按序收到的，其中会有一些早达到，一些迟到达。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png\" alt=\"tcps-receive-disorder.png\"></p>\n<p>如图中的 34、35 字节序，先收到了，接收窗口也不会移动。<br>因为有可能 32、33 字节序会出现丢包或者超时，这时就需要发送端重发报文段了。    </p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo.htm\" target=\"_blank\" rel=\"external\">The TCP/IP Guide</a><br><a href=\"http://coolshell.cn/articles/11609.html\" target=\"_blank\" rel=\"external\">TCP 的那些事儿（下）</a><br><a href=\"https://book.douban.com/subject/26850616/\" target=\"_blank\" rel=\"external\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\" target=\"_blank\" rel=\"external\">《计算机网络》</a>    </p>\n","excerpt":"","more":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<p>TCP 是一种提供可靠性交付的协议。<br>也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。<br>但是在网络中相连两端之间的介质，是复杂的，并不确保数据的可靠性交付，那么 TCP 是怎么样解决问题的？<br>这就需要了解 TCP 的几种技术：    </p>\n<ol>\n<li>滑动窗口    </li>\n<li>超时重传    </li>\n<li>流量控制    </li>\n<li>拥塞控制    </li>\n</ol>\n<p>下面来分别讲一下这几种技术的实现原理。    </p>\n<h1 id=\"超时重传\"><a href=\"#超时重传\" class=\"headerlink\" title=\"超时重传\"></a>超时重传</h1><h2 id=\"重传时机\"><a href=\"#重传时机\" class=\"headerlink\" title=\"重传时机\"></a>重传时机</h2><p>TCP 报文段在传输的过程中，下面的情况都是有可能发生的：</p>\n<ol>\n<li>数据包中途丢失；</li>\n<li>数据包顺利到达，但对方发送的 ACK 报文中途丢失；</li>\n<li>数据包顺利到达，但对方异常未响应 ACK 或被对方丢弃；</li>\n</ol>\n<p>当出现这些异常情况时，TCP 就会超时重传。<br>TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到了，但还没有收到确认，就重传这一报文段，这个就叫做「超时重传」。    </p>\n<h2 id=\"重传算法\"><a href=\"#重传算法\" class=\"headerlink\" title=\"重传算法\"></a>重传算法</h2><h3 id=\"先认识两个概念\"><a href=\"#先认识两个概念\" class=\"headerlink\" title=\"先认识两个概念\"></a>先认识两个概念</h3><h4 id=\"RTO-Retransmission-Time-Out-重传超时时间\"><a href=\"#RTO-Retransmission-Time-Out-重传超时时间\" class=\"headerlink\" title=\"RTO ( Retransmission Time-Out ) 重传超时时间\"></a>RTO ( Retransmission Time-Out ) 重传超时时间</h4><p>指发送端发送数据后、重传数据前等待接收方收到该数据 ACK 报文的时间。<br>大白话就是，需要等待多长时间还没收到确认，就重新传一次。    </p>\n<p>RTO 的设置对于重传非常重要：    </p>\n<ol>\n<li>设长了，重发就慢，没有效率，性能差；</li>\n<li>设短了，重发得就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>\n</ol>\n<h4 id=\"RTT-Round-Trip-Time-连接往返时间\"><a href=\"#RTT-Round-Trip-Time-连接往返时间\" class=\"headerlink\" title=\"RTT ( Round Trip Time ) 连接往返时间\"></a>RTT ( Round Trip Time ) 连接往返时间</h4><p>指发送端从发送 TCP 包开始到接收它的 ACK 报文之间所耗费的时间。<br>而在实际的网络传输中，RTT 的值每次都是随机的，无法事先预预知。<br>TCP 通过测量来获得连接当前 RTT 的一个估计值，并以该 RTT 估计值为基准来设置当前的 RTO。<br>这就引入了一类算法的称呼：自适应重传算法（Adaptive Restransmission Algorithm）<br>这类算法的关键就在于对当前 RTT 的准确估计，以便适时调整 RTO。    </p>\n<p>关于自适应重传算法，经历过多次的迭代和修正。<br>从 1981 年的 <a href=\"https://tools.ietf.org/html/rfc793\">RFC793</a> 提及的经典算法，到 1987 年 Karn 提出的 Karn/Partridge 算法，再到后来的 1988 年的 Jacobson / Karels 算法。<br>最后的这个算法在被用在今天的 TCP 协议中（Linux的源代码在：<a href=\"http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609\"><code>tcp_rtt_estimator</code></a>）。    </p>\n<p>自适应重传算法的发展读者有兴趣可以参考其他资料，在这里我拎一个现在在用的算法出来讲讲，随意感受一下。    </p>\n<h3 id=\"Jacobson-Karels-算法\"><a href=\"#Jacobson-Karels-算法\" class=\"headerlink\" title=\"Jacobson / Karels 算法\"></a>Jacobson / Karels 算法</h3><p>1988年，有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看<a href=\"https://tools.ietf.org/html/rfc2988\">RFC6298</a>）。<br>其计算公式：</p>\n<blockquote>\n<p>SRTT = SRTT + α ( RTT – SRTT )  —— 计算平滑 RTT</p>\n</blockquote>\n<blockquote>\n<p>DevRTT = ( 1-β ) <em> DevRTT + β </em> ( | RTT - SRTT | ) ——计算平滑 RTT 和真实的差距（加权移动平均）</p>\n</blockquote>\n<blockquote>\n<p>RTO= µ <em> SRTT + ∂ </em> DevRTT </p>\n</blockquote>\n<p>其中：</p>\n<ul>\n<li><p><code>α</code>、<code>β</code>、<code>μ</code>、<code>∂</code> 是可以调整的参数，在 RFC6298 中给出了对应的参考值，而在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4；</p>\n</li>\n<li><p>SRTT 是 Smoothed RTT 的意思，是 RTT 的平滑计算值，即根据每次测量的 RTT 和旧的 RTT 进行运算，得出新的 RTT。SRTT 的值，会在每一次测量到 RTT 之后进行更新；</p>\n</li>\n<li><p>DevRTT 是 Deviation RTT 的意思，根据每次测量的 RTT 和旧的 SRTT 值进行运算，得出新的 DevRTT；</p>\n</li>\n</ul>\n<p>由算法可以知道 RTO 的值会根据每次测量的 RTT 值变化而变化，基本要点是 TCP 监视每个连接的性能，由每一个 TCP 的连接情况推算出合适的 RTO 值，根据不同的网络情况，自动修改 RTO 值，以适应负责的网络变化。</p>\n<h1 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h1><h1 id=\"滑动窗口-Sliding-Window\"><a href=\"#滑动窗口-Sliding-Window\" class=\"headerlink\" title=\"滑动窗口 Sliding Window\"></a>滑动窗口 Sliding Window</h1><p>滑动窗口协议比较复杂，也是 TCP 协议的精髓所在。    </p>\n<p>TCP 头里有一个字段叫 Window，叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。    </p>\n<p>滑动窗口分为「接收窗口」和「发送窗口」<br>因为 TCP 协议是全双工的，会话的双方都可以同时接收和发送，那么就需要各自维护一个「发送窗口」和「接收窗口」。    </p>\n<h2 id=\"发送窗口\"><a href=\"#发送窗口\" class=\"headerlink\" title=\"发送窗口\"></a>发送窗口</h2><p>大小取决于对端通告的接受窗口。<br>只有收到对端对于本端发送窗口内字节的 ACK 确认，才会移动发送窗口的左边界。    </p>\n<p>下图是发送窗口的示意图：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png\" alt=\"tcps-send-wwindows.png\"></p>\n<p>对于发送窗口，在缓存内的数据有四种状态：</p>\n<ul>\n<li>#1 已发送，并得到接收方 ACK 确认；</li>\n<li>#2 已发送，但还未收到接收方 ACK；</li>\n<li>#3 未发送，但接收方允许发送，接收方还有空间</li>\n<li>#4 未发送，且接收方不允许发送，接收方没有空间</li>\n</ul>\n<p>如果下一刻，收到了接收方对于 32-36 字节序的数据包的 ACK 确认，那么发送方的窗口就会发生「滑动」。<br>并且发送下一个 46-51 字节序的数据包。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png\" alt=\"tcps-send-wslide.png\"></p>\n<p>滑动窗口的概念，描述了 TCP 的数据是怎么发送，以及怎么接收的。<br>TCP 的滑动窗口是动态的，我们可以想象成小学常见的一个数学题，一个水池，体积 V，每小时进水量 V1, 出水量 V2。<br>当水池满了就不允许再注入了，如果有个液压系统控制水池大小，那么就可以控制水的注入速率和量了。<br>应用程序可以根据自身的处理能力变化，通过 API 来控制本端 TCP 接收窗口的大小，来进行流量控制。    </p>\n<h2 id=\"接收窗口\"><a href=\"#接收窗口\" class=\"headerlink\" title=\"接收窗口\"></a>接收窗口</h2><p>大小取决于应用、系统、硬件的限制。    </p>\n<p>下图是接收窗口的示意图（找不到图，唯有自己画了）：    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png\" alt=\"tcps-receive-wwindows.png\"></p>\n<p>相对于发送窗口，接受窗口在缓存内的数据只有三种状态：</p>\n<ul>\n<li>已接收已确认；</li>\n<li>未接收，准备接收；</li>\n<li>未接收，并未准备接收；</li>\n</ul>\n<p>下一刻接收到来自发送端的 32-36 数据包，然后回送 ACK 确认报，并且移动接收窗口。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png\" alt=\"tcps-receive-wslide.png\"></p>\n<p>另外接收端相对于发送端还有不同的一点，只有前面所有的段都确认的情况下才会移动左边界，<br>在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认，以此确保对端会对这些数据重传。<br>假如 32-36 字节不是一个报文段的，而是每个字节一个报文段的话，那么就会分成了 5 个报文段。<br>在实际的网络环境中，不能确保是按序收到的，其中会有一些早达到，一些迟到达。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png\" alt=\"tcps-receive-disorder.png\"></p>\n<p>如图中的 34、35 字节序，先收到了，接收窗口也不会移动。<br>因为有可能 32、33 字节序会出现丢包或者超时，这时就需要发送端重发报文段了。    </p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo.htm\">The TCP/IP Guide</a><br><a href=\"http://coolshell.cn/articles/11609.html\">TCP 的那些事儿（下）</a><br><a href=\"https://book.douban.com/subject/26850616/\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\">《计算机网络》</a>    </p>\n"},{"title":"理解TCP（四）：状态流转","date":"2017-03-02T07:59:25.000Z","_content":"\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\n无论客户端还是服务器，在双方 TCP 通讯的过程中，都会有着一个「状态」的概念，状态会随着 TCP 通讯的不同阶段而变化。\n\n## TCP 状态流转图\n![TCP 状态流转图.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/DB900F916ECD267746706FEA8DF682CD.png)\n\n## 各种状态表示的意思\n\n**CLOSED**：表示初始状态\n\n**LISTEN**：表示服务器端的某个 socket 处于监听状态，可以接受连接\n\n**SYN_SENT**：在服务端监听后，客户端 socket 执行 CONNECT 连接时，客户端发送 SYN 报文，此时客户端就进入 SYN_SENT 状态，等待服务端确认。\n\n**SYN_RCVD**：表示服务端接收到了 SYN 报文。\n\n**ESTABLISHED**：表示连接已经建立了。\n\n**FIN_WAIT_1**：其中一方请求终止连接，等待对方的 FIN 报文。\n\n**FIN_WAIT_2**：在 **FIN_WAIT_2** 之后， 当对方回应 ACK 报文之后，进入该状态。\n\n**TIME_WAIT**：表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 之后即可回到 CLOSED 状态。\n\n**CLOSING**：一种罕见状态，发生在发送 FIN 报文之后，本应是先收到 ACK 报文，却先收到对方的 FIN 报文，那么就从 FIN_WAIT_1 的状态进入 CLOSING 状态。\n\n**CLOSE_WAIT**：表示等待关闭，在 ESTABLISHED 过渡到 LAST_ACK 的一个过渡阶段，该阶段需要考虑是否还有数据发送给对方，如果没有，就可以关闭连接，发送 FIN 报文，然后进入 LAST_ACK 状态。\n\n**LAST_ACK**：被动关闭一方发送 FIN 报文之后，最后等待对方的 ACK 报文所处的状态。\n\n**CLOSED**：当收到 ACK 保温后，就可以进入 CLOSED 状态了。\n\n## 参考\n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)k.douban.com/subject/2970300/)","source":"_posts/understand-tcp-4.md","raw":"---\ntitle: 理解TCP（四）：状态流转\ncategory: 搬砖码农\ndate: 2017-03-02 15:59:25\ntags: \n- tcp\n---\n\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\n无论客户端还是服务器，在双方 TCP 通讯的过程中，都会有着一个「状态」的概念，状态会随着 TCP 通讯的不同阶段而变化。\n\n## TCP 状态流转图\n![TCP 状态流转图.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/DB900F916ECD267746706FEA8DF682CD.png)\n\n## 各种状态表示的意思\n\n**CLOSED**：表示初始状态\n\n**LISTEN**：表示服务器端的某个 socket 处于监听状态，可以接受连接\n\n**SYN_SENT**：在服务端监听后，客户端 socket 执行 CONNECT 连接时，客户端发送 SYN 报文，此时客户端就进入 SYN_SENT 状态，等待服务端确认。\n\n**SYN_RCVD**：表示服务端接收到了 SYN 报文。\n\n**ESTABLISHED**：表示连接已经建立了。\n\n**FIN_WAIT_1**：其中一方请求终止连接，等待对方的 FIN 报文。\n\n**FIN_WAIT_2**：在 **FIN_WAIT_2** 之后， 当对方回应 ACK 报文之后，进入该状态。\n\n**TIME_WAIT**：表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 之后即可回到 CLOSED 状态。\n\n**CLOSING**：一种罕见状态，发生在发送 FIN 报文之后，本应是先收到 ACK 报文，却先收到对方的 FIN 报文，那么就从 FIN_WAIT_1 的状态进入 CLOSING 状态。\n\n**CLOSE_WAIT**：表示等待关闭，在 ESTABLISHED 过渡到 LAST_ACK 的一个过渡阶段，该阶段需要考虑是否还有数据发送给对方，如果没有，就可以关闭连接，发送 FIN 报文，然后进入 LAST_ACK 状态。\n\n**LAST_ACK**：被动关闭一方发送 FIN 报文之后，最后等待对方的 ACK 报文所处的状态。\n\n**CLOSED**：当收到 ACK 保温后，就可以进入 CLOSED 状态了。\n\n## 参考\n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)k.douban.com/subject/2970300/)","slug":"understand-tcp-4","published":1,"updated":"2020-12-13T13:47:15.664Z","_id":"cl270y8si0044xwrlr3nkzin6","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\" target=\"_blank\" rel=\"external\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<p>无论客户端还是服务器，在双方 TCP 通讯的过程中，都会有着一个「状态」的概念，状态会随着 TCP 通讯的不同阶段而变化。</p>\n<h2 id=\"TCP-状态流转图\"><a href=\"#TCP-状态流转图\" class=\"headerlink\" title=\"TCP 状态流转图\"></a>TCP 状态流转图</h2><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/DB900F916ECD267746706FEA8DF682CD.png\" alt=\"TCP 状态流转图.png\"></p>\n<h2 id=\"各种状态表示的意思\"><a href=\"#各种状态表示的意思\" class=\"headerlink\" title=\"各种状态表示的意思\"></a>各种状态表示的意思</h2><p><strong>CLOSED</strong>：表示初始状态</p>\n<p><strong>LISTEN</strong>：表示服务器端的某个 socket 处于监听状态，可以接受连接</p>\n<p><strong>SYN_SENT</strong>：在服务端监听后，客户端 socket 执行 CONNECT 连接时，客户端发送 SYN 报文，此时客户端就进入 SYN_SENT 状态，等待服务端确认。</p>\n<p><strong>SYN_RCVD</strong>：表示服务端接收到了 SYN 报文。</p>\n<p><strong>ESTABLISHED</strong>：表示连接已经建立了。</p>\n<p><strong>FIN_WAIT_1</strong>：其中一方请求终止连接，等待对方的 FIN 报文。</p>\n<p><strong>FIN_WAIT_2</strong>：在 <strong>FIN_WAIT_2</strong> 之后， 当对方回应 ACK 报文之后，进入该状态。</p>\n<p><strong>TIME_WAIT</strong>：表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 之后即可回到 CLOSED 状态。</p>\n<p><strong>CLOSING</strong>：一种罕见状态，发生在发送 FIN 报文之后，本应是先收到 ACK 报文，却先收到对方的 FIN 报文，那么就从 FIN_WAIT_1 的状态进入 CLOSING 状态。</p>\n<p><strong>CLOSE_WAIT</strong>：表示等待关闭，在 ESTABLISHED 过渡到 LAST_ACK 的一个过渡阶段，该阶段需要考虑是否还有数据发送给对方，如果没有，就可以关闭连接，发送 FIN 报文，然后进入 LAST_ACK 状态。</p>\n<p><strong>LAST_ACK</strong>：被动关闭一方发送 FIN 报文之后，最后等待对方的 ACK 报文所处的状态。</p>\n<p><strong>CLOSED</strong>：当收到 ACK 保温后，就可以进入 CLOSED 状态了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://book.douban.com/subject/26850616/\" target=\"_blank\" rel=\"external\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\" target=\"_blank\" rel=\"external\">《计算机网络》</a>k.douban.com/subject/2970300/)</p>\n","excerpt":"","more":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<p>无论客户端还是服务器，在双方 TCP 通讯的过程中，都会有着一个「状态」的概念，状态会随着 TCP 通讯的不同阶段而变化。</p>\n<h2 id=\"TCP-状态流转图\"><a href=\"#TCP-状态流转图\" class=\"headerlink\" title=\"TCP 状态流转图\"></a>TCP 状态流转图</h2><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/DB900F916ECD267746706FEA8DF682CD.png\" alt=\"TCP 状态流转图.png\"></p>\n<h2 id=\"各种状态表示的意思\"><a href=\"#各种状态表示的意思\" class=\"headerlink\" title=\"各种状态表示的意思\"></a>各种状态表示的意思</h2><p><strong>CLOSED</strong>：表示初始状态</p>\n<p><strong>LISTEN</strong>：表示服务器端的某个 socket 处于监听状态，可以接受连接</p>\n<p><strong>SYN_SENT</strong>：在服务端监听后，客户端 socket 执行 CONNECT 连接时，客户端发送 SYN 报文，此时客户端就进入 SYN_SENT 状态，等待服务端确认。</p>\n<p><strong>SYN_RCVD</strong>：表示服务端接收到了 SYN 报文。</p>\n<p><strong>ESTABLISHED</strong>：表示连接已经建立了。</p>\n<p><strong>FIN_WAIT_1</strong>：其中一方请求终止连接，等待对方的 FIN 报文。</p>\n<p><strong>FIN_WAIT_2</strong>：在 <strong>FIN_WAIT_2</strong> 之后， 当对方回应 ACK 报文之后，进入该状态。</p>\n<p><strong>TIME_WAIT</strong>：表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 之后即可回到 CLOSED 状态。</p>\n<p><strong>CLOSING</strong>：一种罕见状态，发生在发送 FIN 报文之后，本应是先收到 ACK 报文，却先收到对方的 FIN 报文，那么就从 FIN_WAIT_1 的状态进入 CLOSING 状态。</p>\n<p><strong>CLOSE_WAIT</strong>：表示等待关闭，在 ESTABLISHED 过渡到 LAST_ACK 的一个过渡阶段，该阶段需要考虑是否还有数据发送给对方，如果没有，就可以关闭连接，发送 FIN 报文，然后进入 LAST_ACK 状态。</p>\n<p><strong>LAST_ACK</strong>：被动关闭一方发送 FIN 报文之后，最后等待对方的 ACK 报文所处的状态。</p>\n<p><strong>CLOSED</strong>：当收到 ACK 保温后，就可以进入 CLOSED 状态了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://book.douban.com/subject/26850616/\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\">《计算机网络》</a>k.douban.com/subject/2970300/)</p>\n"},{"title":"理解TCP（三）：连接的建立和释放","date":"2017-03-02T07:58:25.000Z","_content":"\n\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\nTCP 的整个交流过程可以总结为：先建立连接，然后传输数据，最后释放链接。    \n\n![三次握手和四次挥手.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/08EAF7F3E7FFCEF3E781385BF62BA2BC.png)\n\n## 三次握手，建立连接\nTCP 连接建立要解决的首要问题就是：**要使每一方能够确知对方的存在。**    \n\n三次握手就像，在一个黑暗的森林，你知道前方十点钟方向好像有人。    \n你喊了一句：Hello？I'am JerryC，Who are you？    \n对面回了一句：Hi! I'am David, and nice to meet you!    \n然后你回了一句：Nice to meet you too!    \n......(自此，你们才算真正认识了双方，开始了后面省略3000字的谈话)    \n\n所以说，两个人需要交朋友（两个端点需要建立连接），至少需要三次的通话（握手）    \n\n其实，网络上的传输是没有连接的，TCP 也是一样的。    \n而 TCP 所谓的「连接」，其实只不过是在通信的双方维护一个「连接状态」，让它看上去好像有连接一样。    \n\n### 连接建立过程\nTCP 连接的建立采用客户服务器方式，主动发起连接建立的一方叫**客户端（Client）**，被动等待连接建立的一方叫**服务器（Server）**。    \n\n最初的时候，两端都处于 **CLOSED** 的状态，然后服务器打开了 TCP 服务，进入 **LISTEN** 状态，监听特定端口，等待客户端的 TCP 请求。    \n\n**第一次握手**：\n客户端主动打开连接，发送 TCP 报文，进行第一次握手，然后进入 **SYN_SEND** 状态，等待服务器发回确认报文。    \n这时首部的同步位 SYN = 1，同时初始化一个序号 Sequence Number = J。    \nTCP 规定，SYN 报文段不能携带数据，但会消耗一个序号。    \n\n**第二次握手**：\n服务器收到了 SYN 报文，如果同意建立连接，则向客户端发送一个确认报文，然后服务器进入 **SYN_RCVD** 状态。    \n这时首部的 SYN = 1，ACK = 1，而确认号 Acknowledgemt Number = J + 1，同时也为自己初始化一个序号 Sequence Number = K。    \n这个报文同样不携带数据。    \n\n**第三次握手**：    \n客户端收到了服务器发过来的确认报文，还要向服务器给出确认，然后进入 **ESTABLISHED** 状态。    \n这时首部的 SYN 不再置为 1，而 ACK = 1，确认号 Acknowledgemt Number = K + 1，序号 Sequence Number = J + 1。    \n第三次握手，一般会携带真正需要传输的数据，当服务器收到该数据报文的时候，就会同样进入 **ESTABLISHED** 状态。\n此时，TCP 连接已经建立。    \n\n对于建立连接的三次握手，主要目的是初始化序号 Sequence Number，并且通信的双方都需要告知对方自己的初始化序号，所以这个过程也叫 SYN。    \n这个序号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，因为TCP 会用这个序号来拼接数据。    \n\n### 利用连接设计缺陷实施 TCP Flood 攻击\n知道了 TCP 建立一个连接，需要进行三次握手。    \n但如果你开始思考「三次握手的必要性」的时候，就会知道，其实网络是很复杂的，一个信息在途中丢失的可能性是有的。    \n如果数据丢失了，那么，就需要重新发送，这时候就要知道数据是否真的送达了。    \n这就是三次握手的必要性。    \n但是再向深一层思考，你给我发信息，我收到了，我回复，因为我是君子。    \n如果是小人，你给我发信息，我就算收到了，我也不回复，你就一直等我着我的回复。    \n那么很多小人都这样做，你就要一直记住你在等待着小人1号、小人2号、小人3号......直到你的脑容量爆棚，烧坏脑袋。    \n黑客就是利用这样的设计缺陷，实施 TCP Flood 攻击，属于 DDOS 攻击的一种。   \n想了解更多 SYN Flood 攻击请看：[SYN flood - wiki](https://www.wikiwand.com/en/SYN_flood) \n\n## 四次挥手，释放连接\n\nTCP 有一个特别的概念叫做**半关闭**，这个概念是说，TCP 的连接是全双工（可以同时发送和接收）的连接，因此在关闭连接的时候，必须关闭传送和接收两个方向上的连接。    \n客户端给服务器发送一个携带 FIN 的 TCP 结束报文段，然后服务器返回给客户端一个 确认报文段，同时发送一个 结束报文段，当客户端回复一个 确认报文段 之后，连接就结束了。    \n\n### 释放连接过程\n\n在结束之前，通信双方都是处于 **ESTABLISHED** 状态，然后其中一方主动断开连接。    \n下面假如客户端先主动断开连接。    \n\n**第一次挥手：**     \n客户端向服务器发送结束报文段，然后进入 **FIN_WAIT_1** 状态。    \n此报文段 FIN = 1， Sequence Number = M。    \n\n**第二次挥手：**     \n服务端收到客户端的结束报文段，然后发送确认报文段，进入 **CLOSE_WAIT** 状态。    \n此报文段 ACK = 1， Sequence Number = M + 1。    \n\n客户端收到该报文，会进入 **FIN_WAIT_2** 状态。    \n\n**第三次挥手：**     \n同时服务端向客户端发送结束报文段，然后进入 **LAST_ACK** 状态。    \n此报文段 FIN = 1，Sequence Number = N。    \n\n**第四次挥手：**    \n客户端收到服务端的结束报文段，然后发送确认报文段，进入 **TIME_WAIT** 状态，经过 2MSL 之后，自动进入 **CLOSED** 状态。    \n此报文段 ACK = 1, Sequence Number = N + 1。    \n\n服务端收到该报文之后，进入 **CLOSED** 状态。    \n\n**关于 TIME_WAIT 过渡到 CLOSED 状态说明**：    \n从 **TIME_WAIT** 进入 **CLOSED** 需要经过 2MSL，其中 MSL 就叫做 最长报文段寿命（Maxinum Segment Lifetime），根据 RFC 793 建议该值这是为 2 分钟，也就是说需要经过 4 分钟，才进入 **CLOSED** 状态。    \n\n# 参考\n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)","source":"_posts/understand-tcp-3.md","raw":"---\ntitle: 理解TCP（三）：连接的建立和释放\ncategory: 搬砖码农\ndate: 2017-03-02 15:58:25\ntags: \n- tcp\n---\n\n\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\nTCP 的整个交流过程可以总结为：先建立连接，然后传输数据，最后释放链接。    \n\n![三次握手和四次挥手.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/08EAF7F3E7FFCEF3E781385BF62BA2BC.png)\n\n## 三次握手，建立连接\nTCP 连接建立要解决的首要问题就是：**要使每一方能够确知对方的存在。**    \n\n三次握手就像，在一个黑暗的森林，你知道前方十点钟方向好像有人。    \n你喊了一句：Hello？I'am JerryC，Who are you？    \n对面回了一句：Hi! I'am David, and nice to meet you!    \n然后你回了一句：Nice to meet you too!    \n......(自此，你们才算真正认识了双方，开始了后面省略3000字的谈话)    \n\n所以说，两个人需要交朋友（两个端点需要建立连接），至少需要三次的通话（握手）    \n\n其实，网络上的传输是没有连接的，TCP 也是一样的。    \n而 TCP 所谓的「连接」，其实只不过是在通信的双方维护一个「连接状态」，让它看上去好像有连接一样。    \n\n### 连接建立过程\nTCP 连接的建立采用客户服务器方式，主动发起连接建立的一方叫**客户端（Client）**，被动等待连接建立的一方叫**服务器（Server）**。    \n\n最初的时候，两端都处于 **CLOSED** 的状态，然后服务器打开了 TCP 服务，进入 **LISTEN** 状态，监听特定端口，等待客户端的 TCP 请求。    \n\n**第一次握手**：\n客户端主动打开连接，发送 TCP 报文，进行第一次握手，然后进入 **SYN_SEND** 状态，等待服务器发回确认报文。    \n这时首部的同步位 SYN = 1，同时初始化一个序号 Sequence Number = J。    \nTCP 规定，SYN 报文段不能携带数据，但会消耗一个序号。    \n\n**第二次握手**：\n服务器收到了 SYN 报文，如果同意建立连接，则向客户端发送一个确认报文，然后服务器进入 **SYN_RCVD** 状态。    \n这时首部的 SYN = 1，ACK = 1，而确认号 Acknowledgemt Number = J + 1，同时也为自己初始化一个序号 Sequence Number = K。    \n这个报文同样不携带数据。    \n\n**第三次握手**：    \n客户端收到了服务器发过来的确认报文，还要向服务器给出确认，然后进入 **ESTABLISHED** 状态。    \n这时首部的 SYN 不再置为 1，而 ACK = 1，确认号 Acknowledgemt Number = K + 1，序号 Sequence Number = J + 1。    \n第三次握手，一般会携带真正需要传输的数据，当服务器收到该数据报文的时候，就会同样进入 **ESTABLISHED** 状态。\n此时，TCP 连接已经建立。    \n\n对于建立连接的三次握手，主要目的是初始化序号 Sequence Number，并且通信的双方都需要告知对方自己的初始化序号，所以这个过程也叫 SYN。    \n这个序号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，因为TCP 会用这个序号来拼接数据。    \n\n### 利用连接设计缺陷实施 TCP Flood 攻击\n知道了 TCP 建立一个连接，需要进行三次握手。    \n但如果你开始思考「三次握手的必要性」的时候，就会知道，其实网络是很复杂的，一个信息在途中丢失的可能性是有的。    \n如果数据丢失了，那么，就需要重新发送，这时候就要知道数据是否真的送达了。    \n这就是三次握手的必要性。    \n但是再向深一层思考，你给我发信息，我收到了，我回复，因为我是君子。    \n如果是小人，你给我发信息，我就算收到了，我也不回复，你就一直等我着我的回复。    \n那么很多小人都这样做，你就要一直记住你在等待着小人1号、小人2号、小人3号......直到你的脑容量爆棚，烧坏脑袋。    \n黑客就是利用这样的设计缺陷，实施 TCP Flood 攻击，属于 DDOS 攻击的一种。   \n想了解更多 SYN Flood 攻击请看：[SYN flood - wiki](https://www.wikiwand.com/en/SYN_flood) \n\n## 四次挥手，释放连接\n\nTCP 有一个特别的概念叫做**半关闭**，这个概念是说，TCP 的连接是全双工（可以同时发送和接收）的连接，因此在关闭连接的时候，必须关闭传送和接收两个方向上的连接。    \n客户端给服务器发送一个携带 FIN 的 TCP 结束报文段，然后服务器返回给客户端一个 确认报文段，同时发送一个 结束报文段，当客户端回复一个 确认报文段 之后，连接就结束了。    \n\n### 释放连接过程\n\n在结束之前，通信双方都是处于 **ESTABLISHED** 状态，然后其中一方主动断开连接。    \n下面假如客户端先主动断开连接。    \n\n**第一次挥手：**     \n客户端向服务器发送结束报文段，然后进入 **FIN_WAIT_1** 状态。    \n此报文段 FIN = 1， Sequence Number = M。    \n\n**第二次挥手：**     \n服务端收到客户端的结束报文段，然后发送确认报文段，进入 **CLOSE_WAIT** 状态。    \n此报文段 ACK = 1， Sequence Number = M + 1。    \n\n客户端收到该报文，会进入 **FIN_WAIT_2** 状态。    \n\n**第三次挥手：**     \n同时服务端向客户端发送结束报文段，然后进入 **LAST_ACK** 状态。    \n此报文段 FIN = 1，Sequence Number = N。    \n\n**第四次挥手：**    \n客户端收到服务端的结束报文段，然后发送确认报文段，进入 **TIME_WAIT** 状态，经过 2MSL 之后，自动进入 **CLOSED** 状态。    \n此报文段 ACK = 1, Sequence Number = N + 1。    \n\n服务端收到该报文之后，进入 **CLOSED** 状态。    \n\n**关于 TIME_WAIT 过渡到 CLOSED 状态说明**：    \n从 **TIME_WAIT** 进入 **CLOSED** 需要经过 2MSL，其中 MSL 就叫做 最长报文段寿命（Maxinum Segment Lifetime），根据 RFC 793 建议该值这是为 2 分钟，也就是说需要经过 4 分钟，才进入 **CLOSED** 状态。    \n\n# 参考\n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)","slug":"understand-tcp-3","published":1,"updated":"2020-12-13T13:47:15.664Z","_id":"cl270y8sj0047xwrluqhsjfzj","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\" target=\"_blank\" rel=\"external\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<p>TCP 的整个交流过程可以总结为：先建立连接，然后传输数据，最后释放链接。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/08EAF7F3E7FFCEF3E781385BF62BA2BC.png\" alt=\"三次握手和四次挥手.png\"></p>\n<h2 id=\"三次握手，建立连接\"><a href=\"#三次握手，建立连接\" class=\"headerlink\" title=\"三次握手，建立连接\"></a>三次握手，建立连接</h2><p>TCP 连接建立要解决的首要问题就是：<strong>要使每一方能够确知对方的存在。</strong>    </p>\n<p>三次握手就像，在一个黑暗的森林，你知道前方十点钟方向好像有人。<br>你喊了一句：Hello？I’am JerryC，Who are you？<br>对面回了一句：Hi! I’am David, and nice to meet you!<br>然后你回了一句：Nice to meet you too!<br>……(自此，你们才算真正认识了双方，开始了后面省略3000字的谈话)    </p>\n<p>所以说，两个人需要交朋友（两个端点需要建立连接），至少需要三次的通话（握手）    </p>\n<p>其实，网络上的传输是没有连接的，TCP 也是一样的。<br>而 TCP 所谓的「连接」，其实只不过是在通信的双方维护一个「连接状态」，让它看上去好像有连接一样。    </p>\n<h3 id=\"连接建立过程\"><a href=\"#连接建立过程\" class=\"headerlink\" title=\"连接建立过程\"></a>连接建立过程</h3><p>TCP 连接的建立采用客户服务器方式，主动发起连接建立的一方叫<strong>客户端（Client）</strong>，被动等待连接建立的一方叫<strong>服务器（Server）</strong>。    </p>\n<p>最初的时候，两端都处于 <strong>CLOSED</strong> 的状态，然后服务器打开了 TCP 服务，进入 <strong>LISTEN</strong> 状态，监听特定端口，等待客户端的 TCP 请求。    </p>\n<p><strong>第一次握手</strong>：<br>客户端主动打开连接，发送 TCP 报文，进行第一次握手，然后进入 <strong>SYN_SEND</strong> 状态，等待服务器发回确认报文。<br>这时首部的同步位 SYN = 1，同时初始化一个序号 Sequence Number = J。<br>TCP 规定，SYN 报文段不能携带数据，但会消耗一个序号。    </p>\n<p><strong>第二次握手</strong>：<br>服务器收到了 SYN 报文，如果同意建立连接，则向客户端发送一个确认报文，然后服务器进入 <strong>SYN_RCVD</strong> 状态。<br>这时首部的 SYN = 1，ACK = 1，而确认号 Acknowledgemt Number = J + 1，同时也为自己初始化一个序号 Sequence Number = K。<br>这个报文同样不携带数据。    </p>\n<p><strong>第三次握手</strong>：<br>客户端收到了服务器发过来的确认报文，还要向服务器给出确认，然后进入 <strong>ESTABLISHED</strong> 状态。<br>这时首部的 SYN 不再置为 1，而 ACK = 1，确认号 Acknowledgemt Number = K + 1，序号 Sequence Number = J + 1。<br>第三次握手，一般会携带真正需要传输的数据，当服务器收到该数据报文的时候，就会同样进入 <strong>ESTABLISHED</strong> 状态。<br>此时，TCP 连接已经建立。    </p>\n<p>对于建立连接的三次握手，主要目的是初始化序号 Sequence Number，并且通信的双方都需要告知对方自己的初始化序号，所以这个过程也叫 SYN。<br>这个序号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，因为TCP 会用这个序号来拼接数据。    </p>\n<h3 id=\"利用连接设计缺陷实施-TCP-Flood-攻击\"><a href=\"#利用连接设计缺陷实施-TCP-Flood-攻击\" class=\"headerlink\" title=\"利用连接设计缺陷实施 TCP Flood 攻击\"></a>利用连接设计缺陷实施 TCP Flood 攻击</h3><p>知道了 TCP 建立一个连接，需要进行三次握手。<br>但如果你开始思考「三次握手的必要性」的时候，就会知道，其实网络是很复杂的，一个信息在途中丢失的可能性是有的。<br>如果数据丢失了，那么，就需要重新发送，这时候就要知道数据是否真的送达了。<br>这就是三次握手的必要性。<br>但是再向深一层思考，你给我发信息，我收到了，我回复，因为我是君子。<br>如果是小人，你给我发信息，我就算收到了，我也不回复，你就一直等我着我的回复。<br>那么很多小人都这样做，你就要一直记住你在等待着小人1号、小人2号、小人3号……直到你的脑容量爆棚，烧坏脑袋。<br>黑客就是利用这样的设计缺陷，实施 TCP Flood 攻击，属于 DDOS 攻击的一种。<br>想了解更多 SYN Flood 攻击请看：<a href=\"https://www.wikiwand.com/en/SYN_flood\" target=\"_blank\" rel=\"external\">SYN flood - wiki</a> </p>\n<h2 id=\"四次挥手，释放连接\"><a href=\"#四次挥手，释放连接\" class=\"headerlink\" title=\"四次挥手，释放连接\"></a>四次挥手，释放连接</h2><p>TCP 有一个特别的概念叫做<strong>半关闭</strong>，这个概念是说，TCP 的连接是全双工（可以同时发送和接收）的连接，因此在关闭连接的时候，必须关闭传送和接收两个方向上的连接。<br>客户端给服务器发送一个携带 FIN 的 TCP 结束报文段，然后服务器返回给客户端一个 确认报文段，同时发送一个 结束报文段，当客户端回复一个 确认报文段 之后，连接就结束了。    </p>\n<h3 id=\"释放连接过程\"><a href=\"#释放连接过程\" class=\"headerlink\" title=\"释放连接过程\"></a>释放连接过程</h3><p>在结束之前，通信双方都是处于 <strong>ESTABLISHED</strong> 状态，然后其中一方主动断开连接。<br>下面假如客户端先主动断开连接。    </p>\n<p><strong>第一次挥手：</strong><br>客户端向服务器发送结束报文段，然后进入 <strong>FIN_WAIT_1</strong> 状态。<br>此报文段 FIN = 1， Sequence Number = M。    </p>\n<p><strong>第二次挥手：</strong><br>服务端收到客户端的结束报文段，然后发送确认报文段，进入 <strong>CLOSE_WAIT</strong> 状态。<br>此报文段 ACK = 1， Sequence Number = M + 1。    </p>\n<p>客户端收到该报文，会进入 <strong>FIN_WAIT_2</strong> 状态。    </p>\n<p><strong>第三次挥手：</strong><br>同时服务端向客户端发送结束报文段，然后进入 <strong>LAST_ACK</strong> 状态。<br>此报文段 FIN = 1，Sequence Number = N。    </p>\n<p><strong>第四次挥手：</strong><br>客户端收到服务端的结束报文段，然后发送确认报文段，进入 <strong>TIME_WAIT</strong> 状态，经过 2MSL 之后，自动进入 <strong>CLOSED</strong> 状态。<br>此报文段 ACK = 1, Sequence Number = N + 1。    </p>\n<p>服务端收到该报文之后，进入 <strong>CLOSED</strong> 状态。    </p>\n<p><strong>关于 TIME_WAIT 过渡到 CLOSED 状态说明</strong>：<br>从 <strong>TIME_WAIT</strong> 进入 <strong>CLOSED</strong> 需要经过 2MSL，其中 MSL 就叫做 最长报文段寿命（Maxinum Segment Lifetime），根据 RFC 793 建议该值这是为 2 分钟，也就是说需要经过 4 分钟，才进入 <strong>CLOSED</strong> 状态。    </p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://book.douban.com/subject/26850616/\" target=\"_blank\" rel=\"external\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\" target=\"_blank\" rel=\"external\">《计算机网络》</a></p>\n","excerpt":"","more":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<p>TCP 的整个交流过程可以总结为：先建立连接，然后传输数据，最后释放链接。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/08EAF7F3E7FFCEF3E781385BF62BA2BC.png\" alt=\"三次握手和四次挥手.png\"></p>\n<h2 id=\"三次握手，建立连接\"><a href=\"#三次握手，建立连接\" class=\"headerlink\" title=\"三次握手，建立连接\"></a>三次握手，建立连接</h2><p>TCP 连接建立要解决的首要问题就是：<strong>要使每一方能够确知对方的存在。</strong>    </p>\n<p>三次握手就像，在一个黑暗的森林，你知道前方十点钟方向好像有人。<br>你喊了一句：Hello？I’am JerryC，Who are you？<br>对面回了一句：Hi! I’am David, and nice to meet you!<br>然后你回了一句：Nice to meet you too!<br>……(自此，你们才算真正认识了双方，开始了后面省略3000字的谈话)    </p>\n<p>所以说，两个人需要交朋友（两个端点需要建立连接），至少需要三次的通话（握手）    </p>\n<p>其实，网络上的传输是没有连接的，TCP 也是一样的。<br>而 TCP 所谓的「连接」，其实只不过是在通信的双方维护一个「连接状态」，让它看上去好像有连接一样。    </p>\n<h3 id=\"连接建立过程\"><a href=\"#连接建立过程\" class=\"headerlink\" title=\"连接建立过程\"></a>连接建立过程</h3><p>TCP 连接的建立采用客户服务器方式，主动发起连接建立的一方叫<strong>客户端（Client）</strong>，被动等待连接建立的一方叫<strong>服务器（Server）</strong>。    </p>\n<p>最初的时候，两端都处于 <strong>CLOSED</strong> 的状态，然后服务器打开了 TCP 服务，进入 <strong>LISTEN</strong> 状态，监听特定端口，等待客户端的 TCP 请求。    </p>\n<p><strong>第一次握手</strong>：<br>客户端主动打开连接，发送 TCP 报文，进行第一次握手，然后进入 <strong>SYN_SEND</strong> 状态，等待服务器发回确认报文。<br>这时首部的同步位 SYN = 1，同时初始化一个序号 Sequence Number = J。<br>TCP 规定，SYN 报文段不能携带数据，但会消耗一个序号。    </p>\n<p><strong>第二次握手</strong>：<br>服务器收到了 SYN 报文，如果同意建立连接，则向客户端发送一个确认报文，然后服务器进入 <strong>SYN_RCVD</strong> 状态。<br>这时首部的 SYN = 1，ACK = 1，而确认号 Acknowledgemt Number = J + 1，同时也为自己初始化一个序号 Sequence Number = K。<br>这个报文同样不携带数据。    </p>\n<p><strong>第三次握手</strong>：<br>客户端收到了服务器发过来的确认报文，还要向服务器给出确认，然后进入 <strong>ESTABLISHED</strong> 状态。<br>这时首部的 SYN 不再置为 1，而 ACK = 1，确认号 Acknowledgemt Number = K + 1，序号 Sequence Number = J + 1。<br>第三次握手，一般会携带真正需要传输的数据，当服务器收到该数据报文的时候，就会同样进入 <strong>ESTABLISHED</strong> 状态。<br>此时，TCP 连接已经建立。    </p>\n<p>对于建立连接的三次握手，主要目的是初始化序号 Sequence Number，并且通信的双方都需要告知对方自己的初始化序号，所以这个过程也叫 SYN。<br>这个序号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，因为TCP 会用这个序号来拼接数据。    </p>\n<h3 id=\"利用连接设计缺陷实施-TCP-Flood-攻击\"><a href=\"#利用连接设计缺陷实施-TCP-Flood-攻击\" class=\"headerlink\" title=\"利用连接设计缺陷实施 TCP Flood 攻击\"></a>利用连接设计缺陷实施 TCP Flood 攻击</h3><p>知道了 TCP 建立一个连接，需要进行三次握手。<br>但如果你开始思考「三次握手的必要性」的时候，就会知道，其实网络是很复杂的，一个信息在途中丢失的可能性是有的。<br>如果数据丢失了，那么，就需要重新发送，这时候就要知道数据是否真的送达了。<br>这就是三次握手的必要性。<br>但是再向深一层思考，你给我发信息，我收到了，我回复，因为我是君子。<br>如果是小人，你给我发信息，我就算收到了，我也不回复，你就一直等我着我的回复。<br>那么很多小人都这样做，你就要一直记住你在等待着小人1号、小人2号、小人3号……直到你的脑容量爆棚，烧坏脑袋。<br>黑客就是利用这样的设计缺陷，实施 TCP Flood 攻击，属于 DDOS 攻击的一种。<br>想了解更多 SYN Flood 攻击请看：<a href=\"https://www.wikiwand.com/en/SYN_flood\">SYN flood - wiki</a> </p>\n<h2 id=\"四次挥手，释放连接\"><a href=\"#四次挥手，释放连接\" class=\"headerlink\" title=\"四次挥手，释放连接\"></a>四次挥手，释放连接</h2><p>TCP 有一个特别的概念叫做<strong>半关闭</strong>，这个概念是说，TCP 的连接是全双工（可以同时发送和接收）的连接，因此在关闭连接的时候，必须关闭传送和接收两个方向上的连接。<br>客户端给服务器发送一个携带 FIN 的 TCP 结束报文段，然后服务器返回给客户端一个 确认报文段，同时发送一个 结束报文段，当客户端回复一个 确认报文段 之后，连接就结束了。    </p>\n<h3 id=\"释放连接过程\"><a href=\"#释放连接过程\" class=\"headerlink\" title=\"释放连接过程\"></a>释放连接过程</h3><p>在结束之前，通信双方都是处于 <strong>ESTABLISHED</strong> 状态，然后其中一方主动断开连接。<br>下面假如客户端先主动断开连接。    </p>\n<p><strong>第一次挥手：</strong><br>客户端向服务器发送结束报文段，然后进入 <strong>FIN_WAIT_1</strong> 状态。<br>此报文段 FIN = 1， Sequence Number = M。    </p>\n<p><strong>第二次挥手：</strong><br>服务端收到客户端的结束报文段，然后发送确认报文段，进入 <strong>CLOSE_WAIT</strong> 状态。<br>此报文段 ACK = 1， Sequence Number = M + 1。    </p>\n<p>客户端收到该报文，会进入 <strong>FIN_WAIT_2</strong> 状态。    </p>\n<p><strong>第三次挥手：</strong><br>同时服务端向客户端发送结束报文段，然后进入 <strong>LAST_ACK</strong> 状态。<br>此报文段 FIN = 1，Sequence Number = N。    </p>\n<p><strong>第四次挥手：</strong><br>客户端收到服务端的结束报文段，然后发送确认报文段，进入 <strong>TIME_WAIT</strong> 状态，经过 2MSL 之后，自动进入 <strong>CLOSED</strong> 状态。<br>此报文段 ACK = 1, Sequence Number = N + 1。    </p>\n<p>服务端收到该报文之后，进入 <strong>CLOSED</strong> 状态。    </p>\n<p><strong>关于 TIME_WAIT 过渡到 CLOSED 状态说明</strong>：<br>从 <strong>TIME_WAIT</strong> 进入 <strong>CLOSED</strong> 需要经过 2MSL，其中 MSL 就叫做 最长报文段寿命（Maxinum Segment Lifetime），根据 RFC 793 建议该值这是为 2 分钟，也就是说需要经过 4 分钟，才进入 <strong>CLOSED</strong> 状态。    </p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://book.douban.com/subject/26850616/\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\">《计算机网络》</a></p>\n"},{"title":"理解TCP（二）：报文结构","date":"2017-03-02T07:57:25.000Z","_content":"\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\nTCP 是面向字节流的，但传送的数据单元却是报文段。\n\n**什么是报文？**    \n例如一个 100kb 的 HTML 文档需要传送到另外一台计算机，并不会整个文档直接传送过去，可能会切割成几个部分，比如四个分别为 25kb 的数据段。    \n而每个数据段再加上一个 TCP 首部，就组成了 TCP 报文。    \n一共四个 TCP 报文，发送到另外一个端。    \n另外一端收到数据包，然后再剔除 TCP 首部，组装起来。    \n等到四个数据包都收到了，就能还原出来一个完整的 HTML 文档了。    \n\n在 OSI 的七层协议中，第二层（数据链路层）的数据叫「Frame」，第三层（网络层）上的数据叫「Packet」，第四层（传输层）的数据叫「Segment」。\n\nTCP 报文 (Segment)，包括首部和数据部分。    \n\n![报文结构.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/3A60080FBC8767DB575C2D2919097613.png)\n\n而 TCP 的全部功能都体现在它首部中各字段的作用，只有弄清 TCP 首部各字段的作用才能掌握 TCP 的工作原理。    \nTCP 报文段首部的前20个字节是固定的，后面有 4N 字节是根据需要而增加的。    \n下图是把 TCP 报文中的首部放大来看。    \n\n![报文首部结构.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/CFC6314E4B2FD039C450821D946E93E2.png)\n\nTCP 的首部包括以下内容：    \n\n1. 源端口 source port    \n2. 目的端口 destination port    \n3. 序号 sequence number    \n4. 确认号 acknowledgment number    \n5. 数据偏移 offset    \n6. 保留 reserved    \n7. 标志位 tcp flags    \n8. 窗口大小 window size    \n9. 检验和 checksum    \n10. 紧急指针 urgent pointer    \n11. 选项 tcp options    \n\n下面展开来描述个字段的意义和作用。    \n\n## TCP 首部各字段的意义和作用\n\n### 源端口和目的端口 Port\n各占 2 个 字节，共 4 个字节。    \n用来告知主机该报文段是来自哪里以及传送给哪个应用程序（应用程序绑定了端口）的。    \n进行 TCP 通讯时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。    \n\n### 序号 Sequence Number\n占 4 个字节。    \nTCP 是面向字节流的，在一个 TCP 连接中传输的字节流中的每个字节都按照顺序编号。    \n例如 100 kb 的 HTML 文档数据，一共 102400 (100 * 1024) 个字节，那么每一个字节就都有了编号，整个文档的编号的范围是 0 ~ 102399。    \n\n序号字段值指的是**本报文段**所发送的数据的第一个字节的序号。    \n那么 100 的 HTML 文档分割成四个等分之后，    \n第一个 TCP 报文段包含的是第一个 25kb 的数据，0 ~ 25599 字节， 该报文的序号的值就是：0    \n第二个 TCP 报文段包含的是第二个 25kb 的数据，25600 ~ 51199 字节，该报文的序号的值就是：25600    \n......    \n\n根据 8 位 = 1 字节，那么 4 个字节可以表示的数值范围：[0, 2^32]，一共 2^32 (4294967296) 个序号。    \n序号增加到最大值的时候，下一个序号又回到了 0.    \n也就是说 TCP 协议可对 4GB  的数据进行编号，在一般情况下可保证当序号重复使用时，旧序号的数据早已经通过网络到达终点或者丢失了。    \n\n### 确认号 Acknowledgemt Number\n占 4 个字节。    \n表示**期望收到对方下一个报文段的序号值**。    \nTCP 的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。    \n就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。    \n**那么，确认报文，就会包含确认号**。    \n例如，通讯的一方收到了第一个 25kb 的报文，该报文的 序号值=0，那么就需要回复一个**确认报文**，其中的确认号 = 25600.    \n\n### 数据偏移 Offset\n占 0.5 个字节 (4 位)。    \n这个字段实际上是指出了 **TCP 报文段的首部长度** ，它指出了 TCP报文段的数据起始处 距离 TCP报文的起始处 有多远。（注意 数据起始处 和 报文起始处 的意思）    \n\n一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大长度。    \n\n### 保留 Reserved\n占 0.75 个字节 (6 位)。    \n保留为今后使用，但目前应置为 0。    \n\n### 标志位 TCP Flags\n标志位，一共有 6 个，分别占 1 位，共 6 位 。    \n每一位的值只有 0 和 1，分别表达不同意思。    \n\n#### 紧急 URG (Urgent)\n当 URG = 1 的时候，表示紧急指针（Urgent Pointer）有效。    \n它告诉系统此报文段中有紧急数据，应尽快传送，而不要按原来的排队顺序来传送。    \nURG 要与首部中的 紧急指针 字段配合使用。    \n\n#### 确认 ACK (Acknowlegemt)\n当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。    \n一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。    \nTCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。    \n\n#### 推送 PSH (Push)\n当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。    \n\n#### 复位 RST (Reset)\n当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。    \n一般称携带 RST 标志的 TCP 报文段为「复位报文段」。    \n\n#### 同步 SYN (SYNchronization)\n当 SYN = 1 的时候，表明这是一个请求连接报文段。    \n一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。    \n在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。    \n对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。    \n\n#### 终止 FIN (Finis)\n当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。    \n一般称携带 FIN 的报文段为「结束报文段」。    \n在 TCP 四次挥手释放连接的时候，就会用到该标志。    \n\n### 窗口大小 Window Size\n占 2 字节。    \n该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。    \n窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。    \n例如，假如确认号是 701 ，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。    \n\n### 校验和 TCP Checksum\n占 2 个字节。    \n由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。    \n检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。    \n\n### 紧急指针 Urgent Pointer\n占 2 个字节。    \n仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。    \n当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的**最前面**，而在紧急数据后面的数据仍是普通数据。    \n因此，紧急指针指出了紧急数据的末尾在报文段中的位置。    \n\n# 参考\n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)ect/2970300/)","source":"_posts/understand-tcp-2.md","raw":"---\ntitle: 理解TCP（二）：报文结构\ncategory: 搬砖码农\ndate: 2017-03-02 15:57:25\ntags: \n- tcp\n---\n\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\nTCP 是面向字节流的，但传送的数据单元却是报文段。\n\n**什么是报文？**    \n例如一个 100kb 的 HTML 文档需要传送到另外一台计算机，并不会整个文档直接传送过去，可能会切割成几个部分，比如四个分别为 25kb 的数据段。    \n而每个数据段再加上一个 TCP 首部，就组成了 TCP 报文。    \n一共四个 TCP 报文，发送到另外一个端。    \n另外一端收到数据包，然后再剔除 TCP 首部，组装起来。    \n等到四个数据包都收到了，就能还原出来一个完整的 HTML 文档了。    \n\n在 OSI 的七层协议中，第二层（数据链路层）的数据叫「Frame」，第三层（网络层）上的数据叫「Packet」，第四层（传输层）的数据叫「Segment」。\n\nTCP 报文 (Segment)，包括首部和数据部分。    \n\n![报文结构.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/3A60080FBC8767DB575C2D2919097613.png)\n\n而 TCP 的全部功能都体现在它首部中各字段的作用，只有弄清 TCP 首部各字段的作用才能掌握 TCP 的工作原理。    \nTCP 报文段首部的前20个字节是固定的，后面有 4N 字节是根据需要而增加的。    \n下图是把 TCP 报文中的首部放大来看。    \n\n![报文首部结构.png](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/CFC6314E4B2FD039C450821D946E93E2.png)\n\nTCP 的首部包括以下内容：    \n\n1. 源端口 source port    \n2. 目的端口 destination port    \n3. 序号 sequence number    \n4. 确认号 acknowledgment number    \n5. 数据偏移 offset    \n6. 保留 reserved    \n7. 标志位 tcp flags    \n8. 窗口大小 window size    \n9. 检验和 checksum    \n10. 紧急指针 urgent pointer    \n11. 选项 tcp options    \n\n下面展开来描述个字段的意义和作用。    \n\n## TCP 首部各字段的意义和作用\n\n### 源端口和目的端口 Port\n各占 2 个 字节，共 4 个字节。    \n用来告知主机该报文段是来自哪里以及传送给哪个应用程序（应用程序绑定了端口）的。    \n进行 TCP 通讯时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。    \n\n### 序号 Sequence Number\n占 4 个字节。    \nTCP 是面向字节流的，在一个 TCP 连接中传输的字节流中的每个字节都按照顺序编号。    \n例如 100 kb 的 HTML 文档数据，一共 102400 (100 * 1024) 个字节，那么每一个字节就都有了编号，整个文档的编号的范围是 0 ~ 102399。    \n\n序号字段值指的是**本报文段**所发送的数据的第一个字节的序号。    \n那么 100 的 HTML 文档分割成四个等分之后，    \n第一个 TCP 报文段包含的是第一个 25kb 的数据，0 ~ 25599 字节， 该报文的序号的值就是：0    \n第二个 TCP 报文段包含的是第二个 25kb 的数据，25600 ~ 51199 字节，该报文的序号的值就是：25600    \n......    \n\n根据 8 位 = 1 字节，那么 4 个字节可以表示的数值范围：[0, 2^32]，一共 2^32 (4294967296) 个序号。    \n序号增加到最大值的时候，下一个序号又回到了 0.    \n也就是说 TCP 协议可对 4GB  的数据进行编号，在一般情况下可保证当序号重复使用时，旧序号的数据早已经通过网络到达终点或者丢失了。    \n\n### 确认号 Acknowledgemt Number\n占 4 个字节。    \n表示**期望收到对方下一个报文段的序号值**。    \nTCP 的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。    \n就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。    \n**那么，确认报文，就会包含确认号**。    \n例如，通讯的一方收到了第一个 25kb 的报文，该报文的 序号值=0，那么就需要回复一个**确认报文**，其中的确认号 = 25600.    \n\n### 数据偏移 Offset\n占 0.5 个字节 (4 位)。    \n这个字段实际上是指出了 **TCP 报文段的首部长度** ，它指出了 TCP报文段的数据起始处 距离 TCP报文的起始处 有多远。（注意 数据起始处 和 报文起始处 的意思）    \n\n一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大长度。    \n\n### 保留 Reserved\n占 0.75 个字节 (6 位)。    \n保留为今后使用，但目前应置为 0。    \n\n### 标志位 TCP Flags\n标志位，一共有 6 个，分别占 1 位，共 6 位 。    \n每一位的值只有 0 和 1，分别表达不同意思。    \n\n#### 紧急 URG (Urgent)\n当 URG = 1 的时候，表示紧急指针（Urgent Pointer）有效。    \n它告诉系统此报文段中有紧急数据，应尽快传送，而不要按原来的排队顺序来传送。    \nURG 要与首部中的 紧急指针 字段配合使用。    \n\n#### 确认 ACK (Acknowlegemt)\n当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。    \n一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。    \nTCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。    \n\n#### 推送 PSH (Push)\n当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。    \n\n#### 复位 RST (Reset)\n当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。    \n一般称携带 RST 标志的 TCP 报文段为「复位报文段」。    \n\n#### 同步 SYN (SYNchronization)\n当 SYN = 1 的时候，表明这是一个请求连接报文段。    \n一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。    \n在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。    \n对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。    \n\n#### 终止 FIN (Finis)\n当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。    \n一般称携带 FIN 的报文段为「结束报文段」。    \n在 TCP 四次挥手释放连接的时候，就会用到该标志。    \n\n### 窗口大小 Window Size\n占 2 字节。    \n该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。    \n窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。    \n例如，假如确认号是 701 ，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。    \n\n### 校验和 TCP Checksum\n占 2 个字节。    \n由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。    \n检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。    \n\n### 紧急指针 Urgent Pointer\n占 2 个字节。    \n仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。    \n当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的**最前面**，而在紧急数据后面的数据仍是普通数据。    \n因此，紧急指针指出了紧急数据的末尾在报文段中的位置。    \n\n# 参考\n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)ect/2970300/)","slug":"understand-tcp-2","published":1,"updated":"2020-12-13T13:47:15.663Z","_id":"cl270y8sk004axwrlbyiywa0f","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\" target=\"_blank\" rel=\"external\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<p>TCP 是面向字节流的，但传送的数据单元却是报文段。</p>\n<p><strong>什么是报文？</strong><br>例如一个 100kb 的 HTML 文档需要传送到另外一台计算机，并不会整个文档直接传送过去，可能会切割成几个部分，比如四个分别为 25kb 的数据段。<br>而每个数据段再加上一个 TCP 首部，就组成了 TCP 报文。<br>一共四个 TCP 报文，发送到另外一个端。<br>另外一端收到数据包，然后再剔除 TCP 首部，组装起来。<br>等到四个数据包都收到了，就能还原出来一个完整的 HTML 文档了。    </p>\n<p>在 OSI 的七层协议中，第二层（数据链路层）的数据叫「Frame」，第三层（网络层）上的数据叫「Packet」，第四层（传输层）的数据叫「Segment」。</p>\n<p>TCP 报文 (Segment)，包括首部和数据部分。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/3A60080FBC8767DB575C2D2919097613.png\" alt=\"报文结构.png\"></p>\n<p>而 TCP 的全部功能都体现在它首部中各字段的作用，只有弄清 TCP 首部各字段的作用才能掌握 TCP 的工作原理。<br>TCP 报文段首部的前20个字节是固定的，后面有 4N 字节是根据需要而增加的。<br>下图是把 TCP 报文中的首部放大来看。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/CFC6314E4B2FD039C450821D946E93E2.png\" alt=\"报文首部结构.png\"></p>\n<p>TCP 的首部包括以下内容：    </p>\n<ol>\n<li>源端口 source port    </li>\n<li>目的端口 destination port    </li>\n<li>序号 sequence number    </li>\n<li>确认号 acknowledgment number    </li>\n<li>数据偏移 offset    </li>\n<li>保留 reserved    </li>\n<li>标志位 tcp flags    </li>\n<li>窗口大小 window size    </li>\n<li>检验和 checksum    </li>\n<li>紧急指针 urgent pointer    </li>\n<li>选项 tcp options    </li>\n</ol>\n<p>下面展开来描述个字段的意义和作用。    </p>\n<h2 id=\"TCP-首部各字段的意义和作用\"><a href=\"#TCP-首部各字段的意义和作用\" class=\"headerlink\" title=\"TCP 首部各字段的意义和作用\"></a>TCP 首部各字段的意义和作用</h2><h3 id=\"源端口和目的端口-Port\"><a href=\"#源端口和目的端口-Port\" class=\"headerlink\" title=\"源端口和目的端口 Port\"></a>源端口和目的端口 Port</h3><p>各占 2 个 字节，共 4 个字节。<br>用来告知主机该报文段是来自哪里以及传送给哪个应用程序（应用程序绑定了端口）的。<br>进行 TCP 通讯时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。    </p>\n<h3 id=\"序号-Sequence-Number\"><a href=\"#序号-Sequence-Number\" class=\"headerlink\" title=\"序号 Sequence Number\"></a>序号 Sequence Number</h3><p>占 4 个字节。<br>TCP 是面向字节流的，在一个 TCP 连接中传输的字节流中的每个字节都按照顺序编号。<br>例如 100 kb 的 HTML 文档数据，一共 102400 (100 * 1024) 个字节，那么每一个字节就都有了编号，整个文档的编号的范围是 0 ~ 102399。    </p>\n<p>序号字段值指的是<strong>本报文段</strong>所发送的数据的第一个字节的序号。<br>那么 100 的 HTML 文档分割成四个等分之后，<br>第一个 TCP 报文段包含的是第一个 25kb 的数据，0 ~ 25599 字节， 该报文的序号的值就是：0<br>第二个 TCP 报文段包含的是第二个 25kb 的数据，25600 ~ 51199 字节，该报文的序号的值就是：25600<br>……    </p>\n<p>根据 8 位 = 1 字节，那么 4 个字节可以表示的数值范围：[0, 2^32]，一共 2^32 (4294967296) 个序号。<br>序号增加到最大值的时候，下一个序号又回到了 0.<br>也就是说 TCP 协议可对 4GB  的数据进行编号，在一般情况下可保证当序号重复使用时，旧序号的数据早已经通过网络到达终点或者丢失了。    </p>\n<h3 id=\"确认号-Acknowledgemt-Number\"><a href=\"#确认号-Acknowledgemt-Number\" class=\"headerlink\" title=\"确认号 Acknowledgemt Number\"></a>确认号 Acknowledgemt Number</h3><p>占 4 个字节。<br>表示<strong>期望收到对方下一个报文段的序号值</strong>。<br>TCP 的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。<br>就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。<br><strong>那么，确认报文，就会包含确认号</strong>。<br>例如，通讯的一方收到了第一个 25kb 的报文，该报文的 序号值=0，那么就需要回复一个<strong>确认报文</strong>，其中的确认号 = 25600.    </p>\n<h3 id=\"数据偏移-Offset\"><a href=\"#数据偏移-Offset\" class=\"headerlink\" title=\"数据偏移 Offset\"></a>数据偏移 Offset</h3><p>占 0.5 个字节 (4 位)。<br>这个字段实际上是指出了 <strong>TCP 报文段的首部长度</strong> ，它指出了 TCP报文段的数据起始处 距离 TCP报文的起始处 有多远。（注意 数据起始处 和 报文起始处 的意思）    </p>\n<p>一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大长度。    </p>\n<h3 id=\"保留-Reserved\"><a href=\"#保留-Reserved\" class=\"headerlink\" title=\"保留 Reserved\"></a>保留 Reserved</h3><p>占 0.75 个字节 (6 位)。<br>保留为今后使用，但目前应置为 0。    </p>\n<h3 id=\"标志位-TCP-Flags\"><a href=\"#标志位-TCP-Flags\" class=\"headerlink\" title=\"标志位 TCP Flags\"></a>标志位 TCP Flags</h3><p>标志位，一共有 6 个，分别占 1 位，共 6 位 。<br>每一位的值只有 0 和 1，分别表达不同意思。    </p>\n<h4 id=\"紧急-URG-Urgent\"><a href=\"#紧急-URG-Urgent\" class=\"headerlink\" title=\"紧急 URG (Urgent)\"></a>紧急 URG (Urgent)</h4><p>当 URG = 1 的时候，表示紧急指针（Urgent Pointer）有效。<br>它告诉系统此报文段中有紧急数据，应尽快传送，而不要按原来的排队顺序来传送。<br>URG 要与首部中的 紧急指针 字段配合使用。    </p>\n<h4 id=\"确认-ACK-Acknowlegemt\"><a href=\"#确认-ACK-Acknowlegemt\" class=\"headerlink\" title=\"确认 ACK (Acknowlegemt)\"></a>确认 ACK (Acknowlegemt)</h4><p>当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。<br>一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。<br>TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。    </p>\n<h4 id=\"推送-PSH-Push\"><a href=\"#推送-PSH-Push\" class=\"headerlink\" title=\"推送 PSH (Push)\"></a>推送 PSH (Push)</h4><p>当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。    </p>\n<h4 id=\"复位-RST-Reset\"><a href=\"#复位-RST-Reset\" class=\"headerlink\" title=\"复位 RST (Reset)\"></a>复位 RST (Reset)</h4><p>当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。<br>一般称携带 RST 标志的 TCP 报文段为「复位报文段」。    </p>\n<h4 id=\"同步-SYN-SYNchronization\"><a href=\"#同步-SYN-SYNchronization\" class=\"headerlink\" title=\"同步 SYN (SYNchronization)\"></a>同步 SYN (SYNchronization)</h4><p>当 SYN = 1 的时候，表明这是一个请求连接报文段。<br>一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。<br>在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。<br>对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。    </p>\n<h4 id=\"终止-FIN-Finis\"><a href=\"#终止-FIN-Finis\" class=\"headerlink\" title=\"终止 FIN (Finis)\"></a>终止 FIN (Finis)</h4><p>当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。<br>一般称携带 FIN 的报文段为「结束报文段」。<br>在 TCP 四次挥手释放连接的时候，就会用到该标志。    </p>\n<h3 id=\"窗口大小-Window-Size\"><a href=\"#窗口大小-Window-Size\" class=\"headerlink\" title=\"窗口大小 Window Size\"></a>窗口大小 Window Size</h3><p>占 2 字节。<br>该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。<br>窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。<br>例如，假如确认号是 701 ，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。    </p>\n<h3 id=\"校验和-TCP-Checksum\"><a href=\"#校验和-TCP-Checksum\" class=\"headerlink\" title=\"校验和 TCP Checksum\"></a>校验和 TCP Checksum</h3><p>占 2 个字节。<br>由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。<br>检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。    </p>\n<h3 id=\"紧急指针-Urgent-Pointer\"><a href=\"#紧急指针-Urgent-Pointer\" class=\"headerlink\" title=\"紧急指针 Urgent Pointer\"></a>紧急指针 Urgent Pointer</h3><p>占 2 个字节。<br>仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。<br>当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的<strong>最前面</strong>，而在紧急数据后面的数据仍是普通数据。<br>因此，紧急指针指出了紧急数据的末尾在报文段中的位置。    </p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://book.douban.com/subject/26850616/\" target=\"_blank\" rel=\"external\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\" target=\"_blank\" rel=\"external\">《计算机网络》</a>ect/2970300/)</p>\n","excerpt":"","more":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<p>TCP 是面向字节流的，但传送的数据单元却是报文段。</p>\n<p><strong>什么是报文？</strong><br>例如一个 100kb 的 HTML 文档需要传送到另外一台计算机，并不会整个文档直接传送过去，可能会切割成几个部分，比如四个分别为 25kb 的数据段。<br>而每个数据段再加上一个 TCP 首部，就组成了 TCP 报文。<br>一共四个 TCP 报文，发送到另外一个端。<br>另外一端收到数据包，然后再剔除 TCP 首部，组装起来。<br>等到四个数据包都收到了，就能还原出来一个完整的 HTML 文档了。    </p>\n<p>在 OSI 的七层协议中，第二层（数据链路层）的数据叫「Frame」，第三层（网络层）上的数据叫「Packet」，第四层（传输层）的数据叫「Segment」。</p>\n<p>TCP 报文 (Segment)，包括首部和数据部分。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/3A60080FBC8767DB575C2D2919097613.png\" alt=\"报文结构.png\"></p>\n<p>而 TCP 的全部功能都体现在它首部中各字段的作用，只有弄清 TCP 首部各字段的作用才能掌握 TCP 的工作原理。<br>TCP 报文段首部的前20个字节是固定的，后面有 4N 字节是根据需要而增加的。<br>下图是把 TCP 报文中的首部放大来看。    </p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/CFC6314E4B2FD039C450821D946E93E2.png\" alt=\"报文首部结构.png\"></p>\n<p>TCP 的首部包括以下内容：    </p>\n<ol>\n<li>源端口 source port    </li>\n<li>目的端口 destination port    </li>\n<li>序号 sequence number    </li>\n<li>确认号 acknowledgment number    </li>\n<li>数据偏移 offset    </li>\n<li>保留 reserved    </li>\n<li>标志位 tcp flags    </li>\n<li>窗口大小 window size    </li>\n<li>检验和 checksum    </li>\n<li>紧急指针 urgent pointer    </li>\n<li>选项 tcp options    </li>\n</ol>\n<p>下面展开来描述个字段的意义和作用。    </p>\n<h2 id=\"TCP-首部各字段的意义和作用\"><a href=\"#TCP-首部各字段的意义和作用\" class=\"headerlink\" title=\"TCP 首部各字段的意义和作用\"></a>TCP 首部各字段的意义和作用</h2><h3 id=\"源端口和目的端口-Port\"><a href=\"#源端口和目的端口-Port\" class=\"headerlink\" title=\"源端口和目的端口 Port\"></a>源端口和目的端口 Port</h3><p>各占 2 个 字节，共 4 个字节。<br>用来告知主机该报文段是来自哪里以及传送给哪个应用程序（应用程序绑定了端口）的。<br>进行 TCP 通讯时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。    </p>\n<h3 id=\"序号-Sequence-Number\"><a href=\"#序号-Sequence-Number\" class=\"headerlink\" title=\"序号 Sequence Number\"></a>序号 Sequence Number</h3><p>占 4 个字节。<br>TCP 是面向字节流的，在一个 TCP 连接中传输的字节流中的每个字节都按照顺序编号。<br>例如 100 kb 的 HTML 文档数据，一共 102400 (100 * 1024) 个字节，那么每一个字节就都有了编号，整个文档的编号的范围是 0 ~ 102399。    </p>\n<p>序号字段值指的是<strong>本报文段</strong>所发送的数据的第一个字节的序号。<br>那么 100 的 HTML 文档分割成四个等分之后，<br>第一个 TCP 报文段包含的是第一个 25kb 的数据，0 ~ 25599 字节， 该报文的序号的值就是：0<br>第二个 TCP 报文段包含的是第二个 25kb 的数据，25600 ~ 51199 字节，该报文的序号的值就是：25600<br>……    </p>\n<p>根据 8 位 = 1 字节，那么 4 个字节可以表示的数值范围：[0, 2^32]，一共 2^32 (4294967296) 个序号。<br>序号增加到最大值的时候，下一个序号又回到了 0.<br>也就是说 TCP 协议可对 4GB  的数据进行编号，在一般情况下可保证当序号重复使用时，旧序号的数据早已经通过网络到达终点或者丢失了。    </p>\n<h3 id=\"确认号-Acknowledgemt-Number\"><a href=\"#确认号-Acknowledgemt-Number\" class=\"headerlink\" title=\"确认号 Acknowledgemt Number\"></a>确认号 Acknowledgemt Number</h3><p>占 4 个字节。<br>表示<strong>期望收到对方下一个报文段的序号值</strong>。<br>TCP 的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。<br>就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。<br><strong>那么，确认报文，就会包含确认号</strong>。<br>例如，通讯的一方收到了第一个 25kb 的报文，该报文的 序号值=0，那么就需要回复一个<strong>确认报文</strong>，其中的确认号 = 25600.    </p>\n<h3 id=\"数据偏移-Offset\"><a href=\"#数据偏移-Offset\" class=\"headerlink\" title=\"数据偏移 Offset\"></a>数据偏移 Offset</h3><p>占 0.5 个字节 (4 位)。<br>这个字段实际上是指出了 <strong>TCP 报文段的首部长度</strong> ，它指出了 TCP报文段的数据起始处 距离 TCP报文的起始处 有多远。（注意 数据起始处 和 报文起始处 的意思）    </p>\n<p>一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大长度。    </p>\n<h3 id=\"保留-Reserved\"><a href=\"#保留-Reserved\" class=\"headerlink\" title=\"保留 Reserved\"></a>保留 Reserved</h3><p>占 0.75 个字节 (6 位)。<br>保留为今后使用，但目前应置为 0。    </p>\n<h3 id=\"标志位-TCP-Flags\"><a href=\"#标志位-TCP-Flags\" class=\"headerlink\" title=\"标志位 TCP Flags\"></a>标志位 TCP Flags</h3><p>标志位，一共有 6 个，分别占 1 位，共 6 位 。<br>每一位的值只有 0 和 1，分别表达不同意思。    </p>\n<h4 id=\"紧急-URG-Urgent\"><a href=\"#紧急-URG-Urgent\" class=\"headerlink\" title=\"紧急 URG (Urgent)\"></a>紧急 URG (Urgent)</h4><p>当 URG = 1 的时候，表示紧急指针（Urgent Pointer）有效。<br>它告诉系统此报文段中有紧急数据，应尽快传送，而不要按原来的排队顺序来传送。<br>URG 要与首部中的 紧急指针 字段配合使用。    </p>\n<h4 id=\"确认-ACK-Acknowlegemt\"><a href=\"#确认-ACK-Acknowlegemt\" class=\"headerlink\" title=\"确认 ACK (Acknowlegemt)\"></a>确认 ACK (Acknowlegemt)</h4><p>当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。<br>一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。<br>TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。    </p>\n<h4 id=\"推送-PSH-Push\"><a href=\"#推送-PSH-Push\" class=\"headerlink\" title=\"推送 PSH (Push)\"></a>推送 PSH (Push)</h4><p>当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。    </p>\n<h4 id=\"复位-RST-Reset\"><a href=\"#复位-RST-Reset\" class=\"headerlink\" title=\"复位 RST (Reset)\"></a>复位 RST (Reset)</h4><p>当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。<br>一般称携带 RST 标志的 TCP 报文段为「复位报文段」。    </p>\n<h4 id=\"同步-SYN-SYNchronization\"><a href=\"#同步-SYN-SYNchronization\" class=\"headerlink\" title=\"同步 SYN (SYNchronization)\"></a>同步 SYN (SYNchronization)</h4><p>当 SYN = 1 的时候，表明这是一个请求连接报文段。<br>一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。<br>在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。<br>对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。    </p>\n<h4 id=\"终止-FIN-Finis\"><a href=\"#终止-FIN-Finis\" class=\"headerlink\" title=\"终止 FIN (Finis)\"></a>终止 FIN (Finis)</h4><p>当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。<br>一般称携带 FIN 的报文段为「结束报文段」。<br>在 TCP 四次挥手释放连接的时候，就会用到该标志。    </p>\n<h3 id=\"窗口大小-Window-Size\"><a href=\"#窗口大小-Window-Size\" class=\"headerlink\" title=\"窗口大小 Window Size\"></a>窗口大小 Window Size</h3><p>占 2 字节。<br>该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。<br>窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。<br>例如，假如确认号是 701 ，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。    </p>\n<h3 id=\"校验和-TCP-Checksum\"><a href=\"#校验和-TCP-Checksum\" class=\"headerlink\" title=\"校验和 TCP Checksum\"></a>校验和 TCP Checksum</h3><p>占 2 个字节。<br>由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。<br>检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。    </p>\n<h3 id=\"紧急指针-Urgent-Pointer\"><a href=\"#紧急指针-Urgent-Pointer\" class=\"headerlink\" title=\"紧急指针 Urgent Pointer\"></a>紧急指针 Urgent Pointer</h3><p>占 2 个字节。<br>仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。<br>当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的<strong>最前面</strong>，而在紧急数据后面的数据仍是普通数据。<br>因此，紧急指针指出了紧急数据的末尾在报文段中的位置。    </p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://book.douban.com/subject/26850616/\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\">《计算机网络》</a>ect/2970300/)</p>\n"},{"title":"理解TCP（一）：端口","date":"2017-03-02T07:56:25.000Z","_content":"\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\n## 端口与进程\nTCP 的包是不包含 IP 地址信息的，那是 IP 层上的事，但是有源端口和目的端口。    \n就是说，端口这一东西，是属于 TCP 知识范畴的。    \n\n我们知道两个进程，在计算机内部进行通信，可以有管道、内存共享、信号量、消息队列等方法。    \n而两个进程如果需要进行通讯最基本的一个前提是能够唯一的标识一个进程，在本地进程通讯中我们可以使用 **「PID(进程标识符)」** 来唯一标识一个进程。    \n但 PID 只在本地唯一，如果把两个进程放到了不同的两台计算机，然后他们要通信的话，PID 就不够用了，这样就需要另外一种手段了。    \n\n解决这个问题的方法就是在运输层使用 **「协议端口号 (protocol port number)」**，简称 **「端口 (port)」**.    \n我们知道 IP 层的 ip 地址可以唯一标识主机，而 TCP 层协议和端口号可以唯一标识主机的一个进程，这样我们可以利用：**「ip地址＋协议＋端口号」**唯一标示网络中的一个进程。    \n在一些场合，也把这种唯一标识的模式称为**「套接字 (Socket)」**。    \n\n这就是说，虽然通信的重点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的端口，剩下的工作就由 TCP 来完成了。    \n\n## 认识端口\nTCP 用一个 16 位端口号来标识一个端口，可允许有 65536 ( 2的16次方) 个不同的端口号，范围在 0 ~ 65535 之间。    \n\n端口号根据服务器使用还是客户端使用，以及常见不常见的维度来区分，主要有以下类别：\n\n1. 服务器端使用的端口号\n  - 熟知端口号\n  - 登记端口号\n2. 客户端使用的端口号\n\n下面展开来说说。    \n### 端口号的分类\n#### 服务器端使用的端口号\n**熟知端口号**：    \n取值范围：0 ~ 1023。    \n可以在 www.iana.org 查到，服务器机器一接通电源，服务器程序就运行起来，为了让因特网上所有的客户程序都能找到服务器程序，服务器程序所使用的端口就必须是固定的，并且总所众所周知的。    \n\n一些常见的端口号：    \n\n|应用程序 | FTP | TELNET | SMTP | DNS | TFTP | HTTP | HTTPS | SNMP |\n| ---| --- | --- |--- |--- |--- |--- |--- |--- |--- |--- |--- |\n|熟知端口号| **21** | 23 | 25 | 53 | 69 | **80** | **443** | 161 |\n\n**登记端口号**：    \n取值范围：1024 ~ 49151。    \n这类端口没有熟知的应用程序使用，但是需要登记，以防重复\n\n#### 客户端使用的端口号\n取值范围：49152 ~ 65535。    \n这类端口仅在客户端进程运行时才动态选择。    \n又叫 短暂端口号，表示这种端口的存在时间是短暂的，客户进程并不在意操作系统给它分配的是哪一个端口号，因为客户进程之所以必须有一个端口号，是为了让传输层的实体能够找到自己。    \n\n*PS：在`/etc/services`文件中可以查看所有知名服务使用的端口。*\n\n# 参考\n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)","source":"_posts/understand-tcp-1.md","raw":"---\ntitle: 理解TCP（一）：端口\ncategory: 搬砖码农\ndate: 2017-03-02 15:56:25\ntags: \n- tcp\n---\n\n> 更好阅读体验：[《理解 TCP 和 UDP》— By Gitbook](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/)    \n\n## 端口与进程\nTCP 的包是不包含 IP 地址信息的，那是 IP 层上的事，但是有源端口和目的端口。    \n就是说，端口这一东西，是属于 TCP 知识范畴的。    \n\n我们知道两个进程，在计算机内部进行通信，可以有管道、内存共享、信号量、消息队列等方法。    \n而两个进程如果需要进行通讯最基本的一个前提是能够唯一的标识一个进程，在本地进程通讯中我们可以使用 **「PID(进程标识符)」** 来唯一标识一个进程。    \n但 PID 只在本地唯一，如果把两个进程放到了不同的两台计算机，然后他们要通信的话，PID 就不够用了，这样就需要另外一种手段了。    \n\n解决这个问题的方法就是在运输层使用 **「协议端口号 (protocol port number)」**，简称 **「端口 (port)」**.    \n我们知道 IP 层的 ip 地址可以唯一标识主机，而 TCP 层协议和端口号可以唯一标识主机的一个进程，这样我们可以利用：**「ip地址＋协议＋端口号」**唯一标示网络中的一个进程。    \n在一些场合，也把这种唯一标识的模式称为**「套接字 (Socket)」**。    \n\n这就是说，虽然通信的重点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的端口，剩下的工作就由 TCP 来完成了。    \n\n## 认识端口\nTCP 用一个 16 位端口号来标识一个端口，可允许有 65536 ( 2的16次方) 个不同的端口号，范围在 0 ~ 65535 之间。    \n\n端口号根据服务器使用还是客户端使用，以及常见不常见的维度来区分，主要有以下类别：\n\n1. 服务器端使用的端口号\n  - 熟知端口号\n  - 登记端口号\n2. 客户端使用的端口号\n\n下面展开来说说。    \n### 端口号的分类\n#### 服务器端使用的端口号\n**熟知端口号**：    \n取值范围：0 ~ 1023。    \n可以在 www.iana.org 查到，服务器机器一接通电源，服务器程序就运行起来，为了让因特网上所有的客户程序都能找到服务器程序，服务器程序所使用的端口就必须是固定的，并且总所众所周知的。    \n\n一些常见的端口号：    \n\n|应用程序 | FTP | TELNET | SMTP | DNS | TFTP | HTTP | HTTPS | SNMP |\n| ---| --- | --- |--- |--- |--- |--- |--- |--- |--- |--- |--- |\n|熟知端口号| **21** | 23 | 25 | 53 | 69 | **80** | **443** | 161 |\n\n**登记端口号**：    \n取值范围：1024 ~ 49151。    \n这类端口没有熟知的应用程序使用，但是需要登记，以防重复\n\n#### 客户端使用的端口号\n取值范围：49152 ~ 65535。    \n这类端口仅在客户端进程运行时才动态选择。    \n又叫 短暂端口号，表示这种端口的存在时间是短暂的，客户进程并不在意操作系统给它分配的是哪一个端口号，因为客户进程之所以必须有一个端口号，是为了让传输层的实体能够找到自己。    \n\n*PS：在`/etc/services`文件中可以查看所有知名服务使用的端口。*\n\n# 参考\n[《后台开发 核心技术与应用实践》](https://book.douban.com/subject/26850616/)    \n[《计算机网络》](https://book.douban.com/subject/2970300/)","slug":"understand-tcp-1","published":1,"updated":"2018-05-01T16:16:02.082Z","_id":"cl270y8sk004dxwrlhgl6e6vx","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\" target=\"_blank\" rel=\"external\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<h2 id=\"端口与进程\"><a href=\"#端口与进程\" class=\"headerlink\" title=\"端口与进程\"></a>端口与进程</h2><p>TCP 的包是不包含 IP 地址信息的，那是 IP 层上的事，但是有源端口和目的端口。<br>就是说，端口这一东西，是属于 TCP 知识范畴的。    </p>\n<p>我们知道两个进程，在计算机内部进行通信，可以有管道、内存共享、信号量、消息队列等方法。<br>而两个进程如果需要进行通讯最基本的一个前提是能够唯一的标识一个进程，在本地进程通讯中我们可以使用 <strong>「PID(进程标识符)」</strong> 来唯一标识一个进程。<br>但 PID 只在本地唯一，如果把两个进程放到了不同的两台计算机，然后他们要通信的话，PID 就不够用了，这样就需要另外一种手段了。    </p>\n<p>解决这个问题的方法就是在运输层使用 <strong>「协议端口号 (protocol port number)」</strong>，简称 <strong>「端口 (port)」</strong>.<br>我们知道 IP 层的 ip 地址可以唯一标识主机，而 TCP 层协议和端口号可以唯一标识主机的一个进程，这样我们可以利用：<strong>「ip地址＋协议＋端口号」</strong>唯一标示网络中的一个进程。<br>在一些场合，也把这种唯一标识的模式称为<strong>「套接字 (Socket)」</strong>。    </p>\n<p>这就是说，虽然通信的重点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的端口，剩下的工作就由 TCP 来完成了。    </p>\n<h2 id=\"认识端口\"><a href=\"#认识端口\" class=\"headerlink\" title=\"认识端口\"></a>认识端口</h2><p>TCP 用一个 16 位端口号来标识一个端口，可允许有 65536 ( 2的16次方) 个不同的端口号，范围在 0 ~ 65535 之间。    </p>\n<p>端口号根据服务器使用还是客户端使用，以及常见不常见的维度来区分，主要有以下类别：</p>\n<ol>\n<li>服务器端使用的端口号<ul>\n<li>熟知端口号</li>\n<li>登记端口号</li>\n</ul>\n</li>\n<li>客户端使用的端口号</li>\n</ol>\n<p>下面展开来说说。    </p>\n<h3 id=\"端口号的分类\"><a href=\"#端口号的分类\" class=\"headerlink\" title=\"端口号的分类\"></a>端口号的分类</h3><h4 id=\"服务器端使用的端口号\"><a href=\"#服务器端使用的端口号\" class=\"headerlink\" title=\"服务器端使用的端口号\"></a>服务器端使用的端口号</h4><p><strong>熟知端口号</strong>：<br>取值范围：0 ~ 1023。<br>可以在 <a href=\"http://www.iana.org\" target=\"_blank\" rel=\"external\">www.iana.org</a> 查到，服务器机器一接通电源，服务器程序就运行起来，为了让因特网上所有的客户程序都能找到服务器程序，服务器程序所使用的端口就必须是固定的，并且总所众所周知的。    </p>\n<p>一些常见的端口号：    </p>\n<table>\n<thead>\n<tr>\n<th>应用程序</th>\n<th>FTP</th>\n<th>TELNET</th>\n<th>SMTP</th>\n<th>DNS</th>\n<th>TFTP</th>\n<th>HTTP</th>\n<th>HTTPS</th>\n<th>SNMP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>熟知端口号</td>\n<td><strong>21</strong></td>\n<td>23</td>\n<td>25</td>\n<td>53</td>\n<td>69</td>\n<td><strong>80</strong></td>\n<td><strong>443</strong></td>\n<td>161</td>\n</tr>\n</tbody>\n</table>\n<p><strong>登记端口号</strong>：<br>取值范围：1024 ~ 49151。<br>这类端口没有熟知的应用程序使用，但是需要登记，以防重复</p>\n<h4 id=\"客户端使用的端口号\"><a href=\"#客户端使用的端口号\" class=\"headerlink\" title=\"客户端使用的端口号\"></a>客户端使用的端口号</h4><p>取值范围：49152 ~ 65535。<br>这类端口仅在客户端进程运行时才动态选择。<br>又叫 短暂端口号，表示这种端口的存在时间是短暂的，客户进程并不在意操作系统给它分配的是哪一个端口号，因为客户进程之所以必须有一个端口号，是为了让传输层的实体能够找到自己。    </p>\n<p><em>PS：在<code>/etc/services</code>文件中可以查看所有知名服务使用的端口。</em></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://book.douban.com/subject/26850616/\" target=\"_blank\" rel=\"external\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\" target=\"_blank\" rel=\"external\">《计算机网络》</a></p>\n","excerpt":"","more":"<blockquote>\n<p>更好阅读体验：<a href=\"https://jerryc8080.gitbooks.io/understand-tcp-and-udp/\">《理解 TCP 和 UDP》— By Gitbook</a>    </p>\n</blockquote>\n<h2 id=\"端口与进程\"><a href=\"#端口与进程\" class=\"headerlink\" title=\"端口与进程\"></a>端口与进程</h2><p>TCP 的包是不包含 IP 地址信息的，那是 IP 层上的事，但是有源端口和目的端口。<br>就是说，端口这一东西，是属于 TCP 知识范畴的。    </p>\n<p>我们知道两个进程，在计算机内部进行通信，可以有管道、内存共享、信号量、消息队列等方法。<br>而两个进程如果需要进行通讯最基本的一个前提是能够唯一的标识一个进程，在本地进程通讯中我们可以使用 <strong>「PID(进程标识符)」</strong> 来唯一标识一个进程。<br>但 PID 只在本地唯一，如果把两个进程放到了不同的两台计算机，然后他们要通信的话，PID 就不够用了，这样就需要另外一种手段了。    </p>\n<p>解决这个问题的方法就是在运输层使用 <strong>「协议端口号 (protocol port number)」</strong>，简称 <strong>「端口 (port)」</strong>.<br>我们知道 IP 层的 ip 地址可以唯一标识主机，而 TCP 层协议和端口号可以唯一标识主机的一个进程，这样我们可以利用：<strong>「ip地址＋协议＋端口号」</strong>唯一标示网络中的一个进程。<br>在一些场合，也把这种唯一标识的模式称为<strong>「套接字 (Socket)」</strong>。    </p>\n<p>这就是说，虽然通信的重点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的端口，剩下的工作就由 TCP 来完成了。    </p>\n<h2 id=\"认识端口\"><a href=\"#认识端口\" class=\"headerlink\" title=\"认识端口\"></a>认识端口</h2><p>TCP 用一个 16 位端口号来标识一个端口，可允许有 65536 ( 2的16次方) 个不同的端口号，范围在 0 ~ 65535 之间。    </p>\n<p>端口号根据服务器使用还是客户端使用，以及常见不常见的维度来区分，主要有以下类别：</p>\n<ol>\n<li>服务器端使用的端口号<ul>\n<li>熟知端口号</li>\n<li>登记端口号</li>\n</ul>\n</li>\n<li>客户端使用的端口号</li>\n</ol>\n<p>下面展开来说说。    </p>\n<h3 id=\"端口号的分类\"><a href=\"#端口号的分类\" class=\"headerlink\" title=\"端口号的分类\"></a>端口号的分类</h3><h4 id=\"服务器端使用的端口号\"><a href=\"#服务器端使用的端口号\" class=\"headerlink\" title=\"服务器端使用的端口号\"></a>服务器端使用的端口号</h4><p><strong>熟知端口号</strong>：<br>取值范围：0 ~ 1023。<br>可以在 <a href=\"http://www.iana.org\">www.iana.org</a> 查到，服务器机器一接通电源，服务器程序就运行起来，为了让因特网上所有的客户程序都能找到服务器程序，服务器程序所使用的端口就必须是固定的，并且总所众所周知的。    </p>\n<p>一些常见的端口号：    </p>\n<table>\n<thead>\n<tr>\n<th>应用程序</th>\n<th>FTP</th>\n<th>TELNET</th>\n<th>SMTP</th>\n<th>DNS</th>\n<th>TFTP</th>\n<th>HTTP</th>\n<th>HTTPS</th>\n<th>SNMP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>熟知端口号</td>\n<td><strong>21</strong></td>\n<td>23</td>\n<td>25</td>\n<td>53</td>\n<td>69</td>\n<td><strong>80</strong></td>\n<td><strong>443</strong></td>\n<td>161</td>\n</tr>\n</tbody>\n</table>\n<p><strong>登记端口号</strong>：<br>取值范围：1024 ~ 49151。<br>这类端口没有熟知的应用程序使用，但是需要登记，以防重复</p>\n<h4 id=\"客户端使用的端口号\"><a href=\"#客户端使用的端口号\" class=\"headerlink\" title=\"客户端使用的端口号\"></a>客户端使用的端口号</h4><p>取值范围：49152 ~ 65535。<br>这类端口仅在客户端进程运行时才动态选择。<br>又叫 短暂端口号，表示这种端口的存在时间是短暂的，客户进程并不在意操作系统给它分配的是哪一个端口号，因为客户进程之所以必须有一个端口号，是为了让传输层的实体能够找到自己。    </p>\n<p><em>PS：在<code>/etc/services</code>文件中可以查看所有知名服务使用的端口。</em></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://book.douban.com/subject/26850616/\">《后台开发 核心技术与应用实践》</a><br><a href=\"https://book.douban.com/subject/2970300/\">《计算机网络》</a></p>\n"},{"title":"魅族的冬与夏","date":"2017-01-24T17:47:00.000Z","_content":"\n# 冬天\n我在离职协议书上面，签下了名字。\n犹如当年签订实习协议一样的字迹，不同的只是那份心情。\n\n我坐在魅族大楼前面围绕着一颗树而摆成的弧形长椅子，喝了口小卖部买来的咖啡。\n两年半之间，偶尔在午后偷得一丝慵懒，来到这里喝杯咖啡，感受着珠海的安静。\n\n抬头45度，当年满载绿叶的树，已经被寒风吹散，只剩下枝与干。\n我曾经幻想过很多次，会有一个两鬓斑白的老人坐在我身旁，告诉我这棵树的名字和故事。\n\n如此我的故事就会变得更具戏剧性，但现在我只能叫它「一棵树」。\n一棵树先生，花开花落，经历过多少个珠海的冬与夏。\n我两年半的魅族生涯，也被他看在眼里。\n\n![冬天](/image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg)\n\n\n# 实习\n2014 年的暑假过后，跟我一起在大学做了不少项目的死党糖水哥找到了深圳的实习。\n他总是什么都比我快一步，也是从他话语中知道了珠海魅族下的笔戈科技在招「前端开发」。\n\n同时，带我入坑前端开发以及给予我第一个实战机会的师兄，邀请我到他的公司工作。\n在投简历的前两天，我去拜访以前实习的公司。因为那里是我成长过的地方，那时候公司不大，几个人，但是气氛很好。虽然短短的两个月，但是对这家公司的感情还是蛮深刻的。\n师兄知道我正在找实习，就邀请我来一起干，让我负责主要的 NodeJS 和前端开发。\n一时间，我下不了决定。一方面难以拒绝师兄的热情相邀，一方面又放不下自己准备良久的面试。我当时就实说了，正在准备面试一家公司，待我回去考虑过再给答复。\n回去后，我思考了一个晚上，也用笔和纸列举了去两家公司的利与弊。\n最终，我还是决定了先去魅族试一下。\n\n我很感激师兄的邀请和对我的欣赏，但是那时候的我就一心想见识更多的人与事。\n我记得跟他说了一句话：「我想试一下魅族」。\n是的，我只投了一封简历，只投给了魅族笔戈科技。\n\n很快就收到了面试官回复的邮件。大概内容就是很高兴收到简历，然后约定电话面试的时间。\n在经过一个多小时的电话面试，以及一个面对面面试。\n我终于收到了魅族的 Offer 邮件。\n\n同时，还收到了总监盖文张的额外邮件，邮件内容主要介绍了魅族科技、笔戈科技、还有简单的个人简介，还扔了一大堆文献资料要我去阅读。最后还不忘布置一个家庭作业：一份关于我自身的全面社交账号列表，以及详细的自我简介，以及我未来想要做的事情。\n\n从邮件的文字中，能深刻的感受盖文张对于每个成员负责的态度。\n那时候我很高兴，能和一位如此有亲和力和有想法的人工作，那是多么幸运的事情。\n\n所以，尽然我语文作文能力低弱，也是使劲的憋出了一篇2000字的感想。\n\n\n# 笔戈科技\n我记得第一次踏入魅族科技楼的一瞬间，看到一楼大厅的装横的那份感动。\n就像那时候魅族设计出来的手机一样，那么的简洁，那么的灵动。\n\n![魅族一楼大厅](/image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg)\n\n我在笔戈科技，所属于 Web 开发组，组内只有老大一个 NodeJS 开发，再加上包括我在内的三个前端实习生。\n老大跟我说，你看这么多前端实习生，本来不打算再招前端实习生了，但是看到你以前做的项目蛮多的，就破例了。这句话，让我心里偷偷窃喜了好一段时间。\n\n当时我们组主要是负责笔戈博客项目，以及一些营销导向型的短期项目。\n笔戈博客是在 Ghost 的基础上构建的，修修补补源代码，加上了一些业务性的定制功能。\n我记得那时候看 Ghost 的源码，因为不懂 Promise ，看的非常吃力。\nGhost 的前端部分使用的是 EmberJS，在2014年前端的 MVC 框架比较流行的是 AngularJS、EmberJS、BackboneJS。\n构建项目的用的是 Grunt，CSS 部分的 sass、less 在当年也已经开始普及起来。\n对于我一个只懂 jQuery、BootStrap 、以及前端三项基本功的实习生，掌握前端工程化技术是一项让人充满新鲜感与兴奋的挑战。\n\n当时技术团队的人员配置很不平衡，一个后端对应三个前端，所以后端的工作强度很大，前端反而显得清闲。\n不出半个月，一个午饭时分，老大跟我说：「你不是会 NodeJS 吗，要不尝试转后端？」\n我思考了很久，大学立下的职业规划是成为一名出色的前端工程师。\n但是要做好前端，首先是成为一名合格的软件工程师。我觉得是一次机会，所以就答应了，后面的两年的时间，工作上就绝大部分从事着后端开发。\n随后我也感激我当时的选择，后端的工作能让我从不同的角度来了解软件开发。\n在我转型不久，很快又来了一位 NodeJS 实习生。从现在来看，他也是我们组最后的一位实习生。\n\n在笔戈科技，虽然有不同的职能组，但是那时候人还少，不同职能的大家都可以混在一起，而且管理上也十分的扁平化。我们使用很多优秀的工具来进行团队合作，例如 Teambition、Google Docs，还统一购买科学上网服务。\n\n就像我在入职前写给盖文张对于笔戈的看法所描述的，笔戈科技就像魅族的一个特种部队，效率和敏捷性都很高。\n\n# 笔戈玩\n在入职直到 2014 年末之前，我都一直做着一些琐碎的事情，笔戈博客的维护，以及一些营销导向性的短期项目，就像内部的一个外包技术团队。\n我想，如果那时候没有魅玩帮的立项，估计我半年之后就不会在魅族了。\n\n就趋近于年末的时候，盖文张召集我们技术组开会，谈论一个新项目的想法。\n要做一个魅族旗下推广型的平台，推广方向就是我们所从事的「智能硬件」方向。\n这时候，一个智能硬件试玩网站的雏形诞生了，叫「笔戈玩」。\n\n项目立项了，就要撸起袖子开始干了。\n团队的主要技术栈是 NodeJS，我们需要一个能快速搭建项目的 NodeJS 企业级开发框架。\n我们对比了 Meteor、Strongloop、SailsJS，最后被 SailsJS 清晰的 MVC 分层所吸引，选择了 SailsJS 框架来开发。当然，框架的功能性，扩展性，和社区活跃度都是需要被考虑的，记得当年我写了一篇 [《为什么使用 SailsJS》](http://huang-jerryc.com/2015/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Sails/)，现在看回去，有不少的东西可以补充。\n\n\n就这样，一个老大带着四个实习生，三个 NodeJS，两个前端，从项目分析、概要设计、详细设计、数据库设计、再到编码实现，在农历年之前完成了「笔戈玩」的第一版本。\n年后，由于之前对框架的不熟悉，导致产出的代码欠佳，然后重新推翻，再次重构。\n又一个月的时间，发布了第一个内部测试版本。\n经过一段时间的测试、修复、运营准备，终于在 2015 年 5 月 21 日，「笔戈玩」正式上线。\n\n# 简书 —— 笔戈 Web Team\n\n在「笔戈玩」第一版本上线之后，我也迎来了我的毕业。\n\n盖文张是很注重团队成员自身发展的，他也很鼓励我们多看书多涉猎，也建立了读书经费。\n在我们办公室的角落，就有一个小小的书柜，都放满了大家要求买的书。\n除了看书，多写作也是被鼓励的。\n笔戈博客是我们部门的业余产出，写作就像笔戈不成形的团队文化，当时就在全部门内推行了这样的制度：每人每月定额产出文章，产出不奖励，不产出要罚钱。\n产出的文章，经过筛选，会发表在笔戈博客。\n我们写代码的人要求低一点，一个月一篇，写不出要罚 100 块，罚的钱，用来补贴部门经费。\n我那时候的实习工资 2000 加上补贴，一个月不缺勤到手也就 2700。罚 100 块，是多么痛心的事情。\n所以我们憋也要憋出来几个字。\n\n如果我们写一些技术类的，倒是没那么痛苦。\n可偏偏那时候我们技术老大说，尽量不要写技术类的。理由是笔戈博客的读者并不是技术向的。\n其实对于我们这群纯理科生，是有点为难的。\n我在笔戈的第一篇文章，是使劲憋出来的：[《盘点国内的那些ROM》](http://huang-jerryc.com/2015/03/03/%E7%9B%98%E7%82%B9%E5%9B%BD%E5%86%85%E7%9A%84%E9%82%A3%E4%BA%9BROM/)\n\n之后我就在思考，有什么办法可以发挥我们的所长，并且符合这个制度。\n我的想法是，我们团队应该是作为一个技术团队的名义来抛头露面，我们的产出可以是纯技术导向，我们把内容聚合起来，作为一个专题，或一个频道，或者其他什么样的形式。\n\n正好笔戈当时也在简书上面发表文章，以增加曝光度。\n我就回学校毕业之前，给盖文张发了一封邮件，把我对团队文化建设的构思路描述了一遍。\n大概就是先从简书开始，建立一个「笔戈 Web Team」的专题，以笔戈的名义为依托，来给我们技术人提供练笔和展示的地方。\n因为简书并不是纯粹的技术社区，受众并不多，我们可以肆无忌惮的写一点东西，而不怕被人鄙视水平不够。\n待我们的水平和产出上来了，考虑转移更纯粹的技术社区，或者建立团队的技术博客。\n我举例了 AlloyTeam，Taobao FED 这些大厂出名的博客。\n同时还说明了这样做的好处，一是写作会逼迫我们思考和总结，对我们技术水平提升有明显的作用。二是可以打响名声，提高成员自豪感，提升凝聚力，同时也有助于招聘。\n\n盖文张很快回复了邮件，他赞同这样的做法，另外给了我笔戈科技在简书的账号密码，让我来创建这个专题。\n同时，我也把这个想法跟技术老大说。我们老大是很进步向的，也很赞成这样的做法。\n\n自此，我们开始以团队的名义进行技术文章的产出，一点一点的积累和提升。\n截止现在，尽管我们已经转移产出的场地，但是简书上面的 「[笔戈 Web Team](http://www.jianshu.com/c/2a4335808d4c)」，已经有103篇文章。\n\n# 第一次出省\n\n从大学毕业之后，我和魅族签订了我人生的第一份劳动合同。正式成为了魅族的员工，虽然之前实习的日子都是被当做正式员工来用。但是不同的是，我终于可以领着符合水平的薪水了。\n\n毕业回来正好碰上了 MX5 的发布会，公司需要征集员工志愿者，我就应征了。\n于是乎，人生第一次出差，也是这个稚嫩的广东人的第一次出省。\n\n我们订的是动卧票，晚上从广州出发， 第二天就能到北京。\n看着地图的定位慢慢的越过广东的边界，心头涌上莫名的一股激动。\n记得那天晚上，躺在摇晃的车厢中，闭上眼，脑海晃出了很多画面，一场星际旅行。\n\n然后，打开当时很流行的「足记」，写下了一些胡思乱想。\n现在看回去，自己还真像个小孩。\n\n![出省](/image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg)\n\n同行的还有几个要好的同事，我们是提前一天到达的。\n在空闲的时间，我们相约去了北京的「798艺术区」。\n我想，每一个来到这里的年轻人，都会爱上这里弥漫着创意以及艺术气息的空气。\n\n![798艺术区](/image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg)\n\n# 第一次出国\n\n在北京回来之后，正好碰上公司的年度旅游。\n听一些老员工说「今年开始才有旅游经费的，你碰到好时候了」，比较遗憾的是，那也是唯一一年有旅游经费的。\n公司的旅游经费只够短距离玩个三四天左右，以自行组织报销的形式，然后部门的一些土豪君给出一种方案，就是自己多掏腰包，然后一起去泰国玩一转。\n听到这方案，心里埋藏已久的射手座的心，再出跳出来作祟。\n花光了一年实习的积蓄，跟着土豪同事们去泰国了，那也是我第一次踏出中国的大陆。\n\n![泰旅](/image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg)\n![泰旅](/image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg)\n\n# 魅玩帮\n\n2015 年 9 月，「笔戈玩」更名「魅玩帮」，明确定位「魅族旗下新品分享平台」，由新的总监接手这个项目，帮团队理了至关重要的一件事：产品要和魅族价值挂钩。\n\nWeb 开发组，自然而然也就划分到新总监门下。\n这时候我们小组已经从当初的 5 人小团队，增加到 11 人了，\n继我们组最后一个实习生之后， 又来了一个测试妹子，后来转运维去了。 \n然后，又来了一个 NodeJS 的后端，除了帅人品还很好。\n然后，又来了一个测试妹子，爱吃爱玩，还会卖萌，我经常说：「你要是瘦了肯定是个美女」。\n同时间来的还有一个香港硕士生，做前端开发，人帅，逼格比我还高。\n再后来，又来了一个 JAVA 的后端，也是硕士毕业，基础很赞，人很接地气。\n最后，再来了一个项目经理。\n再加上原来项目整合分配到的一位御用设计师，和一位会卖萌的产品经理。\n于是乎，「魅玩帮」团队，从一个实习生团队，慢慢的增长到一个成型的小团队，配置到位。\n卖萌产经经常说，她遇到一群聪明的人。\n\n项目重定位之后的一系列工作就是接入魅族用户中心，魅族论坛，Flyme 论坛。\n这涉及到跨部门之间的合作，由于技术上是由我一直跟对方沟通的。\n后来，老大跟我说：「你参与的比较多，由你来主导这次开发吧」，喜出望外。\n随后被打了鸡血一样，事无巨细，从设计、文档、技术方案给理了清楚，再加上一群很棒的伙伴，功能很快就做完了。\n\n随着「魅玩帮」的用户量上升，产品想要一个「消息提醒」的功能。之前的工作给老大留下了不错的印象，这个任务就被分给我了。\n消息系统的开发，也是我觉得工作内做的比较有条理性的工作之一。\n经常性，产品想要一个东西，但是并不能完全的描述这个东西的细节，消息提醒也是一样。\n开发需要做的是，帮忙缕清整个东西的逻辑和业务，我首先是分析业内的一些成型的产品，例如知乎、简书的消息提醒功能。\n通过分析，抽象本质，整理业务功能，写出大概的功能设计，以及实现思路，然后再开会沟通。\n经过多次沟通和修改，然后编码实现。\n那时候明白了一个道理，一项功能或者一个项目，最费时间和精力的是在前期的沟通和设计上面，编码实现在一个熟练的开发者手上，反而是最简单的事情。\n最后内部整理文档，外部输出思路：[《消息系统设计与实现》](http://huang-jerryc.com/2015/10/14/%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8C%E4%B8%8A%E7%AF%87%E3%80%8D/)\n\n# 优秀员工\n\n很快，2015 年过去了。\n部门年会在一家酒店吃年夜饭，那是难忘的一天。\n那一天，收到了一个肯定，「优秀员工奖」。\n是我们技术老大帮忙提名的，记得他年末跟我谈话的时候说的一句：「你是进步最快的，比其他人更靠谱些」。\n\n![优秀员工奖](/image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg)\n\n# Segmentfault —— 魅族科技开发团队\n\n年后，经过半年的时间，我们组对于技术的积累，以及文笔的熟练度，有了一定的提升。\n于是乎，我们开始考虑换一个输出文章的地方。\n当时我的想法是，建立一个我们独立的博客站点，但我的只能算作提议，最终还是技术 leader 以他认可的方式行动了：在 Segmentfault 以团队的名义来输出内容。\n于是，我们在 SF 建立了专题：「[魅族科技开发团队](https://segmentfault.com/blog/meizu)」。\n现在回想起来，这的确是一个明智之举，借助更垂直化的社区，可以给我们带来更多的关注量，和曝光度。当时魅族内部，还没有以团队名义来对外输出内容，我们做了，而且还做得不错。\n同时，以团队为的姿势，也得到了 SF 社区的欢迎。\n\n还记得，曾经连续两个季度入选 Top Writer 之后，均收到社区寄过来的小礼物和卡片，那份激动的心情。\n以前也混过想 CNodeJS，V2EX，CSDN 之类的技术社区，但是从来没有遇到一个这么认真的技术社区。能感觉得到 SF 社区的那颗真诚在做社区的心。\n\n我经常说，程序员就像中欧的骑士一样， Fight For Honor。\n如果 SF 捉到了这一点，就可以留住更多的优秀产出者，就会吸引更多学习者，然后再反过来哺乳社区，形成一个良性循环。\n\n![SF Top Writer](/image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg)\n\n# 凌晨六点的东岸牌坊\n\n2016 年 3 月份，我接到了一个很酷的工作。\n公司预定在 4 月 6 日开一场魅蓝新品发布会，而在发布会之前的预热活动，想搞一个抽奖，送特斯拉。\n我们 Web 组提供技术支持，设计以及策划的工作由市场部的其他部门协作完成。\n整个项目工期很赶，我们基本实行了临时的 996，加班加点赶工期，那时候很充实。\n\n就在 3 月 23 日上午，我们上线了「406魅蓝发布会」的项目。\n上线的前一天晚上大家通宵战到天亮，我们下班打卡的时候，已经连续工作了 29 个小时。\n\n项目上线的前几个小时，太阳刚从东边升起，我们眼睁睁的看着漆黑的夜，渐渐地明亮起来。\n珠海的三四月正是潮湿天气，空气中充满了水分子，初升的阳光很弱，还没有足够的能量消散这一层薄雾。\n走到办公室的窗前，一副迷人朦胧的景色映入眼帘。\n这是，凌晨 6 点钟的东岸牌坊。\n\n![东岸牌坊](/image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg)\n\n因为公司动用了大部分的传播渠道来推广这个网站，当天的日 PV 突破 100W，让我激动了很久。\n整个项目我负责的不单单只是后端功能的开发，还需要在整个项目上把握进度，那时候能感觉到老大有放权给我们的意思，虽然没有明说。\n这让我们在项目上，进度上，站在更加有责任感的位置思考问题。\n技术上比较简单，前端页面提供几个 HTML 页面，服务器使用了阿里云，以及阿里云提供的 MySQL 。\n在单元测试上我比较重视，覆盖率 100%。\n安全性方面，使用了极验的验证码，绝大程度上避免了恶意的刷码行为。\n这一次的项目，让我在做一个高并发、高性能、高稳定、响应速度高要求的项目有了更多的经验。\n\n# 危机感\n\n本来一切都是很顺利，团队氛围很好，也很有干劲。\n加上之前的顺风顺水，我曾以为我能在公司干出一番成绩和事业。\n然而开始有了一些不好的变化，4 月份公司发生了一些不开心的事，于是乎，奇怪的味道慢慢蔓延开来，从最初的难以察觉到后面越发刺鼻。\n4 月，也正值跳槽旺季，我收到了几个猎头和一些公司的邀请。\n由于一个意外，老大知道了，就在这个大家嗅觉都特别敏感的时期。\n然后被约去喝咖啡了，我也正好把我所思所虑表达清楚。\n我们老大是一个平易近人，也很能理解下属的 leader。\n我说，魅玩帮 2.0 在即，我还可以提供一些推动力，最起码 2016 年还会留着，干完该干的事情。\n我这样说是给老大承诺，也给自己定心，我知道坚持的美。\n其实那时候，尽然有对薪资的不满意，但是对团队的感情，以及产品的感情更胜于此。\n噢，不舍的还有珠海安逸的生活。\n没有人不在意钱，我也在意。\n而大多数人赚钱，也是为了让生活更美好。\n但是如果一旦你的生活跟一家公司强关联起来，就没法确保你安逸的生活哪一天不会被毁掉。\n同时，你的决定和行动也会受到更加多因素的影响和束缚。\n\n无论怎么样，终究，我的危机感变得比以往更加强烈。\n\n# 魅玩帮 2.0\n\n魅玩帮尝试了最后一个转型，从「试玩」为主转向「内容输出」为主。\n于是，魅玩帮走向了 2.0。\n2.0 的功能点很多，需求也很多。\n但是对于我来说，技术上早已经轻车熟路，所以问题不大。\n大多都是业务，逻辑，API。\n值得写的东西也不多。\n\n# 西山日薄的魅玩帮\n\n经过两年的时间，魅玩帮的模式也玩的差不多了，功能也越发趋于完善，产品也越来越成熟。\n但是，我也渐渐地明白，魅玩帮的模式，有一个致命的弱点，没有直接的盈利模式。\n它的影响力，是附属在魅族品牌下的，只能是营销上的一个辅助性工具，就算我们技术上把项目做得再精，再出色。\n没有发现盈利点，就没能够在内部提高我们的不可割舍性，最直接的影响也就是我们的待遇和福利。\n我们没有给公司创造收入，那么我们的工资就像是在烧钱。（实际上，我们内部接的营销项目，也是间接帮公司省掉外包的支出）\n在年末，上层决定要把「魅玩帮」并入到「魅族社区」，我渐渐的意识到我们做了两年多的产品已经西山日薄了。\n\n我也发现，这时候离开，是对团队的影响最小的时候。\n\n\n# 成长\n\n从大学实习开始，直到毕业之后的一年半，已经在魅族度过了两年零三个月。\n在这里经历过很多的第一次，也认识了很棒很聪明的朋友和同事，从他们身上看到，也学到了很多东西。\n在这里，我的生活和工作是融合在一起的，但却没有一丝的违和感，融合的那么自然，有机。\n团队的大家除了是同事，还是一群好朋友，好基友。\n而技术老大，两年了，也像师傅一样，从最初的手把手教，到后面的信任，放手。\n慢慢的，忽然意识到，是时候出师了。\n\n在这里锻炼的不单单只有技术，\n还有做人、做事的道理，\n还有职场上处事的道理，\n还有眼界和认识，\n还有思维方式，思考方法\n等等......\n\n是的，感谢魅族。\n今天，我毕业了，从魅族。\n\n\n# 夏天\n魅族，诞生在一个南方的海滨城市——珠海。\n这里一年中似乎只有夏天与冬天，秋天和春天短到以至于你感觉不到他们来过。\n魅族科技楼的前面，立着一颗树。\n我依然清晰的记得，那一年，我来的时候，它满载绿油油的叶子。\n在阳光下，温暖且湿润的风吹过，叶子唰唰的响，切出无数缕光束，打到我的脸上。\n\n![夏天](/image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg)","source":"_posts/the-winter-and-summer-of-Meizu.md","raw":"---\ntitle: 魅族的冬与夏\ncategory: 三省吾身\ndate: 2017-01-25 01:47:00\n---\n\n# 冬天\n我在离职协议书上面，签下了名字。\n犹如当年签订实习协议一样的字迹，不同的只是那份心情。\n\n我坐在魅族大楼前面围绕着一颗树而摆成的弧形长椅子，喝了口小卖部买来的咖啡。\n两年半之间，偶尔在午后偷得一丝慵懒，来到这里喝杯咖啡，感受着珠海的安静。\n\n抬头45度，当年满载绿叶的树，已经被寒风吹散，只剩下枝与干。\n我曾经幻想过很多次，会有一个两鬓斑白的老人坐在我身旁，告诉我这棵树的名字和故事。\n\n如此我的故事就会变得更具戏剧性，但现在我只能叫它「一棵树」。\n一棵树先生，花开花落，经历过多少个珠海的冬与夏。\n我两年半的魅族生涯，也被他看在眼里。\n\n![冬天](/image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg)\n\n\n# 实习\n2014 年的暑假过后，跟我一起在大学做了不少项目的死党糖水哥找到了深圳的实习。\n他总是什么都比我快一步，也是从他话语中知道了珠海魅族下的笔戈科技在招「前端开发」。\n\n同时，带我入坑前端开发以及给予我第一个实战机会的师兄，邀请我到他的公司工作。\n在投简历的前两天，我去拜访以前实习的公司。因为那里是我成长过的地方，那时候公司不大，几个人，但是气氛很好。虽然短短的两个月，但是对这家公司的感情还是蛮深刻的。\n师兄知道我正在找实习，就邀请我来一起干，让我负责主要的 NodeJS 和前端开发。\n一时间，我下不了决定。一方面难以拒绝师兄的热情相邀，一方面又放不下自己准备良久的面试。我当时就实说了，正在准备面试一家公司，待我回去考虑过再给答复。\n回去后，我思考了一个晚上，也用笔和纸列举了去两家公司的利与弊。\n最终，我还是决定了先去魅族试一下。\n\n我很感激师兄的邀请和对我的欣赏，但是那时候的我就一心想见识更多的人与事。\n我记得跟他说了一句话：「我想试一下魅族」。\n是的，我只投了一封简历，只投给了魅族笔戈科技。\n\n很快就收到了面试官回复的邮件。大概内容就是很高兴收到简历，然后约定电话面试的时间。\n在经过一个多小时的电话面试，以及一个面对面面试。\n我终于收到了魅族的 Offer 邮件。\n\n同时，还收到了总监盖文张的额外邮件，邮件内容主要介绍了魅族科技、笔戈科技、还有简单的个人简介，还扔了一大堆文献资料要我去阅读。最后还不忘布置一个家庭作业：一份关于我自身的全面社交账号列表，以及详细的自我简介，以及我未来想要做的事情。\n\n从邮件的文字中，能深刻的感受盖文张对于每个成员负责的态度。\n那时候我很高兴，能和一位如此有亲和力和有想法的人工作，那是多么幸运的事情。\n\n所以，尽然我语文作文能力低弱，也是使劲的憋出了一篇2000字的感想。\n\n\n# 笔戈科技\n我记得第一次踏入魅族科技楼的一瞬间，看到一楼大厅的装横的那份感动。\n就像那时候魅族设计出来的手机一样，那么的简洁，那么的灵动。\n\n![魅族一楼大厅](/image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg)\n\n我在笔戈科技，所属于 Web 开发组，组内只有老大一个 NodeJS 开发，再加上包括我在内的三个前端实习生。\n老大跟我说，你看这么多前端实习生，本来不打算再招前端实习生了，但是看到你以前做的项目蛮多的，就破例了。这句话，让我心里偷偷窃喜了好一段时间。\n\n当时我们组主要是负责笔戈博客项目，以及一些营销导向型的短期项目。\n笔戈博客是在 Ghost 的基础上构建的，修修补补源代码，加上了一些业务性的定制功能。\n我记得那时候看 Ghost 的源码，因为不懂 Promise ，看的非常吃力。\nGhost 的前端部分使用的是 EmberJS，在2014年前端的 MVC 框架比较流行的是 AngularJS、EmberJS、BackboneJS。\n构建项目的用的是 Grunt，CSS 部分的 sass、less 在当年也已经开始普及起来。\n对于我一个只懂 jQuery、BootStrap 、以及前端三项基本功的实习生，掌握前端工程化技术是一项让人充满新鲜感与兴奋的挑战。\n\n当时技术团队的人员配置很不平衡，一个后端对应三个前端，所以后端的工作强度很大，前端反而显得清闲。\n不出半个月，一个午饭时分，老大跟我说：「你不是会 NodeJS 吗，要不尝试转后端？」\n我思考了很久，大学立下的职业规划是成为一名出色的前端工程师。\n但是要做好前端，首先是成为一名合格的软件工程师。我觉得是一次机会，所以就答应了，后面的两年的时间，工作上就绝大部分从事着后端开发。\n随后我也感激我当时的选择，后端的工作能让我从不同的角度来了解软件开发。\n在我转型不久，很快又来了一位 NodeJS 实习生。从现在来看，他也是我们组最后的一位实习生。\n\n在笔戈科技，虽然有不同的职能组，但是那时候人还少，不同职能的大家都可以混在一起，而且管理上也十分的扁平化。我们使用很多优秀的工具来进行团队合作，例如 Teambition、Google Docs，还统一购买科学上网服务。\n\n就像我在入职前写给盖文张对于笔戈的看法所描述的，笔戈科技就像魅族的一个特种部队，效率和敏捷性都很高。\n\n# 笔戈玩\n在入职直到 2014 年末之前，我都一直做着一些琐碎的事情，笔戈博客的维护，以及一些营销导向性的短期项目，就像内部的一个外包技术团队。\n我想，如果那时候没有魅玩帮的立项，估计我半年之后就不会在魅族了。\n\n就趋近于年末的时候，盖文张召集我们技术组开会，谈论一个新项目的想法。\n要做一个魅族旗下推广型的平台，推广方向就是我们所从事的「智能硬件」方向。\n这时候，一个智能硬件试玩网站的雏形诞生了，叫「笔戈玩」。\n\n项目立项了，就要撸起袖子开始干了。\n团队的主要技术栈是 NodeJS，我们需要一个能快速搭建项目的 NodeJS 企业级开发框架。\n我们对比了 Meteor、Strongloop、SailsJS，最后被 SailsJS 清晰的 MVC 分层所吸引，选择了 SailsJS 框架来开发。当然，框架的功能性，扩展性，和社区活跃度都是需要被考虑的，记得当年我写了一篇 [《为什么使用 SailsJS》](http://huang-jerryc.com/2015/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Sails/)，现在看回去，有不少的东西可以补充。\n\n\n就这样，一个老大带着四个实习生，三个 NodeJS，两个前端，从项目分析、概要设计、详细设计、数据库设计、再到编码实现，在农历年之前完成了「笔戈玩」的第一版本。\n年后，由于之前对框架的不熟悉，导致产出的代码欠佳，然后重新推翻，再次重构。\n又一个月的时间，发布了第一个内部测试版本。\n经过一段时间的测试、修复、运营准备，终于在 2015 年 5 月 21 日，「笔戈玩」正式上线。\n\n# 简书 —— 笔戈 Web Team\n\n在「笔戈玩」第一版本上线之后，我也迎来了我的毕业。\n\n盖文张是很注重团队成员自身发展的，他也很鼓励我们多看书多涉猎，也建立了读书经费。\n在我们办公室的角落，就有一个小小的书柜，都放满了大家要求买的书。\n除了看书，多写作也是被鼓励的。\n笔戈博客是我们部门的业余产出，写作就像笔戈不成形的团队文化，当时就在全部门内推行了这样的制度：每人每月定额产出文章，产出不奖励，不产出要罚钱。\n产出的文章，经过筛选，会发表在笔戈博客。\n我们写代码的人要求低一点，一个月一篇，写不出要罚 100 块，罚的钱，用来补贴部门经费。\n我那时候的实习工资 2000 加上补贴，一个月不缺勤到手也就 2700。罚 100 块，是多么痛心的事情。\n所以我们憋也要憋出来几个字。\n\n如果我们写一些技术类的，倒是没那么痛苦。\n可偏偏那时候我们技术老大说，尽量不要写技术类的。理由是笔戈博客的读者并不是技术向的。\n其实对于我们这群纯理科生，是有点为难的。\n我在笔戈的第一篇文章，是使劲憋出来的：[《盘点国内的那些ROM》](http://huang-jerryc.com/2015/03/03/%E7%9B%98%E7%82%B9%E5%9B%BD%E5%86%85%E7%9A%84%E9%82%A3%E4%BA%9BROM/)\n\n之后我就在思考，有什么办法可以发挥我们的所长，并且符合这个制度。\n我的想法是，我们团队应该是作为一个技术团队的名义来抛头露面，我们的产出可以是纯技术导向，我们把内容聚合起来，作为一个专题，或一个频道，或者其他什么样的形式。\n\n正好笔戈当时也在简书上面发表文章，以增加曝光度。\n我就回学校毕业之前，给盖文张发了一封邮件，把我对团队文化建设的构思路描述了一遍。\n大概就是先从简书开始，建立一个「笔戈 Web Team」的专题，以笔戈的名义为依托，来给我们技术人提供练笔和展示的地方。\n因为简书并不是纯粹的技术社区，受众并不多，我们可以肆无忌惮的写一点东西，而不怕被人鄙视水平不够。\n待我们的水平和产出上来了，考虑转移更纯粹的技术社区，或者建立团队的技术博客。\n我举例了 AlloyTeam，Taobao FED 这些大厂出名的博客。\n同时还说明了这样做的好处，一是写作会逼迫我们思考和总结，对我们技术水平提升有明显的作用。二是可以打响名声，提高成员自豪感，提升凝聚力，同时也有助于招聘。\n\n盖文张很快回复了邮件，他赞同这样的做法，另外给了我笔戈科技在简书的账号密码，让我来创建这个专题。\n同时，我也把这个想法跟技术老大说。我们老大是很进步向的，也很赞成这样的做法。\n\n自此，我们开始以团队的名义进行技术文章的产出，一点一点的积累和提升。\n截止现在，尽管我们已经转移产出的场地，但是简书上面的 「[笔戈 Web Team](http://www.jianshu.com/c/2a4335808d4c)」，已经有103篇文章。\n\n# 第一次出省\n\n从大学毕业之后，我和魅族签订了我人生的第一份劳动合同。正式成为了魅族的员工，虽然之前实习的日子都是被当做正式员工来用。但是不同的是，我终于可以领着符合水平的薪水了。\n\n毕业回来正好碰上了 MX5 的发布会，公司需要征集员工志愿者，我就应征了。\n于是乎，人生第一次出差，也是这个稚嫩的广东人的第一次出省。\n\n我们订的是动卧票，晚上从广州出发， 第二天就能到北京。\n看着地图的定位慢慢的越过广东的边界，心头涌上莫名的一股激动。\n记得那天晚上，躺在摇晃的车厢中，闭上眼，脑海晃出了很多画面，一场星际旅行。\n\n然后，打开当时很流行的「足记」，写下了一些胡思乱想。\n现在看回去，自己还真像个小孩。\n\n![出省](/image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg)\n\n同行的还有几个要好的同事，我们是提前一天到达的。\n在空闲的时间，我们相约去了北京的「798艺术区」。\n我想，每一个来到这里的年轻人，都会爱上这里弥漫着创意以及艺术气息的空气。\n\n![798艺术区](/image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg)\n\n# 第一次出国\n\n在北京回来之后，正好碰上公司的年度旅游。\n听一些老员工说「今年开始才有旅游经费的，你碰到好时候了」，比较遗憾的是，那也是唯一一年有旅游经费的。\n公司的旅游经费只够短距离玩个三四天左右，以自行组织报销的形式，然后部门的一些土豪君给出一种方案，就是自己多掏腰包，然后一起去泰国玩一转。\n听到这方案，心里埋藏已久的射手座的心，再出跳出来作祟。\n花光了一年实习的积蓄，跟着土豪同事们去泰国了，那也是我第一次踏出中国的大陆。\n\n![泰旅](/image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg)\n![泰旅](/image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg)\n\n# 魅玩帮\n\n2015 年 9 月，「笔戈玩」更名「魅玩帮」，明确定位「魅族旗下新品分享平台」，由新的总监接手这个项目，帮团队理了至关重要的一件事：产品要和魅族价值挂钩。\n\nWeb 开发组，自然而然也就划分到新总监门下。\n这时候我们小组已经从当初的 5 人小团队，增加到 11 人了，\n继我们组最后一个实习生之后， 又来了一个测试妹子，后来转运维去了。 \n然后，又来了一个 NodeJS 的后端，除了帅人品还很好。\n然后，又来了一个测试妹子，爱吃爱玩，还会卖萌，我经常说：「你要是瘦了肯定是个美女」。\n同时间来的还有一个香港硕士生，做前端开发，人帅，逼格比我还高。\n再后来，又来了一个 JAVA 的后端，也是硕士毕业，基础很赞，人很接地气。\n最后，再来了一个项目经理。\n再加上原来项目整合分配到的一位御用设计师，和一位会卖萌的产品经理。\n于是乎，「魅玩帮」团队，从一个实习生团队，慢慢的增长到一个成型的小团队，配置到位。\n卖萌产经经常说，她遇到一群聪明的人。\n\n项目重定位之后的一系列工作就是接入魅族用户中心，魅族论坛，Flyme 论坛。\n这涉及到跨部门之间的合作，由于技术上是由我一直跟对方沟通的。\n后来，老大跟我说：「你参与的比较多，由你来主导这次开发吧」，喜出望外。\n随后被打了鸡血一样，事无巨细，从设计、文档、技术方案给理了清楚，再加上一群很棒的伙伴，功能很快就做完了。\n\n随着「魅玩帮」的用户量上升，产品想要一个「消息提醒」的功能。之前的工作给老大留下了不错的印象，这个任务就被分给我了。\n消息系统的开发，也是我觉得工作内做的比较有条理性的工作之一。\n经常性，产品想要一个东西，但是并不能完全的描述这个东西的细节，消息提醒也是一样。\n开发需要做的是，帮忙缕清整个东西的逻辑和业务，我首先是分析业内的一些成型的产品，例如知乎、简书的消息提醒功能。\n通过分析，抽象本质，整理业务功能，写出大概的功能设计，以及实现思路，然后再开会沟通。\n经过多次沟通和修改，然后编码实现。\n那时候明白了一个道理，一项功能或者一个项目，最费时间和精力的是在前期的沟通和设计上面，编码实现在一个熟练的开发者手上，反而是最简单的事情。\n最后内部整理文档，外部输出思路：[《消息系统设计与实现》](http://huang-jerryc.com/2015/10/14/%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8C%E4%B8%8A%E7%AF%87%E3%80%8D/)\n\n# 优秀员工\n\n很快，2015 年过去了。\n部门年会在一家酒店吃年夜饭，那是难忘的一天。\n那一天，收到了一个肯定，「优秀员工奖」。\n是我们技术老大帮忙提名的，记得他年末跟我谈话的时候说的一句：「你是进步最快的，比其他人更靠谱些」。\n\n![优秀员工奖](/image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg)\n\n# Segmentfault —— 魅族科技开发团队\n\n年后，经过半年的时间，我们组对于技术的积累，以及文笔的熟练度，有了一定的提升。\n于是乎，我们开始考虑换一个输出文章的地方。\n当时我的想法是，建立一个我们独立的博客站点，但我的只能算作提议，最终还是技术 leader 以他认可的方式行动了：在 Segmentfault 以团队的名义来输出内容。\n于是，我们在 SF 建立了专题：「[魅族科技开发团队](https://segmentfault.com/blog/meizu)」。\n现在回想起来，这的确是一个明智之举，借助更垂直化的社区，可以给我们带来更多的关注量，和曝光度。当时魅族内部，还没有以团队名义来对外输出内容，我们做了，而且还做得不错。\n同时，以团队为的姿势，也得到了 SF 社区的欢迎。\n\n还记得，曾经连续两个季度入选 Top Writer 之后，均收到社区寄过来的小礼物和卡片，那份激动的心情。\n以前也混过想 CNodeJS，V2EX，CSDN 之类的技术社区，但是从来没有遇到一个这么认真的技术社区。能感觉得到 SF 社区的那颗真诚在做社区的心。\n\n我经常说，程序员就像中欧的骑士一样， Fight For Honor。\n如果 SF 捉到了这一点，就可以留住更多的优秀产出者，就会吸引更多学习者，然后再反过来哺乳社区，形成一个良性循环。\n\n![SF Top Writer](/image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg)\n\n# 凌晨六点的东岸牌坊\n\n2016 年 3 月份，我接到了一个很酷的工作。\n公司预定在 4 月 6 日开一场魅蓝新品发布会，而在发布会之前的预热活动，想搞一个抽奖，送特斯拉。\n我们 Web 组提供技术支持，设计以及策划的工作由市场部的其他部门协作完成。\n整个项目工期很赶，我们基本实行了临时的 996，加班加点赶工期，那时候很充实。\n\n就在 3 月 23 日上午，我们上线了「406魅蓝发布会」的项目。\n上线的前一天晚上大家通宵战到天亮，我们下班打卡的时候，已经连续工作了 29 个小时。\n\n项目上线的前几个小时，太阳刚从东边升起，我们眼睁睁的看着漆黑的夜，渐渐地明亮起来。\n珠海的三四月正是潮湿天气，空气中充满了水分子，初升的阳光很弱，还没有足够的能量消散这一层薄雾。\n走到办公室的窗前，一副迷人朦胧的景色映入眼帘。\n这是，凌晨 6 点钟的东岸牌坊。\n\n![东岸牌坊](/image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg)\n\n因为公司动用了大部分的传播渠道来推广这个网站，当天的日 PV 突破 100W，让我激动了很久。\n整个项目我负责的不单单只是后端功能的开发，还需要在整个项目上把握进度，那时候能感觉到老大有放权给我们的意思，虽然没有明说。\n这让我们在项目上，进度上，站在更加有责任感的位置思考问题。\n技术上比较简单，前端页面提供几个 HTML 页面，服务器使用了阿里云，以及阿里云提供的 MySQL 。\n在单元测试上我比较重视，覆盖率 100%。\n安全性方面，使用了极验的验证码，绝大程度上避免了恶意的刷码行为。\n这一次的项目，让我在做一个高并发、高性能、高稳定、响应速度高要求的项目有了更多的经验。\n\n# 危机感\n\n本来一切都是很顺利，团队氛围很好，也很有干劲。\n加上之前的顺风顺水，我曾以为我能在公司干出一番成绩和事业。\n然而开始有了一些不好的变化，4 月份公司发生了一些不开心的事，于是乎，奇怪的味道慢慢蔓延开来，从最初的难以察觉到后面越发刺鼻。\n4 月，也正值跳槽旺季，我收到了几个猎头和一些公司的邀请。\n由于一个意外，老大知道了，就在这个大家嗅觉都特别敏感的时期。\n然后被约去喝咖啡了，我也正好把我所思所虑表达清楚。\n我们老大是一个平易近人，也很能理解下属的 leader。\n我说，魅玩帮 2.0 在即，我还可以提供一些推动力，最起码 2016 年还会留着，干完该干的事情。\n我这样说是给老大承诺，也给自己定心，我知道坚持的美。\n其实那时候，尽然有对薪资的不满意，但是对团队的感情，以及产品的感情更胜于此。\n噢，不舍的还有珠海安逸的生活。\n没有人不在意钱，我也在意。\n而大多数人赚钱，也是为了让生活更美好。\n但是如果一旦你的生活跟一家公司强关联起来，就没法确保你安逸的生活哪一天不会被毁掉。\n同时，你的决定和行动也会受到更加多因素的影响和束缚。\n\n无论怎么样，终究，我的危机感变得比以往更加强烈。\n\n# 魅玩帮 2.0\n\n魅玩帮尝试了最后一个转型，从「试玩」为主转向「内容输出」为主。\n于是，魅玩帮走向了 2.0。\n2.0 的功能点很多，需求也很多。\n但是对于我来说，技术上早已经轻车熟路，所以问题不大。\n大多都是业务，逻辑，API。\n值得写的东西也不多。\n\n# 西山日薄的魅玩帮\n\n经过两年的时间，魅玩帮的模式也玩的差不多了，功能也越发趋于完善，产品也越来越成熟。\n但是，我也渐渐地明白，魅玩帮的模式，有一个致命的弱点，没有直接的盈利模式。\n它的影响力，是附属在魅族品牌下的，只能是营销上的一个辅助性工具，就算我们技术上把项目做得再精，再出色。\n没有发现盈利点，就没能够在内部提高我们的不可割舍性，最直接的影响也就是我们的待遇和福利。\n我们没有给公司创造收入，那么我们的工资就像是在烧钱。（实际上，我们内部接的营销项目，也是间接帮公司省掉外包的支出）\n在年末，上层决定要把「魅玩帮」并入到「魅族社区」，我渐渐的意识到我们做了两年多的产品已经西山日薄了。\n\n我也发现，这时候离开，是对团队的影响最小的时候。\n\n\n# 成长\n\n从大学实习开始，直到毕业之后的一年半，已经在魅族度过了两年零三个月。\n在这里经历过很多的第一次，也认识了很棒很聪明的朋友和同事，从他们身上看到，也学到了很多东西。\n在这里，我的生活和工作是融合在一起的，但却没有一丝的违和感，融合的那么自然，有机。\n团队的大家除了是同事，还是一群好朋友，好基友。\n而技术老大，两年了，也像师傅一样，从最初的手把手教，到后面的信任，放手。\n慢慢的，忽然意识到，是时候出师了。\n\n在这里锻炼的不单单只有技术，\n还有做人、做事的道理，\n还有职场上处事的道理，\n还有眼界和认识，\n还有思维方式，思考方法\n等等......\n\n是的，感谢魅族。\n今天，我毕业了，从魅族。\n\n\n# 夏天\n魅族，诞生在一个南方的海滨城市——珠海。\n这里一年中似乎只有夏天与冬天，秋天和春天短到以至于你感觉不到他们来过。\n魅族科技楼的前面，立着一颗树。\n我依然清晰的记得，那一年，我来的时候，它满载绿油油的叶子。\n在阳光下，温暖且湿润的风吹过，叶子唰唰的响，切出无数缕光束，打到我的脸上。\n\n![夏天](/image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg)","slug":"the-winter-and-summer-of-Meizu","published":1,"updated":"2017-02-04T14:02:58.000Z","_id":"cl270y8sm004gxwrlmkekmpvy","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"冬天\"><a href=\"#冬天\" class=\"headerlink\" title=\"冬天\"></a>冬天</h1><p>我在离职协议书上面，签下了名字。<br>犹如当年签订实习协议一样的字迹，不同的只是那份心情。</p>\n<p>我坐在魅族大楼前面围绕着一颗树而摆成的弧形长椅子，喝了口小卖部买来的咖啡。<br>两年半之间，偶尔在午后偷得一丝慵懒，来到这里喝杯咖啡，感受着珠海的安静。</p>\n<p>抬头45度，当年满载绿叶的树，已经被寒风吹散，只剩下枝与干。<br>我曾经幻想过很多次，会有一个两鬓斑白的老人坐在我身旁，告诉我这棵树的名字和故事。</p>\n<p>如此我的故事就会变得更具戏剧性，但现在我只能叫它「一棵树」。<br>一棵树先生，花开花落，经历过多少个珠海的冬与夏。<br>我两年半的魅族生涯，也被他看在眼里。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg\" alt=\"冬天\"></p>\n<h1 id=\"实习\"><a href=\"#实习\" class=\"headerlink\" title=\"实习\"></a>实习</h1><p>2014 年的暑假过后，跟我一起在大学做了不少项目的死党糖水哥找到了深圳的实习。<br>他总是什么都比我快一步，也是从他话语中知道了珠海魅族下的笔戈科技在招「前端开发」。</p>\n<p>同时，带我入坑前端开发以及给予我第一个实战机会的师兄，邀请我到他的公司工作。<br>在投简历的前两天，我去拜访以前实习的公司。因为那里是我成长过的地方，那时候公司不大，几个人，但是气氛很好。虽然短短的两个月，但是对这家公司的感情还是蛮深刻的。<br>师兄知道我正在找实习，就邀请我来一起干，让我负责主要的 NodeJS 和前端开发。<br>一时间，我下不了决定。一方面难以拒绝师兄的热情相邀，一方面又放不下自己准备良久的面试。我当时就实说了，正在准备面试一家公司，待我回去考虑过再给答复。<br>回去后，我思考了一个晚上，也用笔和纸列举了去两家公司的利与弊。<br>最终，我还是决定了先去魅族试一下。</p>\n<p>我很感激师兄的邀请和对我的欣赏，但是那时候的我就一心想见识更多的人与事。<br>我记得跟他说了一句话：「我想试一下魅族」。<br>是的，我只投了一封简历，只投给了魅族笔戈科技。</p>\n<p>很快就收到了面试官回复的邮件。大概内容就是很高兴收到简历，然后约定电话面试的时间。<br>在经过一个多小时的电话面试，以及一个面对面面试。<br>我终于收到了魅族的 Offer 邮件。</p>\n<p>同时，还收到了总监盖文张的额外邮件，邮件内容主要介绍了魅族科技、笔戈科技、还有简单的个人简介，还扔了一大堆文献资料要我去阅读。最后还不忘布置一个家庭作业：一份关于我自身的全面社交账号列表，以及详细的自我简介，以及我未来想要做的事情。</p>\n<p>从邮件的文字中，能深刻的感受盖文张对于每个成员负责的态度。<br>那时候我很高兴，能和一位如此有亲和力和有想法的人工作，那是多么幸运的事情。</p>\n<p>所以，尽然我语文作文能力低弱，也是使劲的憋出了一篇2000字的感想。</p>\n<h1 id=\"笔戈科技\"><a href=\"#笔戈科技\" class=\"headerlink\" title=\"笔戈科技\"></a>笔戈科技</h1><p>我记得第一次踏入魅族科技楼的一瞬间，看到一楼大厅的装横的那份感动。<br>就像那时候魅族设计出来的手机一样，那么的简洁，那么的灵动。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg\" alt=\"魅族一楼大厅\"></p>\n<p>我在笔戈科技，所属于 Web 开发组，组内只有老大一个 NodeJS 开发，再加上包括我在内的三个前端实习生。<br>老大跟我说，你看这么多前端实习生，本来不打算再招前端实习生了，但是看到你以前做的项目蛮多的，就破例了。这句话，让我心里偷偷窃喜了好一段时间。</p>\n<p>当时我们组主要是负责笔戈博客项目，以及一些营销导向型的短期项目。<br>笔戈博客是在 Ghost 的基础上构建的，修修补补源代码，加上了一些业务性的定制功能。<br>我记得那时候看 Ghost 的源码，因为不懂 Promise ，看的非常吃力。<br>Ghost 的前端部分使用的是 EmberJS，在2014年前端的 MVC 框架比较流行的是 AngularJS、EmberJS、BackboneJS。<br>构建项目的用的是 Grunt，CSS 部分的 sass、less 在当年也已经开始普及起来。<br>对于我一个只懂 jQuery、BootStrap 、以及前端三项基本功的实习生，掌握前端工程化技术是一项让人充满新鲜感与兴奋的挑战。</p>\n<p>当时技术团队的人员配置很不平衡，一个后端对应三个前端，所以后端的工作强度很大，前端反而显得清闲。<br>不出半个月，一个午饭时分，老大跟我说：「你不是会 NodeJS 吗，要不尝试转后端？」<br>我思考了很久，大学立下的职业规划是成为一名出色的前端工程师。<br>但是要做好前端，首先是成为一名合格的软件工程师。我觉得是一次机会，所以就答应了，后面的两年的时间，工作上就绝大部分从事着后端开发。<br>随后我也感激我当时的选择，后端的工作能让我从不同的角度来了解软件开发。<br>在我转型不久，很快又来了一位 NodeJS 实习生。从现在来看，他也是我们组最后的一位实习生。</p>\n<p>在笔戈科技，虽然有不同的职能组，但是那时候人还少，不同职能的大家都可以混在一起，而且管理上也十分的扁平化。我们使用很多优秀的工具来进行团队合作，例如 Teambition、Google Docs，还统一购买科学上网服务。</p>\n<p>就像我在入职前写给盖文张对于笔戈的看法所描述的，笔戈科技就像魅族的一个特种部队，效率和敏捷性都很高。</p>\n<h1 id=\"笔戈玩\"><a href=\"#笔戈玩\" class=\"headerlink\" title=\"笔戈玩\"></a>笔戈玩</h1><p>在入职直到 2014 年末之前，我都一直做着一些琐碎的事情，笔戈博客的维护，以及一些营销导向性的短期项目，就像内部的一个外包技术团队。<br>我想，如果那时候没有魅玩帮的立项，估计我半年之后就不会在魅族了。</p>\n<p>就趋近于年末的时候，盖文张召集我们技术组开会，谈论一个新项目的想法。<br>要做一个魅族旗下推广型的平台，推广方向就是我们所从事的「智能硬件」方向。<br>这时候，一个智能硬件试玩网站的雏形诞生了，叫「笔戈玩」。</p>\n<p>项目立项了，就要撸起袖子开始干了。<br>团队的主要技术栈是 NodeJS，我们需要一个能快速搭建项目的 NodeJS 企业级开发框架。<br>我们对比了 Meteor、Strongloop、SailsJS，最后被 SailsJS 清晰的 MVC 分层所吸引，选择了 SailsJS 框架来开发。当然，框架的功能性，扩展性，和社区活跃度都是需要被考虑的，记得当年我写了一篇 <a href=\"http://huang-jerryc.com/2015/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Sails/\">《为什么使用 SailsJS》</a>，现在看回去，有不少的东西可以补充。</p>\n<p>就这样，一个老大带着四个实习生，三个 NodeJS，两个前端，从项目分析、概要设计、详细设计、数据库设计、再到编码实现，在农历年之前完成了「笔戈玩」的第一版本。<br>年后，由于之前对框架的不熟悉，导致产出的代码欠佳，然后重新推翻，再次重构。<br>又一个月的时间，发布了第一个内部测试版本。<br>经过一段时间的测试、修复、运营准备，终于在 2015 年 5 月 21 日，「笔戈玩」正式上线。</p>\n<h1 id=\"简书-——-笔戈-Web-Team\"><a href=\"#简书-——-笔戈-Web-Team\" class=\"headerlink\" title=\"简书 —— 笔戈 Web Team\"></a>简书 —— 笔戈 Web Team</h1><p>在「笔戈玩」第一版本上线之后，我也迎来了我的毕业。</p>\n<p>盖文张是很注重团队成员自身发展的，他也很鼓励我们多看书多涉猎，也建立了读书经费。<br>在我们办公室的角落，就有一个小小的书柜，都放满了大家要求买的书。<br>除了看书，多写作也是被鼓励的。<br>笔戈博客是我们部门的业余产出，写作就像笔戈不成形的团队文化，当时就在全部门内推行了这样的制度：每人每月定额产出文章，产出不奖励，不产出要罚钱。<br>产出的文章，经过筛选，会发表在笔戈博客。<br>我们写代码的人要求低一点，一个月一篇，写不出要罚 100 块，罚的钱，用来补贴部门经费。<br>我那时候的实习工资 2000 加上补贴，一个月不缺勤到手也就 2700。罚 100 块，是多么痛心的事情。<br>所以我们憋也要憋出来几个字。</p>\n<p>如果我们写一些技术类的，倒是没那么痛苦。<br>可偏偏那时候我们技术老大说，尽量不要写技术类的。理由是笔戈博客的读者并不是技术向的。<br>其实对于我们这群纯理科生，是有点为难的。<br>我在笔戈的第一篇文章，是使劲憋出来的：<a href=\"http://huang-jerryc.com/2015/03/03/%E7%9B%98%E7%82%B9%E5%9B%BD%E5%86%85%E7%9A%84%E9%82%A3%E4%BA%9BROM/\">《盘点国内的那些ROM》</a></p>\n<p>之后我就在思考，有什么办法可以发挥我们的所长，并且符合这个制度。<br>我的想法是，我们团队应该是作为一个技术团队的名义来抛头露面，我们的产出可以是纯技术导向，我们把内容聚合起来，作为一个专题，或一个频道，或者其他什么样的形式。</p>\n<p>正好笔戈当时也在简书上面发表文章，以增加曝光度。<br>我就回学校毕业之前，给盖文张发了一封邮件，把我对团队文化建设的构思路描述了一遍。<br>大概就是先从简书开始，建立一个「笔戈 Web Team」的专题，以笔戈的名义为依托，来给我们技术人提供练笔和展示的地方。<br>因为简书并不是纯粹的技术社区，受众并不多，我们可以肆无忌惮的写一点东西，而不怕被人鄙视水平不够。<br>待我们的水平和产出上来了，考虑转移更纯粹的技术社区，或者建立团队的技术博客。<br>我举例了 AlloyTeam，Taobao FED 这些大厂出名的博客。<br>同时还说明了这样做的好处，一是写作会逼迫我们思考和总结，对我们技术水平提升有明显的作用。二是可以打响名声，提高成员自豪感，提升凝聚力，同时也有助于招聘。</p>\n<p>盖文张很快回复了邮件，他赞同这样的做法，另外给了我笔戈科技在简书的账号密码，让我来创建这个专题。<br>同时，我也把这个想法跟技术老大说。我们老大是很进步向的，也很赞成这样的做法。</p>\n<p>自此，我们开始以团队的名义进行技术文章的产出，一点一点的积累和提升。<br>截止现在，尽管我们已经转移产出的场地，但是简书上面的 「<a href=\"http://www.jianshu.com/c/2a4335808d4c\" target=\"_blank\" rel=\"external\">笔戈 Web Team</a>」，已经有103篇文章。</p>\n<h1 id=\"第一次出省\"><a href=\"#第一次出省\" class=\"headerlink\" title=\"第一次出省\"></a>第一次出省</h1><p>从大学毕业之后，我和魅族签订了我人生的第一份劳动合同。正式成为了魅族的员工，虽然之前实习的日子都是被当做正式员工来用。但是不同的是，我终于可以领着符合水平的薪水了。</p>\n<p>毕业回来正好碰上了 MX5 的发布会，公司需要征集员工志愿者，我就应征了。<br>于是乎，人生第一次出差，也是这个稚嫩的广东人的第一次出省。</p>\n<p>我们订的是动卧票，晚上从广州出发， 第二天就能到北京。<br>看着地图的定位慢慢的越过广东的边界，心头涌上莫名的一股激动。<br>记得那天晚上，躺在摇晃的车厢中，闭上眼，脑海晃出了很多画面，一场星际旅行。</p>\n<p>然后，打开当时很流行的「足记」，写下了一些胡思乱想。<br>现在看回去，自己还真像个小孩。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg\" alt=\"出省\"></p>\n<p>同行的还有几个要好的同事，我们是提前一天到达的。<br>在空闲的时间，我们相约去了北京的「798艺术区」。<br>我想，每一个来到这里的年轻人，都会爱上这里弥漫着创意以及艺术气息的空气。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg\" alt=\"798艺术区\"></p>\n<h1 id=\"第一次出国\"><a href=\"#第一次出国\" class=\"headerlink\" title=\"第一次出国\"></a>第一次出国</h1><p>在北京回来之后，正好碰上公司的年度旅游。<br>听一些老员工说「今年开始才有旅游经费的，你碰到好时候了」，比较遗憾的是，那也是唯一一年有旅游经费的。<br>公司的旅游经费只够短距离玩个三四天左右，以自行组织报销的形式，然后部门的一些土豪君给出一种方案，就是自己多掏腰包，然后一起去泰国玩一转。<br>听到这方案，心里埋藏已久的射手座的心，再出跳出来作祟。<br>花光了一年实习的积蓄，跟着土豪同事们去泰国了，那也是我第一次踏出中国的大陆。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg\" alt=\"泰旅\"><br><img src=\"/image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg\" alt=\"泰旅\"></p>\n<h1 id=\"魅玩帮\"><a href=\"#魅玩帮\" class=\"headerlink\" title=\"魅玩帮\"></a>魅玩帮</h1><p>2015 年 9 月，「笔戈玩」更名「魅玩帮」，明确定位「魅族旗下新品分享平台」，由新的总监接手这个项目，帮团队理了至关重要的一件事：产品要和魅族价值挂钩。</p>\n<p>Web 开发组，自然而然也就划分到新总监门下。<br>这时候我们小组已经从当初的 5 人小团队，增加到 11 人了，<br>继我们组最后一个实习生之后， 又来了一个测试妹子，后来转运维去了。<br>然后，又来了一个 NodeJS 的后端，除了帅人品还很好。<br>然后，又来了一个测试妹子，爱吃爱玩，还会卖萌，我经常说：「你要是瘦了肯定是个美女」。<br>同时间来的还有一个香港硕士生，做前端开发，人帅，逼格比我还高。<br>再后来，又来了一个 JAVA 的后端，也是硕士毕业，基础很赞，人很接地气。<br>最后，再来了一个项目经理。<br>再加上原来项目整合分配到的一位御用设计师，和一位会卖萌的产品经理。<br>于是乎，「魅玩帮」团队，从一个实习生团队，慢慢的增长到一个成型的小团队，配置到位。<br>卖萌产经经常说，她遇到一群聪明的人。</p>\n<p>项目重定位之后的一系列工作就是接入魅族用户中心，魅族论坛，Flyme 论坛。<br>这涉及到跨部门之间的合作，由于技术上是由我一直跟对方沟通的。<br>后来，老大跟我说：「你参与的比较多，由你来主导这次开发吧」，喜出望外。<br>随后被打了鸡血一样，事无巨细，从设计、文档、技术方案给理了清楚，再加上一群很棒的伙伴，功能很快就做完了。</p>\n<p>随着「魅玩帮」的用户量上升，产品想要一个「消息提醒」的功能。之前的工作给老大留下了不错的印象，这个任务就被分给我了。<br>消息系统的开发，也是我觉得工作内做的比较有条理性的工作之一。<br>经常性，产品想要一个东西，但是并不能完全的描述这个东西的细节，消息提醒也是一样。<br>开发需要做的是，帮忙缕清整个东西的逻辑和业务，我首先是分析业内的一些成型的产品，例如知乎、简书的消息提醒功能。<br>通过分析，抽象本质，整理业务功能，写出大概的功能设计，以及实现思路，然后再开会沟通。<br>经过多次沟通和修改，然后编码实现。<br>那时候明白了一个道理，一项功能或者一个项目，最费时间和精力的是在前期的沟通和设计上面，编码实现在一个熟练的开发者手上，反而是最简单的事情。<br>最后内部整理文档，外部输出思路：<a href=\"http://huang-jerryc.com/2015/10/14/%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8C%E4%B8%8A%E7%AF%87%E3%80%8D/\">《消息系统设计与实现》</a></p>\n<h1 id=\"优秀员工\"><a href=\"#优秀员工\" class=\"headerlink\" title=\"优秀员工\"></a>优秀员工</h1><p>很快，2015 年过去了。<br>部门年会在一家酒店吃年夜饭，那是难忘的一天。<br>那一天，收到了一个肯定，「优秀员工奖」。<br>是我们技术老大帮忙提名的，记得他年末跟我谈话的时候说的一句：「你是进步最快的，比其他人更靠谱些」。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg\" alt=\"优秀员工奖\"></p>\n<h1 id=\"Segmentfault-——-魅族科技开发团队\"><a href=\"#Segmentfault-——-魅族科技开发团队\" class=\"headerlink\" title=\"Segmentfault —— 魅族科技开发团队\"></a>Segmentfault —— 魅族科技开发团队</h1><p>年后，经过半年的时间，我们组对于技术的积累，以及文笔的熟练度，有了一定的提升。<br>于是乎，我们开始考虑换一个输出文章的地方。<br>当时我的想法是，建立一个我们独立的博客站点，但我的只能算作提议，最终还是技术 leader 以他认可的方式行动了：在 Segmentfault 以团队的名义来输出内容。<br>于是，我们在 SF 建立了专题：「<a href=\"https://segmentfault.com/blog/meizu\" target=\"_blank\" rel=\"external\">魅族科技开发团队</a>」。<br>现在回想起来，这的确是一个明智之举，借助更垂直化的社区，可以给我们带来更多的关注量，和曝光度。当时魅族内部，还没有以团队名义来对外输出内容，我们做了，而且还做得不错。<br>同时，以团队为的姿势，也得到了 SF 社区的欢迎。</p>\n<p>还记得，曾经连续两个季度入选 Top Writer 之后，均收到社区寄过来的小礼物和卡片，那份激动的心情。<br>以前也混过想 CNodeJS，V2EX，CSDN 之类的技术社区，但是从来没有遇到一个这么认真的技术社区。能感觉得到 SF 社区的那颗真诚在做社区的心。</p>\n<p>我经常说，程序员就像中欧的骑士一样， Fight For Honor。<br>如果 SF 捉到了这一点，就可以留住更多的优秀产出者，就会吸引更多学习者，然后再反过来哺乳社区，形成一个良性循环。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg\" alt=\"SF Top Writer\"></p>\n<h1 id=\"凌晨六点的东岸牌坊\"><a href=\"#凌晨六点的东岸牌坊\" class=\"headerlink\" title=\"凌晨六点的东岸牌坊\"></a>凌晨六点的东岸牌坊</h1><p>2016 年 3 月份，我接到了一个很酷的工作。<br>公司预定在 4 月 6 日开一场魅蓝新品发布会，而在发布会之前的预热活动，想搞一个抽奖，送特斯拉。<br>我们 Web 组提供技术支持，设计以及策划的工作由市场部的其他部门协作完成。<br>整个项目工期很赶，我们基本实行了临时的 996，加班加点赶工期，那时候很充实。</p>\n<p>就在 3 月 23 日上午，我们上线了「406魅蓝发布会」的项目。<br>上线的前一天晚上大家通宵战到天亮，我们下班打卡的时候，已经连续工作了 29 个小时。</p>\n<p>项目上线的前几个小时，太阳刚从东边升起，我们眼睁睁的看着漆黑的夜，渐渐地明亮起来。<br>珠海的三四月正是潮湿天气，空气中充满了水分子，初升的阳光很弱，还没有足够的能量消散这一层薄雾。<br>走到办公室的窗前，一副迷人朦胧的景色映入眼帘。<br>这是，凌晨 6 点钟的东岸牌坊。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg\" alt=\"东岸牌坊\"></p>\n<p>因为公司动用了大部分的传播渠道来推广这个网站，当天的日 PV 突破 100W，让我激动了很久。<br>整个项目我负责的不单单只是后端功能的开发，还需要在整个项目上把握进度，那时候能感觉到老大有放权给我们的意思，虽然没有明说。<br>这让我们在项目上，进度上，站在更加有责任感的位置思考问题。<br>技术上比较简单，前端页面提供几个 HTML 页面，服务器使用了阿里云，以及阿里云提供的 MySQL 。<br>在单元测试上我比较重视，覆盖率 100%。<br>安全性方面，使用了极验的验证码，绝大程度上避免了恶意的刷码行为。<br>这一次的项目，让我在做一个高并发、高性能、高稳定、响应速度高要求的项目有了更多的经验。</p>\n<h1 id=\"危机感\"><a href=\"#危机感\" class=\"headerlink\" title=\"危机感\"></a>危机感</h1><p>本来一切都是很顺利，团队氛围很好，也很有干劲。<br>加上之前的顺风顺水，我曾以为我能在公司干出一番成绩和事业。<br>然而开始有了一些不好的变化，4 月份公司发生了一些不开心的事，于是乎，奇怪的味道慢慢蔓延开来，从最初的难以察觉到后面越发刺鼻。<br>4 月，也正值跳槽旺季，我收到了几个猎头和一些公司的邀请。<br>由于一个意外，老大知道了，就在这个大家嗅觉都特别敏感的时期。<br>然后被约去喝咖啡了，我也正好把我所思所虑表达清楚。<br>我们老大是一个平易近人，也很能理解下属的 leader。<br>我说，魅玩帮 2.0 在即，我还可以提供一些推动力，最起码 2016 年还会留着，干完该干的事情。<br>我这样说是给老大承诺，也给自己定心，我知道坚持的美。<br>其实那时候，尽然有对薪资的不满意，但是对团队的感情，以及产品的感情更胜于此。<br>噢，不舍的还有珠海安逸的生活。<br>没有人不在意钱，我也在意。<br>而大多数人赚钱，也是为了让生活更美好。<br>但是如果一旦你的生活跟一家公司强关联起来，就没法确保你安逸的生活哪一天不会被毁掉。<br>同时，你的决定和行动也会受到更加多因素的影响和束缚。</p>\n<p>无论怎么样，终究，我的危机感变得比以往更加强烈。</p>\n<h1 id=\"魅玩帮-2-0\"><a href=\"#魅玩帮-2-0\" class=\"headerlink\" title=\"魅玩帮 2.0\"></a>魅玩帮 2.0</h1><p>魅玩帮尝试了最后一个转型，从「试玩」为主转向「内容输出」为主。<br>于是，魅玩帮走向了 2.0。<br>2.0 的功能点很多，需求也很多。<br>但是对于我来说，技术上早已经轻车熟路，所以问题不大。<br>大多都是业务，逻辑，API。<br>值得写的东西也不多。</p>\n<h1 id=\"西山日薄的魅玩帮\"><a href=\"#西山日薄的魅玩帮\" class=\"headerlink\" title=\"西山日薄的魅玩帮\"></a>西山日薄的魅玩帮</h1><p>经过两年的时间，魅玩帮的模式也玩的差不多了，功能也越发趋于完善，产品也越来越成熟。<br>但是，我也渐渐地明白，魅玩帮的模式，有一个致命的弱点，没有直接的盈利模式。<br>它的影响力，是附属在魅族品牌下的，只能是营销上的一个辅助性工具，就算我们技术上把项目做得再精，再出色。<br>没有发现盈利点，就没能够在内部提高我们的不可割舍性，最直接的影响也就是我们的待遇和福利。<br>我们没有给公司创造收入，那么我们的工资就像是在烧钱。（实际上，我们内部接的营销项目，也是间接帮公司省掉外包的支出）<br>在年末，上层决定要把「魅玩帮」并入到「魅族社区」，我渐渐的意识到我们做了两年多的产品已经西山日薄了。</p>\n<p>我也发现，这时候离开，是对团队的影响最小的时候。</p>\n<h1 id=\"成长\"><a href=\"#成长\" class=\"headerlink\" title=\"成长\"></a>成长</h1><p>从大学实习开始，直到毕业之后的一年半，已经在魅族度过了两年零三个月。<br>在这里经历过很多的第一次，也认识了很棒很聪明的朋友和同事，从他们身上看到，也学到了很多东西。<br>在这里，我的生活和工作是融合在一起的，但却没有一丝的违和感，融合的那么自然，有机。<br>团队的大家除了是同事，还是一群好朋友，好基友。<br>而技术老大，两年了，也像师傅一样，从最初的手把手教，到后面的信任，放手。<br>慢慢的，忽然意识到，是时候出师了。</p>\n<p>在这里锻炼的不单单只有技术，<br>还有做人、做事的道理，<br>还有职场上处事的道理，<br>还有眼界和认识，<br>还有思维方式，思考方法<br>等等……</p>\n<p>是的，感谢魅族。<br>今天，我毕业了，从魅族。</p>\n<h1 id=\"夏天\"><a href=\"#夏天\" class=\"headerlink\" title=\"夏天\"></a>夏天</h1><p>魅族，诞生在一个南方的海滨城市——珠海。<br>这里一年中似乎只有夏天与冬天，秋天和春天短到以至于你感觉不到他们来过。<br>魅族科技楼的前面，立着一颗树。<br>我依然清晰的记得，那一年，我来的时候，它满载绿油油的叶子。<br>在阳光下，温暖且湿润的风吹过，叶子唰唰的响，切出无数缕光束，打到我的脸上。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg\" alt=\"夏天\"></p>\n","excerpt":"","more":"<h1 id=\"冬天\"><a href=\"#冬天\" class=\"headerlink\" title=\"冬天\"></a>冬天</h1><p>我在离职协议书上面，签下了名字。<br>犹如当年签订实习协议一样的字迹，不同的只是那份心情。</p>\n<p>我坐在魅族大楼前面围绕着一颗树而摆成的弧形长椅子，喝了口小卖部买来的咖啡。<br>两年半之间，偶尔在午后偷得一丝慵懒，来到这里喝杯咖啡，感受着珠海的安静。</p>\n<p>抬头45度，当年满载绿叶的树，已经被寒风吹散，只剩下枝与干。<br>我曾经幻想过很多次，会有一个两鬓斑白的老人坐在我身旁，告诉我这棵树的名字和故事。</p>\n<p>如此我的故事就会变得更具戏剧性，但现在我只能叫它「一棵树」。<br>一棵树先生，花开花落，经历过多少个珠海的冬与夏。<br>我两年半的魅族生涯，也被他看在眼里。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg\" alt=\"冬天\"></p>\n<h1 id=\"实习\"><a href=\"#实习\" class=\"headerlink\" title=\"实习\"></a>实习</h1><p>2014 年的暑假过后，跟我一起在大学做了不少项目的死党糖水哥找到了深圳的实习。<br>他总是什么都比我快一步，也是从他话语中知道了珠海魅族下的笔戈科技在招「前端开发」。</p>\n<p>同时，带我入坑前端开发以及给予我第一个实战机会的师兄，邀请我到他的公司工作。<br>在投简历的前两天，我去拜访以前实习的公司。因为那里是我成长过的地方，那时候公司不大，几个人，但是气氛很好。虽然短短的两个月，但是对这家公司的感情还是蛮深刻的。<br>师兄知道我正在找实习，就邀请我来一起干，让我负责主要的 NodeJS 和前端开发。<br>一时间，我下不了决定。一方面难以拒绝师兄的热情相邀，一方面又放不下自己准备良久的面试。我当时就实说了，正在准备面试一家公司，待我回去考虑过再给答复。<br>回去后，我思考了一个晚上，也用笔和纸列举了去两家公司的利与弊。<br>最终，我还是决定了先去魅族试一下。</p>\n<p>我很感激师兄的邀请和对我的欣赏，但是那时候的我就一心想见识更多的人与事。<br>我记得跟他说了一句话：「我想试一下魅族」。<br>是的，我只投了一封简历，只投给了魅族笔戈科技。</p>\n<p>很快就收到了面试官回复的邮件。大概内容就是很高兴收到简历，然后约定电话面试的时间。<br>在经过一个多小时的电话面试，以及一个面对面面试。<br>我终于收到了魅族的 Offer 邮件。</p>\n<p>同时，还收到了总监盖文张的额外邮件，邮件内容主要介绍了魅族科技、笔戈科技、还有简单的个人简介，还扔了一大堆文献资料要我去阅读。最后还不忘布置一个家庭作业：一份关于我自身的全面社交账号列表，以及详细的自我简介，以及我未来想要做的事情。</p>\n<p>从邮件的文字中，能深刻的感受盖文张对于每个成员负责的态度。<br>那时候我很高兴，能和一位如此有亲和力和有想法的人工作，那是多么幸运的事情。</p>\n<p>所以，尽然我语文作文能力低弱，也是使劲的憋出了一篇2000字的感想。</p>\n<h1 id=\"笔戈科技\"><a href=\"#笔戈科技\" class=\"headerlink\" title=\"笔戈科技\"></a>笔戈科技</h1><p>我记得第一次踏入魅族科技楼的一瞬间，看到一楼大厅的装横的那份感动。<br>就像那时候魅族设计出来的手机一样，那么的简洁，那么的灵动。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg\" alt=\"魅族一楼大厅\"></p>\n<p>我在笔戈科技，所属于 Web 开发组，组内只有老大一个 NodeJS 开发，再加上包括我在内的三个前端实习生。<br>老大跟我说，你看这么多前端实习生，本来不打算再招前端实习生了，但是看到你以前做的项目蛮多的，就破例了。这句话，让我心里偷偷窃喜了好一段时间。</p>\n<p>当时我们组主要是负责笔戈博客项目，以及一些营销导向型的短期项目。<br>笔戈博客是在 Ghost 的基础上构建的，修修补补源代码，加上了一些业务性的定制功能。<br>我记得那时候看 Ghost 的源码，因为不懂 Promise ，看的非常吃力。<br>Ghost 的前端部分使用的是 EmberJS，在2014年前端的 MVC 框架比较流行的是 AngularJS、EmberJS、BackboneJS。<br>构建项目的用的是 Grunt，CSS 部分的 sass、less 在当年也已经开始普及起来。<br>对于我一个只懂 jQuery、BootStrap 、以及前端三项基本功的实习生，掌握前端工程化技术是一项让人充满新鲜感与兴奋的挑战。</p>\n<p>当时技术团队的人员配置很不平衡，一个后端对应三个前端，所以后端的工作强度很大，前端反而显得清闲。<br>不出半个月，一个午饭时分，老大跟我说：「你不是会 NodeJS 吗，要不尝试转后端？」<br>我思考了很久，大学立下的职业规划是成为一名出色的前端工程师。<br>但是要做好前端，首先是成为一名合格的软件工程师。我觉得是一次机会，所以就答应了，后面的两年的时间，工作上就绝大部分从事着后端开发。<br>随后我也感激我当时的选择，后端的工作能让我从不同的角度来了解软件开发。<br>在我转型不久，很快又来了一位 NodeJS 实习生。从现在来看，他也是我们组最后的一位实习生。</p>\n<p>在笔戈科技，虽然有不同的职能组，但是那时候人还少，不同职能的大家都可以混在一起，而且管理上也十分的扁平化。我们使用很多优秀的工具来进行团队合作，例如 Teambition、Google Docs，还统一购买科学上网服务。</p>\n<p>就像我在入职前写给盖文张对于笔戈的看法所描述的，笔戈科技就像魅族的一个特种部队，效率和敏捷性都很高。</p>\n<h1 id=\"笔戈玩\"><a href=\"#笔戈玩\" class=\"headerlink\" title=\"笔戈玩\"></a>笔戈玩</h1><p>在入职直到 2014 年末之前，我都一直做着一些琐碎的事情，笔戈博客的维护，以及一些营销导向性的短期项目，就像内部的一个外包技术团队。<br>我想，如果那时候没有魅玩帮的立项，估计我半年之后就不会在魅族了。</p>\n<p>就趋近于年末的时候，盖文张召集我们技术组开会，谈论一个新项目的想法。<br>要做一个魅族旗下推广型的平台，推广方向就是我们所从事的「智能硬件」方向。<br>这时候，一个智能硬件试玩网站的雏形诞生了，叫「笔戈玩」。</p>\n<p>项目立项了，就要撸起袖子开始干了。<br>团队的主要技术栈是 NodeJS，我们需要一个能快速搭建项目的 NodeJS 企业级开发框架。<br>我们对比了 Meteor、Strongloop、SailsJS，最后被 SailsJS 清晰的 MVC 分层所吸引，选择了 SailsJS 框架来开发。当然，框架的功能性，扩展性，和社区活跃度都是需要被考虑的，记得当年我写了一篇 <a href=\"http://huang-jerryc.com/2015/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Sails/\">《为什么使用 SailsJS》</a>，现在看回去，有不少的东西可以补充。</p>\n<p>就这样，一个老大带着四个实习生，三个 NodeJS，两个前端，从项目分析、概要设计、详细设计、数据库设计、再到编码实现，在农历年之前完成了「笔戈玩」的第一版本。<br>年后，由于之前对框架的不熟悉，导致产出的代码欠佳，然后重新推翻，再次重构。<br>又一个月的时间，发布了第一个内部测试版本。<br>经过一段时间的测试、修复、运营准备，终于在 2015 年 5 月 21 日，「笔戈玩」正式上线。</p>\n<h1 id=\"简书-——-笔戈-Web-Team\"><a href=\"#简书-——-笔戈-Web-Team\" class=\"headerlink\" title=\"简书 —— 笔戈 Web Team\"></a>简书 —— 笔戈 Web Team</h1><p>在「笔戈玩」第一版本上线之后，我也迎来了我的毕业。</p>\n<p>盖文张是很注重团队成员自身发展的，他也很鼓励我们多看书多涉猎，也建立了读书经费。<br>在我们办公室的角落，就有一个小小的书柜，都放满了大家要求买的书。<br>除了看书，多写作也是被鼓励的。<br>笔戈博客是我们部门的业余产出，写作就像笔戈不成形的团队文化，当时就在全部门内推行了这样的制度：每人每月定额产出文章，产出不奖励，不产出要罚钱。<br>产出的文章，经过筛选，会发表在笔戈博客。<br>我们写代码的人要求低一点，一个月一篇，写不出要罚 100 块，罚的钱，用来补贴部门经费。<br>我那时候的实习工资 2000 加上补贴，一个月不缺勤到手也就 2700。罚 100 块，是多么痛心的事情。<br>所以我们憋也要憋出来几个字。</p>\n<p>如果我们写一些技术类的，倒是没那么痛苦。<br>可偏偏那时候我们技术老大说，尽量不要写技术类的。理由是笔戈博客的读者并不是技术向的。<br>其实对于我们这群纯理科生，是有点为难的。<br>我在笔戈的第一篇文章，是使劲憋出来的：<a href=\"http://huang-jerryc.com/2015/03/03/%E7%9B%98%E7%82%B9%E5%9B%BD%E5%86%85%E7%9A%84%E9%82%A3%E4%BA%9BROM/\">《盘点国内的那些ROM》</a></p>\n<p>之后我就在思考，有什么办法可以发挥我们的所长，并且符合这个制度。<br>我的想法是，我们团队应该是作为一个技术团队的名义来抛头露面，我们的产出可以是纯技术导向，我们把内容聚合起来，作为一个专题，或一个频道，或者其他什么样的形式。</p>\n<p>正好笔戈当时也在简书上面发表文章，以增加曝光度。<br>我就回学校毕业之前，给盖文张发了一封邮件，把我对团队文化建设的构思路描述了一遍。<br>大概就是先从简书开始，建立一个「笔戈 Web Team」的专题，以笔戈的名义为依托，来给我们技术人提供练笔和展示的地方。<br>因为简书并不是纯粹的技术社区，受众并不多，我们可以肆无忌惮的写一点东西，而不怕被人鄙视水平不够。<br>待我们的水平和产出上来了，考虑转移更纯粹的技术社区，或者建立团队的技术博客。<br>我举例了 AlloyTeam，Taobao FED 这些大厂出名的博客。<br>同时还说明了这样做的好处，一是写作会逼迫我们思考和总结，对我们技术水平提升有明显的作用。二是可以打响名声，提高成员自豪感，提升凝聚力，同时也有助于招聘。</p>\n<p>盖文张很快回复了邮件，他赞同这样的做法，另外给了我笔戈科技在简书的账号密码，让我来创建这个专题。<br>同时，我也把这个想法跟技术老大说。我们老大是很进步向的，也很赞成这样的做法。</p>\n<p>自此，我们开始以团队的名义进行技术文章的产出，一点一点的积累和提升。<br>截止现在，尽管我们已经转移产出的场地，但是简书上面的 「<a href=\"http://www.jianshu.com/c/2a4335808d4c\">笔戈 Web Team</a>」，已经有103篇文章。</p>\n<h1 id=\"第一次出省\"><a href=\"#第一次出省\" class=\"headerlink\" title=\"第一次出省\"></a>第一次出省</h1><p>从大学毕业之后，我和魅族签订了我人生的第一份劳动合同。正式成为了魅族的员工，虽然之前实习的日子都是被当做正式员工来用。但是不同的是，我终于可以领着符合水平的薪水了。</p>\n<p>毕业回来正好碰上了 MX5 的发布会，公司需要征集员工志愿者，我就应征了。<br>于是乎，人生第一次出差，也是这个稚嫩的广东人的第一次出省。</p>\n<p>我们订的是动卧票，晚上从广州出发， 第二天就能到北京。<br>看着地图的定位慢慢的越过广东的边界，心头涌上莫名的一股激动。<br>记得那天晚上，躺在摇晃的车厢中，闭上眼，脑海晃出了很多画面，一场星际旅行。</p>\n<p>然后，打开当时很流行的「足记」，写下了一些胡思乱想。<br>现在看回去，自己还真像个小孩。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg\" alt=\"出省\"></p>\n<p>同行的还有几个要好的同事，我们是提前一天到达的。<br>在空闲的时间，我们相约去了北京的「798艺术区」。<br>我想，每一个来到这里的年轻人，都会爱上这里弥漫着创意以及艺术气息的空气。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg\" alt=\"798艺术区\"></p>\n<h1 id=\"第一次出国\"><a href=\"#第一次出国\" class=\"headerlink\" title=\"第一次出国\"></a>第一次出国</h1><p>在北京回来之后，正好碰上公司的年度旅游。<br>听一些老员工说「今年开始才有旅游经费的，你碰到好时候了」，比较遗憾的是，那也是唯一一年有旅游经费的。<br>公司的旅游经费只够短距离玩个三四天左右，以自行组织报销的形式，然后部门的一些土豪君给出一种方案，就是自己多掏腰包，然后一起去泰国玩一转。<br>听到这方案，心里埋藏已久的射手座的心，再出跳出来作祟。<br>花光了一年实习的积蓄，跟着土豪同事们去泰国了，那也是我第一次踏出中国的大陆。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg\" alt=\"泰旅\"><br><img src=\"/image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg\" alt=\"泰旅\"></p>\n<h1 id=\"魅玩帮\"><a href=\"#魅玩帮\" class=\"headerlink\" title=\"魅玩帮\"></a>魅玩帮</h1><p>2015 年 9 月，「笔戈玩」更名「魅玩帮」，明确定位「魅族旗下新品分享平台」，由新的总监接手这个项目，帮团队理了至关重要的一件事：产品要和魅族价值挂钩。</p>\n<p>Web 开发组，自然而然也就划分到新总监门下。<br>这时候我们小组已经从当初的 5 人小团队，增加到 11 人了，<br>继我们组最后一个实习生之后， 又来了一个测试妹子，后来转运维去了。<br>然后，又来了一个 NodeJS 的后端，除了帅人品还很好。<br>然后，又来了一个测试妹子，爱吃爱玩，还会卖萌，我经常说：「你要是瘦了肯定是个美女」。<br>同时间来的还有一个香港硕士生，做前端开发，人帅，逼格比我还高。<br>再后来，又来了一个 JAVA 的后端，也是硕士毕业，基础很赞，人很接地气。<br>最后，再来了一个项目经理。<br>再加上原来项目整合分配到的一位御用设计师，和一位会卖萌的产品经理。<br>于是乎，「魅玩帮」团队，从一个实习生团队，慢慢的增长到一个成型的小团队，配置到位。<br>卖萌产经经常说，她遇到一群聪明的人。</p>\n<p>项目重定位之后的一系列工作就是接入魅族用户中心，魅族论坛，Flyme 论坛。<br>这涉及到跨部门之间的合作，由于技术上是由我一直跟对方沟通的。<br>后来，老大跟我说：「你参与的比较多，由你来主导这次开发吧」，喜出望外。<br>随后被打了鸡血一样，事无巨细，从设计、文档、技术方案给理了清楚，再加上一群很棒的伙伴，功能很快就做完了。</p>\n<p>随着「魅玩帮」的用户量上升，产品想要一个「消息提醒」的功能。之前的工作给老大留下了不错的印象，这个任务就被分给我了。<br>消息系统的开发，也是我觉得工作内做的比较有条理性的工作之一。<br>经常性，产品想要一个东西，但是并不能完全的描述这个东西的细节，消息提醒也是一样。<br>开发需要做的是，帮忙缕清整个东西的逻辑和业务，我首先是分析业内的一些成型的产品，例如知乎、简书的消息提醒功能。<br>通过分析，抽象本质，整理业务功能，写出大概的功能设计，以及实现思路，然后再开会沟通。<br>经过多次沟通和修改，然后编码实现。<br>那时候明白了一个道理，一项功能或者一个项目，最费时间和精力的是在前期的沟通和设计上面，编码实现在一个熟练的开发者手上，反而是最简单的事情。<br>最后内部整理文档，外部输出思路：<a href=\"http://huang-jerryc.com/2015/10/14/%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8C%E4%B8%8A%E7%AF%87%E3%80%8D/\">《消息系统设计与实现》</a></p>\n<h1 id=\"优秀员工\"><a href=\"#优秀员工\" class=\"headerlink\" title=\"优秀员工\"></a>优秀员工</h1><p>很快，2015 年过去了。<br>部门年会在一家酒店吃年夜饭，那是难忘的一天。<br>那一天，收到了一个肯定，「优秀员工奖」。<br>是我们技术老大帮忙提名的，记得他年末跟我谈话的时候说的一句：「你是进步最快的，比其他人更靠谱些」。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg\" alt=\"优秀员工奖\"></p>\n<h1 id=\"Segmentfault-——-魅族科技开发团队\"><a href=\"#Segmentfault-——-魅族科技开发团队\" class=\"headerlink\" title=\"Segmentfault —— 魅族科技开发团队\"></a>Segmentfault —— 魅族科技开发团队</h1><p>年后，经过半年的时间，我们组对于技术的积累，以及文笔的熟练度，有了一定的提升。<br>于是乎，我们开始考虑换一个输出文章的地方。<br>当时我的想法是，建立一个我们独立的博客站点，但我的只能算作提议，最终还是技术 leader 以他认可的方式行动了：在 Segmentfault 以团队的名义来输出内容。<br>于是，我们在 SF 建立了专题：「<a href=\"https://segmentfault.com/blog/meizu\">魅族科技开发团队</a>」。<br>现在回想起来，这的确是一个明智之举，借助更垂直化的社区，可以给我们带来更多的关注量，和曝光度。当时魅族内部，还没有以团队名义来对外输出内容，我们做了，而且还做得不错。<br>同时，以团队为的姿势，也得到了 SF 社区的欢迎。</p>\n<p>还记得，曾经连续两个季度入选 Top Writer 之后，均收到社区寄过来的小礼物和卡片，那份激动的心情。<br>以前也混过想 CNodeJS，V2EX，CSDN 之类的技术社区，但是从来没有遇到一个这么认真的技术社区。能感觉得到 SF 社区的那颗真诚在做社区的心。</p>\n<p>我经常说，程序员就像中欧的骑士一样， Fight For Honor。<br>如果 SF 捉到了这一点，就可以留住更多的优秀产出者，就会吸引更多学习者，然后再反过来哺乳社区，形成一个良性循环。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg\" alt=\"SF Top Writer\"></p>\n<h1 id=\"凌晨六点的东岸牌坊\"><a href=\"#凌晨六点的东岸牌坊\" class=\"headerlink\" title=\"凌晨六点的东岸牌坊\"></a>凌晨六点的东岸牌坊</h1><p>2016 年 3 月份，我接到了一个很酷的工作。<br>公司预定在 4 月 6 日开一场魅蓝新品发布会，而在发布会之前的预热活动，想搞一个抽奖，送特斯拉。<br>我们 Web 组提供技术支持，设计以及策划的工作由市场部的其他部门协作完成。<br>整个项目工期很赶，我们基本实行了临时的 996，加班加点赶工期，那时候很充实。</p>\n<p>就在 3 月 23 日上午，我们上线了「406魅蓝发布会」的项目。<br>上线的前一天晚上大家通宵战到天亮，我们下班打卡的时候，已经连续工作了 29 个小时。</p>\n<p>项目上线的前几个小时，太阳刚从东边升起，我们眼睁睁的看着漆黑的夜，渐渐地明亮起来。<br>珠海的三四月正是潮湿天气，空气中充满了水分子，初升的阳光很弱，还没有足够的能量消散这一层薄雾。<br>走到办公室的窗前，一副迷人朦胧的景色映入眼帘。<br>这是，凌晨 6 点钟的东岸牌坊。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg\" alt=\"东岸牌坊\"></p>\n<p>因为公司动用了大部分的传播渠道来推广这个网站，当天的日 PV 突破 100W，让我激动了很久。<br>整个项目我负责的不单单只是后端功能的开发，还需要在整个项目上把握进度，那时候能感觉到老大有放权给我们的意思，虽然没有明说。<br>这让我们在项目上，进度上，站在更加有责任感的位置思考问题。<br>技术上比较简单，前端页面提供几个 HTML 页面，服务器使用了阿里云，以及阿里云提供的 MySQL 。<br>在单元测试上我比较重视，覆盖率 100%。<br>安全性方面，使用了极验的验证码，绝大程度上避免了恶意的刷码行为。<br>这一次的项目，让我在做一个高并发、高性能、高稳定、响应速度高要求的项目有了更多的经验。</p>\n<h1 id=\"危机感\"><a href=\"#危机感\" class=\"headerlink\" title=\"危机感\"></a>危机感</h1><p>本来一切都是很顺利，团队氛围很好，也很有干劲。<br>加上之前的顺风顺水，我曾以为我能在公司干出一番成绩和事业。<br>然而开始有了一些不好的变化，4 月份公司发生了一些不开心的事，于是乎，奇怪的味道慢慢蔓延开来，从最初的难以察觉到后面越发刺鼻。<br>4 月，也正值跳槽旺季，我收到了几个猎头和一些公司的邀请。<br>由于一个意外，老大知道了，就在这个大家嗅觉都特别敏感的时期。<br>然后被约去喝咖啡了，我也正好把我所思所虑表达清楚。<br>我们老大是一个平易近人，也很能理解下属的 leader。<br>我说，魅玩帮 2.0 在即，我还可以提供一些推动力，最起码 2016 年还会留着，干完该干的事情。<br>我这样说是给老大承诺，也给自己定心，我知道坚持的美。<br>其实那时候，尽然有对薪资的不满意，但是对团队的感情，以及产品的感情更胜于此。<br>噢，不舍的还有珠海安逸的生活。<br>没有人不在意钱，我也在意。<br>而大多数人赚钱，也是为了让生活更美好。<br>但是如果一旦你的生活跟一家公司强关联起来，就没法确保你安逸的生活哪一天不会被毁掉。<br>同时，你的决定和行动也会受到更加多因素的影响和束缚。</p>\n<p>无论怎么样，终究，我的危机感变得比以往更加强烈。</p>\n<h1 id=\"魅玩帮-2-0\"><a href=\"#魅玩帮-2-0\" class=\"headerlink\" title=\"魅玩帮 2.0\"></a>魅玩帮 2.0</h1><p>魅玩帮尝试了最后一个转型，从「试玩」为主转向「内容输出」为主。<br>于是，魅玩帮走向了 2.0。<br>2.0 的功能点很多，需求也很多。<br>但是对于我来说，技术上早已经轻车熟路，所以问题不大。<br>大多都是业务，逻辑，API。<br>值得写的东西也不多。</p>\n<h1 id=\"西山日薄的魅玩帮\"><a href=\"#西山日薄的魅玩帮\" class=\"headerlink\" title=\"西山日薄的魅玩帮\"></a>西山日薄的魅玩帮</h1><p>经过两年的时间，魅玩帮的模式也玩的差不多了，功能也越发趋于完善，产品也越来越成熟。<br>但是，我也渐渐地明白，魅玩帮的模式，有一个致命的弱点，没有直接的盈利模式。<br>它的影响力，是附属在魅族品牌下的，只能是营销上的一个辅助性工具，就算我们技术上把项目做得再精，再出色。<br>没有发现盈利点，就没能够在内部提高我们的不可割舍性，最直接的影响也就是我们的待遇和福利。<br>我们没有给公司创造收入，那么我们的工资就像是在烧钱。（实际上，我们内部接的营销项目，也是间接帮公司省掉外包的支出）<br>在年末，上层决定要把「魅玩帮」并入到「魅族社区」，我渐渐的意识到我们做了两年多的产品已经西山日薄了。</p>\n<p>我也发现，这时候离开，是对团队的影响最小的时候。</p>\n<h1 id=\"成长\"><a href=\"#成长\" class=\"headerlink\" title=\"成长\"></a>成长</h1><p>从大学实习开始，直到毕业之后的一年半，已经在魅族度过了两年零三个月。<br>在这里经历过很多的第一次，也认识了很棒很聪明的朋友和同事，从他们身上看到，也学到了很多东西。<br>在这里，我的生活和工作是融合在一起的，但却没有一丝的违和感，融合的那么自然，有机。<br>团队的大家除了是同事，还是一群好朋友，好基友。<br>而技术老大，两年了，也像师傅一样，从最初的手把手教，到后面的信任，放手。<br>慢慢的，忽然意识到，是时候出师了。</p>\n<p>在这里锻炼的不单单只有技术，<br>还有做人、做事的道理，<br>还有职场上处事的道理，<br>还有眼界和认识，<br>还有思维方式，思考方法<br>等等……</p>\n<p>是的，感谢魅族。<br>今天，我毕业了，从魅族。</p>\n<h1 id=\"夏天\"><a href=\"#夏天\" class=\"headerlink\" title=\"夏天\"></a>夏天</h1><p>魅族，诞生在一个南方的海滨城市——珠海。<br>这里一年中似乎只有夏天与冬天，秋天和春天短到以至于你感觉不到他们来过。<br>魅族科技楼的前面，立着一颗树。<br>我依然清晰的记得，那一年，我来的时候，它满载绿油油的叶子。<br>在阳光下，温暖且湿润的风吹过，叶子唰唰的响，切出无数缕光束，打到我的脸上。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg\" alt=\"夏天\"></p>\n"},{"title":"JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS","date":"2016-11-08T02:36:00.000Z","_content":"\n\n# Motivation\nJavaScript 是一款拥有「自动垃圾回收」功能的编程语言。\n市面上具有这样功能的语言，一般都是拥有相对应的虚拟机的，像 Java的JVM ，C#的CLR ，PHP的Zend。\n虚拟机一般实现了代码解析，内存的管理、布局、垃圾回收等功能。\n不像C/C++这种没有虚拟机的语言，它们需要手动管理内存。\nC/C++语言编译后的文件，是可以直接运行的。\n\n我认为学习一门开发语言，除了知道一些语法上的使用，各种API的调用以外。学习相应的虚拟机也是很有必要的。而 JavaScript 由于其特殊的历史原因，并不是只有 V8 一个引擎。但是目前 V8 它是业界最优秀的 JavaScript 引擎，也就成为了一个学习样本。\n\n如今的 JavaScript 不仅仅是用在浏览器端了，也因为 NodeJS 的关系得以在服务器端运行。和浏览器端不同的地方在于服务器端对资源的敏感性是很高的。当业务规模大了，并发量上来了，一些很细小的问题会放大。这时候一些小小的内存泄漏，都会酿造灾难。\n\n所以作为一个 JavaScript 开发者，搞清楚从敲入 `console.log('hello   world')`，直到后面交由CPU执行的中间过程是很重要的。\n这也对如何用 JavaScript 这门松散的语言编写出高质量的代码是具有指导作用的。\n\n想真正做到 JavaScript 全栈，路漫漫其修远兮。\n\n# V8 概述\nV8 作为一个 JavaScript 引擎，最初是服役于 Google Chrome 浏览器的。它随着 Chrome 的第一版发布而发布以及开源。现在它除了 Chrome 浏览器，已经有很多其他的使用者了。诸如 NodeJS、MongoDB、CouchDB 等。\n\nJavaScript 作为 Prototype-Based Language , 基于它使用 Prototype 继承的特征，V8 使用了直译的方式，即把 JavaScript 代码直接编译成机器码( Machine Code, 有些地方也叫 Native Code )，然后直接交由硬件执行。\n与传统的「编译-解析-执行」的流程不同，V8 处理 JavaScript，并没有二进制码或其他的中间码。\n\n** 简单来说，V8主要工作就是：「把 JavaScript 直译成机器码，然后运行」**\n但这中间，往往是一个复杂的过程，它需要处理很多的难题，诸如：\n1. 编译优化\n2. 内存管理\n3. 垃圾回收\n\n我写的这一系列文章，也是从这三个大点来出发，解读V8针对这些内容的处理。\n\n# V8 In NodeJS\n\n## NodeJS源码小览\n\nNodeJS，是怎么引入V8的？\n我们关注[Node的源码](https://github.com/nodejs/node)目录：\n\n```\n.\n├── ...\n├── deps\n│   ├── ...\n│   ├── v8\n│   ├── ...\n├── ...\n├── lib\n│   ├── ...\n│   ├── buffer.js\n│   ├── child_process.js\n│   ├── console.js\n│   ├── ...\n├── node -> out/Release/node\n├── ...\n├── out\n│   ├── ...\n│   ├── Release\n|         ├── node\n|         ├── node.d\n|         ├── obj\n|             └── gen\n|                 ├── ...\n|                 ├── node_natives.h\n|                 ├── ...\n│   ├── ...\n├── src\n│   ├── ...\n│   ├── debug-agent.cc\n│   ├── debug-agent.h\n│   ├── env-inl.h\n│   ├── env.cc\n│   ├── ...\n├── \n...\n```\n\n需要关注的几个目录和文件：\n\n**`/deps/v8`**：这里是V8源码所在文件夹，你会发现里面的目录结构跟[V8源码](https://github.com/v8/v8)十分相似。NodeJS除了移植V8源码，还在增添了一些内容。\n\n**`/src`**：由C/C++编写的核心模块所在文件夹，由C/C++编写的这部分模块被称为「Builtin Module」\n\n**`/lib`**：由JavaScript编写的核心模块所在文件夹，这部分被称为「Native Code」，在编译Node源码的时候，会采用V8附带的`js2c.py`工具，把所有内置的JavaScript代码转换成C++里面的数组，生成`out/Release/obj/gen/node_natives.h`文件。有些 Native Module 需要借助于 Builtin Module 实现背后的功能。\n\n**`/out`**：该目录是Node源码编译(命令行运行`make`)后生成的目录，里面包含了Node的可执行文件。当在命令行中键入`node xxx.js`，实际就是运行了`out/Release/node`文件。\n\n来张图说明一下V8在Node运行时的整体过程。\n\n![v8 in nodejs.png](/image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png)\n\nNode在启动的时候，就已经把 Native Module，Builtin Module 加载到内存里面了。后来的 JavaScript 代码，就需要通过 V8 进行动态编译解析运行。\n\n## 查看V8版本号\n\nNodeJS的进步与V8息息相关，关注每个NodeJS版本所对应的V8版本，可以加强该版本新功能的理解和由来。\n\n在NodeJS中，通过`process.versions`可以查看NodeJS依赖模块的版本号，V8就包含其中。\n\n例如，我运行的 `v7.0.0`的NodeJS：\n```\n$ node\n> process.versions\n{ http_parser: '2.7.0',\n  node: '8.0.0-pre',\n  v8: '5.4.500.36',\n  uv: '1.10.0',\n  zlib: '1.2.8',\n  ares: '1.10.1-DEV',\n  modules: '51',\n  openssl: '1.0.2j',\n  icu: '58.1',\n  unicode: '9.0',\n  cldr: '30.0.2',\n  tz: '2016g' }\n```\n\n# NodeJS与V8的缠绵\n\n- 2008年9月，V8 的第一个版本随着 Chrome 的第一版本发布。\n- 2009年5月，NodeJS 的第一个版本由 Ryan Dahl 在 GitHub 上发布。\n- 2010年12月，[官方公布](https://blog.chromium.org/2010/12/new-crankshaft-for-v8.html) V8 的名为 Crankshaft 的优化编译器，与原来的 Full Compiler 一起工作，声称较2008年版本提高50%性能。\n- 2014年12月， io.js 从久久不更新的 NodeJS 分出来支，并且引入最新的 V8 ，这时候 NodeJS 处于`0.12.17`版本。\n- 2015年2月，NodeJS基金宣布NodeJS(`v0.12`)和io.js(`v3.3`)合并，合并版本在未来发布。\n- 2015年7月7日，[官方公布](https://blog.chromium.org/2015/07/revving-up-javascript-performance-with.html)又一个新的名为TurBoFan的优化编译器，主要提供ES6的新语法，以及提高性能。并表明该编译器最终目标是全部替代Crankshaft编译器\n- 2015年7月17日，[官方发布](http://v8project.blogspot.com/2015/07/v8-45-release.html)集成TurboFan的V8版本(`v4.5`)\n- 2015年9月08日，NodeJS紧跟着[发布](https://nodejs.org/en/blog/release/v4.0.0/)了与io.js的合并版本(`V4.0`)，引入最新的V8，给开发者们带来了最新的ES6语法，以及性能上的提高。\n- 2015年8月28日，V8[发布](http://v8project.blogspot.com/2015/08/v8-release-46.html)`v4.6`版本\n- 2015年10月29日，NodeJS[发布](https://nodejs.org/en/blog/release/v5.0.0/)`V5.0.0`版本\n- 2016年3月15日，V8[发布](http://v8project.blogspot.com/2016/03/v8-release-50.html)`v5.0`版本\n- 2016年4月26日，NodeJS[发布](https://nodejs.org/en/blog/release/v6.0.0/)`V6.0.0`版本\n- 2016年7月18日，V8[发布](http://v8project.blogspot.com/2016/07/v8-release-53.html)`v5.3`版本，新增名为Ignition的解析器(Interpreter)，跟原有的优化编译器(Crankshaft and TurboFan)进行串联工作，提供了更加优化的内存使用方案，主要针对于低内存的Android设备，并称在未来会普及到全平台。\n- 2016年10月25日，NodeJS[发布](https://nodejs.org/en/blog/release/v7.0.0/)`v7.0.0`版本\n- 截止到今天(2016年11月)，NodeJS版本`v7.0.0`，搭配了`v5.4`的v8，而官方发布的最新v8版本是`v5.5`。\n\n回顾整个历程，由于NodeJS是搭建在V8之上的，所以NodeJS很多「新增语言特性」和「提高性能」等更新都需要依赖V8的发布日程。\n\n就像NodeJS和io.js宣布合并，和真正发布`V4.0`版本的中间，还隔了V8的生命历程一个重大的更新(发布 TurboFan 编译器，该编译器引入了大量的ES6语法支持。)。这个更新直接提供了相当一部分的ES6语法，以及性能上的提高。\n\n# 总结\n本篇主要描述了下面几点：\n1. 我的写作动机，理解NodeJS底层，给写出高质量JavaScript代码提供指导。\n2. 简单描述V8的角色，以及主要职责：编译优化、内存管理、垃圾回收。\n3. 通过NodeJS源码目录，以及NodeJS代码加载过程，来认识V8在这之中的位置。\n4. 罗列NodeJS与V8的历代迭代版本以及联系，强调V8在NodeJS中的地位。","source":"_posts/the-v8-what-javascripter-should-konw-of-v8-in-nodejs.md","raw":"---\ntitle: JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS\ndate: 2016-11-08 10:36:00\ntags:\n- Javascript\n- v8\n- NodeJS\ncategory: 搬砖码农\n---\n\n\n# Motivation\nJavaScript 是一款拥有「自动垃圾回收」功能的编程语言。\n市面上具有这样功能的语言，一般都是拥有相对应的虚拟机的，像 Java的JVM ，C#的CLR ，PHP的Zend。\n虚拟机一般实现了代码解析，内存的管理、布局、垃圾回收等功能。\n不像C/C++这种没有虚拟机的语言，它们需要手动管理内存。\nC/C++语言编译后的文件，是可以直接运行的。\n\n我认为学习一门开发语言，除了知道一些语法上的使用，各种API的调用以外。学习相应的虚拟机也是很有必要的。而 JavaScript 由于其特殊的历史原因，并不是只有 V8 一个引擎。但是目前 V8 它是业界最优秀的 JavaScript 引擎，也就成为了一个学习样本。\n\n如今的 JavaScript 不仅仅是用在浏览器端了，也因为 NodeJS 的关系得以在服务器端运行。和浏览器端不同的地方在于服务器端对资源的敏感性是很高的。当业务规模大了，并发量上来了，一些很细小的问题会放大。这时候一些小小的内存泄漏，都会酿造灾难。\n\n所以作为一个 JavaScript 开发者，搞清楚从敲入 `console.log('hello   world')`，直到后面交由CPU执行的中间过程是很重要的。\n这也对如何用 JavaScript 这门松散的语言编写出高质量的代码是具有指导作用的。\n\n想真正做到 JavaScript 全栈，路漫漫其修远兮。\n\n# V8 概述\nV8 作为一个 JavaScript 引擎，最初是服役于 Google Chrome 浏览器的。它随着 Chrome 的第一版发布而发布以及开源。现在它除了 Chrome 浏览器，已经有很多其他的使用者了。诸如 NodeJS、MongoDB、CouchDB 等。\n\nJavaScript 作为 Prototype-Based Language , 基于它使用 Prototype 继承的特征，V8 使用了直译的方式，即把 JavaScript 代码直接编译成机器码( Machine Code, 有些地方也叫 Native Code )，然后直接交由硬件执行。\n与传统的「编译-解析-执行」的流程不同，V8 处理 JavaScript，并没有二进制码或其他的中间码。\n\n** 简单来说，V8主要工作就是：「把 JavaScript 直译成机器码，然后运行」**\n但这中间，往往是一个复杂的过程，它需要处理很多的难题，诸如：\n1. 编译优化\n2. 内存管理\n3. 垃圾回收\n\n我写的这一系列文章，也是从这三个大点来出发，解读V8针对这些内容的处理。\n\n# V8 In NodeJS\n\n## NodeJS源码小览\n\nNodeJS，是怎么引入V8的？\n我们关注[Node的源码](https://github.com/nodejs/node)目录：\n\n```\n.\n├── ...\n├── deps\n│   ├── ...\n│   ├── v8\n│   ├── ...\n├── ...\n├── lib\n│   ├── ...\n│   ├── buffer.js\n│   ├── child_process.js\n│   ├── console.js\n│   ├── ...\n├── node -> out/Release/node\n├── ...\n├── out\n│   ├── ...\n│   ├── Release\n|         ├── node\n|         ├── node.d\n|         ├── obj\n|             └── gen\n|                 ├── ...\n|                 ├── node_natives.h\n|                 ├── ...\n│   ├── ...\n├── src\n│   ├── ...\n│   ├── debug-agent.cc\n│   ├── debug-agent.h\n│   ├── env-inl.h\n│   ├── env.cc\n│   ├── ...\n├── \n...\n```\n\n需要关注的几个目录和文件：\n\n**`/deps/v8`**：这里是V8源码所在文件夹，你会发现里面的目录结构跟[V8源码](https://github.com/v8/v8)十分相似。NodeJS除了移植V8源码，还在增添了一些内容。\n\n**`/src`**：由C/C++编写的核心模块所在文件夹，由C/C++编写的这部分模块被称为「Builtin Module」\n\n**`/lib`**：由JavaScript编写的核心模块所在文件夹，这部分被称为「Native Code」，在编译Node源码的时候，会采用V8附带的`js2c.py`工具，把所有内置的JavaScript代码转换成C++里面的数组，生成`out/Release/obj/gen/node_natives.h`文件。有些 Native Module 需要借助于 Builtin Module 实现背后的功能。\n\n**`/out`**：该目录是Node源码编译(命令行运行`make`)后生成的目录，里面包含了Node的可执行文件。当在命令行中键入`node xxx.js`，实际就是运行了`out/Release/node`文件。\n\n来张图说明一下V8在Node运行时的整体过程。\n\n![v8 in nodejs.png](/image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png)\n\nNode在启动的时候，就已经把 Native Module，Builtin Module 加载到内存里面了。后来的 JavaScript 代码，就需要通过 V8 进行动态编译解析运行。\n\n## 查看V8版本号\n\nNodeJS的进步与V8息息相关，关注每个NodeJS版本所对应的V8版本，可以加强该版本新功能的理解和由来。\n\n在NodeJS中，通过`process.versions`可以查看NodeJS依赖模块的版本号，V8就包含其中。\n\n例如，我运行的 `v7.0.0`的NodeJS：\n```\n$ node\n> process.versions\n{ http_parser: '2.7.0',\n  node: '8.0.0-pre',\n  v8: '5.4.500.36',\n  uv: '1.10.0',\n  zlib: '1.2.8',\n  ares: '1.10.1-DEV',\n  modules: '51',\n  openssl: '1.0.2j',\n  icu: '58.1',\n  unicode: '9.0',\n  cldr: '30.0.2',\n  tz: '2016g' }\n```\n\n# NodeJS与V8的缠绵\n\n- 2008年9月，V8 的第一个版本随着 Chrome 的第一版本发布。\n- 2009年5月，NodeJS 的第一个版本由 Ryan Dahl 在 GitHub 上发布。\n- 2010年12月，[官方公布](https://blog.chromium.org/2010/12/new-crankshaft-for-v8.html) V8 的名为 Crankshaft 的优化编译器，与原来的 Full Compiler 一起工作，声称较2008年版本提高50%性能。\n- 2014年12月， io.js 从久久不更新的 NodeJS 分出来支，并且引入最新的 V8 ，这时候 NodeJS 处于`0.12.17`版本。\n- 2015年2月，NodeJS基金宣布NodeJS(`v0.12`)和io.js(`v3.3`)合并，合并版本在未来发布。\n- 2015年7月7日，[官方公布](https://blog.chromium.org/2015/07/revving-up-javascript-performance-with.html)又一个新的名为TurBoFan的优化编译器，主要提供ES6的新语法，以及提高性能。并表明该编译器最终目标是全部替代Crankshaft编译器\n- 2015年7月17日，[官方发布](http://v8project.blogspot.com/2015/07/v8-45-release.html)集成TurboFan的V8版本(`v4.5`)\n- 2015年9月08日，NodeJS紧跟着[发布](https://nodejs.org/en/blog/release/v4.0.0/)了与io.js的合并版本(`V4.0`)，引入最新的V8，给开发者们带来了最新的ES6语法，以及性能上的提高。\n- 2015年8月28日，V8[发布](http://v8project.blogspot.com/2015/08/v8-release-46.html)`v4.6`版本\n- 2015年10月29日，NodeJS[发布](https://nodejs.org/en/blog/release/v5.0.0/)`V5.0.0`版本\n- 2016年3月15日，V8[发布](http://v8project.blogspot.com/2016/03/v8-release-50.html)`v5.0`版本\n- 2016年4月26日，NodeJS[发布](https://nodejs.org/en/blog/release/v6.0.0/)`V6.0.0`版本\n- 2016年7月18日，V8[发布](http://v8project.blogspot.com/2016/07/v8-release-53.html)`v5.3`版本，新增名为Ignition的解析器(Interpreter)，跟原有的优化编译器(Crankshaft and TurboFan)进行串联工作，提供了更加优化的内存使用方案，主要针对于低内存的Android设备，并称在未来会普及到全平台。\n- 2016年10月25日，NodeJS[发布](https://nodejs.org/en/blog/release/v7.0.0/)`v7.0.0`版本\n- 截止到今天(2016年11月)，NodeJS版本`v7.0.0`，搭配了`v5.4`的v8，而官方发布的最新v8版本是`v5.5`。\n\n回顾整个历程，由于NodeJS是搭建在V8之上的，所以NodeJS很多「新增语言特性」和「提高性能」等更新都需要依赖V8的发布日程。\n\n就像NodeJS和io.js宣布合并，和真正发布`V4.0`版本的中间，还隔了V8的生命历程一个重大的更新(发布 TurboFan 编译器，该编译器引入了大量的ES6语法支持。)。这个更新直接提供了相当一部分的ES6语法，以及性能上的提高。\n\n# 总结\n本篇主要描述了下面几点：\n1. 我的写作动机，理解NodeJS底层，给写出高质量JavaScript代码提供指导。\n2. 简单描述V8的角色，以及主要职责：编译优化、内存管理、垃圾回收。\n3. 通过NodeJS源码目录，以及NodeJS代码加载过程，来认识V8在这之中的位置。\n4. 罗列NodeJS与V8的历代迭代版本以及联系，强调V8在NodeJS中的地位。","slug":"the-v8-what-javascripter-should-konw-of-v8-in-nodejs","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8sn004ixwrlmkhha2my","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h1><p>JavaScript 是一款拥有「自动垃圾回收」功能的编程语言。<br>市面上具有这样功能的语言，一般都是拥有相对应的虚拟机的，像 Java的JVM ，C#的CLR ，PHP的Zend。<br>虚拟机一般实现了代码解析，内存的管理、布局、垃圾回收等功能。<br>不像C/C++这种没有虚拟机的语言，它们需要手动管理内存。<br>C/C++语言编译后的文件，是可以直接运行的。</p>\n<p>我认为学习一门开发语言，除了知道一些语法上的使用，各种API的调用以外。学习相应的虚拟机也是很有必要的。而 JavaScript 由于其特殊的历史原因，并不是只有 V8 一个引擎。但是目前 V8 它是业界最优秀的 JavaScript 引擎，也就成为了一个学习样本。</p>\n<p>如今的 JavaScript 不仅仅是用在浏览器端了，也因为 NodeJS 的关系得以在服务器端运行。和浏览器端不同的地方在于服务器端对资源的敏感性是很高的。当业务规模大了，并发量上来了，一些很细小的问题会放大。这时候一些小小的内存泄漏，都会酿造灾难。</p>\n<p>所以作为一个 JavaScript 开发者，搞清楚从敲入 <code>console.log(&#39;hello   world&#39;)</code>，直到后面交由CPU执行的中间过程是很重要的。<br>这也对如何用 JavaScript 这门松散的语言编写出高质量的代码是具有指导作用的。</p>\n<p>想真正做到 JavaScript 全栈，路漫漫其修远兮。</p>\n<h1 id=\"V8-概述\"><a href=\"#V8-概述\" class=\"headerlink\" title=\"V8 概述\"></a>V8 概述</h1><p>V8 作为一个 JavaScript 引擎，最初是服役于 Google Chrome 浏览器的。它随着 Chrome 的第一版发布而发布以及开源。现在它除了 Chrome 浏览器，已经有很多其他的使用者了。诸如 NodeJS、MongoDB、CouchDB 等。</p>\n<p>JavaScript 作为 Prototype-Based Language , 基于它使用 Prototype 继承的特征，V8 使用了直译的方式，即把 JavaScript 代码直接编译成机器码( Machine Code, 有些地方也叫 Native Code )，然后直接交由硬件执行。<br>与传统的「编译-解析-执行」的流程不同，V8 处理 JavaScript，并没有二进制码或其他的中间码。</p>\n<p><strong> 简单来说，V8主要工作就是：「把 JavaScript 直译成机器码，然后运行」</strong><br>但这中间，往往是一个复杂的过程，它需要处理很多的难题，诸如：</p>\n<ol>\n<li>编译优化</li>\n<li>内存管理</li>\n<li>垃圾回收</li>\n</ol>\n<p>我写的这一系列文章，也是从这三个大点来出发，解读V8针对这些内容的处理。</p>\n<h1 id=\"V8-In-NodeJS\"><a href=\"#V8-In-NodeJS\" class=\"headerlink\" title=\"V8 In NodeJS\"></a>V8 In NodeJS</h1><h2 id=\"NodeJS源码小览\"><a href=\"#NodeJS源码小览\" class=\"headerlink\" title=\"NodeJS源码小览\"></a>NodeJS源码小览</h2><p>NodeJS，是怎么引入V8的？<br>我们关注<a href=\"https://github.com/nodejs/node\" target=\"_blank\" rel=\"external\">Node的源码</a>目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── ...</span><br><span class=\"line\">├── deps</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">│   ├── v8</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── ...</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">│   ├── buffer.js</span><br><span class=\"line\">│   ├── child_process.js</span><br><span class=\"line\">│   ├── console.js</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── node -&gt; out/Release/node</span><br><span class=\"line\">├── ...</span><br><span class=\"line\">├── out</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">│   ├── Release</span><br><span class=\"line\">|         ├── node</span><br><span class=\"line\">|         ├── node.d</span><br><span class=\"line\">|         ├── obj</span><br><span class=\"line\">|             └── gen</span><br><span class=\"line\">|                 ├── ...</span><br><span class=\"line\">|                 ├── node_natives.h</span><br><span class=\"line\">|                 ├── ...</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">│   ├── debug-agent.cc</span><br><span class=\"line\">│   ├── debug-agent.h</span><br><span class=\"line\">│   ├── env-inl.h</span><br><span class=\"line\">│   ├── env.cc</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>需要关注的几个目录和文件：</p>\n<p><strong><code>/deps/v8</code></strong>：这里是V8源码所在文件夹，你会发现里面的目录结构跟<a href=\"https://github.com/v8/v8\" target=\"_blank\" rel=\"external\">V8源码</a>十分相似。NodeJS除了移植V8源码，还在增添了一些内容。</p>\n<p><strong><code>/src</code></strong>：由C/C++编写的核心模块所在文件夹，由C/C++编写的这部分模块被称为「Builtin Module」</p>\n<p><strong><code>/lib</code></strong>：由JavaScript编写的核心模块所在文件夹，这部分被称为「Native Code」，在编译Node源码的时候，会采用V8附带的<code>js2c.py</code>工具，把所有内置的JavaScript代码转换成C++里面的数组，生成<code>out/Release/obj/gen/node_natives.h</code>文件。有些 Native Module 需要借助于 Builtin Module 实现背后的功能。</p>\n<p><strong><code>/out</code></strong>：该目录是Node源码编译(命令行运行<code>make</code>)后生成的目录，里面包含了Node的可执行文件。当在命令行中键入<code>node xxx.js</code>，实际就是运行了<code>out/Release/node</code>文件。</p>\n<p>来张图说明一下V8在Node运行时的整体过程。</p>\n<p><img src=\"/image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png\" alt=\"v8 in nodejs.png\"></p>\n<p>Node在启动的时候，就已经把 Native Module，Builtin Module 加载到内存里面了。后来的 JavaScript 代码，就需要通过 V8 进行动态编译解析运行。</p>\n<h2 id=\"查看V8版本号\"><a href=\"#查看V8版本号\" class=\"headerlink\" title=\"查看V8版本号\"></a>查看V8版本号</h2><p>NodeJS的进步与V8息息相关，关注每个NodeJS版本所对应的V8版本，可以加强该版本新功能的理解和由来。</p>\n<p>在NodeJS中，通过<code>process.versions</code>可以查看NodeJS依赖模块的版本号，V8就包含其中。</p>\n<p>例如，我运行的 <code>v7.0.0</code>的NodeJS：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node</span><br><span class=\"line\">&gt; process.versions</span><br><span class=\"line\">&#123; http_parser: &apos;2.7.0&apos;,</span><br><span class=\"line\">  node: &apos;8.0.0-pre&apos;,</span><br><span class=\"line\">  v8: &apos;5.4.500.36&apos;,</span><br><span class=\"line\">  uv: &apos;1.10.0&apos;,</span><br><span class=\"line\">  zlib: &apos;1.2.8&apos;,</span><br><span class=\"line\">  ares: &apos;1.10.1-DEV&apos;,</span><br><span class=\"line\">  modules: &apos;51&apos;,</span><br><span class=\"line\">  openssl: &apos;1.0.2j&apos;,</span><br><span class=\"line\">  icu: &apos;58.1&apos;,</span><br><span class=\"line\">  unicode: &apos;9.0&apos;,</span><br><span class=\"line\">  cldr: &apos;30.0.2&apos;,</span><br><span class=\"line\">  tz: &apos;2016g&apos; &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"NodeJS与V8的缠绵\"><a href=\"#NodeJS与V8的缠绵\" class=\"headerlink\" title=\"NodeJS与V8的缠绵\"></a>NodeJS与V8的缠绵</h1><ul>\n<li>2008年9月，V8 的第一个版本随着 Chrome 的第一版本发布。</li>\n<li>2009年5月，NodeJS 的第一个版本由 Ryan Dahl 在 GitHub 上发布。</li>\n<li>2010年12月，<a href=\"https://blog.chromium.org/2010/12/new-crankshaft-for-v8.html\" target=\"_blank\" rel=\"external\">官方公布</a> V8 的名为 Crankshaft 的优化编译器，与原来的 Full Compiler 一起工作，声称较2008年版本提高50%性能。</li>\n<li>2014年12月， io.js 从久久不更新的 NodeJS 分出来支，并且引入最新的 V8 ，这时候 NodeJS 处于<code>0.12.17</code>版本。</li>\n<li>2015年2月，NodeJS基金宣布NodeJS(<code>v0.12</code>)和io.js(<code>v3.3</code>)合并，合并版本在未来发布。</li>\n<li>2015年7月7日，<a href=\"https://blog.chromium.org/2015/07/revving-up-javascript-performance-with.html\" target=\"_blank\" rel=\"external\">官方公布</a>又一个新的名为TurBoFan的优化编译器，主要提供ES6的新语法，以及提高性能。并表明该编译器最终目标是全部替代Crankshaft编译器</li>\n<li>2015年7月17日，<a href=\"http://v8project.blogspot.com/2015/07/v8-45-release.html\" target=\"_blank\" rel=\"external\">官方发布</a>集成TurboFan的V8版本(<code>v4.5</code>)</li>\n<li>2015年9月08日，NodeJS紧跟着<a href=\"https://nodejs.org/en/blog/release/v4.0.0/\" target=\"_blank\" rel=\"external\">发布</a>了与io.js的合并版本(<code>V4.0</code>)，引入最新的V8，给开发者们带来了最新的ES6语法，以及性能上的提高。</li>\n<li>2015年8月28日，V8<a href=\"http://v8project.blogspot.com/2015/08/v8-release-46.html\" target=\"_blank\" rel=\"external\">发布</a><code>v4.6</code>版本</li>\n<li>2015年10月29日，NodeJS<a href=\"https://nodejs.org/en/blog/release/v5.0.0/\" target=\"_blank\" rel=\"external\">发布</a><code>V5.0.0</code>版本</li>\n<li>2016年3月15日，V8<a href=\"http://v8project.blogspot.com/2016/03/v8-release-50.html\" target=\"_blank\" rel=\"external\">发布</a><code>v5.0</code>版本</li>\n<li>2016年4月26日，NodeJS<a href=\"https://nodejs.org/en/blog/release/v6.0.0/\" target=\"_blank\" rel=\"external\">发布</a><code>V6.0.0</code>版本</li>\n<li>2016年7月18日，V8<a href=\"http://v8project.blogspot.com/2016/07/v8-release-53.html\" target=\"_blank\" rel=\"external\">发布</a><code>v5.3</code>版本，新增名为Ignition的解析器(Interpreter)，跟原有的优化编译器(Crankshaft and TurboFan)进行串联工作，提供了更加优化的内存使用方案，主要针对于低内存的Android设备，并称在未来会普及到全平台。</li>\n<li>2016年10月25日，NodeJS<a href=\"https://nodejs.org/en/blog/release/v7.0.0/\" target=\"_blank\" rel=\"external\">发布</a><code>v7.0.0</code>版本</li>\n<li>截止到今天(2016年11月)，NodeJS版本<code>v7.0.0</code>，搭配了<code>v5.4</code>的v8，而官方发布的最新v8版本是<code>v5.5</code>。</li>\n</ul>\n<p>回顾整个历程，由于NodeJS是搭建在V8之上的，所以NodeJS很多「新增语言特性」和「提高性能」等更新都需要依赖V8的发布日程。</p>\n<p>就像NodeJS和io.js宣布合并，和真正发布<code>V4.0</code>版本的中间，还隔了V8的生命历程一个重大的更新(发布 TurboFan 编译器，该编译器引入了大量的ES6语法支持。)。这个更新直接提供了相当一部分的ES6语法，以及性能上的提高。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本篇主要描述了下面几点：</p>\n<ol>\n<li>我的写作动机，理解NodeJS底层，给写出高质量JavaScript代码提供指导。</li>\n<li>简单描述V8的角色，以及主要职责：编译优化、内存管理、垃圾回收。</li>\n<li>通过NodeJS源码目录，以及NodeJS代码加载过程，来认识V8在这之中的位置。</li>\n<li>罗列NodeJS与V8的历代迭代版本以及联系，强调V8在NodeJS中的地位。</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h1><p>JavaScript 是一款拥有「自动垃圾回收」功能的编程语言。<br>市面上具有这样功能的语言，一般都是拥有相对应的虚拟机的，像 Java的JVM ，C#的CLR ，PHP的Zend。<br>虚拟机一般实现了代码解析，内存的管理、布局、垃圾回收等功能。<br>不像C/C++这种没有虚拟机的语言，它们需要手动管理内存。<br>C/C++语言编译后的文件，是可以直接运行的。</p>\n<p>我认为学习一门开发语言，除了知道一些语法上的使用，各种API的调用以外。学习相应的虚拟机也是很有必要的。而 JavaScript 由于其特殊的历史原因，并不是只有 V8 一个引擎。但是目前 V8 它是业界最优秀的 JavaScript 引擎，也就成为了一个学习样本。</p>\n<p>如今的 JavaScript 不仅仅是用在浏览器端了，也因为 NodeJS 的关系得以在服务器端运行。和浏览器端不同的地方在于服务器端对资源的敏感性是很高的。当业务规模大了，并发量上来了，一些很细小的问题会放大。这时候一些小小的内存泄漏，都会酿造灾难。</p>\n<p>所以作为一个 JavaScript 开发者，搞清楚从敲入 <code>console.log(&#39;hello   world&#39;)</code>，直到后面交由CPU执行的中间过程是很重要的。<br>这也对如何用 JavaScript 这门松散的语言编写出高质量的代码是具有指导作用的。</p>\n<p>想真正做到 JavaScript 全栈，路漫漫其修远兮。</p>\n<h1 id=\"V8-概述\"><a href=\"#V8-概述\" class=\"headerlink\" title=\"V8 概述\"></a>V8 概述</h1><p>V8 作为一个 JavaScript 引擎，最初是服役于 Google Chrome 浏览器的。它随着 Chrome 的第一版发布而发布以及开源。现在它除了 Chrome 浏览器，已经有很多其他的使用者了。诸如 NodeJS、MongoDB、CouchDB 等。</p>\n<p>JavaScript 作为 Prototype-Based Language , 基于它使用 Prototype 继承的特征，V8 使用了直译的方式，即把 JavaScript 代码直接编译成机器码( Machine Code, 有些地方也叫 Native Code )，然后直接交由硬件执行。<br>与传统的「编译-解析-执行」的流程不同，V8 处理 JavaScript，并没有二进制码或其他的中间码。</p>\n<p><strong> 简单来说，V8主要工作就是：「把 JavaScript 直译成机器码，然后运行」</strong><br>但这中间，往往是一个复杂的过程，它需要处理很多的难题，诸如：</p>\n<ol>\n<li>编译优化</li>\n<li>内存管理</li>\n<li>垃圾回收</li>\n</ol>\n<p>我写的这一系列文章，也是从这三个大点来出发，解读V8针对这些内容的处理。</p>\n<h1 id=\"V8-In-NodeJS\"><a href=\"#V8-In-NodeJS\" class=\"headerlink\" title=\"V8 In NodeJS\"></a>V8 In NodeJS</h1><h2 id=\"NodeJS源码小览\"><a href=\"#NodeJS源码小览\" class=\"headerlink\" title=\"NodeJS源码小览\"></a>NodeJS源码小览</h2><p>NodeJS，是怎么引入V8的？<br>我们关注<a href=\"https://github.com/nodejs/node\">Node的源码</a>目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── ...</span><br><span class=\"line\">├── deps</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">│   ├── v8</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── ...</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">│   ├── buffer.js</span><br><span class=\"line\">│   ├── child_process.js</span><br><span class=\"line\">│   ├── console.js</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── node -&gt; out/Release/node</span><br><span class=\"line\">├── ...</span><br><span class=\"line\">├── out</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">│   ├── Release</span><br><span class=\"line\">|         ├── node</span><br><span class=\"line\">|         ├── node.d</span><br><span class=\"line\">|         ├── obj</span><br><span class=\"line\">|             └── gen</span><br><span class=\"line\">|                 ├── ...</span><br><span class=\"line\">|                 ├── node_natives.h</span><br><span class=\"line\">|                 ├── ...</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">│   ├── debug-agent.cc</span><br><span class=\"line\">│   ├── debug-agent.h</span><br><span class=\"line\">│   ├── env-inl.h</span><br><span class=\"line\">│   ├── env.cc</span><br><span class=\"line\">│   ├── ...</span><br><span class=\"line\">├── </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>需要关注的几个目录和文件：</p>\n<p><strong><code>/deps/v8</code></strong>：这里是V8源码所在文件夹，你会发现里面的目录结构跟<a href=\"https://github.com/v8/v8\">V8源码</a>十分相似。NodeJS除了移植V8源码，还在增添了一些内容。</p>\n<p><strong><code>/src</code></strong>：由C/C++编写的核心模块所在文件夹，由C/C++编写的这部分模块被称为「Builtin Module」</p>\n<p><strong><code>/lib</code></strong>：由JavaScript编写的核心模块所在文件夹，这部分被称为「Native Code」，在编译Node源码的时候，会采用V8附带的<code>js2c.py</code>工具，把所有内置的JavaScript代码转换成C++里面的数组，生成<code>out/Release/obj/gen/node_natives.h</code>文件。有些 Native Module 需要借助于 Builtin Module 实现背后的功能。</p>\n<p><strong><code>/out</code></strong>：该目录是Node源码编译(命令行运行<code>make</code>)后生成的目录，里面包含了Node的可执行文件。当在命令行中键入<code>node xxx.js</code>，实际就是运行了<code>out/Release/node</code>文件。</p>\n<p>来张图说明一下V8在Node运行时的整体过程。</p>\n<p><img src=\"/image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png\" alt=\"v8 in nodejs.png\"></p>\n<p>Node在启动的时候，就已经把 Native Module，Builtin Module 加载到内存里面了。后来的 JavaScript 代码，就需要通过 V8 进行动态编译解析运行。</p>\n<h2 id=\"查看V8版本号\"><a href=\"#查看V8版本号\" class=\"headerlink\" title=\"查看V8版本号\"></a>查看V8版本号</h2><p>NodeJS的进步与V8息息相关，关注每个NodeJS版本所对应的V8版本，可以加强该版本新功能的理解和由来。</p>\n<p>在NodeJS中，通过<code>process.versions</code>可以查看NodeJS依赖模块的版本号，V8就包含其中。</p>\n<p>例如，我运行的 <code>v7.0.0</code>的NodeJS：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node</span><br><span class=\"line\">&gt; process.versions</span><br><span class=\"line\">&#123; http_parser: &apos;2.7.0&apos;,</span><br><span class=\"line\">  node: &apos;8.0.0-pre&apos;,</span><br><span class=\"line\">  v8: &apos;5.4.500.36&apos;,</span><br><span class=\"line\">  uv: &apos;1.10.0&apos;,</span><br><span class=\"line\">  zlib: &apos;1.2.8&apos;,</span><br><span class=\"line\">  ares: &apos;1.10.1-DEV&apos;,</span><br><span class=\"line\">  modules: &apos;51&apos;,</span><br><span class=\"line\">  openssl: &apos;1.0.2j&apos;,</span><br><span class=\"line\">  icu: &apos;58.1&apos;,</span><br><span class=\"line\">  unicode: &apos;9.0&apos;,</span><br><span class=\"line\">  cldr: &apos;30.0.2&apos;,</span><br><span class=\"line\">  tz: &apos;2016g&apos; &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"NodeJS与V8的缠绵\"><a href=\"#NodeJS与V8的缠绵\" class=\"headerlink\" title=\"NodeJS与V8的缠绵\"></a>NodeJS与V8的缠绵</h1><ul>\n<li>2008年9月，V8 的第一个版本随着 Chrome 的第一版本发布。</li>\n<li>2009年5月，NodeJS 的第一个版本由 Ryan Dahl 在 GitHub 上发布。</li>\n<li>2010年12月，<a href=\"https://blog.chromium.org/2010/12/new-crankshaft-for-v8.html\">官方公布</a> V8 的名为 Crankshaft 的优化编译器，与原来的 Full Compiler 一起工作，声称较2008年版本提高50%性能。</li>\n<li>2014年12月， io.js 从久久不更新的 NodeJS 分出来支，并且引入最新的 V8 ，这时候 NodeJS 处于<code>0.12.17</code>版本。</li>\n<li>2015年2月，NodeJS基金宣布NodeJS(<code>v0.12</code>)和io.js(<code>v3.3</code>)合并，合并版本在未来发布。</li>\n<li>2015年7月7日，<a href=\"https://blog.chromium.org/2015/07/revving-up-javascript-performance-with.html\">官方公布</a>又一个新的名为TurBoFan的优化编译器，主要提供ES6的新语法，以及提高性能。并表明该编译器最终目标是全部替代Crankshaft编译器</li>\n<li>2015年7月17日，<a href=\"http://v8project.blogspot.com/2015/07/v8-45-release.html\">官方发布</a>集成TurboFan的V8版本(<code>v4.5</code>)</li>\n<li>2015年9月08日，NodeJS紧跟着<a href=\"https://nodejs.org/en/blog/release/v4.0.0/\">发布</a>了与io.js的合并版本(<code>V4.0</code>)，引入最新的V8，给开发者们带来了最新的ES6语法，以及性能上的提高。</li>\n<li>2015年8月28日，V8<a href=\"http://v8project.blogspot.com/2015/08/v8-release-46.html\">发布</a><code>v4.6</code>版本</li>\n<li>2015年10月29日，NodeJS<a href=\"https://nodejs.org/en/blog/release/v5.0.0/\">发布</a><code>V5.0.0</code>版本</li>\n<li>2016年3月15日，V8<a href=\"http://v8project.blogspot.com/2016/03/v8-release-50.html\">发布</a><code>v5.0</code>版本</li>\n<li>2016年4月26日，NodeJS<a href=\"https://nodejs.org/en/blog/release/v6.0.0/\">发布</a><code>V6.0.0</code>版本</li>\n<li>2016年7月18日，V8<a href=\"http://v8project.blogspot.com/2016/07/v8-release-53.html\">发布</a><code>v5.3</code>版本，新增名为Ignition的解析器(Interpreter)，跟原有的优化编译器(Crankshaft and TurboFan)进行串联工作，提供了更加优化的内存使用方案，主要针对于低内存的Android设备，并称在未来会普及到全平台。</li>\n<li>2016年10月25日，NodeJS<a href=\"https://nodejs.org/en/blog/release/v7.0.0/\">发布</a><code>v7.0.0</code>版本</li>\n<li>截止到今天(2016年11月)，NodeJS版本<code>v7.0.0</code>，搭配了<code>v5.4</code>的v8，而官方发布的最新v8版本是<code>v5.5</code>。</li>\n</ul>\n<p>回顾整个历程，由于NodeJS是搭建在V8之上的，所以NodeJS很多「新增语言特性」和「提高性能」等更新都需要依赖V8的发布日程。</p>\n<p>就像NodeJS和io.js宣布合并，和真正发布<code>V4.0</code>版本的中间，还隔了V8的生命历程一个重大的更新(发布 TurboFan 编译器，该编译器引入了大量的ES6语法支持。)。这个更新直接提供了相当一部分的ES6语法，以及性能上的提高。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本篇主要描述了下面几点：</p>\n<ol>\n<li>我的写作动机，理解NodeJS底层，给写出高质量JavaScript代码提供指导。</li>\n<li>简单描述V8的角色，以及主要职责：编译优化、内存管理、垃圾回收。</li>\n<li>通过NodeJS源码目录，以及NodeJS代码加载过程，来认识V8在这之中的位置。</li>\n<li>罗列NodeJS与V8的历代迭代版本以及联系，强调V8在NodeJS中的地位。</li>\n</ol>\n"},{"title":"一款 NodeJS 轻量级内存监控工具","date":"2017-03-17T07:17:38.000Z","_content":"\n# [Memeye](https://github.com/JerryC8080/Memeye)\nGithub 链接：https://github.com/JerryC8080/Memeye\n\nMemeye 是一个轻量级的 NodeJS 进程监控工具，它提供 进程内存、V8 堆空间内存、操作系统内存 三大维度的数据可视化展示。\n前端部分，借助 [Vue2](https://github.com/vuejs/vue) 和 [ChartJS](https://github.com/chartjs/Chart.js) 提供了一个不错的动态展示面板。    \nMemeye 在宿主进程中，只植入了一个简单的数据收集器，其他工作则启动一个子进程，交由子进程来进行。    \n这样做能把 Memeye 的代码对宿主进程的影响降到最低，以确保数据的真实性。    \n\n### 特点\n- 轻量级\n- 简单\n- 面向开发环境\n- 可视化\n\n*Note: Memeye 暂时只支持单进程，NodeJS 分布式进程还不适用，所以不建议在产品环境使用。*\n\n# 动机\n总所周知，NodeJS 对内存是很敏感的。在去年 4 月我用 NodeJS 做的一个营销性的项目，在上线当天 PV 突破了 100W。        \n其中内存就呈现出持续上涨趋势，在排查问题的过程中，想寻找一个轻量级的，只要可视化的呈现内存使用情况的工具，无果。        \n然后就有了这个项目的想法，但当时由于繁忙只做出了一个 Demo 级别的，简单能用就发布了。    \n最近有时间，再次翻出来，重构改版，增加更多维度的数据展示。    \n\n# Demo\n[See preview demo](http://jerryc8080.github.io/Memeye/) (也许需要翻墙)\n\n# 兼容性\n- Node v7.x\n- Node v6.x\n\n# 安装 & 使用\n\n运行下面命令安装 : \n\n```\nnpm install memeye --save-dev\n```\n\n\n然后在你的代码中引入\n\n```\nconst memeye = require('memeye');\nmemeye();\n```\n\n最后打开你的浏览器，输入下面地址：\n\n```\nhttp://localhost:23333  //23333 port by defaul.\n```\n\n就这么简单！\n\n# Memeye 是如何工作的\n\nMemeye 有三个核心概念：Collector, Indicators, Dashboard。    \nCollector 运行在宿主进程中（你的NodeJS进程），Indicator 和 Dashboard 运行在子进程中，这样可以尽量减少 Memeye 代码对你的宿主进程的影响。    \n\n## Collector\nCollector 会监听宿主进程，并且收集数据，然后通过 IPC 通信管道发送数据给子进程，交由子进程处理。    \n\n## Indicator\nIndicator 像一个状态机。当它的属性变化的时候，会触发相应事件。所以我们可以用它来处理收集回来的数据。    \n\n## Dashboard\nDashboard 会以子进程的形式唤起。他会创建一个 Indicator 实例，以及启动一个集成 socket.io 的 Http 服务器。    \n然后绑定 Indicator 和进程通信管道，以接收父进程发过来的数据。    \n最后再绑定 Indicator 和 socket.io，这样可以在 Indicator 属性变化的时候发送数据给前端。    \n\n##Collector, Indicator, Dashboard 之间的通信\n\n![commication.jpeg]((https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190717214117.jpg)\n\n# 预览\n![预览](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190717214216.jpeg)","source":"_posts/the-memeye.md","raw":"---\ntitle: 一款 NodeJS 轻量级内存监控工具\ndate: 2017-03-17 15:17:38\ntags:\n- Nodejs\n- Javascript\n- SOAP\ncategory: 搬砖码农\n---\n\n# [Memeye](https://github.com/JerryC8080/Memeye)\nGithub 链接：https://github.com/JerryC8080/Memeye\n\nMemeye 是一个轻量级的 NodeJS 进程监控工具，它提供 进程内存、V8 堆空间内存、操作系统内存 三大维度的数据可视化展示。\n前端部分，借助 [Vue2](https://github.com/vuejs/vue) 和 [ChartJS](https://github.com/chartjs/Chart.js) 提供了一个不错的动态展示面板。    \nMemeye 在宿主进程中，只植入了一个简单的数据收集器，其他工作则启动一个子进程，交由子进程来进行。    \n这样做能把 Memeye 的代码对宿主进程的影响降到最低，以确保数据的真实性。    \n\n### 特点\n- 轻量级\n- 简单\n- 面向开发环境\n- 可视化\n\n*Note: Memeye 暂时只支持单进程，NodeJS 分布式进程还不适用，所以不建议在产品环境使用。*\n\n# 动机\n总所周知，NodeJS 对内存是很敏感的。在去年 4 月我用 NodeJS 做的一个营销性的项目，在上线当天 PV 突破了 100W。        \n其中内存就呈现出持续上涨趋势，在排查问题的过程中，想寻找一个轻量级的，只要可视化的呈现内存使用情况的工具，无果。        \n然后就有了这个项目的想法，但当时由于繁忙只做出了一个 Demo 级别的，简单能用就发布了。    \n最近有时间，再次翻出来，重构改版，增加更多维度的数据展示。    \n\n# Demo\n[See preview demo](http://jerryc8080.github.io/Memeye/) (也许需要翻墙)\n\n# 兼容性\n- Node v7.x\n- Node v6.x\n\n# 安装 & 使用\n\n运行下面命令安装 : \n\n```\nnpm install memeye --save-dev\n```\n\n\n然后在你的代码中引入\n\n```\nconst memeye = require('memeye');\nmemeye();\n```\n\n最后打开你的浏览器，输入下面地址：\n\n```\nhttp://localhost:23333  //23333 port by defaul.\n```\n\n就这么简单！\n\n# Memeye 是如何工作的\n\nMemeye 有三个核心概念：Collector, Indicators, Dashboard。    \nCollector 运行在宿主进程中（你的NodeJS进程），Indicator 和 Dashboard 运行在子进程中，这样可以尽量减少 Memeye 代码对你的宿主进程的影响。    \n\n## Collector\nCollector 会监听宿主进程，并且收集数据，然后通过 IPC 通信管道发送数据给子进程，交由子进程处理。    \n\n## Indicator\nIndicator 像一个状态机。当它的属性变化的时候，会触发相应事件。所以我们可以用它来处理收集回来的数据。    \n\n## Dashboard\nDashboard 会以子进程的形式唤起。他会创建一个 Indicator 实例，以及启动一个集成 socket.io 的 Http 服务器。    \n然后绑定 Indicator 和进程通信管道，以接收父进程发过来的数据。    \n最后再绑定 Indicator 和 socket.io，这样可以在 Indicator 属性变化的时候发送数据给前端。    \n\n##Collector, Indicator, Dashboard 之间的通信\n\n![commication.jpeg]((https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190717214117.jpg)\n\n# 预览\n![预览](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190717214216.jpeg)","slug":"the-memeye","published":1,"updated":"2019-07-17T13:52:49.737Z","_id":"cl270y8sp004pxwrldcaz4fs0","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Memeye\"><a href=\"#Memeye\" class=\"headerlink\" title=\"Memeye\"></a><a href=\"https://github.com/JerryC8080/Memeye\" target=\"_blank\" rel=\"external\">Memeye</a></h1><p>Github 链接：<a href=\"https://github.com/JerryC8080/Memeye\" target=\"_blank\" rel=\"external\">https://github.com/JerryC8080/Memeye</a></p>\n<p>Memeye 是一个轻量级的 NodeJS 进程监控工具，它提供 进程内存、V8 堆空间内存、操作系统内存 三大维度的数据可视化展示。<br>前端部分，借助 <a href=\"https://github.com/vuejs/vue\" target=\"_blank\" rel=\"external\">Vue2</a> 和 <a href=\"https://github.com/chartjs/Chart.js\" target=\"_blank\" rel=\"external\">ChartJS</a> 提供了一个不错的动态展示面板。<br>Memeye 在宿主进程中，只植入了一个简单的数据收集器，其他工作则启动一个子进程，交由子进程来进行。<br>这样做能把 Memeye 的代码对宿主进程的影响降到最低，以确保数据的真实性。    </p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>轻量级</li>\n<li>简单</li>\n<li>面向开发环境</li>\n<li>可视化</li>\n</ul>\n<p><em>Note: Memeye 暂时只支持单进程，NodeJS 分布式进程还不适用，所以不建议在产品环境使用。</em></p>\n<h1 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h1><p>总所周知，NodeJS 对内存是很敏感的。在去年 4 月我用 NodeJS 做的一个营销性的项目，在上线当天 PV 突破了 100W。<br>其中内存就呈现出持续上涨趋势，在排查问题的过程中，想寻找一个轻量级的，只要可视化的呈现内存使用情况的工具，无果。<br>然后就有了这个项目的想法，但当时由于繁忙只做出了一个 Demo 级别的，简单能用就发布了。<br>最近有时间，再次翻出来，重构改版，增加更多维度的数据展示。    </p>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1><p><a href=\"http://jerryc8080.github.io/Memeye/\" target=\"_blank\" rel=\"external\">See preview demo</a> (也许需要翻墙)</p>\n<h1 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h1><ul>\n<li>Node v7.x</li>\n<li>Node v6.x</li>\n</ul>\n<h1 id=\"安装-amp-使用\"><a href=\"#安装-amp-使用\" class=\"headerlink\" title=\"安装 &amp; 使用\"></a>安装 &amp; 使用</h1><p>运行下面命令安装 : </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install memeye --save-dev</span><br></pre></td></tr></table></figure>\n<p>然后在你的代码中引入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const memeye = require(&apos;memeye&apos;);</span><br><span class=\"line\">memeye();</span><br></pre></td></tr></table></figure>\n<p>最后打开你的浏览器，输入下面地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:23333  //23333 port by defaul.</span><br></pre></td></tr></table></figure>\n<p>就这么简单！</p>\n<h1 id=\"Memeye-是如何工作的\"><a href=\"#Memeye-是如何工作的\" class=\"headerlink\" title=\"Memeye 是如何工作的\"></a>Memeye 是如何工作的</h1><p>Memeye 有三个核心概念：Collector, Indicators, Dashboard。<br>Collector 运行在宿主进程中（你的NodeJS进程），Indicator 和 Dashboard 运行在子进程中，这样可以尽量减少 Memeye 代码对你的宿主进程的影响。    </p>\n<h2 id=\"Collector\"><a href=\"#Collector\" class=\"headerlink\" title=\"Collector\"></a>Collector</h2><p>Collector 会监听宿主进程，并且收集数据，然后通过 IPC 通信管道发送数据给子进程，交由子进程处理。    </p>\n<h2 id=\"Indicator\"><a href=\"#Indicator\" class=\"headerlink\" title=\"Indicator\"></a>Indicator</h2><p>Indicator 像一个状态机。当它的属性变化的时候，会触发相应事件。所以我们可以用它来处理收集回来的数据。    </p>\n<h2 id=\"Dashboard\"><a href=\"#Dashboard\" class=\"headerlink\" title=\"Dashboard\"></a>Dashboard</h2><p>Dashboard 会以子进程的形式唤起。他会创建一个 Indicator 实例，以及启动一个集成 socket.io 的 Http 服务器。<br>然后绑定 Indicator 和进程通信管道，以接收父进程发过来的数据。<br>最后再绑定 Indicator 和 socket.io，这样可以在 Indicator 属性变化的时候发送数据给前端。    </p>\n<p>##Collector, Indicator, Dashboard 之间的通信</p>\n<p><img src=\"(https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190717214117.jpg\" alt=\"commication.jpeg\"></p>\n<h1 id=\"预览\"><a href=\"#预览\" class=\"headerlink\" title=\"预览\"></a>预览</h1><p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190717214216.jpeg\" alt=\"预览\"></p>\n","excerpt":"","more":"<h1 id=\"Memeye\"><a href=\"#Memeye\" class=\"headerlink\" title=\"Memeye\"></a><a href=\"https://github.com/JerryC8080/Memeye\">Memeye</a></h1><p>Github 链接：<a href=\"https://github.com/JerryC8080/Memeye\">https://github.com/JerryC8080/Memeye</a></p>\n<p>Memeye 是一个轻量级的 NodeJS 进程监控工具，它提供 进程内存、V8 堆空间内存、操作系统内存 三大维度的数据可视化展示。<br>前端部分，借助 <a href=\"https://github.com/vuejs/vue\">Vue2</a> 和 <a href=\"https://github.com/chartjs/Chart.js\">ChartJS</a> 提供了一个不错的动态展示面板。<br>Memeye 在宿主进程中，只植入了一个简单的数据收集器，其他工作则启动一个子进程，交由子进程来进行。<br>这样做能把 Memeye 的代码对宿主进程的影响降到最低，以确保数据的真实性。    </p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>轻量级</li>\n<li>简单</li>\n<li>面向开发环境</li>\n<li>可视化</li>\n</ul>\n<p><em>Note: Memeye 暂时只支持单进程，NodeJS 分布式进程还不适用，所以不建议在产品环境使用。</em></p>\n<h1 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h1><p>总所周知，NodeJS 对内存是很敏感的。在去年 4 月我用 NodeJS 做的一个营销性的项目，在上线当天 PV 突破了 100W。<br>其中内存就呈现出持续上涨趋势，在排查问题的过程中，想寻找一个轻量级的，只要可视化的呈现内存使用情况的工具，无果。<br>然后就有了这个项目的想法，但当时由于繁忙只做出了一个 Demo 级别的，简单能用就发布了。<br>最近有时间，再次翻出来，重构改版，增加更多维度的数据展示。    </p>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1><p><a href=\"http://jerryc8080.github.io/Memeye/\">See preview demo</a> (也许需要翻墙)</p>\n<h1 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h1><ul>\n<li>Node v7.x</li>\n<li>Node v6.x</li>\n</ul>\n<h1 id=\"安装-amp-使用\"><a href=\"#安装-amp-使用\" class=\"headerlink\" title=\"安装 &amp; 使用\"></a>安装 &amp; 使用</h1><p>运行下面命令安装 : </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install memeye --save-dev</span><br></pre></td></tr></table></figure>\n<p>然后在你的代码中引入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const memeye = require(&apos;memeye&apos;);</span><br><span class=\"line\">memeye();</span><br></pre></td></tr></table></figure>\n<p>最后打开你的浏览器，输入下面地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:23333  //23333 port by defaul.</span><br></pre></td></tr></table></figure>\n<p>就这么简单！</p>\n<h1 id=\"Memeye-是如何工作的\"><a href=\"#Memeye-是如何工作的\" class=\"headerlink\" title=\"Memeye 是如何工作的\"></a>Memeye 是如何工作的</h1><p>Memeye 有三个核心概念：Collector, Indicators, Dashboard。<br>Collector 运行在宿主进程中（你的NodeJS进程），Indicator 和 Dashboard 运行在子进程中，这样可以尽量减少 Memeye 代码对你的宿主进程的影响。    </p>\n<h2 id=\"Collector\"><a href=\"#Collector\" class=\"headerlink\" title=\"Collector\"></a>Collector</h2><p>Collector 会监听宿主进程，并且收集数据，然后通过 IPC 通信管道发送数据给子进程，交由子进程处理。    </p>\n<h2 id=\"Indicator\"><a href=\"#Indicator\" class=\"headerlink\" title=\"Indicator\"></a>Indicator</h2><p>Indicator 像一个状态机。当它的属性变化的时候，会触发相应事件。所以我们可以用它来处理收集回来的数据。    </p>\n<h2 id=\"Dashboard\"><a href=\"#Dashboard\" class=\"headerlink\" title=\"Dashboard\"></a>Dashboard</h2><p>Dashboard 会以子进程的形式唤起。他会创建一个 Indicator 实例，以及启动一个集成 socket.io 的 Http 服务器。<br>然后绑定 Indicator 和进程通信管道，以接收父进程发过来的数据。<br>最后再绑定 Indicator 和 socket.io，这样可以在 Indicator 属性变化的时候发送数据给前端。    </p>\n<p>##Collector, Indicator, Dashboard 之间的通信</p>\n<p><img src=\"(https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190717214117.jpg\" alt=\"commication.jpeg\"></p>\n<h1 id=\"预览\"><a href=\"#预览\" class=\"headerlink\" title=\"预览\"></a>预览</h1><p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190717214216.jpeg\" alt=\"预览\"></p>\n"},{"title":"谈谈像素以及微信小程序的 rpx","date":"2017-05-21T06:21:25.000Z","_content":"\n# 前言\n最近在负责有赞的某个业务的微信小程序开发，这是我第一次着手微信小程序的开发，这个过程中发现微信小程序所定义的一套 WXSS (WeiXin Style Sheets) 中有一个有趣的长度单位 `rpx`，即 responsive pixel。\n根据官方的描述：\n> rpx（responsive pixel）， 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。\n\n平时我们一般会用 `em` 或者 `rem` 来做屏幕适配，而在微信小程序中，可以方便的借助 `rpx` 来完成这项工作。\n\n那么怎么理解 `rpx`，还有它与 `px` 之间什么关系？什么是物理像素？\n为了更好理解 `rpx`，我打算聊聊下面的一些概念：\n1. 像素 (Pixel)\n2. PPI (Pixels per inch 每英尺像素)\n3. DPR (Device pixel ratio)\n\n# 像素\n像素，英文单词：pixel，是英语单词 「picture」 的简写 「pix」，加上 「element」 的简写 「el」，合成的词汇，表示「图像元素」的意思。 \n一个像素只能表达一个色块，是显示的最小的一个单元。\n\n而在我们写代码的时候，可以把像素分为两种：\n\n1. 物理像素 Physical pixels\n2. 逻辑像素 Logical pixels\n\n## 物理像素\n也被称为设备像素 (Device independent pixels)，即设备在出厂的时候就已经固定了像素。\n\n我们来看一下 iPhone6 (左图) 与 iPhone6 plus (右图) 的官方显示屏的规格说明：\n\n![iPhone6 & iPhone6 plus 规格](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/518488434BEC1074B675EB42A5A57AEF.png)\n\niPhone6 是 `1334px x 750px` 的像素分辨率，意思是当手机竖放的时候，横向有 750 个物理像素，纵向有 1334 个物理像素。\n\n## 逻辑像素\n在 CSS 中也被称为 CSS 像素 (CSS pixels)，是为 Web 开发者创造的，在 CSS 和 JavaScript 中使用的一个抽象的层，每一个 CSS 声明和几乎所有的 Javascript 属性都使用 CSS 像素。\n\n例如我们平时使用 Chrome 的设备调试工具的时候，iPhone6 是高 `667px`，宽是 `375px`，与苹果官方的 `1334px x 750px`，长宽分别少了 2 倍，那么面积就少了 4 倍。这就是经常说的 Retina 屏幕用四个(物理)像素表示一个(逻辑)像素。\n\n![Chrome 下 iPhone6 逻辑像素](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/9C4CD0061C94690AF81DB8DED8F71252.png)\n\n# PPI\n\nPixels per inch，每英寸像素，也被称为像素密度，意思是一英寸中有多少个物理像素。\n其中 1英寸 (inch) = 2.54厘米 (cm)。\n\n回顾一下上面的 iPhone6 和 iPhone6 plus 的官方规格说明图，其中有 `ppi` 这一项，iPhone6 是 `326ppi`，iphone6 plus 是 `401ppi`。\n\n## PPI 怎么算出来的？\n\n要计算显示器的每英寸像素值，首先要确定屏幕的尺寸和分辨率。\nPPI 计算公式：\n\n![PPI 计算公式](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/855BB6047CE2CA7F9DBBF1791D52C6CC.gif)\n\n其中，\n\n* dp (device pixel) 为屏幕对角线的分辨率\n* wp (width pixel) 为屏幕横向分辨率\n* hp (height piexl) 为屏幕纵向分辨率\n* di (device inch) 为屏幕对角线的长度(单位为英寸)。\n\n以 iPhone6 为例：\n\n![iPhone6 PPI 计算](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/2A67EB1D8C0873E419C676DB430570C2.gif)\n\n四舍五入那便是 `326ppi` 了。\n\n## 物理像素有多大？\n\n「物理像素」是有特定长度的，这取决于 ppi 值。\n\n那么如何求出一个设备的物理像素的长度？\n因为绝大多数设备的物理像素都是方形的，我们可以假设当前设备的像素是方形的。\n那么，\n\n* iPhone6 中每个像素长度：1inch / 326ppi ≈ 0.003 inch = 0.0762mm\n* iPhone6 plus 中每个像素长度：1inch / 401ppi ≈ 0.002 inch = 0.0508mm\n\n可以看出 iPhone6 plus 的屏幕制作工艺更加精细。\n因为像素越小，那么单位面积内像素点就越多，显示的效果人眼就越难看出毛刺。\n用来显示一份图像的像素越多，效果就越接近现实。\n\n和物理像素不同，「逻辑像素」没有特定的物理长度的，只是表示显示设备中最小的显示单元，优秀的显示设备完全可以把显示单元做的更加小，以达到更好的显示效果。\n\n# DPR\nDevice Pixel Ratio，设备像素比。\n\n在早先的移动设备中，并没有 DPR 的概念。随着技术的发展，移动设备的屏幕像素密度越来越高。\n从 iPhone4 开始，苹果公司推出了所谓的 Retina 视网膜屏幕。之所以叫做视网膜屏幕，是因为屏幕的 PPI 太高，人的视网膜无法分辨出屏幕上的像素点。\niPhone4 的分辨率提高了一倍，但屏幕尺寸却没有变化，这意味着同样大小的屏幕上，像素多了一倍，于是 `dpr = 2`。\n\n在 Chrome 浏览器可以通过以下代码获取设备的 DPR：\n\n```\nlet dpr = window.devicePixelRatio;\n```\n\n而通过下面的代码可以获取设备的逻辑像素：\n\n```\nlet logicalHeight = screen.height;\nlet logicalWidth = screen.width;\n```\n\n那么很多人看到这里，就会认为：`物理像素 = 逻辑像素 * dpr`\n但实际情况并不是这样，\n留意一下 iPhone6 plus 的物理像素和逻辑像素：\n\n * 物理像素：`1080px x 1920px`\n * 逻辑像素：`414px x 736px`\n \n而官方声称 iPhone6 plus 的 `dpr = 3`，按理应该是：\n\n * `414px x 736px` → 乘以 3 倍 dpr → `1242px x 2208px`\n \n那么 iPhone6 plus 只有 `1080px x 1920px`，怎么去展示 `1241px x 2208px` 的分辨率呢？\n\n原来 iPhone6 plus 对逻辑像素做了缩小处理，以适应物理像素，也就是\n`1241px x 2208px` 除以 `115%` ，得到 `1080px x 1920px`。\n\n换句话来说，本来 iPhone6 plus 的 `dpr = 2.6`，但是通过虚拟技术把物理像素放大 115% ，以达到 `dpr = 3` 的效果。\n\n所以说是假 3 倍 dpr，其实我们开发和设计的时候也不用管这个，当作它就是 3 倍 dpr 就好了。\n\n\n# 回到 rpx\n\n根据官方给出的 rpx 换算 px 的实例：\n![rpx 换算 px](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/ACED349F80C8D926AB74922C360B2F5A.png)\n\n三款机器的逻辑像素：\n\n* iPhone5 : `320px x 568px`\n* iPhone6 : `375px x 667px`\n* iPhone6 plus : `414px x 736px`\n\nrpx 转换成 px 是需要乘以一个系数的：\n\n* `px = rpx * n`\n\n其中系数 n，是跟着设备改变的：\n\n* iPhone5: `n = 2.34`\n* iPhone6: `n = 2`\n* iPhone6 plus: `n = 1.81`\n\n所以 rpx 只是定义一个绝对值 750 宽度，然后简单的根据不同设备的逻辑像素来进行 rpx 到 px 的换算。\n\n精明的观众可能发现了， rpx 压根就不需要关心 DPR 和 PPI 的概念。\n呃，其实我就是在理解 rpx 的过程中，拦不住思维的发散，了解了一大堆概念，然后顺道给你们分享一下罢了。\n\n# 参考\n[Wiki - 像素](https://www.wikiwand.com/zh-sg/%E5%83%8F%E7%B4%A0)\n[Wiki - 每英寸像素](https://www.wikiwand.com/zh-sg/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0)\n[iPhone 6 Screens Demystified](https://www.paintcodeapp.com/news/iphone-6-screens-demystified)\n\n","source":"_posts/talk-about-pixel-and-rpx.md","raw":"---\ntitle: 谈谈像素以及微信小程序的 rpx\ncategory: 搬砖码农\ndate: 2017-05-21 14:21:25\ntags: \n- 前端\n---\n\n# 前言\n最近在负责有赞的某个业务的微信小程序开发，这是我第一次着手微信小程序的开发，这个过程中发现微信小程序所定义的一套 WXSS (WeiXin Style Sheets) 中有一个有趣的长度单位 `rpx`，即 responsive pixel。\n根据官方的描述：\n> rpx（responsive pixel）， 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。\n\n平时我们一般会用 `em` 或者 `rem` 来做屏幕适配，而在微信小程序中，可以方便的借助 `rpx` 来完成这项工作。\n\n那么怎么理解 `rpx`，还有它与 `px` 之间什么关系？什么是物理像素？\n为了更好理解 `rpx`，我打算聊聊下面的一些概念：\n1. 像素 (Pixel)\n2. PPI (Pixels per inch 每英尺像素)\n3. DPR (Device pixel ratio)\n\n# 像素\n像素，英文单词：pixel，是英语单词 「picture」 的简写 「pix」，加上 「element」 的简写 「el」，合成的词汇，表示「图像元素」的意思。 \n一个像素只能表达一个色块，是显示的最小的一个单元。\n\n而在我们写代码的时候，可以把像素分为两种：\n\n1. 物理像素 Physical pixels\n2. 逻辑像素 Logical pixels\n\n## 物理像素\n也被称为设备像素 (Device independent pixels)，即设备在出厂的时候就已经固定了像素。\n\n我们来看一下 iPhone6 (左图) 与 iPhone6 plus (右图) 的官方显示屏的规格说明：\n\n![iPhone6 & iPhone6 plus 规格](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/518488434BEC1074B675EB42A5A57AEF.png)\n\niPhone6 是 `1334px x 750px` 的像素分辨率，意思是当手机竖放的时候，横向有 750 个物理像素，纵向有 1334 个物理像素。\n\n## 逻辑像素\n在 CSS 中也被称为 CSS 像素 (CSS pixels)，是为 Web 开发者创造的，在 CSS 和 JavaScript 中使用的一个抽象的层，每一个 CSS 声明和几乎所有的 Javascript 属性都使用 CSS 像素。\n\n例如我们平时使用 Chrome 的设备调试工具的时候，iPhone6 是高 `667px`，宽是 `375px`，与苹果官方的 `1334px x 750px`，长宽分别少了 2 倍，那么面积就少了 4 倍。这就是经常说的 Retina 屏幕用四个(物理)像素表示一个(逻辑)像素。\n\n![Chrome 下 iPhone6 逻辑像素](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/9C4CD0061C94690AF81DB8DED8F71252.png)\n\n# PPI\n\nPixels per inch，每英寸像素，也被称为像素密度，意思是一英寸中有多少个物理像素。\n其中 1英寸 (inch) = 2.54厘米 (cm)。\n\n回顾一下上面的 iPhone6 和 iPhone6 plus 的官方规格说明图，其中有 `ppi` 这一项，iPhone6 是 `326ppi`，iphone6 plus 是 `401ppi`。\n\n## PPI 怎么算出来的？\n\n要计算显示器的每英寸像素值，首先要确定屏幕的尺寸和分辨率。\nPPI 计算公式：\n\n![PPI 计算公式](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/855BB6047CE2CA7F9DBBF1791D52C6CC.gif)\n\n其中，\n\n* dp (device pixel) 为屏幕对角线的分辨率\n* wp (width pixel) 为屏幕横向分辨率\n* hp (height piexl) 为屏幕纵向分辨率\n* di (device inch) 为屏幕对角线的长度(单位为英寸)。\n\n以 iPhone6 为例：\n\n![iPhone6 PPI 计算](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/2A67EB1D8C0873E419C676DB430570C2.gif)\n\n四舍五入那便是 `326ppi` 了。\n\n## 物理像素有多大？\n\n「物理像素」是有特定长度的，这取决于 ppi 值。\n\n那么如何求出一个设备的物理像素的长度？\n因为绝大多数设备的物理像素都是方形的，我们可以假设当前设备的像素是方形的。\n那么，\n\n* iPhone6 中每个像素长度：1inch / 326ppi ≈ 0.003 inch = 0.0762mm\n* iPhone6 plus 中每个像素长度：1inch / 401ppi ≈ 0.002 inch = 0.0508mm\n\n可以看出 iPhone6 plus 的屏幕制作工艺更加精细。\n因为像素越小，那么单位面积内像素点就越多，显示的效果人眼就越难看出毛刺。\n用来显示一份图像的像素越多，效果就越接近现实。\n\n和物理像素不同，「逻辑像素」没有特定的物理长度的，只是表示显示设备中最小的显示单元，优秀的显示设备完全可以把显示单元做的更加小，以达到更好的显示效果。\n\n# DPR\nDevice Pixel Ratio，设备像素比。\n\n在早先的移动设备中，并没有 DPR 的概念。随着技术的发展，移动设备的屏幕像素密度越来越高。\n从 iPhone4 开始，苹果公司推出了所谓的 Retina 视网膜屏幕。之所以叫做视网膜屏幕，是因为屏幕的 PPI 太高，人的视网膜无法分辨出屏幕上的像素点。\niPhone4 的分辨率提高了一倍，但屏幕尺寸却没有变化，这意味着同样大小的屏幕上，像素多了一倍，于是 `dpr = 2`。\n\n在 Chrome 浏览器可以通过以下代码获取设备的 DPR：\n\n```\nlet dpr = window.devicePixelRatio;\n```\n\n而通过下面的代码可以获取设备的逻辑像素：\n\n```\nlet logicalHeight = screen.height;\nlet logicalWidth = screen.width;\n```\n\n那么很多人看到这里，就会认为：`物理像素 = 逻辑像素 * dpr`\n但实际情况并不是这样，\n留意一下 iPhone6 plus 的物理像素和逻辑像素：\n\n * 物理像素：`1080px x 1920px`\n * 逻辑像素：`414px x 736px`\n \n而官方声称 iPhone6 plus 的 `dpr = 3`，按理应该是：\n\n * `414px x 736px` → 乘以 3 倍 dpr → `1242px x 2208px`\n \n那么 iPhone6 plus 只有 `1080px x 1920px`，怎么去展示 `1241px x 2208px` 的分辨率呢？\n\n原来 iPhone6 plus 对逻辑像素做了缩小处理，以适应物理像素，也就是\n`1241px x 2208px` 除以 `115%` ，得到 `1080px x 1920px`。\n\n换句话来说，本来 iPhone6 plus 的 `dpr = 2.6`，但是通过虚拟技术把物理像素放大 115% ，以达到 `dpr = 3` 的效果。\n\n所以说是假 3 倍 dpr，其实我们开发和设计的时候也不用管这个，当作它就是 3 倍 dpr 就好了。\n\n\n# 回到 rpx\n\n根据官方给出的 rpx 换算 px 的实例：\n![rpx 换算 px](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/ACED349F80C8D926AB74922C360B2F5A.png)\n\n三款机器的逻辑像素：\n\n* iPhone5 : `320px x 568px`\n* iPhone6 : `375px x 667px`\n* iPhone6 plus : `414px x 736px`\n\nrpx 转换成 px 是需要乘以一个系数的：\n\n* `px = rpx * n`\n\n其中系数 n，是跟着设备改变的：\n\n* iPhone5: `n = 2.34`\n* iPhone6: `n = 2`\n* iPhone6 plus: `n = 1.81`\n\n所以 rpx 只是定义一个绝对值 750 宽度，然后简单的根据不同设备的逻辑像素来进行 rpx 到 px 的换算。\n\n精明的观众可能发现了， rpx 压根就不需要关心 DPR 和 PPI 的概念。\n呃，其实我就是在理解 rpx 的过程中，拦不住思维的发散，了解了一大堆概念，然后顺道给你们分享一下罢了。\n\n# 参考\n[Wiki - 像素](https://www.wikiwand.com/zh-sg/%E5%83%8F%E7%B4%A0)\n[Wiki - 每英寸像素](https://www.wikiwand.com/zh-sg/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0)\n[iPhone 6 Screens Demystified](https://www.paintcodeapp.com/news/iphone-6-screens-demystified)\n\n","slug":"talk-about-pixel-and-rpx","published":1,"updated":"2020-12-13T13:47:15.663Z","_id":"cl270y8sq004vxwrlw0lod2ec","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近在负责有赞的某个业务的微信小程序开发，这是我第一次着手微信小程序的开发，这个过程中发现微信小程序所定义的一套 WXSS (WeiXin Style Sheets) 中有一个有趣的长度单位 <code>rpx</code>，即 responsive pixel。<br>根据官方的描述：</p>\n<blockquote>\n<p>rpx（responsive pixel）， 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p>\n</blockquote>\n<p>平时我们一般会用 <code>em</code> 或者 <code>rem</code> 来做屏幕适配，而在微信小程序中，可以方便的借助 <code>rpx</code> 来完成这项工作。</p>\n<p>那么怎么理解 <code>rpx</code>，还有它与 <code>px</code> 之间什么关系？什么是物理像素？<br>为了更好理解 <code>rpx</code>，我打算聊聊下面的一些概念：</p>\n<ol>\n<li>像素 (Pixel)</li>\n<li>PPI (Pixels per inch 每英尺像素)</li>\n<li>DPR (Device pixel ratio)</li>\n</ol>\n<h1 id=\"像素\"><a href=\"#像素\" class=\"headerlink\" title=\"像素\"></a>像素</h1><p>像素，英文单词：pixel，是英语单词 「picture」 的简写 「pix」，加上 「element」 的简写 「el」，合成的词汇，表示「图像元素」的意思。<br>一个像素只能表达一个色块，是显示的最小的一个单元。</p>\n<p>而在我们写代码的时候，可以把像素分为两种：</p>\n<ol>\n<li>物理像素 Physical pixels</li>\n<li>逻辑像素 Logical pixels</li>\n</ol>\n<h2 id=\"物理像素\"><a href=\"#物理像素\" class=\"headerlink\" title=\"物理像素\"></a>物理像素</h2><p>也被称为设备像素 (Device independent pixels)，即设备在出厂的时候就已经固定了像素。</p>\n<p>我们来看一下 iPhone6 (左图) 与 iPhone6 plus (右图) 的官方显示屏的规格说明：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/518488434BEC1074B675EB42A5A57AEF.png\" alt=\"iPhone6 &amp; iPhone6 plus 规格\"></p>\n<p>iPhone6 是 <code>1334px x 750px</code> 的像素分辨率，意思是当手机竖放的时候，横向有 750 个物理像素，纵向有 1334 个物理像素。</p>\n<h2 id=\"逻辑像素\"><a href=\"#逻辑像素\" class=\"headerlink\" title=\"逻辑像素\"></a>逻辑像素</h2><p>在 CSS 中也被称为 CSS 像素 (CSS pixels)，是为 Web 开发者创造的，在 CSS 和 JavaScript 中使用的一个抽象的层，每一个 CSS 声明和几乎所有的 Javascript 属性都使用 CSS 像素。</p>\n<p>例如我们平时使用 Chrome 的设备调试工具的时候，iPhone6 是高 <code>667px</code>，宽是 <code>375px</code>，与苹果官方的 <code>1334px x 750px</code>，长宽分别少了 2 倍，那么面积就少了 4 倍。这就是经常说的 Retina 屏幕用四个(物理)像素表示一个(逻辑)像素。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/9C4CD0061C94690AF81DB8DED8F71252.png\" alt=\"Chrome 下 iPhone6 逻辑像素\"></p>\n<h1 id=\"PPI\"><a href=\"#PPI\" class=\"headerlink\" title=\"PPI\"></a>PPI</h1><p>Pixels per inch，每英寸像素，也被称为像素密度，意思是一英寸中有多少个物理像素。<br>其中 1英寸 (inch) = 2.54厘米 (cm)。</p>\n<p>回顾一下上面的 iPhone6 和 iPhone6 plus 的官方规格说明图，其中有 <code>ppi</code> 这一项，iPhone6 是 <code>326ppi</code>，iphone6 plus 是 <code>401ppi</code>。</p>\n<h2 id=\"PPI-怎么算出来的？\"><a href=\"#PPI-怎么算出来的？\" class=\"headerlink\" title=\"PPI 怎么算出来的？\"></a>PPI 怎么算出来的？</h2><p>要计算显示器的每英寸像素值，首先要确定屏幕的尺寸和分辨率。<br>PPI 计算公式：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/855BB6047CE2CA7F9DBBF1791D52C6CC.gif\" alt=\"PPI 计算公式\"></p>\n<p>其中，</p>\n<ul>\n<li>dp (device pixel) 为屏幕对角线的分辨率</li>\n<li>wp (width pixel) 为屏幕横向分辨率</li>\n<li>hp (height piexl) 为屏幕纵向分辨率</li>\n<li>di (device inch) 为屏幕对角线的长度(单位为英寸)。</li>\n</ul>\n<p>以 iPhone6 为例：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/2A67EB1D8C0873E419C676DB430570C2.gif\" alt=\"iPhone6 PPI 计算\"></p>\n<p>四舍五入那便是 <code>326ppi</code> 了。</p>\n<h2 id=\"物理像素有多大？\"><a href=\"#物理像素有多大？\" class=\"headerlink\" title=\"物理像素有多大？\"></a>物理像素有多大？</h2><p>「物理像素」是有特定长度的，这取决于 ppi 值。</p>\n<p>那么如何求出一个设备的物理像素的长度？<br>因为绝大多数设备的物理像素都是方形的，我们可以假设当前设备的像素是方形的。<br>那么，</p>\n<ul>\n<li>iPhone6 中每个像素长度：1inch / 326ppi ≈ 0.003 inch = 0.0762mm</li>\n<li>iPhone6 plus 中每个像素长度：1inch / 401ppi ≈ 0.002 inch = 0.0508mm</li>\n</ul>\n<p>可以看出 iPhone6 plus 的屏幕制作工艺更加精细。<br>因为像素越小，那么单位面积内像素点就越多，显示的效果人眼就越难看出毛刺。<br>用来显示一份图像的像素越多，效果就越接近现实。</p>\n<p>和物理像素不同，「逻辑像素」没有特定的物理长度的，只是表示显示设备中最小的显示单元，优秀的显示设备完全可以把显示单元做的更加小，以达到更好的显示效果。</p>\n<h1 id=\"DPR\"><a href=\"#DPR\" class=\"headerlink\" title=\"DPR\"></a>DPR</h1><p>Device Pixel Ratio，设备像素比。</p>\n<p>在早先的移动设备中，并没有 DPR 的概念。随着技术的发展，移动设备的屏幕像素密度越来越高。<br>从 iPhone4 开始，苹果公司推出了所谓的 Retina 视网膜屏幕。之所以叫做视网膜屏幕，是因为屏幕的 PPI 太高，人的视网膜无法分辨出屏幕上的像素点。<br>iPhone4 的分辨率提高了一倍，但屏幕尺寸却没有变化，这意味着同样大小的屏幕上，像素多了一倍，于是 <code>dpr = 2</code>。</p>\n<p>在 Chrome 浏览器可以通过以下代码获取设备的 DPR：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let dpr = window.devicePixelRatio;</span><br></pre></td></tr></table></figure>\n<p>而通过下面的代码可以获取设备的逻辑像素：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let logicalHeight = screen.height;</span><br><span class=\"line\">let logicalWidth = screen.width;</span><br></pre></td></tr></table></figure>\n<p>那么很多人看到这里，就会认为：<code>物理像素 = 逻辑像素 * dpr</code><br>但实际情况并不是这样，<br>留意一下 iPhone6 plus 的物理像素和逻辑像素：</p>\n<ul>\n<li>物理像素：<code>1080px x 1920px</code></li>\n<li>逻辑像素：<code>414px x 736px</code></li>\n</ul>\n<p>而官方声称 iPhone6 plus 的 <code>dpr = 3</code>，按理应该是：</p>\n<ul>\n<li><code>414px x 736px</code> → 乘以 3 倍 dpr → <code>1242px x 2208px</code></li>\n</ul>\n<p>那么 iPhone6 plus 只有 <code>1080px x 1920px</code>，怎么去展示 <code>1241px x 2208px</code> 的分辨率呢？</p>\n<p>原来 iPhone6 plus 对逻辑像素做了缩小处理，以适应物理像素，也就是<br><code>1241px x 2208px</code> 除以 <code>115%</code> ，得到 <code>1080px x 1920px</code>。</p>\n<p>换句话来说，本来 iPhone6 plus 的 <code>dpr = 2.6</code>，但是通过虚拟技术把物理像素放大 115% ，以达到 <code>dpr = 3</code> 的效果。</p>\n<p>所以说是假 3 倍 dpr，其实我们开发和设计的时候也不用管这个，当作它就是 3 倍 dpr 就好了。</p>\n<h1 id=\"回到-rpx\"><a href=\"#回到-rpx\" class=\"headerlink\" title=\"回到 rpx\"></a>回到 rpx</h1><p>根据官方给出的 rpx 换算 px 的实例：<br><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/ACED349F80C8D926AB74922C360B2F5A.png\" alt=\"rpx 换算 px\"></p>\n<p>三款机器的逻辑像素：</p>\n<ul>\n<li>iPhone5 : <code>320px x 568px</code></li>\n<li>iPhone6 : <code>375px x 667px</code></li>\n<li>iPhone6 plus : <code>414px x 736px</code></li>\n</ul>\n<p>rpx 转换成 px 是需要乘以一个系数的：</p>\n<ul>\n<li><code>px = rpx * n</code></li>\n</ul>\n<p>其中系数 n，是跟着设备改变的：</p>\n<ul>\n<li>iPhone5: <code>n = 2.34</code></li>\n<li>iPhone6: <code>n = 2</code></li>\n<li>iPhone6 plus: <code>n = 1.81</code></li>\n</ul>\n<p>所以 rpx 只是定义一个绝对值 750 宽度，然后简单的根据不同设备的逻辑像素来进行 rpx 到 px 的换算。</p>\n<p>精明的观众可能发现了， rpx 压根就不需要关心 DPR 和 PPI 的概念。<br>呃，其实我就是在理解 rpx 的过程中，拦不住思维的发散，了解了一大堆概念，然后顺道给你们分享一下罢了。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.wikiwand.com/zh-sg/%E5%83%8F%E7%B4%A0\" target=\"_blank\" rel=\"external\">Wiki - 像素</a><br><a href=\"https://www.wikiwand.com/zh-sg/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0\" target=\"_blank\" rel=\"external\">Wiki - 每英寸像素</a><br><a href=\"https://www.paintcodeapp.com/news/iphone-6-screens-demystified\" target=\"_blank\" rel=\"external\">iPhone 6 Screens Demystified</a></p>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近在负责有赞的某个业务的微信小程序开发，这是我第一次着手微信小程序的开发，这个过程中发现微信小程序所定义的一套 WXSS (WeiXin Style Sheets) 中有一个有趣的长度单位 <code>rpx</code>，即 responsive pixel。<br>根据官方的描述：</p>\n<blockquote>\n<p>rpx（responsive pixel）， 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p>\n</blockquote>\n<p>平时我们一般会用 <code>em</code> 或者 <code>rem</code> 来做屏幕适配，而在微信小程序中，可以方便的借助 <code>rpx</code> 来完成这项工作。</p>\n<p>那么怎么理解 <code>rpx</code>，还有它与 <code>px</code> 之间什么关系？什么是物理像素？<br>为了更好理解 <code>rpx</code>，我打算聊聊下面的一些概念：</p>\n<ol>\n<li>像素 (Pixel)</li>\n<li>PPI (Pixels per inch 每英尺像素)</li>\n<li>DPR (Device pixel ratio)</li>\n</ol>\n<h1 id=\"像素\"><a href=\"#像素\" class=\"headerlink\" title=\"像素\"></a>像素</h1><p>像素，英文单词：pixel，是英语单词 「picture」 的简写 「pix」，加上 「element」 的简写 「el」，合成的词汇，表示「图像元素」的意思。<br>一个像素只能表达一个色块，是显示的最小的一个单元。</p>\n<p>而在我们写代码的时候，可以把像素分为两种：</p>\n<ol>\n<li>物理像素 Physical pixels</li>\n<li>逻辑像素 Logical pixels</li>\n</ol>\n<h2 id=\"物理像素\"><a href=\"#物理像素\" class=\"headerlink\" title=\"物理像素\"></a>物理像素</h2><p>也被称为设备像素 (Device independent pixels)，即设备在出厂的时候就已经固定了像素。</p>\n<p>我们来看一下 iPhone6 (左图) 与 iPhone6 plus (右图) 的官方显示屏的规格说明：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/518488434BEC1074B675EB42A5A57AEF.png\" alt=\"iPhone6 &amp; iPhone6 plus 规格\"></p>\n<p>iPhone6 是 <code>1334px x 750px</code> 的像素分辨率，意思是当手机竖放的时候，横向有 750 个物理像素，纵向有 1334 个物理像素。</p>\n<h2 id=\"逻辑像素\"><a href=\"#逻辑像素\" class=\"headerlink\" title=\"逻辑像素\"></a>逻辑像素</h2><p>在 CSS 中也被称为 CSS 像素 (CSS pixels)，是为 Web 开发者创造的，在 CSS 和 JavaScript 中使用的一个抽象的层，每一个 CSS 声明和几乎所有的 Javascript 属性都使用 CSS 像素。</p>\n<p>例如我们平时使用 Chrome 的设备调试工具的时候，iPhone6 是高 <code>667px</code>，宽是 <code>375px</code>，与苹果官方的 <code>1334px x 750px</code>，长宽分别少了 2 倍，那么面积就少了 4 倍。这就是经常说的 Retina 屏幕用四个(物理)像素表示一个(逻辑)像素。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/9C4CD0061C94690AF81DB8DED8F71252.png\" alt=\"Chrome 下 iPhone6 逻辑像素\"></p>\n<h1 id=\"PPI\"><a href=\"#PPI\" class=\"headerlink\" title=\"PPI\"></a>PPI</h1><p>Pixels per inch，每英寸像素，也被称为像素密度，意思是一英寸中有多少个物理像素。<br>其中 1英寸 (inch) = 2.54厘米 (cm)。</p>\n<p>回顾一下上面的 iPhone6 和 iPhone6 plus 的官方规格说明图，其中有 <code>ppi</code> 这一项，iPhone6 是 <code>326ppi</code>，iphone6 plus 是 <code>401ppi</code>。</p>\n<h2 id=\"PPI-怎么算出来的？\"><a href=\"#PPI-怎么算出来的？\" class=\"headerlink\" title=\"PPI 怎么算出来的？\"></a>PPI 怎么算出来的？</h2><p>要计算显示器的每英寸像素值，首先要确定屏幕的尺寸和分辨率。<br>PPI 计算公式：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/855BB6047CE2CA7F9DBBF1791D52C6CC.gif\" alt=\"PPI 计算公式\"></p>\n<p>其中，</p>\n<ul>\n<li>dp (device pixel) 为屏幕对角线的分辨率</li>\n<li>wp (width pixel) 为屏幕横向分辨率</li>\n<li>hp (height piexl) 为屏幕纵向分辨率</li>\n<li>di (device inch) 为屏幕对角线的长度(单位为英寸)。</li>\n</ul>\n<p>以 iPhone6 为例：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/2A67EB1D8C0873E419C676DB430570C2.gif\" alt=\"iPhone6 PPI 计算\"></p>\n<p>四舍五入那便是 <code>326ppi</code> 了。</p>\n<h2 id=\"物理像素有多大？\"><a href=\"#物理像素有多大？\" class=\"headerlink\" title=\"物理像素有多大？\"></a>物理像素有多大？</h2><p>「物理像素」是有特定长度的，这取决于 ppi 值。</p>\n<p>那么如何求出一个设备的物理像素的长度？<br>因为绝大多数设备的物理像素都是方形的，我们可以假设当前设备的像素是方形的。<br>那么，</p>\n<ul>\n<li>iPhone6 中每个像素长度：1inch / 326ppi ≈ 0.003 inch = 0.0762mm</li>\n<li>iPhone6 plus 中每个像素长度：1inch / 401ppi ≈ 0.002 inch = 0.0508mm</li>\n</ul>\n<p>可以看出 iPhone6 plus 的屏幕制作工艺更加精细。<br>因为像素越小，那么单位面积内像素点就越多，显示的效果人眼就越难看出毛刺。<br>用来显示一份图像的像素越多，效果就越接近现实。</p>\n<p>和物理像素不同，「逻辑像素」没有特定的物理长度的，只是表示显示设备中最小的显示单元，优秀的显示设备完全可以把显示单元做的更加小，以达到更好的显示效果。</p>\n<h1 id=\"DPR\"><a href=\"#DPR\" class=\"headerlink\" title=\"DPR\"></a>DPR</h1><p>Device Pixel Ratio，设备像素比。</p>\n<p>在早先的移动设备中，并没有 DPR 的概念。随着技术的发展，移动设备的屏幕像素密度越来越高。<br>从 iPhone4 开始，苹果公司推出了所谓的 Retina 视网膜屏幕。之所以叫做视网膜屏幕，是因为屏幕的 PPI 太高，人的视网膜无法分辨出屏幕上的像素点。<br>iPhone4 的分辨率提高了一倍，但屏幕尺寸却没有变化，这意味着同样大小的屏幕上，像素多了一倍，于是 <code>dpr = 2</code>。</p>\n<p>在 Chrome 浏览器可以通过以下代码获取设备的 DPR：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let dpr = window.devicePixelRatio;</span><br></pre></td></tr></table></figure>\n<p>而通过下面的代码可以获取设备的逻辑像素：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let logicalHeight = screen.height;</span><br><span class=\"line\">let logicalWidth = screen.width;</span><br></pre></td></tr></table></figure>\n<p>那么很多人看到这里，就会认为：<code>物理像素 = 逻辑像素 * dpr</code><br>但实际情况并不是这样，<br>留意一下 iPhone6 plus 的物理像素和逻辑像素：</p>\n<ul>\n<li>物理像素：<code>1080px x 1920px</code></li>\n<li>逻辑像素：<code>414px x 736px</code></li>\n</ul>\n<p>而官方声称 iPhone6 plus 的 <code>dpr = 3</code>，按理应该是：</p>\n<ul>\n<li><code>414px x 736px</code> → 乘以 3 倍 dpr → <code>1242px x 2208px</code></li>\n</ul>\n<p>那么 iPhone6 plus 只有 <code>1080px x 1920px</code>，怎么去展示 <code>1241px x 2208px</code> 的分辨率呢？</p>\n<p>原来 iPhone6 plus 对逻辑像素做了缩小处理，以适应物理像素，也就是<br><code>1241px x 2208px</code> 除以 <code>115%</code> ，得到 <code>1080px x 1920px</code>。</p>\n<p>换句话来说，本来 iPhone6 plus 的 <code>dpr = 2.6</code>，但是通过虚拟技术把物理像素放大 115% ，以达到 <code>dpr = 3</code> 的效果。</p>\n<p>所以说是假 3 倍 dpr，其实我们开发和设计的时候也不用管这个，当作它就是 3 倍 dpr 就好了。</p>\n<h1 id=\"回到-rpx\"><a href=\"#回到-rpx\" class=\"headerlink\" title=\"回到 rpx\"></a>回到 rpx</h1><p>根据官方给出的 rpx 换算 px 的实例：<br><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/ACED349F80C8D926AB74922C360B2F5A.png\" alt=\"rpx 换算 px\"></p>\n<p>三款机器的逻辑像素：</p>\n<ul>\n<li>iPhone5 : <code>320px x 568px</code></li>\n<li>iPhone6 : <code>375px x 667px</code></li>\n<li>iPhone6 plus : <code>414px x 736px</code></li>\n</ul>\n<p>rpx 转换成 px 是需要乘以一个系数的：</p>\n<ul>\n<li><code>px = rpx * n</code></li>\n</ul>\n<p>其中系数 n，是跟着设备改变的：</p>\n<ul>\n<li>iPhone5: <code>n = 2.34</code></li>\n<li>iPhone6: <code>n = 2</code></li>\n<li>iPhone6 plus: <code>n = 1.81</code></li>\n</ul>\n<p>所以 rpx 只是定义一个绝对值 750 宽度，然后简单的根据不同设备的逻辑像素来进行 rpx 到 px 的换算。</p>\n<p>精明的观众可能发现了， rpx 压根就不需要关心 DPR 和 PPI 的概念。<br>呃，其实我就是在理解 rpx 的过程中，拦不住思维的发散，了解了一大堆概念，然后顺道给你们分享一下罢了。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.wikiwand.com/zh-sg/%E5%83%8F%E7%B4%A0\">Wiki - 像素</a><br><a href=\"https://www.wikiwand.com/zh-sg/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0\">Wiki - 每英寸像素</a><br><a href=\"https://www.paintcodeapp.com/news/iphone-6-screens-demystified\">iPhone 6 Screens Demystified</a></p>\n"},{"title":"2017 第一季度复盘","date":"2017-05-03T16:33:02.000Z","_content":"\n# The Past\n1.  [Memeye](https://github.com/JerryC8080/Memeye) 终于开源了，到目前为止已经有 153 个 star 了，但是后续没有再维护了，打算等我学完 Vue 以及对前端更加熟练之后，对前端部分进行重构，使得界面更加流畅。\n2. 输出文章九篇，其中八篇技术文。\n3. 输出了一本小书：「[理解 TCP 和 UDP](https://github.com/JerryC8080/understand-tcp-udp)」，这是我在复习计算机网络的产物，有幸能拿到 123 star （数字很特别）。\n4. 从魅族离职，入职有赞，换了个 Title，从「NodeJS 工程师」到「前端工程师」，这是很符合我个人的发展计划的，以 JS 栈为主的全栈道路。当然，前提需要是一个优秀的软件工程师。\n\n可惜的是，2017年的开头没有好好整理今年的目标。\n记得有句话很深刻：「人生中最适合的时机有两个，一个是十年前，一个是现在」\n虽然过了三分之一了，但现在计划，还来得及。\n\n# The Next\n希望到了 2018 年的自己：\n1. **Target**: 能解决大部分前端业务上的开发\n\t1. 深入前端，补足前端基础，包括 CSS、HTML5、ReactJS、Vue2，移动端开发\n\t2. 学习设计理论、色彩理论、看更多的优秀设计。\n\t3. 寻找设计领域比较好的读物，给读完。\n2. **Target**: 在社区有更加多的影响力\n\t1. 全年至少产出文章 12 - 20 篇\n\t2. 拥有一个 300 star 的开源项目\n\t3. 影响所在团队，逐渐营造技术氛围\n3. **Target**: 持续扎实基础实力\n\t1. 《鸟哥的Linux私房菜》\n\t2. 《设计模式》\n\t3. 《深入理解计算机操作系统》\n\t4. 《深入浅出 NodeJS》、《NodeJS 硬实战》、《Security Your NodeJS Application》\n\t5. 《高性能MySQL》\n\t6. 《CSS 权威指南》、《CSS 揭秘》\n\t7. 《Redis 设计与实现》、《Redis 实战》\n\t9. 《你不知道的 JavaScript》\n4. **Target**: 具有敏捷开发的实践经验\n\t1. 团队沟通\n\t2. 文档沉淀\n\t3. 影响力输出\n\t4. 代码质量\n\t5. 稳定交付\n\t6. 快速迭代流程\n5. **Target**: 拓展自身的技术视野\n\t1. 学习 Python，感受社区\n\t2. 学习 Go，感受社区\n6. **Target**: 技术之外\n\t1. 《软技能》\n\t2. 《浪潮之巅》一二册\n\t3. 《暗时间》第二次阅读\n\t4. 《如何阅读一本书》\n\n共勉。","source":"_posts/reconsidering-for-2017-Q1.md","raw":"---\ntitle: 2017 第一季度复盘\ncategory: 三省吾身\ndate: 2017-05-04 00:33:02\n---\n\n# The Past\n1.  [Memeye](https://github.com/JerryC8080/Memeye) 终于开源了，到目前为止已经有 153 个 star 了，但是后续没有再维护了，打算等我学完 Vue 以及对前端更加熟练之后，对前端部分进行重构，使得界面更加流畅。\n2. 输出文章九篇，其中八篇技术文。\n3. 输出了一本小书：「[理解 TCP 和 UDP](https://github.com/JerryC8080/understand-tcp-udp)」，这是我在复习计算机网络的产物，有幸能拿到 123 star （数字很特别）。\n4. 从魅族离职，入职有赞，换了个 Title，从「NodeJS 工程师」到「前端工程师」，这是很符合我个人的发展计划的，以 JS 栈为主的全栈道路。当然，前提需要是一个优秀的软件工程师。\n\n可惜的是，2017年的开头没有好好整理今年的目标。\n记得有句话很深刻：「人生中最适合的时机有两个，一个是十年前，一个是现在」\n虽然过了三分之一了，但现在计划，还来得及。\n\n# The Next\n希望到了 2018 年的自己：\n1. **Target**: 能解决大部分前端业务上的开发\n\t1. 深入前端，补足前端基础，包括 CSS、HTML5、ReactJS、Vue2，移动端开发\n\t2. 学习设计理论、色彩理论、看更多的优秀设计。\n\t3. 寻找设计领域比较好的读物，给读完。\n2. **Target**: 在社区有更加多的影响力\n\t1. 全年至少产出文章 12 - 20 篇\n\t2. 拥有一个 300 star 的开源项目\n\t3. 影响所在团队，逐渐营造技术氛围\n3. **Target**: 持续扎实基础实力\n\t1. 《鸟哥的Linux私房菜》\n\t2. 《设计模式》\n\t3. 《深入理解计算机操作系统》\n\t4. 《深入浅出 NodeJS》、《NodeJS 硬实战》、《Security Your NodeJS Application》\n\t5. 《高性能MySQL》\n\t6. 《CSS 权威指南》、《CSS 揭秘》\n\t7. 《Redis 设计与实现》、《Redis 实战》\n\t9. 《你不知道的 JavaScript》\n4. **Target**: 具有敏捷开发的实践经验\n\t1. 团队沟通\n\t2. 文档沉淀\n\t3. 影响力输出\n\t4. 代码质量\n\t5. 稳定交付\n\t6. 快速迭代流程\n5. **Target**: 拓展自身的技术视野\n\t1. 学习 Python，感受社区\n\t2. 学习 Go，感受社区\n6. **Target**: 技术之外\n\t1. 《软技能》\n\t2. 《浪潮之巅》一二册\n\t3. 《暗时间》第二次阅读\n\t4. 《如何阅读一本书》\n\n共勉。","slug":"reconsidering-for-2017-Q1","published":1,"updated":"2018-05-01T16:16:02.081Z","_id":"cl270y8sr004zxwrlsqhvjasm","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"The-Past\"><a href=\"#The-Past\" class=\"headerlink\" title=\"The Past\"></a>The Past</h1><ol>\n<li><a href=\"https://github.com/JerryC8080/Memeye\" target=\"_blank\" rel=\"external\">Memeye</a> 终于开源了，到目前为止已经有 153 个 star 了，但是后续没有再维护了，打算等我学完 Vue 以及对前端更加熟练之后，对前端部分进行重构，使得界面更加流畅。</li>\n<li>输出文章九篇，其中八篇技术文。</li>\n<li>输出了一本小书：「<a href=\"https://github.com/JerryC8080/understand-tcp-udp\" target=\"_blank\" rel=\"external\">理解 TCP 和 UDP</a>」，这是我在复习计算机网络的产物，有幸能拿到 123 star （数字很特别）。</li>\n<li>从魅族离职，入职有赞，换了个 Title，从「NodeJS 工程师」到「前端工程师」，这是很符合我个人的发展计划的，以 JS 栈为主的全栈道路。当然，前提需要是一个优秀的软件工程师。</li>\n</ol>\n<p>可惜的是，2017年的开头没有好好整理今年的目标。<br>记得有句话很深刻：「人生中最适合的时机有两个，一个是十年前，一个是现在」<br>虽然过了三分之一了，但现在计划，还来得及。</p>\n<h1 id=\"The-Next\"><a href=\"#The-Next\" class=\"headerlink\" title=\"The Next\"></a>The Next</h1><p>希望到了 2018 年的自己：</p>\n<ol>\n<li><strong>Target</strong>: 能解决大部分前端业务上的开发<ol>\n<li>深入前端，补足前端基础，包括 CSS、HTML5、ReactJS、Vue2，移动端开发</li>\n<li>学习设计理论、色彩理论、看更多的优秀设计。</li>\n<li>寻找设计领域比较好的读物，给读完。</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 在社区有更加多的影响力<ol>\n<li>全年至少产出文章 12 - 20 篇</li>\n<li>拥有一个 300 star 的开源项目</li>\n<li>影响所在团队，逐渐营造技术氛围</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 持续扎实基础实力<ol>\n<li>《鸟哥的Linux私房菜》</li>\n<li>《设计模式》</li>\n<li>《深入理解计算机操作系统》</li>\n<li>《深入浅出 NodeJS》、《NodeJS 硬实战》、《Security Your NodeJS Application》</li>\n<li>《高性能MySQL》</li>\n<li>《CSS 权威指南》、《CSS 揭秘》</li>\n<li>《Redis 设计与实现》、《Redis 实战》</li>\n<li>《你不知道的 JavaScript》</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 具有敏捷开发的实践经验<ol>\n<li>团队沟通</li>\n<li>文档沉淀</li>\n<li>影响力输出</li>\n<li>代码质量</li>\n<li>稳定交付</li>\n<li>快速迭代流程</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 拓展自身的技术视野<ol>\n<li>学习 Python，感受社区</li>\n<li>学习 Go，感受社区</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 技术之外<ol>\n<li>《软技能》</li>\n<li>《浪潮之巅》一二册</li>\n<li>《暗时间》第二次阅读</li>\n<li>《如何阅读一本书》</li>\n</ol>\n</li>\n</ol>\n<p>共勉。</p>\n","excerpt":"","more":"<h1 id=\"The-Past\"><a href=\"#The-Past\" class=\"headerlink\" title=\"The Past\"></a>The Past</h1><ol>\n<li><a href=\"https://github.com/JerryC8080/Memeye\">Memeye</a> 终于开源了，到目前为止已经有 153 个 star 了，但是后续没有再维护了，打算等我学完 Vue 以及对前端更加熟练之后，对前端部分进行重构，使得界面更加流畅。</li>\n<li>输出文章九篇，其中八篇技术文。</li>\n<li>输出了一本小书：「<a href=\"https://github.com/JerryC8080/understand-tcp-udp\">理解 TCP 和 UDP</a>」，这是我在复习计算机网络的产物，有幸能拿到 123 star （数字很特别）。</li>\n<li>从魅族离职，入职有赞，换了个 Title，从「NodeJS 工程师」到「前端工程师」，这是很符合我个人的发展计划的，以 JS 栈为主的全栈道路。当然，前提需要是一个优秀的软件工程师。</li>\n</ol>\n<p>可惜的是，2017年的开头没有好好整理今年的目标。<br>记得有句话很深刻：「人生中最适合的时机有两个，一个是十年前，一个是现在」<br>虽然过了三分之一了，但现在计划，还来得及。</p>\n<h1 id=\"The-Next\"><a href=\"#The-Next\" class=\"headerlink\" title=\"The Next\"></a>The Next</h1><p>希望到了 2018 年的自己：</p>\n<ol>\n<li><strong>Target</strong>: 能解决大部分前端业务上的开发<ol>\n<li>深入前端，补足前端基础，包括 CSS、HTML5、ReactJS、Vue2，移动端开发</li>\n<li>学习设计理论、色彩理论、看更多的优秀设计。</li>\n<li>寻找设计领域比较好的读物，给读完。</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 在社区有更加多的影响力<ol>\n<li>全年至少产出文章 12 - 20 篇</li>\n<li>拥有一个 300 star 的开源项目</li>\n<li>影响所在团队，逐渐营造技术氛围</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 持续扎实基础实力<ol>\n<li>《鸟哥的Linux私房菜》</li>\n<li>《设计模式》</li>\n<li>《深入理解计算机操作系统》</li>\n<li>《深入浅出 NodeJS》、《NodeJS 硬实战》、《Security Your NodeJS Application》</li>\n<li>《高性能MySQL》</li>\n<li>《CSS 权威指南》、《CSS 揭秘》</li>\n<li>《Redis 设计与实现》、《Redis 实战》</li>\n<li>《你不知道的 JavaScript》</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 具有敏捷开发的实践经验<ol>\n<li>团队沟通</li>\n<li>文档沉淀</li>\n<li>影响力输出</li>\n<li>代码质量</li>\n<li>稳定交付</li>\n<li>快速迭代流程</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 拓展自身的技术视野<ol>\n<li>学习 Python，感受社区</li>\n<li>学习 Go，感受社区</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 技术之外<ol>\n<li>《软技能》</li>\n<li>《浪潮之巅》一二册</li>\n<li>《暗时间》第二次阅读</li>\n<li>《如何阅读一本书》</li>\n</ol>\n</li>\n</ol>\n<p>共勉。</p>\n"},{"title":"《管理的常识》读后感 「一」","date":"2019-03-21T12:46:40.000Z","_content":"\n# 《管理的常识》读后感 「一」\n\n陈春花的《管理的常识》是一本相见恨晚的书。在读的过程中会有一种「如果能早点遇到你多好啊」的感慨。但换种思路，一年前读与现在读，肯定是完全不同的收获。现在读，能更多结合过去的实际感受，提炼更多的感悟和反思。\n这本书我读的很慢，它虽然很薄，但是有大量的内容值得深度思考，并且每个人不同的时期不同的经历，也会有不同的理解和感悟。倘若一年后再来读，感受也是不一样的。\n从3月4日拿到书，到今天为止，我还没有完全读完，我挑了两个最有感悟的点来分享下心得，分别是：「关于管理」和「关于激励」。\n\n## 关于管理\n\n很喜欢德鲁克的一句话：「管理是一种实践，其本质不在于知，而在于行；其验证不在于逻辑，而在于成果；其唯一的权威性就是成就」。\n强调的是，管理是关注「实践」与「结果」的。\n\n### 管理的目的是为了提升效率 \n管理最终是服务于「企业经营」的，而为了实现企业经营，是通过不断提升「效率」来达成。从管理学历史的角度来看，管理学的演变被陈春花老师分为了三个阶段。\n\n**第一阶段，科学管理阶段**，这个阶段要解决的问题是「劳动效率最大化」。而使劳动效率最大化的手段就是「分工」，它有四条原理：\n1. 科学划分工作元素\n2. 员工选择、培训和开发\n3. 与员工经常沟通\n4. 管理者与员工应有平等的工作和责任范围\n\n**第二阶段，行政组织管理阶段**，这个阶段要解决的问题是「组织效率最大化」，其中最重要的手段是「专业化水平和等级制度的结合」。\n专业化水平，指的是需要强化各岗位的专业化能力，无论是开发、产品、销售、领导者、管理者，都需要具备岗位独特的专业能力。只有让各岗位贡献了专业化的水平，才算是胜任了管理工作。\n而分权分责的等级制度，能够是职位和权力两者合为一体，在这个基础上，管理的效能才会有效发挥。\n\n**第三阶段，人力资源管理阶段**，这个阶段要解决的问题是「个人效率最大化」，其中重要的手段是「个人创造组织环境，满足需求，挖掘潜力」。\n管理者其实就是一个微型的人力资源部，而不仅仅关心事务性的事情。这是角色转变很重要的一个观念。管理者也需要更多关注人，关注成员的目标与组织目标的一致性。\n激励要以团队精神为导向，个人成果要跟团队挂钩，团队的成果要跟业务挂钩。在这方面，我想到了有赞年终奖的分配逻辑上，个人绩效需要乘以团队绩效系数。这就把员工需求和组织发展的目标连接在一起。\n\n综上，管理实现效率，就是实现「劳动效率」、「组织效率」、「个人效率」，并且它们的循序是需要不断递进的过程。\n\n### 管理是一种分配 \n管理其实就是对于「职责」、「权力」、「利益」的分配。\n这是一个能改变我认知的一个理解方式。\n把职责分配下去，让每一个成员承担起责任，并且再给予和责任相适应的资源和权力，管理的效能就会发挥出来。\n最理想的情况下，就是三者都能等分，形成一个铁三角型。\n但是现实情况往往很难做到，虽然如此，也要有意识地去注意这个问题。\n\n### 「传统管理者」与「有效管理者」\n在德鲁克先生的观点下，对管理者分了两类，「传统管理者」和「有效管理者」。\n\n传统管理者几个特征：\n1. 专注于繁琐事务，时间属于别人\n2. 屁股指挥脑袋，只从所在岗位的视角看问题\n3. 忽略了对人的培养\n\n有效管理者的几个特征：\n1. 进行时间管理，明确的优先级，所有事情都有序和合理\n2. 系统性思考，认识到整体与局部的关系\n3. 培养人\n\n看着这两个分类，感触良多。\n回想 2018 上半年，刚成为 TL，角色转变。当时实际最紧迫的任务是招人，而我自身还是深陷于业务需求中。后来反省，尽管业务需求很紧急，但是在这个位置上，应当做更加重要的事情。这是当时做的很不好的地方。\n而 2018 下半年，新成员的加入，让我能够稍微脱离细节，更注重培养人，后来团队能输出不错的小伙伴，还是很欣慰的。\n而现在，我需要更多的关注在系统性思考上，跳出岗位，跳出职业视角，认识到整体和局部，这不是个短期内容易提升的事情。\n\n## 关于激励\n\n我一直认为的一个观念，大家之所以来这里工作，是有个人需求的。可能是一份薪水，可能是进步，发展，和实现个人价值。这里要回答的一个问题是：「人们为什么工作」\n企业和个人是一个双向选择过程，各取所需，各司其职，双方都会关心投入产出比。\n所以，关于如何搞清对方需求，给予激励，提高绩效。这方面我会更想找到答案。\n\n### 激励的两个角度 \n\n对于激励有两个核心的思考角度。\n第一个，是想办法让工作变成游戏，让人从中获取更多快乐，这就跟有赞强调的 Enjoy 很切合了。\n第二个，是永远站在对方的角度来思考，理解对方的述求。\n\n\n### 「保健因素」与「激励因素」\n在众多的常见激励手段中，陈春花把它们分了两类：「保健因素」和「激励因素」。\n例如，\n* 保健因素：工资、岗位，培训、福利、工作设备等。\n* 激励因素：晋升、奖金、价值的肯定、额外的工作条件等。\n\n保健因素，是一个人工作的最基本，最必须的条件，如果缺乏保健因素的话，就会引起不满。另外一个特点是，大部分人都有的，不具有独特性的。\n\n激励因素，是一个人做好工作所需要的条件，他能够带来满足感，能够激起人的欲望和潜力的。另外一个特点是，少部分有的，需要踮脚拿到的。\n\n所以，不同激励与感受的关系是，保健因素 → 降低不满，激励因素 → 提升满足感。\n\n需要注意的是，激励因素是有可能变成保健因素的。例如现在大部分公司都发年终奖，并且人人都有，HR 谈薪资的时候，也会用年薪的概念把年终奖算进收入里面，作为一个 package。那么年终奖，就变成了保健因素了。一旦公司年底发不出年终奖，或者不及预期，那就会引起不满。\n\n### 「激励」与「绩效」\n\n时刻不能忘的是，管理最终是服务于企业经营的。激励是重要的管理手段，最终也是要为绩效负责的。「激励」和「绩效」的关系，有些要注意的。\n\n** 满足感并不一定带来高绩效 **\n在满足员工的需求，让员工获得满足感的基础下，一定要：**「让员工的满足感来源于工作本身而不是个人需求」**\n\n因为人们的需求是很个人化的，例如有的人需求是工作环境，而不是工作中获得绩效。那么当工作环境很好的时候，导致员工很有满足感，但是他并不关心工作本身。\n\n**激励有时候不会发挥作用**\n有些情况下，不管采用何种激励措施，都无法达到效果：\n1. 工作量超量所造成的疲惫\n2. 角色不清，任务冲突\n3. 不公平待遇\n\n在这三种情况下，更应该切实的改变人们所处的状态，合理的工作量设计、清晰的责权利、公平的待遇。在这个基础之上，通过有效的激励措施，才能获得高的工作绩效。\n\n\n### 期望理论\n\n「人会成为他所期望的样子」这是一句大实话，人的进步都源于期望，也许来自于他人，也许来自于自身。\n期望理论有三个基本条件：\n1. 期望价，这个目标需要能够实现的，如果太高就没有可行性。\n2. 媒介，主要是要获取信任感，相信结果是可获得的，跟目标是一致的。\n3. 承诺会兑现，不管多少人达成期望，都一定要能实现当初的承诺。\n\n期望理论满足这三个基本条件，才能真正达到效果，激励人们向更高的期望努力。\n\n### 当下我更多可以做的激励动作\n\n成本最低的而且最有效的激励措施，也就是性价比最高的激励措施：鼓掌、赞美、鲜花、隆重的仪式、授权与信任。\n\n前三者（鼓掌、赞美、鲜花），我归纳为对付出的肯定，那么就归类为：\n1. 肯定（鼓掌、赞美、鲜花）\n4. 仪式感\n5. 授权与信任\n\n对人们的结果，要及时的给予肯定，让他们知道有人看得到，并且得到欣赏，这也是人类最基本的社会述求。\n在重要的事情上，要有一定的仪式感，例如一个项目的建立，一个团队的建立，一件重要事情的达成等等。\n尤其重要的是授权与信任，这个我回想起两年前初来有赞的时候，跟前司很大不同的是，能得到很好的授权与信任，以及足够的自由和发挥空间。\n\n\n## 最后\n\n《管理的常识》这本书，在物理空间上，它很薄。但这不妨碍它能囊括很强大的内容，这些内容很适合细细品读与感悟。也很庆幸在这个时间遇到一本好书，让自己重新总结和审视过去的经验和见识。\n另外，标题加了个「一」，是为了立个 Flag，让我继续读完这本书，然后再写一篇心得。\n最后，管理，确实是一门科学，也是一门艺术。","source":"_posts/management-of-common-sense-1.md","raw":"---\ntitle: 《管理的常识》读后感 「一」\ncategory: 三省吾身\ndate: 2019-3-21 20:46:40\n---\n\n# 《管理的常识》读后感 「一」\n\n陈春花的《管理的常识》是一本相见恨晚的书。在读的过程中会有一种「如果能早点遇到你多好啊」的感慨。但换种思路，一年前读与现在读，肯定是完全不同的收获。现在读，能更多结合过去的实际感受，提炼更多的感悟和反思。\n这本书我读的很慢，它虽然很薄，但是有大量的内容值得深度思考，并且每个人不同的时期不同的经历，也会有不同的理解和感悟。倘若一年后再来读，感受也是不一样的。\n从3月4日拿到书，到今天为止，我还没有完全读完，我挑了两个最有感悟的点来分享下心得，分别是：「关于管理」和「关于激励」。\n\n## 关于管理\n\n很喜欢德鲁克的一句话：「管理是一种实践，其本质不在于知，而在于行；其验证不在于逻辑，而在于成果；其唯一的权威性就是成就」。\n强调的是，管理是关注「实践」与「结果」的。\n\n### 管理的目的是为了提升效率 \n管理最终是服务于「企业经营」的，而为了实现企业经营，是通过不断提升「效率」来达成。从管理学历史的角度来看，管理学的演变被陈春花老师分为了三个阶段。\n\n**第一阶段，科学管理阶段**，这个阶段要解决的问题是「劳动效率最大化」。而使劳动效率最大化的手段就是「分工」，它有四条原理：\n1. 科学划分工作元素\n2. 员工选择、培训和开发\n3. 与员工经常沟通\n4. 管理者与员工应有平等的工作和责任范围\n\n**第二阶段，行政组织管理阶段**，这个阶段要解决的问题是「组织效率最大化」，其中最重要的手段是「专业化水平和等级制度的结合」。\n专业化水平，指的是需要强化各岗位的专业化能力，无论是开发、产品、销售、领导者、管理者，都需要具备岗位独特的专业能力。只有让各岗位贡献了专业化的水平，才算是胜任了管理工作。\n而分权分责的等级制度，能够是职位和权力两者合为一体，在这个基础上，管理的效能才会有效发挥。\n\n**第三阶段，人力资源管理阶段**，这个阶段要解决的问题是「个人效率最大化」，其中重要的手段是「个人创造组织环境，满足需求，挖掘潜力」。\n管理者其实就是一个微型的人力资源部，而不仅仅关心事务性的事情。这是角色转变很重要的一个观念。管理者也需要更多关注人，关注成员的目标与组织目标的一致性。\n激励要以团队精神为导向，个人成果要跟团队挂钩，团队的成果要跟业务挂钩。在这方面，我想到了有赞年终奖的分配逻辑上，个人绩效需要乘以团队绩效系数。这就把员工需求和组织发展的目标连接在一起。\n\n综上，管理实现效率，就是实现「劳动效率」、「组织效率」、「个人效率」，并且它们的循序是需要不断递进的过程。\n\n### 管理是一种分配 \n管理其实就是对于「职责」、「权力」、「利益」的分配。\n这是一个能改变我认知的一个理解方式。\n把职责分配下去，让每一个成员承担起责任，并且再给予和责任相适应的资源和权力，管理的效能就会发挥出来。\n最理想的情况下，就是三者都能等分，形成一个铁三角型。\n但是现实情况往往很难做到，虽然如此，也要有意识地去注意这个问题。\n\n### 「传统管理者」与「有效管理者」\n在德鲁克先生的观点下，对管理者分了两类，「传统管理者」和「有效管理者」。\n\n传统管理者几个特征：\n1. 专注于繁琐事务，时间属于别人\n2. 屁股指挥脑袋，只从所在岗位的视角看问题\n3. 忽略了对人的培养\n\n有效管理者的几个特征：\n1. 进行时间管理，明确的优先级，所有事情都有序和合理\n2. 系统性思考，认识到整体与局部的关系\n3. 培养人\n\n看着这两个分类，感触良多。\n回想 2018 上半年，刚成为 TL，角色转变。当时实际最紧迫的任务是招人，而我自身还是深陷于业务需求中。后来反省，尽管业务需求很紧急，但是在这个位置上，应当做更加重要的事情。这是当时做的很不好的地方。\n而 2018 下半年，新成员的加入，让我能够稍微脱离细节，更注重培养人，后来团队能输出不错的小伙伴，还是很欣慰的。\n而现在，我需要更多的关注在系统性思考上，跳出岗位，跳出职业视角，认识到整体和局部，这不是个短期内容易提升的事情。\n\n## 关于激励\n\n我一直认为的一个观念，大家之所以来这里工作，是有个人需求的。可能是一份薪水，可能是进步，发展，和实现个人价值。这里要回答的一个问题是：「人们为什么工作」\n企业和个人是一个双向选择过程，各取所需，各司其职，双方都会关心投入产出比。\n所以，关于如何搞清对方需求，给予激励，提高绩效。这方面我会更想找到答案。\n\n### 激励的两个角度 \n\n对于激励有两个核心的思考角度。\n第一个，是想办法让工作变成游戏，让人从中获取更多快乐，这就跟有赞强调的 Enjoy 很切合了。\n第二个，是永远站在对方的角度来思考，理解对方的述求。\n\n\n### 「保健因素」与「激励因素」\n在众多的常见激励手段中，陈春花把它们分了两类：「保健因素」和「激励因素」。\n例如，\n* 保健因素：工资、岗位，培训、福利、工作设备等。\n* 激励因素：晋升、奖金、价值的肯定、额外的工作条件等。\n\n保健因素，是一个人工作的最基本，最必须的条件，如果缺乏保健因素的话，就会引起不满。另外一个特点是，大部分人都有的，不具有独特性的。\n\n激励因素，是一个人做好工作所需要的条件，他能够带来满足感，能够激起人的欲望和潜力的。另外一个特点是，少部分有的，需要踮脚拿到的。\n\n所以，不同激励与感受的关系是，保健因素 → 降低不满，激励因素 → 提升满足感。\n\n需要注意的是，激励因素是有可能变成保健因素的。例如现在大部分公司都发年终奖，并且人人都有，HR 谈薪资的时候，也会用年薪的概念把年终奖算进收入里面，作为一个 package。那么年终奖，就变成了保健因素了。一旦公司年底发不出年终奖，或者不及预期，那就会引起不满。\n\n### 「激励」与「绩效」\n\n时刻不能忘的是，管理最终是服务于企业经营的。激励是重要的管理手段，最终也是要为绩效负责的。「激励」和「绩效」的关系，有些要注意的。\n\n** 满足感并不一定带来高绩效 **\n在满足员工的需求，让员工获得满足感的基础下，一定要：**「让员工的满足感来源于工作本身而不是个人需求」**\n\n因为人们的需求是很个人化的，例如有的人需求是工作环境，而不是工作中获得绩效。那么当工作环境很好的时候，导致员工很有满足感，但是他并不关心工作本身。\n\n**激励有时候不会发挥作用**\n有些情况下，不管采用何种激励措施，都无法达到效果：\n1. 工作量超量所造成的疲惫\n2. 角色不清，任务冲突\n3. 不公平待遇\n\n在这三种情况下，更应该切实的改变人们所处的状态，合理的工作量设计、清晰的责权利、公平的待遇。在这个基础之上，通过有效的激励措施，才能获得高的工作绩效。\n\n\n### 期望理论\n\n「人会成为他所期望的样子」这是一句大实话，人的进步都源于期望，也许来自于他人，也许来自于自身。\n期望理论有三个基本条件：\n1. 期望价，这个目标需要能够实现的，如果太高就没有可行性。\n2. 媒介，主要是要获取信任感，相信结果是可获得的，跟目标是一致的。\n3. 承诺会兑现，不管多少人达成期望，都一定要能实现当初的承诺。\n\n期望理论满足这三个基本条件，才能真正达到效果，激励人们向更高的期望努力。\n\n### 当下我更多可以做的激励动作\n\n成本最低的而且最有效的激励措施，也就是性价比最高的激励措施：鼓掌、赞美、鲜花、隆重的仪式、授权与信任。\n\n前三者（鼓掌、赞美、鲜花），我归纳为对付出的肯定，那么就归类为：\n1. 肯定（鼓掌、赞美、鲜花）\n4. 仪式感\n5. 授权与信任\n\n对人们的结果，要及时的给予肯定，让他们知道有人看得到，并且得到欣赏，这也是人类最基本的社会述求。\n在重要的事情上，要有一定的仪式感，例如一个项目的建立，一个团队的建立，一件重要事情的达成等等。\n尤其重要的是授权与信任，这个我回想起两年前初来有赞的时候，跟前司很大不同的是，能得到很好的授权与信任，以及足够的自由和发挥空间。\n\n\n## 最后\n\n《管理的常识》这本书，在物理空间上，它很薄。但这不妨碍它能囊括很强大的内容，这些内容很适合细细品读与感悟。也很庆幸在这个时间遇到一本好书，让自己重新总结和审视过去的经验和见识。\n另外，标题加了个「一」，是为了立个 Flag，让我继续读完这本书，然后再写一篇心得。\n最后，管理，确实是一门科学，也是一门艺术。","slug":"management-of-common-sense-1","published":1,"updated":"2019-04-13T09:30:38.771Z","_id":"cl270y8t80053xwrlv7zhv57u","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"《管理的常识》读后感-「一」\"><a href=\"#《管理的常识》读后感-「一」\" class=\"headerlink\" title=\"《管理的常识》读后感 「一」\"></a>《管理的常识》读后感 「一」</h1><p>陈春花的《管理的常识》是一本相见恨晚的书。在读的过程中会有一种「如果能早点遇到你多好啊」的感慨。但换种思路，一年前读与现在读，肯定是完全不同的收获。现在读，能更多结合过去的实际感受，提炼更多的感悟和反思。<br>这本书我读的很慢，它虽然很薄，但是有大量的内容值得深度思考，并且每个人不同的时期不同的经历，也会有不同的理解和感悟。倘若一年后再来读，感受也是不一样的。<br>从3月4日拿到书，到今天为止，我还没有完全读完，我挑了两个最有感悟的点来分享下心得，分别是：「关于管理」和「关于激励」。</p>\n<h2 id=\"关于管理\"><a href=\"#关于管理\" class=\"headerlink\" title=\"关于管理\"></a>关于管理</h2><p>很喜欢德鲁克的一句话：「管理是一种实践，其本质不在于知，而在于行；其验证不在于逻辑，而在于成果；其唯一的权威性就是成就」。<br>强调的是，管理是关注「实践」与「结果」的。</p>\n<h3 id=\"管理的目的是为了提升效率\"><a href=\"#管理的目的是为了提升效率\" class=\"headerlink\" title=\"管理的目的是为了提升效率\"></a>管理的目的是为了提升效率</h3><p>管理最终是服务于「企业经营」的，而为了实现企业经营，是通过不断提升「效率」来达成。从管理学历史的角度来看，管理学的演变被陈春花老师分为了三个阶段。</p>\n<p><strong>第一阶段，科学管理阶段</strong>，这个阶段要解决的问题是「劳动效率最大化」。而使劳动效率最大化的手段就是「分工」，它有四条原理：</p>\n<ol>\n<li>科学划分工作元素</li>\n<li>员工选择、培训和开发</li>\n<li>与员工经常沟通</li>\n<li>管理者与员工应有平等的工作和责任范围</li>\n</ol>\n<p><strong>第二阶段，行政组织管理阶段</strong>，这个阶段要解决的问题是「组织效率最大化」，其中最重要的手段是「专业化水平和等级制度的结合」。<br>专业化水平，指的是需要强化各岗位的专业化能力，无论是开发、产品、销售、领导者、管理者，都需要具备岗位独特的专业能力。只有让各岗位贡献了专业化的水平，才算是胜任了管理工作。<br>而分权分责的等级制度，能够是职位和权力两者合为一体，在这个基础上，管理的效能才会有效发挥。</p>\n<p><strong>第三阶段，人力资源管理阶段</strong>，这个阶段要解决的问题是「个人效率最大化」，其中重要的手段是「个人创造组织环境，满足需求，挖掘潜力」。<br>管理者其实就是一个微型的人力资源部，而不仅仅关心事务性的事情。这是角色转变很重要的一个观念。管理者也需要更多关注人，关注成员的目标与组织目标的一致性。<br>激励要以团队精神为导向，个人成果要跟团队挂钩，团队的成果要跟业务挂钩。在这方面，我想到了有赞年终奖的分配逻辑上，个人绩效需要乘以团队绩效系数。这就把员工需求和组织发展的目标连接在一起。</p>\n<p>综上，管理实现效率，就是实现「劳动效率」、「组织效率」、「个人效率」，并且它们的循序是需要不断递进的过程。</p>\n<h3 id=\"管理是一种分配\"><a href=\"#管理是一种分配\" class=\"headerlink\" title=\"管理是一种分配\"></a>管理是一种分配</h3><p>管理其实就是对于「职责」、「权力」、「利益」的分配。<br>这是一个能改变我认知的一个理解方式。<br>把职责分配下去，让每一个成员承担起责任，并且再给予和责任相适应的资源和权力，管理的效能就会发挥出来。<br>最理想的情况下，就是三者都能等分，形成一个铁三角型。<br>但是现实情况往往很难做到，虽然如此，也要有意识地去注意这个问题。</p>\n<h3 id=\"「传统管理者」与「有效管理者」\"><a href=\"#「传统管理者」与「有效管理者」\" class=\"headerlink\" title=\"「传统管理者」与「有效管理者」\"></a>「传统管理者」与「有效管理者」</h3><p>在德鲁克先生的观点下，对管理者分了两类，「传统管理者」和「有效管理者」。</p>\n<p>传统管理者几个特征：</p>\n<ol>\n<li>专注于繁琐事务，时间属于别人</li>\n<li>屁股指挥脑袋，只从所在岗位的视角看问题</li>\n<li>忽略了对人的培养</li>\n</ol>\n<p>有效管理者的几个特征：</p>\n<ol>\n<li>进行时间管理，明确的优先级，所有事情都有序和合理</li>\n<li>系统性思考，认识到整体与局部的关系</li>\n<li>培养人</li>\n</ol>\n<p>看着这两个分类，感触良多。<br>回想 2018 上半年，刚成为 TL，角色转变。当时实际最紧迫的任务是招人，而我自身还是深陷于业务需求中。后来反省，尽管业务需求很紧急，但是在这个位置上，应当做更加重要的事情。这是当时做的很不好的地方。<br>而 2018 下半年，新成员的加入，让我能够稍微脱离细节，更注重培养人，后来团队能输出不错的小伙伴，还是很欣慰的。<br>而现在，我需要更多的关注在系统性思考上，跳出岗位，跳出职业视角，认识到整体和局部，这不是个短期内容易提升的事情。</p>\n<h2 id=\"关于激励\"><a href=\"#关于激励\" class=\"headerlink\" title=\"关于激励\"></a>关于激励</h2><p>我一直认为的一个观念，大家之所以来这里工作，是有个人需求的。可能是一份薪水，可能是进步，发展，和实现个人价值。这里要回答的一个问题是：「人们为什么工作」<br>企业和个人是一个双向选择过程，各取所需，各司其职，双方都会关心投入产出比。<br>所以，关于如何搞清对方需求，给予激励，提高绩效。这方面我会更想找到答案。</p>\n<h3 id=\"激励的两个角度\"><a href=\"#激励的两个角度\" class=\"headerlink\" title=\"激励的两个角度\"></a>激励的两个角度</h3><p>对于激励有两个核心的思考角度。<br>第一个，是想办法让工作变成游戏，让人从中获取更多快乐，这就跟有赞强调的 Enjoy 很切合了。<br>第二个，是永远站在对方的角度来思考，理解对方的述求。</p>\n<h3 id=\"「保健因素」与「激励因素」\"><a href=\"#「保健因素」与「激励因素」\" class=\"headerlink\" title=\"「保健因素」与「激励因素」\"></a>「保健因素」与「激励因素」</h3><p>在众多的常见激励手段中，陈春花把它们分了两类：「保健因素」和「激励因素」。<br>例如，</p>\n<ul>\n<li>保健因素：工资、岗位，培训、福利、工作设备等。</li>\n<li>激励因素：晋升、奖金、价值的肯定、额外的工作条件等。</li>\n</ul>\n<p>保健因素，是一个人工作的最基本，最必须的条件，如果缺乏保健因素的话，就会引起不满。另外一个特点是，大部分人都有的，不具有独特性的。</p>\n<p>激励因素，是一个人做好工作所需要的条件，他能够带来满足感，能够激起人的欲望和潜力的。另外一个特点是，少部分有的，需要踮脚拿到的。</p>\n<p>所以，不同激励与感受的关系是，保健因素 → 降低不满，激励因素 → 提升满足感。</p>\n<p>需要注意的是，激励因素是有可能变成保健因素的。例如现在大部分公司都发年终奖，并且人人都有，HR 谈薪资的时候，也会用年薪的概念把年终奖算进收入里面，作为一个 package。那么年终奖，就变成了保健因素了。一旦公司年底发不出年终奖，或者不及预期，那就会引起不满。</p>\n<h3 id=\"「激励」与「绩效」\"><a href=\"#「激励」与「绩效」\" class=\"headerlink\" title=\"「激励」与「绩效」\"></a>「激励」与「绩效」</h3><p>时刻不能忘的是，管理最终是服务于企业经营的。激励是重要的管理手段，最终也是要为绩效负责的。「激励」和「绩效」的关系，有些要注意的。</p>\n<p><strong> 满足感并不一定带来高绩效 </strong><br>在满足员工的需求，让员工获得满足感的基础下，一定要：<strong>「让员工的满足感来源于工作本身而不是个人需求」</strong></p>\n<p>因为人们的需求是很个人化的，例如有的人需求是工作环境，而不是工作中获得绩效。那么当工作环境很好的时候，导致员工很有满足感，但是他并不关心工作本身。</p>\n<p><strong>激励有时候不会发挥作用</strong><br>有些情况下，不管采用何种激励措施，都无法达到效果：</p>\n<ol>\n<li>工作量超量所造成的疲惫</li>\n<li>角色不清，任务冲突</li>\n<li>不公平待遇</li>\n</ol>\n<p>在这三种情况下，更应该切实的改变人们所处的状态，合理的工作量设计、清晰的责权利、公平的待遇。在这个基础之上，通过有效的激励措施，才能获得高的工作绩效。</p>\n<h3 id=\"期望理论\"><a href=\"#期望理论\" class=\"headerlink\" title=\"期望理论\"></a>期望理论</h3><p>「人会成为他所期望的样子」这是一句大实话，人的进步都源于期望，也许来自于他人，也许来自于自身。<br>期望理论有三个基本条件：</p>\n<ol>\n<li>期望价，这个目标需要能够实现的，如果太高就没有可行性。</li>\n<li>媒介，主要是要获取信任感，相信结果是可获得的，跟目标是一致的。</li>\n<li>承诺会兑现，不管多少人达成期望，都一定要能实现当初的承诺。</li>\n</ol>\n<p>期望理论满足这三个基本条件，才能真正达到效果，激励人们向更高的期望努力。</p>\n<h3 id=\"当下我更多可以做的激励动作\"><a href=\"#当下我更多可以做的激励动作\" class=\"headerlink\" title=\"当下我更多可以做的激励动作\"></a>当下我更多可以做的激励动作</h3><p>成本最低的而且最有效的激励措施，也就是性价比最高的激励措施：鼓掌、赞美、鲜花、隆重的仪式、授权与信任。</p>\n<p>前三者（鼓掌、赞美、鲜花），我归纳为对付出的肯定，那么就归类为：</p>\n<ol>\n<li>肯定（鼓掌、赞美、鲜花）</li>\n<li>仪式感</li>\n<li>授权与信任</li>\n</ol>\n<p>对人们的结果，要及时的给予肯定，让他们知道有人看得到，并且得到欣赏，这也是人类最基本的社会述求。<br>在重要的事情上，要有一定的仪式感，例如一个项目的建立，一个团队的建立，一件重要事情的达成等等。<br>尤其重要的是授权与信任，这个我回想起两年前初来有赞的时候，跟前司很大不同的是，能得到很好的授权与信任，以及足够的自由和发挥空间。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>《管理的常识》这本书，在物理空间上，它很薄。但这不妨碍它能囊括很强大的内容，这些内容很适合细细品读与感悟。也很庆幸在这个时间遇到一本好书，让自己重新总结和审视过去的经验和见识。<br>另外，标题加了个「一」，是为了立个 Flag，让我继续读完这本书，然后再写一篇心得。<br>最后，管理，确实是一门科学，也是一门艺术。</p>\n","excerpt":"","more":"<h1 id=\"《管理的常识》读后感-「一」\"><a href=\"#《管理的常识》读后感-「一」\" class=\"headerlink\" title=\"《管理的常识》读后感 「一」\"></a>《管理的常识》读后感 「一」</h1><p>陈春花的《管理的常识》是一本相见恨晚的书。在读的过程中会有一种「如果能早点遇到你多好啊」的感慨。但换种思路，一年前读与现在读，肯定是完全不同的收获。现在读，能更多结合过去的实际感受，提炼更多的感悟和反思。<br>这本书我读的很慢，它虽然很薄，但是有大量的内容值得深度思考，并且每个人不同的时期不同的经历，也会有不同的理解和感悟。倘若一年后再来读，感受也是不一样的。<br>从3月4日拿到书，到今天为止，我还没有完全读完，我挑了两个最有感悟的点来分享下心得，分别是：「关于管理」和「关于激励」。</p>\n<h2 id=\"关于管理\"><a href=\"#关于管理\" class=\"headerlink\" title=\"关于管理\"></a>关于管理</h2><p>很喜欢德鲁克的一句话：「管理是一种实践，其本质不在于知，而在于行；其验证不在于逻辑，而在于成果；其唯一的权威性就是成就」。<br>强调的是，管理是关注「实践」与「结果」的。</p>\n<h3 id=\"管理的目的是为了提升效率\"><a href=\"#管理的目的是为了提升效率\" class=\"headerlink\" title=\"管理的目的是为了提升效率\"></a>管理的目的是为了提升效率</h3><p>管理最终是服务于「企业经营」的，而为了实现企业经营，是通过不断提升「效率」来达成。从管理学历史的角度来看，管理学的演变被陈春花老师分为了三个阶段。</p>\n<p><strong>第一阶段，科学管理阶段</strong>，这个阶段要解决的问题是「劳动效率最大化」。而使劳动效率最大化的手段就是「分工」，它有四条原理：</p>\n<ol>\n<li>科学划分工作元素</li>\n<li>员工选择、培训和开发</li>\n<li>与员工经常沟通</li>\n<li>管理者与员工应有平等的工作和责任范围</li>\n</ol>\n<p><strong>第二阶段，行政组织管理阶段</strong>，这个阶段要解决的问题是「组织效率最大化」，其中最重要的手段是「专业化水平和等级制度的结合」。<br>专业化水平，指的是需要强化各岗位的专业化能力，无论是开发、产品、销售、领导者、管理者，都需要具备岗位独特的专业能力。只有让各岗位贡献了专业化的水平，才算是胜任了管理工作。<br>而分权分责的等级制度，能够是职位和权力两者合为一体，在这个基础上，管理的效能才会有效发挥。</p>\n<p><strong>第三阶段，人力资源管理阶段</strong>，这个阶段要解决的问题是「个人效率最大化」，其中重要的手段是「个人创造组织环境，满足需求，挖掘潜力」。<br>管理者其实就是一个微型的人力资源部，而不仅仅关心事务性的事情。这是角色转变很重要的一个观念。管理者也需要更多关注人，关注成员的目标与组织目标的一致性。<br>激励要以团队精神为导向，个人成果要跟团队挂钩，团队的成果要跟业务挂钩。在这方面，我想到了有赞年终奖的分配逻辑上，个人绩效需要乘以团队绩效系数。这就把员工需求和组织发展的目标连接在一起。</p>\n<p>综上，管理实现效率，就是实现「劳动效率」、「组织效率」、「个人效率」，并且它们的循序是需要不断递进的过程。</p>\n<h3 id=\"管理是一种分配\"><a href=\"#管理是一种分配\" class=\"headerlink\" title=\"管理是一种分配\"></a>管理是一种分配</h3><p>管理其实就是对于「职责」、「权力」、「利益」的分配。<br>这是一个能改变我认知的一个理解方式。<br>把职责分配下去，让每一个成员承担起责任，并且再给予和责任相适应的资源和权力，管理的效能就会发挥出来。<br>最理想的情况下，就是三者都能等分，形成一个铁三角型。<br>但是现实情况往往很难做到，虽然如此，也要有意识地去注意这个问题。</p>\n<h3 id=\"「传统管理者」与「有效管理者」\"><a href=\"#「传统管理者」与「有效管理者」\" class=\"headerlink\" title=\"「传统管理者」与「有效管理者」\"></a>「传统管理者」与「有效管理者」</h3><p>在德鲁克先生的观点下，对管理者分了两类，「传统管理者」和「有效管理者」。</p>\n<p>传统管理者几个特征：</p>\n<ol>\n<li>专注于繁琐事务，时间属于别人</li>\n<li>屁股指挥脑袋，只从所在岗位的视角看问题</li>\n<li>忽略了对人的培养</li>\n</ol>\n<p>有效管理者的几个特征：</p>\n<ol>\n<li>进行时间管理，明确的优先级，所有事情都有序和合理</li>\n<li>系统性思考，认识到整体与局部的关系</li>\n<li>培养人</li>\n</ol>\n<p>看着这两个分类，感触良多。<br>回想 2018 上半年，刚成为 TL，角色转变。当时实际最紧迫的任务是招人，而我自身还是深陷于业务需求中。后来反省，尽管业务需求很紧急，但是在这个位置上，应当做更加重要的事情。这是当时做的很不好的地方。<br>而 2018 下半年，新成员的加入，让我能够稍微脱离细节，更注重培养人，后来团队能输出不错的小伙伴，还是很欣慰的。<br>而现在，我需要更多的关注在系统性思考上，跳出岗位，跳出职业视角，认识到整体和局部，这不是个短期内容易提升的事情。</p>\n<h2 id=\"关于激励\"><a href=\"#关于激励\" class=\"headerlink\" title=\"关于激励\"></a>关于激励</h2><p>我一直认为的一个观念，大家之所以来这里工作，是有个人需求的。可能是一份薪水，可能是进步，发展，和实现个人价值。这里要回答的一个问题是：「人们为什么工作」<br>企业和个人是一个双向选择过程，各取所需，各司其职，双方都会关心投入产出比。<br>所以，关于如何搞清对方需求，给予激励，提高绩效。这方面我会更想找到答案。</p>\n<h3 id=\"激励的两个角度\"><a href=\"#激励的两个角度\" class=\"headerlink\" title=\"激励的两个角度\"></a>激励的两个角度</h3><p>对于激励有两个核心的思考角度。<br>第一个，是想办法让工作变成游戏，让人从中获取更多快乐，这就跟有赞强调的 Enjoy 很切合了。<br>第二个，是永远站在对方的角度来思考，理解对方的述求。</p>\n<h3 id=\"「保健因素」与「激励因素」\"><a href=\"#「保健因素」与「激励因素」\" class=\"headerlink\" title=\"「保健因素」与「激励因素」\"></a>「保健因素」与「激励因素」</h3><p>在众多的常见激励手段中，陈春花把它们分了两类：「保健因素」和「激励因素」。<br>例如，</p>\n<ul>\n<li>保健因素：工资、岗位，培训、福利、工作设备等。</li>\n<li>激励因素：晋升、奖金、价值的肯定、额外的工作条件等。</li>\n</ul>\n<p>保健因素，是一个人工作的最基本，最必须的条件，如果缺乏保健因素的话，就会引起不满。另外一个特点是，大部分人都有的，不具有独特性的。</p>\n<p>激励因素，是一个人做好工作所需要的条件，他能够带来满足感，能够激起人的欲望和潜力的。另外一个特点是，少部分有的，需要踮脚拿到的。</p>\n<p>所以，不同激励与感受的关系是，保健因素 → 降低不满，激励因素 → 提升满足感。</p>\n<p>需要注意的是，激励因素是有可能变成保健因素的。例如现在大部分公司都发年终奖，并且人人都有，HR 谈薪资的时候，也会用年薪的概念把年终奖算进收入里面，作为一个 package。那么年终奖，就变成了保健因素了。一旦公司年底发不出年终奖，或者不及预期，那就会引起不满。</p>\n<h3 id=\"「激励」与「绩效」\"><a href=\"#「激励」与「绩效」\" class=\"headerlink\" title=\"「激励」与「绩效」\"></a>「激励」与「绩效」</h3><p>时刻不能忘的是，管理最终是服务于企业经营的。激励是重要的管理手段，最终也是要为绩效负责的。「激励」和「绩效」的关系，有些要注意的。</p>\n<p><strong> 满足感并不一定带来高绩效 </strong><br>在满足员工的需求，让员工获得满足感的基础下，一定要：<strong>「让员工的满足感来源于工作本身而不是个人需求」</strong></p>\n<p>因为人们的需求是很个人化的，例如有的人需求是工作环境，而不是工作中获得绩效。那么当工作环境很好的时候，导致员工很有满足感，但是他并不关心工作本身。</p>\n<p><strong>激励有时候不会发挥作用</strong><br>有些情况下，不管采用何种激励措施，都无法达到效果：</p>\n<ol>\n<li>工作量超量所造成的疲惫</li>\n<li>角色不清，任务冲突</li>\n<li>不公平待遇</li>\n</ol>\n<p>在这三种情况下，更应该切实的改变人们所处的状态，合理的工作量设计、清晰的责权利、公平的待遇。在这个基础之上，通过有效的激励措施，才能获得高的工作绩效。</p>\n<h3 id=\"期望理论\"><a href=\"#期望理论\" class=\"headerlink\" title=\"期望理论\"></a>期望理论</h3><p>「人会成为他所期望的样子」这是一句大实话，人的进步都源于期望，也许来自于他人，也许来自于自身。<br>期望理论有三个基本条件：</p>\n<ol>\n<li>期望价，这个目标需要能够实现的，如果太高就没有可行性。</li>\n<li>媒介，主要是要获取信任感，相信结果是可获得的，跟目标是一致的。</li>\n<li>承诺会兑现，不管多少人达成期望，都一定要能实现当初的承诺。</li>\n</ol>\n<p>期望理论满足这三个基本条件，才能真正达到效果，激励人们向更高的期望努力。</p>\n<h3 id=\"当下我更多可以做的激励动作\"><a href=\"#当下我更多可以做的激励动作\" class=\"headerlink\" title=\"当下我更多可以做的激励动作\"></a>当下我更多可以做的激励动作</h3><p>成本最低的而且最有效的激励措施，也就是性价比最高的激励措施：鼓掌、赞美、鲜花、隆重的仪式、授权与信任。</p>\n<p>前三者（鼓掌、赞美、鲜花），我归纳为对付出的肯定，那么就归类为：</p>\n<ol>\n<li>肯定（鼓掌、赞美、鲜花）</li>\n<li>仪式感</li>\n<li>授权与信任</li>\n</ol>\n<p>对人们的结果，要及时的给予肯定，让他们知道有人看得到，并且得到欣赏，这也是人类最基本的社会述求。<br>在重要的事情上，要有一定的仪式感，例如一个项目的建立，一个团队的建立，一件重要事情的达成等等。<br>尤其重要的是授权与信任，这个我回想起两年前初来有赞的时候，跟前司很大不同的是，能得到很好的授权与信任，以及足够的自由和发挥空间。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>《管理的常识》这本书，在物理空间上，它很薄。但这不妨碍它能囊括很强大的内容，这些内容很适合细细品读与感悟。也很庆幸在这个时间遇到一本好书，让自己重新总结和审视过去的经验和见识。<br>另外，标题加了个「一」，是为了立个 Flag，让我继续读完这本书，然后再写一篇心得。<br>最后，管理，确实是一门科学，也是一门艺术。</p>\n"},{"title":"程序员如何保证「专注」与「效率」","date":"2016-11-27T05:08:00.000Z","_content":"\n多年前，家母常骂我容易沉迷，沉迷游戏，沉迷小说，沉迷电视剧，沉迷XXX。\n意思就是说，例如当我在玩游戏的时候，很难打断我，完全沉入进去了，叫吃饭都听不见。\n在我看来，「沉迷」与「专注」实质描述同一样事物的两个相反词义的词汇。\n用在主观认为正确的事情上，叫「专注」，专注读书，专注学习，专注搬砖写代码。\n用在主观认为不正确的事情上，叫「沉迷」，沉迷游戏，沉迷小说，沉迷肥皂电视剧。\n所以，小孩子千万别「沉迷」，像「沉迷网游」会被爱子心切的家长送去给杨教授进行电击治疗的哦。\n我们还是来谈谈可以提高生产率的「专注」。\n\n# 什么是专注\n简而言之，专注就是注意力分散的对立面。\n记得大学时候教我英语的老教授说过的一句，\n「知道为什么你们一直都学不好英语么，你们这一代人生活在一个太多诱惑的世界。」\n\n每一天，我们坐下来打开电脑，想做点什么正经事情的时候。\n却又无意中打开微博看看热搜榜，看看林丹出轨，宋冬野吸毒入狱，papi酱和逻辑思维闹分手。\n又会拿起手机刷刷朋友圈，看看小伙伴自拍照，旅游照，三姑六婆姨妈姑丈的心灵鸡汤。\n还会打开知乎，看看各种「如何评价XXX」，「XXX是什么样的体验」。\n\n就像吴晓波每周都会说的「世界如此喧嚣」。\n现代人生活在一个充满了干扰的世界，社交、邮件、电话、短信、走神、打断，纷至沓来。\n\n不知道你还记得最近一次解决真正的难题是什么时候吗？\n你可能是在试图修复一些BUG，或者要弄清楚为什么代码跑不动。\n时间飞逝，你忘了吃饭、喝水乃至睡觉，一门心思扑在你的任务上。\n你全身心的投入到单个项目上，如果任何人胆敢打扰你，你就会暴跳如雷。\n这就是「专注」。\n就像生活中许多事情一样，专注就像一个「冲量」的游戏，想要达到专注工作的状态很难，但是一旦进入专注状态，就能轻松的保持下去。\n\n## 冲量\n「冲量」是一个物理词汇\n> 冲量是作用在物体上的力在时间上的累积，一个随时间改变的力对一个物体的冲量指这个力的作用对时间的积累效果。\n\n我觉得用来形容人类思维从一个「注意力分散」的状态进入到「专注」状态的过程是再好不过的概念了。\n\n就像我们开车在高速公路上行驶时的提速过程，车在进入高速行驶之前需要更换几个档位，让车提到五档，需要点时间和油耗。一旦开到五档，那就能轻松巡航了。\n倘若你开在每隔一百米一个红绿灯的道路上，总是不断的起步停车，那么整体的速度会很慢，且油耗高，顺带还给「雾霾」增添多一分贡献。\n\n又像我们启动电脑程序，第一次打开程序往往需要较长的时间。因为计算机要花一些时间把程序代码写入到内存，之后，你使用软件就更加顺畅了。\n就像以前写Java的程序员，上班第一件事打开MyEclipse，然后直到下班才关闭。\n也像你忽悠产品经理，打开网站第一次会慢点，第二次就会飞快了。\n\n所以，当我们需要对一件事情「专注」的时候，我们需要花一些时间把所有的事务在脑子里过一遍，然后才能达到思维高峰以完成任务。\n\n如果不幸，你专注期间，产经忽如其来讨论需求，测试忽如其来报BUG，之后你还需要重新回想刚才做到哪里，重新花一些时间来形成「冲量」。就像计算机线程间来回切换所需要花费的成本。\n被打断的间隔越长，需要继续之前的任务所需要的成本也就越高。\n忽然想起个段子：「你跟产经讨论了一天，他的需求有了，你的代码呢？」\n\n## 思维体力\n我觉得进入专注所需要的「冲量」是可以通过锻炼来缩短的。\n也就是说每个人进入「专注」状态所需要的时间是不一样的，并且我们可以通过特定技巧和方法来锻炼，进而缩短进入「专注」所需要的成本。\n\n如果把这个过程比喻为「思维预热」，那么「思维体力」可以用来指的长期保持专注状态的能力。\n这个能力，因人而异，也因事而异。\n\n有些人能一下子专注几个小时，例如爱音乐的吉他手可以抱着吉他玩一下午直到腰酸背痛。\n有些人却只能一下子专注半小时，例如开个会议，直到听到老领导说「我再讲最后几句」。\n还有些人只能专注前面的十分钟，例如大部分学生，听老教授讲枯燥无味的课。(不排除趣味相投的学生听的津津有味)\n\n长时间的「专注」，容易让人思维疲劳。\n不同人对于不同的事情保持「专注」的时间也不一样。\n明白这样的道理，我们可以通过一些规则或者灵活的方法来让我们的思维可以在「休息」和「运行」的状态有序的切换。\n\n比如「番茄工作法」。\n番茄工作法的核心概念也很简单，可以总结成：\n> 一个标准番茄时间是25分钟(工作)，前后两个番茄时间的标准间隔时间是5分钟(休息)。\n把一个任务所需要完成的时间，细分到以番茄时间来做单位。\n番茄时间内强迫自己专注到当前任务中，休息时间可以用来处理需要处理的其他事务（回邮件，回短信等等）。\n以这种「工作」，「休息」的状态来回切换，达到高效率完成工作任务。\n\n## 单线程\n人的思维，就像一台「单核计算机」，同一个时间，你只能处理一个任务。\n我们所承担的多个任务都要「环境切换」的成本。\n当我们从一个任务切换到另外一个任务的时候，我们必须要唤醒某些记忆才可以重新开始工作。\n\n想必你也试过，一下子想完成多个事情，犹豫再三，决定从某一个任务开始着手，结果在执行这个任务的过程中，心理还想着其他的任务，以至于没有完全投入当前任务，大大降低效率。\n\n如果把「人脑」比作「CPU」，那么我们需要一些方法来进行「资源调度」，以及「任务管理」。\n让我们的大脑「明确目标」，专心处理当前任务，而不用去考虑其他没有完成的任务。\n\n# 如何保持专注\n\n明白了什么是「专注」，以及专注的克星「打断」。\n我们可以总结保持专注所需要解决的几个主要问题：\n1. 锻炼专注，缩短冲量的成本\n2. 减少干扰源，避免打断\n3. 注意休息，注意思维体力\n4. 学会管理任务，明确目标\n\n下面是，一些建议与安利。\n\n## 「番茄闹钟」类工具\n**[番茄土豆](https://pomotodo.com/)**\n我用了最久的一款集成了 GTD 应用，它集成了「番茄闹钟」和「任务管理」的功能。\n以下是这款产品做的很不错的几点：\n1. 支持多个客户端，囊括了iOS、Android、Mac、Windows以及网页端。\n2. 还支持「时间记录」的功能，一周下来，你可以看看时间都花在哪里了，效率如何。\n3. 支持任务打标签\n\n**此刻**\n一款iOS平台的单纯的「番茄闹钟」，别有任务管理，没有白噪音。只有单纯的「25分钟-5分钟」的循环。\n当我极简风的情绪来了，就会用这个APP。\n\n## 「白噪音」类应用\n**[潮汐](https://itunes.apple.com/cn/app/chao-xi-bao-chi-zhuan-zhu/id1077776989?mt=8)**\niOS平台独占，融合了「冥想」「白噪音」「番茄闹钟」的应用。\n也用过一段时间，是一款难得的优秀作品，只有五种白噪音，清新的界面，很适合调整心情，来装一会逼。\n\n![潮汐](/image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg)\n(注：界面太美，忍不住贴个图了)\n\n## 「一副耳机」 加 「一份后摇歌单」 再加 「一双普通的海绵耳塞」\n当我打开IDE或者文本编译器，准备专注的写几段代码的时候。\n发现戴上耳机，播放着一张「后摇」歌单，特别能让我专注的思考如何实现功能，编码的效率也提升不少。\n\n**一副耳机**\n这里我不需要讨论耳机的选购，每个人的爱好需求都不一样。选择你自己喜欢的就好。\n\n**一份后摇歌单**\n有些人把后摇看作摇滚乐的一种，虽在音乐界这个叫法有些争议，但我们不需要去管。\n后摇的一个特点是，所用乐器一般与摇滚乐相同，但节奏、和声、旋律、音色及和弦进行，都有别于传统摇滚。\n没有歌词，没有人声，打破传统歌曲长度，有些甚至长达二三十分钟。\n后摇给我的感觉，不像传统类似「班得瑞」那种「轻音乐」，它多了一丝激情，多了一份节奏感，更适合写代码。\n\n如果你不嫌弃的话，这里有一份不错的网易云音乐的歌单：[多巴胺作菜，后摇作酒](http://music.163.com/#/share/1337344/122993280)\n\n** 再额外推荐点，班得瑞十三张专辑 **\n如果你不喜欢「后摇」，想找一份不错的「轻音乐」歌单，可以试试[「班得瑞」](http://music.163.com/#/artist/album?id=88149)十三张专辑。\n班得瑞（Bandari）是瑞士音乐公司AG旗下的一个新纪元音乐项目。\n其作品以环境音乐、冥想音乐为主，主要以睡眠、减压为主要音乐功能。\n风格方面，班得瑞的音乐有许多改编自日本和欧美的新世纪音乐、凯尔特音乐、乡村音乐或老式情歌的乐曲。\n\n\n**一双普通的海绵耳塞**\n耳机戴多了，戴久了，是会严重影响听力的，并且是不可恢复的损伤。\n「白噪音」的方法并不能滥用，所以你的抗噪音能力较弱的话，可以去淘宝十几块钱买一副普通的海绵耳塞，戴上也可以隔离世界。但就是有点撑耳朵，一开始会不习惯。\n\n## 「GTD (Go To Do)」类工具\n\n**[Wunderlist](https://www.wunderlist.com)**\n中文叫「奇妙清单」，一款我从大学就用到现在的GTD应用，对比 Trello，Teambition，这款更适于个人使用。\n单纯的记录想做的事情，做完了就打钩，打钩的那一声清脆的「叮」还是百听不厌。\n一个账号通用Android、iOS、Mac、Windows、网页平台。\n\n**[Trello](https://trello.com/)**\n更适合团队协作的，「面板式」的任务管理工具。\n能把任务分为不同的状态，分配给不同的人，定义好时间。\n项目进度，个人进度一目了然。\n支持Web、iOS、Android三个平台\n\n**[Teambition](https://www.teambition.com/)**\n这也是一款在我大学和小伙伴做项目的就开始用的团队任务协作工具，是国内一家位于上海的优秀团队的产品。\n同样支持Web、iOS、Android三个平台。\n有企业版和免费两个版本，如果低于10个人合作的话，Teambition是一个不错的选择。\n\n## 「记录日志」类工具\n\n回顾和总结是一个好习惯。\n一天一小结，一周一大结，还有季度总结，年度总结。\n并不是写给谁看，而是写给自己看，记录自己的时间，知道时间花费去哪里了，有哪些产出，有哪些长进。\n无论你选择怎么样的生活方式，也不应该让不断流逝的时间走得不明不白，不清不楚。\n\n对我个人来说，记笔记最重要的是两点：\n1. 支持云同步\n2. 支持Markdown\n\n** [印象笔记](https://www.yinxiang.com/?from=evernote) 结合 [马克飞象](https://maxiang.io/) **\n很久以前我用「有道云笔记」，后来因为找不到支持 Markdown 的支持加上网易邮箱暴库的原因。就转到了「印象笔记」，然后结合着第三方开发者开发的「马克飞象」，来用 Markdown 语法写了一段时间的日志。\n总的体验还不错，但是这种方式还是显得有些笨拙，而且不支持其他客户端的编辑。\n直到遇到了「Day One」的限免。\n\n** [Day One](http://dayoneapp.com/) **\n又是一款iOS平台独占的优秀应用，对于苹果党来说绝对是强悍的日记应用。只要你手头上有ipad，或者iphone，或者macbook，随时拿起来写点什么。\n就是因为这种方便性，我在day ones写了有很多突发奇想的idea或者感悟或者感想，以及一些可以用来写作的主题。\n\n## 「思维导图」类工具\n\n1970年，英国的托尼·布詹提出了一种辅助思考的工具——思维导图。\n它是通过平面上一个主题发散出来相关联对象所形成的中心网状结构的图。\n由于这种表现方式比单纯的文本更加接近人类思考时的空间想象，越来越多人用于创造性思维过程中。\n而我用思维脑图来做的比较多的是：\n1. 项目设计、架构设计。\n2. 个人任务整理。\n3. 思考的时候用来记录思维过程。\n4. 做会议笔记、读书笔记。\n\n**[百度脑图](http://naotu.baidu.com/)**\n尽管最近的百度口碑都不好，但是无可厚非的是，百度下面的确有些产品是做的不错的，也不能一言蔽之。\n百度脑图算是一个，比较纯粹的操作方式，加上一个云同步的功能，已经足够大部分需求了。\n但是唯一让我还不满足的是，没有移动端的支持。\n又是直到 「MindNode」限免为止.....\n\n**[Mindnode](http://mindnode.com/)**\n如 DayOne ，Mindnode 是iOS独占的一款优秀应用，最重要可以三个客户端同步使用。\n嗯，如果你是个苹果党，也正好不差钱，Mindnode我认为是最好的解决方案。\n\n## 最后的一个建议，关注健康\n身体乃革命本钱，人类有区别与其他动物，就是能有反思自己思维的能力。\n我们以血肉之躯来到世上，在诸如科幻片中可以实现「思想数字化」之前，我们的思想和思维的运作，都要依赖于我们现在的身体。\n保养好我们的身体，可以让我们更好的完成更多的事情。\n所以，我们开始站立办公了，解决方案就是：[「39块的宜家拉克边桌」](http://www.ikea.com/cn/zh/catalog/products/00193664/)\n\n![站立办公](/image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg)\n\n\n# 最后再啰嗦一下，关于团队效率\n以上，都是讲述了如何提高个人的工作效率。\n但是，现实的人类生产工作，都是团队性的，我们寻求在能保证个人效率之外，还需最大兼容到团队的效率。\n\n这里有一篇文章很好地讲述了一些「团队效率」的观点，也基本符合我现在所在团队的价值观。\n[腾讯：管理研发大团队就像10人小分队](http://m.jiemian.com/article/800398.html)\n\n我的总结如下：\n1. 角色分明，各司其职\n2. 迭代流程，形成循环\n3. 需求透明，进度透明\n4. 线上数据，随手可得\n5. 沟通沉淀，形成归档\n\n然后我们也一直在思考如何提高团队的效率，也有辅助一些工具，由于边幅问题。\n改天另立文章，来安利一些不错的工具。\n\n# 总结\n本篇讲述了以下内容：\n1. 关于什么是专注，如何理解专注，以及如何达到专注。\n2. 要做到专注，需要解决的问题。\n3. 借助工具来解决这些问题，安利了一波。\n4. 简单提及了一下团队效率\n\n# 关于转载\n本文默认允许转载，但：\n1. 请务必注明出处：[BlueSun | 《程序员如何保证「专注」与「效率」》](http://huang-jerryc.com/2016/11/27/keep-focus-and-efficiency/)\n2. 如果你不介意，我希望转载的同时，可以得到一声告知。(Email：huangjerryc@gmail.com)\n\n感谢！","source":"_posts/keep-focus-and-efficiency.md","raw":"---\ntitle: 程序员如何保证「专注」与「效率」\ndate: 2016-11-27 13:08:00\ntags:\n- 效率\n- 专注\ncategory: 搬砖码农\n---\n\n多年前，家母常骂我容易沉迷，沉迷游戏，沉迷小说，沉迷电视剧，沉迷XXX。\n意思就是说，例如当我在玩游戏的时候，很难打断我，完全沉入进去了，叫吃饭都听不见。\n在我看来，「沉迷」与「专注」实质描述同一样事物的两个相反词义的词汇。\n用在主观认为正确的事情上，叫「专注」，专注读书，专注学习，专注搬砖写代码。\n用在主观认为不正确的事情上，叫「沉迷」，沉迷游戏，沉迷小说，沉迷肥皂电视剧。\n所以，小孩子千万别「沉迷」，像「沉迷网游」会被爱子心切的家长送去给杨教授进行电击治疗的哦。\n我们还是来谈谈可以提高生产率的「专注」。\n\n# 什么是专注\n简而言之，专注就是注意力分散的对立面。\n记得大学时候教我英语的老教授说过的一句，\n「知道为什么你们一直都学不好英语么，你们这一代人生活在一个太多诱惑的世界。」\n\n每一天，我们坐下来打开电脑，想做点什么正经事情的时候。\n却又无意中打开微博看看热搜榜，看看林丹出轨，宋冬野吸毒入狱，papi酱和逻辑思维闹分手。\n又会拿起手机刷刷朋友圈，看看小伙伴自拍照，旅游照，三姑六婆姨妈姑丈的心灵鸡汤。\n还会打开知乎，看看各种「如何评价XXX」，「XXX是什么样的体验」。\n\n就像吴晓波每周都会说的「世界如此喧嚣」。\n现代人生活在一个充满了干扰的世界，社交、邮件、电话、短信、走神、打断，纷至沓来。\n\n不知道你还记得最近一次解决真正的难题是什么时候吗？\n你可能是在试图修复一些BUG，或者要弄清楚为什么代码跑不动。\n时间飞逝，你忘了吃饭、喝水乃至睡觉，一门心思扑在你的任务上。\n你全身心的投入到单个项目上，如果任何人胆敢打扰你，你就会暴跳如雷。\n这就是「专注」。\n就像生活中许多事情一样，专注就像一个「冲量」的游戏，想要达到专注工作的状态很难，但是一旦进入专注状态，就能轻松的保持下去。\n\n## 冲量\n「冲量」是一个物理词汇\n> 冲量是作用在物体上的力在时间上的累积，一个随时间改变的力对一个物体的冲量指这个力的作用对时间的积累效果。\n\n我觉得用来形容人类思维从一个「注意力分散」的状态进入到「专注」状态的过程是再好不过的概念了。\n\n就像我们开车在高速公路上行驶时的提速过程，车在进入高速行驶之前需要更换几个档位，让车提到五档，需要点时间和油耗。一旦开到五档，那就能轻松巡航了。\n倘若你开在每隔一百米一个红绿灯的道路上，总是不断的起步停车，那么整体的速度会很慢，且油耗高，顺带还给「雾霾」增添多一分贡献。\n\n又像我们启动电脑程序，第一次打开程序往往需要较长的时间。因为计算机要花一些时间把程序代码写入到内存，之后，你使用软件就更加顺畅了。\n就像以前写Java的程序员，上班第一件事打开MyEclipse，然后直到下班才关闭。\n也像你忽悠产品经理，打开网站第一次会慢点，第二次就会飞快了。\n\n所以，当我们需要对一件事情「专注」的时候，我们需要花一些时间把所有的事务在脑子里过一遍，然后才能达到思维高峰以完成任务。\n\n如果不幸，你专注期间，产经忽如其来讨论需求，测试忽如其来报BUG，之后你还需要重新回想刚才做到哪里，重新花一些时间来形成「冲量」。就像计算机线程间来回切换所需要花费的成本。\n被打断的间隔越长，需要继续之前的任务所需要的成本也就越高。\n忽然想起个段子：「你跟产经讨论了一天，他的需求有了，你的代码呢？」\n\n## 思维体力\n我觉得进入专注所需要的「冲量」是可以通过锻炼来缩短的。\n也就是说每个人进入「专注」状态所需要的时间是不一样的，并且我们可以通过特定技巧和方法来锻炼，进而缩短进入「专注」所需要的成本。\n\n如果把这个过程比喻为「思维预热」，那么「思维体力」可以用来指的长期保持专注状态的能力。\n这个能力，因人而异，也因事而异。\n\n有些人能一下子专注几个小时，例如爱音乐的吉他手可以抱着吉他玩一下午直到腰酸背痛。\n有些人却只能一下子专注半小时，例如开个会议，直到听到老领导说「我再讲最后几句」。\n还有些人只能专注前面的十分钟，例如大部分学生，听老教授讲枯燥无味的课。(不排除趣味相投的学生听的津津有味)\n\n长时间的「专注」，容易让人思维疲劳。\n不同人对于不同的事情保持「专注」的时间也不一样。\n明白这样的道理，我们可以通过一些规则或者灵活的方法来让我们的思维可以在「休息」和「运行」的状态有序的切换。\n\n比如「番茄工作法」。\n番茄工作法的核心概念也很简单，可以总结成：\n> 一个标准番茄时间是25分钟(工作)，前后两个番茄时间的标准间隔时间是5分钟(休息)。\n把一个任务所需要完成的时间，细分到以番茄时间来做单位。\n番茄时间内强迫自己专注到当前任务中，休息时间可以用来处理需要处理的其他事务（回邮件，回短信等等）。\n以这种「工作」，「休息」的状态来回切换，达到高效率完成工作任务。\n\n## 单线程\n人的思维，就像一台「单核计算机」，同一个时间，你只能处理一个任务。\n我们所承担的多个任务都要「环境切换」的成本。\n当我们从一个任务切换到另外一个任务的时候，我们必须要唤醒某些记忆才可以重新开始工作。\n\n想必你也试过，一下子想完成多个事情，犹豫再三，决定从某一个任务开始着手，结果在执行这个任务的过程中，心理还想着其他的任务，以至于没有完全投入当前任务，大大降低效率。\n\n如果把「人脑」比作「CPU」，那么我们需要一些方法来进行「资源调度」，以及「任务管理」。\n让我们的大脑「明确目标」，专心处理当前任务，而不用去考虑其他没有完成的任务。\n\n# 如何保持专注\n\n明白了什么是「专注」，以及专注的克星「打断」。\n我们可以总结保持专注所需要解决的几个主要问题：\n1. 锻炼专注，缩短冲量的成本\n2. 减少干扰源，避免打断\n3. 注意休息，注意思维体力\n4. 学会管理任务，明确目标\n\n下面是，一些建议与安利。\n\n## 「番茄闹钟」类工具\n**[番茄土豆](https://pomotodo.com/)**\n我用了最久的一款集成了 GTD 应用，它集成了「番茄闹钟」和「任务管理」的功能。\n以下是这款产品做的很不错的几点：\n1. 支持多个客户端，囊括了iOS、Android、Mac、Windows以及网页端。\n2. 还支持「时间记录」的功能，一周下来，你可以看看时间都花在哪里了，效率如何。\n3. 支持任务打标签\n\n**此刻**\n一款iOS平台的单纯的「番茄闹钟」，别有任务管理，没有白噪音。只有单纯的「25分钟-5分钟」的循环。\n当我极简风的情绪来了，就会用这个APP。\n\n## 「白噪音」类应用\n**[潮汐](https://itunes.apple.com/cn/app/chao-xi-bao-chi-zhuan-zhu/id1077776989?mt=8)**\niOS平台独占，融合了「冥想」「白噪音」「番茄闹钟」的应用。\n也用过一段时间，是一款难得的优秀作品，只有五种白噪音，清新的界面，很适合调整心情，来装一会逼。\n\n![潮汐](/image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg)\n(注：界面太美，忍不住贴个图了)\n\n## 「一副耳机」 加 「一份后摇歌单」 再加 「一双普通的海绵耳塞」\n当我打开IDE或者文本编译器，准备专注的写几段代码的时候。\n发现戴上耳机，播放着一张「后摇」歌单，特别能让我专注的思考如何实现功能，编码的效率也提升不少。\n\n**一副耳机**\n这里我不需要讨论耳机的选购，每个人的爱好需求都不一样。选择你自己喜欢的就好。\n\n**一份后摇歌单**\n有些人把后摇看作摇滚乐的一种，虽在音乐界这个叫法有些争议，但我们不需要去管。\n后摇的一个特点是，所用乐器一般与摇滚乐相同，但节奏、和声、旋律、音色及和弦进行，都有别于传统摇滚。\n没有歌词，没有人声，打破传统歌曲长度，有些甚至长达二三十分钟。\n后摇给我的感觉，不像传统类似「班得瑞」那种「轻音乐」，它多了一丝激情，多了一份节奏感，更适合写代码。\n\n如果你不嫌弃的话，这里有一份不错的网易云音乐的歌单：[多巴胺作菜，后摇作酒](http://music.163.com/#/share/1337344/122993280)\n\n** 再额外推荐点，班得瑞十三张专辑 **\n如果你不喜欢「后摇」，想找一份不错的「轻音乐」歌单，可以试试[「班得瑞」](http://music.163.com/#/artist/album?id=88149)十三张专辑。\n班得瑞（Bandari）是瑞士音乐公司AG旗下的一个新纪元音乐项目。\n其作品以环境音乐、冥想音乐为主，主要以睡眠、减压为主要音乐功能。\n风格方面，班得瑞的音乐有许多改编自日本和欧美的新世纪音乐、凯尔特音乐、乡村音乐或老式情歌的乐曲。\n\n\n**一双普通的海绵耳塞**\n耳机戴多了，戴久了，是会严重影响听力的，并且是不可恢复的损伤。\n「白噪音」的方法并不能滥用，所以你的抗噪音能力较弱的话，可以去淘宝十几块钱买一副普通的海绵耳塞，戴上也可以隔离世界。但就是有点撑耳朵，一开始会不习惯。\n\n## 「GTD (Go To Do)」类工具\n\n**[Wunderlist](https://www.wunderlist.com)**\n中文叫「奇妙清单」，一款我从大学就用到现在的GTD应用，对比 Trello，Teambition，这款更适于个人使用。\n单纯的记录想做的事情，做完了就打钩，打钩的那一声清脆的「叮」还是百听不厌。\n一个账号通用Android、iOS、Mac、Windows、网页平台。\n\n**[Trello](https://trello.com/)**\n更适合团队协作的，「面板式」的任务管理工具。\n能把任务分为不同的状态，分配给不同的人，定义好时间。\n项目进度，个人进度一目了然。\n支持Web、iOS、Android三个平台\n\n**[Teambition](https://www.teambition.com/)**\n这也是一款在我大学和小伙伴做项目的就开始用的团队任务协作工具，是国内一家位于上海的优秀团队的产品。\n同样支持Web、iOS、Android三个平台。\n有企业版和免费两个版本，如果低于10个人合作的话，Teambition是一个不错的选择。\n\n## 「记录日志」类工具\n\n回顾和总结是一个好习惯。\n一天一小结，一周一大结，还有季度总结，年度总结。\n并不是写给谁看，而是写给自己看，记录自己的时间，知道时间花费去哪里了，有哪些产出，有哪些长进。\n无论你选择怎么样的生活方式，也不应该让不断流逝的时间走得不明不白，不清不楚。\n\n对我个人来说，记笔记最重要的是两点：\n1. 支持云同步\n2. 支持Markdown\n\n** [印象笔记](https://www.yinxiang.com/?from=evernote) 结合 [马克飞象](https://maxiang.io/) **\n很久以前我用「有道云笔记」，后来因为找不到支持 Markdown 的支持加上网易邮箱暴库的原因。就转到了「印象笔记」，然后结合着第三方开发者开发的「马克飞象」，来用 Markdown 语法写了一段时间的日志。\n总的体验还不错，但是这种方式还是显得有些笨拙，而且不支持其他客户端的编辑。\n直到遇到了「Day One」的限免。\n\n** [Day One](http://dayoneapp.com/) **\n又是一款iOS平台独占的优秀应用，对于苹果党来说绝对是强悍的日记应用。只要你手头上有ipad，或者iphone，或者macbook，随时拿起来写点什么。\n就是因为这种方便性，我在day ones写了有很多突发奇想的idea或者感悟或者感想，以及一些可以用来写作的主题。\n\n## 「思维导图」类工具\n\n1970年，英国的托尼·布詹提出了一种辅助思考的工具——思维导图。\n它是通过平面上一个主题发散出来相关联对象所形成的中心网状结构的图。\n由于这种表现方式比单纯的文本更加接近人类思考时的空间想象，越来越多人用于创造性思维过程中。\n而我用思维脑图来做的比较多的是：\n1. 项目设计、架构设计。\n2. 个人任务整理。\n3. 思考的时候用来记录思维过程。\n4. 做会议笔记、读书笔记。\n\n**[百度脑图](http://naotu.baidu.com/)**\n尽管最近的百度口碑都不好，但是无可厚非的是，百度下面的确有些产品是做的不错的，也不能一言蔽之。\n百度脑图算是一个，比较纯粹的操作方式，加上一个云同步的功能，已经足够大部分需求了。\n但是唯一让我还不满足的是，没有移动端的支持。\n又是直到 「MindNode」限免为止.....\n\n**[Mindnode](http://mindnode.com/)**\n如 DayOne ，Mindnode 是iOS独占的一款优秀应用，最重要可以三个客户端同步使用。\n嗯，如果你是个苹果党，也正好不差钱，Mindnode我认为是最好的解决方案。\n\n## 最后的一个建议，关注健康\n身体乃革命本钱，人类有区别与其他动物，就是能有反思自己思维的能力。\n我们以血肉之躯来到世上，在诸如科幻片中可以实现「思想数字化」之前，我们的思想和思维的运作，都要依赖于我们现在的身体。\n保养好我们的身体，可以让我们更好的完成更多的事情。\n所以，我们开始站立办公了，解决方案就是：[「39块的宜家拉克边桌」](http://www.ikea.com/cn/zh/catalog/products/00193664/)\n\n![站立办公](/image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg)\n\n\n# 最后再啰嗦一下，关于团队效率\n以上，都是讲述了如何提高个人的工作效率。\n但是，现实的人类生产工作，都是团队性的，我们寻求在能保证个人效率之外，还需最大兼容到团队的效率。\n\n这里有一篇文章很好地讲述了一些「团队效率」的观点，也基本符合我现在所在团队的价值观。\n[腾讯：管理研发大团队就像10人小分队](http://m.jiemian.com/article/800398.html)\n\n我的总结如下：\n1. 角色分明，各司其职\n2. 迭代流程，形成循环\n3. 需求透明，进度透明\n4. 线上数据，随手可得\n5. 沟通沉淀，形成归档\n\n然后我们也一直在思考如何提高团队的效率，也有辅助一些工具，由于边幅问题。\n改天另立文章，来安利一些不错的工具。\n\n# 总结\n本篇讲述了以下内容：\n1. 关于什么是专注，如何理解专注，以及如何达到专注。\n2. 要做到专注，需要解决的问题。\n3. 借助工具来解决这些问题，安利了一波。\n4. 简单提及了一下团队效率\n\n# 关于转载\n本文默认允许转载，但：\n1. 请务必注明出处：[BlueSun | 《程序员如何保证「专注」与「效率」》](http://huang-jerryc.com/2016/11/27/keep-focus-and-efficiency/)\n2. 如果你不介意，我希望转载的同时，可以得到一声告知。(Email：huangjerryc@gmail.com)\n\n感谢！","slug":"keep-focus-and-efficiency","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8t90055xwrlkb32rqoo","comments":1,"layout":"post","photos":[],"link":"","content":"<p>多年前，家母常骂我容易沉迷，沉迷游戏，沉迷小说，沉迷电视剧，沉迷XXX。<br>意思就是说，例如当我在玩游戏的时候，很难打断我，完全沉入进去了，叫吃饭都听不见。<br>在我看来，「沉迷」与「专注」实质描述同一样事物的两个相反词义的词汇。<br>用在主观认为正确的事情上，叫「专注」，专注读书，专注学习，专注搬砖写代码。<br>用在主观认为不正确的事情上，叫「沉迷」，沉迷游戏，沉迷小说，沉迷肥皂电视剧。<br>所以，小孩子千万别「沉迷」，像「沉迷网游」会被爱子心切的家长送去给杨教授进行电击治疗的哦。<br>我们还是来谈谈可以提高生产率的「专注」。</p>\n<h1 id=\"什么是专注\"><a href=\"#什么是专注\" class=\"headerlink\" title=\"什么是专注\"></a>什么是专注</h1><p>简而言之，专注就是注意力分散的对立面。<br>记得大学时候教我英语的老教授说过的一句，<br>「知道为什么你们一直都学不好英语么，你们这一代人生活在一个太多诱惑的世界。」</p>\n<p>每一天，我们坐下来打开电脑，想做点什么正经事情的时候。<br>却又无意中打开微博看看热搜榜，看看林丹出轨，宋冬野吸毒入狱，papi酱和逻辑思维闹分手。<br>又会拿起手机刷刷朋友圈，看看小伙伴自拍照，旅游照，三姑六婆姨妈姑丈的心灵鸡汤。<br>还会打开知乎，看看各种「如何评价XXX」，「XXX是什么样的体验」。</p>\n<p>就像吴晓波每周都会说的「世界如此喧嚣」。<br>现代人生活在一个充满了干扰的世界，社交、邮件、电话、短信、走神、打断，纷至沓来。</p>\n<p>不知道你还记得最近一次解决真正的难题是什么时候吗？<br>你可能是在试图修复一些BUG，或者要弄清楚为什么代码跑不动。<br>时间飞逝，你忘了吃饭、喝水乃至睡觉，一门心思扑在你的任务上。<br>你全身心的投入到单个项目上，如果任何人胆敢打扰你，你就会暴跳如雷。<br>这就是「专注」。<br>就像生活中许多事情一样，专注就像一个「冲量」的游戏，想要达到专注工作的状态很难，但是一旦进入专注状态，就能轻松的保持下去。</p>\n<h2 id=\"冲量\"><a href=\"#冲量\" class=\"headerlink\" title=\"冲量\"></a>冲量</h2><p>「冲量」是一个物理词汇</p>\n<blockquote>\n<p>冲量是作用在物体上的力在时间上的累积，一个随时间改变的力对一个物体的冲量指这个力的作用对时间的积累效果。</p>\n</blockquote>\n<p>我觉得用来形容人类思维从一个「注意力分散」的状态进入到「专注」状态的过程是再好不过的概念了。</p>\n<p>就像我们开车在高速公路上行驶时的提速过程，车在进入高速行驶之前需要更换几个档位，让车提到五档，需要点时间和油耗。一旦开到五档，那就能轻松巡航了。<br>倘若你开在每隔一百米一个红绿灯的道路上，总是不断的起步停车，那么整体的速度会很慢，且油耗高，顺带还给「雾霾」增添多一分贡献。</p>\n<p>又像我们启动电脑程序，第一次打开程序往往需要较长的时间。因为计算机要花一些时间把程序代码写入到内存，之后，你使用软件就更加顺畅了。<br>就像以前写Java的程序员，上班第一件事打开MyEclipse，然后直到下班才关闭。<br>也像你忽悠产品经理，打开网站第一次会慢点，第二次就会飞快了。</p>\n<p>所以，当我们需要对一件事情「专注」的时候，我们需要花一些时间把所有的事务在脑子里过一遍，然后才能达到思维高峰以完成任务。</p>\n<p>如果不幸，你专注期间，产经忽如其来讨论需求，测试忽如其来报BUG，之后你还需要重新回想刚才做到哪里，重新花一些时间来形成「冲量」。就像计算机线程间来回切换所需要花费的成本。<br>被打断的间隔越长，需要继续之前的任务所需要的成本也就越高。<br>忽然想起个段子：「你跟产经讨论了一天，他的需求有了，你的代码呢？」</p>\n<h2 id=\"思维体力\"><a href=\"#思维体力\" class=\"headerlink\" title=\"思维体力\"></a>思维体力</h2><p>我觉得进入专注所需要的「冲量」是可以通过锻炼来缩短的。<br>也就是说每个人进入「专注」状态所需要的时间是不一样的，并且我们可以通过特定技巧和方法来锻炼，进而缩短进入「专注」所需要的成本。</p>\n<p>如果把这个过程比喻为「思维预热」，那么「思维体力」可以用来指的长期保持专注状态的能力。<br>这个能力，因人而异，也因事而异。</p>\n<p>有些人能一下子专注几个小时，例如爱音乐的吉他手可以抱着吉他玩一下午直到腰酸背痛。<br>有些人却只能一下子专注半小时，例如开个会议，直到听到老领导说「我再讲最后几句」。<br>还有些人只能专注前面的十分钟，例如大部分学生，听老教授讲枯燥无味的课。(不排除趣味相投的学生听的津津有味)</p>\n<p>长时间的「专注」，容易让人思维疲劳。<br>不同人对于不同的事情保持「专注」的时间也不一样。<br>明白这样的道理，我们可以通过一些规则或者灵活的方法来让我们的思维可以在「休息」和「运行」的状态有序的切换。</p>\n<p>比如「番茄工作法」。<br>番茄工作法的核心概念也很简单，可以总结成：</p>\n<blockquote>\n<p>一个标准番茄时间是25分钟(工作)，前后两个番茄时间的标准间隔时间是5分钟(休息)。<br>把一个任务所需要完成的时间，细分到以番茄时间来做单位。<br>番茄时间内强迫自己专注到当前任务中，休息时间可以用来处理需要处理的其他事务（回邮件，回短信等等）。<br>以这种「工作」，「休息」的状态来回切换，达到高效率完成工作任务。</p>\n</blockquote>\n<h2 id=\"单线程\"><a href=\"#单线程\" class=\"headerlink\" title=\"单线程\"></a>单线程</h2><p>人的思维，就像一台「单核计算机」，同一个时间，你只能处理一个任务。<br>我们所承担的多个任务都要「环境切换」的成本。<br>当我们从一个任务切换到另外一个任务的时候，我们必须要唤醒某些记忆才可以重新开始工作。</p>\n<p>想必你也试过，一下子想完成多个事情，犹豫再三，决定从某一个任务开始着手，结果在执行这个任务的过程中，心理还想着其他的任务，以至于没有完全投入当前任务，大大降低效率。</p>\n<p>如果把「人脑」比作「CPU」，那么我们需要一些方法来进行「资源调度」，以及「任务管理」。<br>让我们的大脑「明确目标」，专心处理当前任务，而不用去考虑其他没有完成的任务。</p>\n<h1 id=\"如何保持专注\"><a href=\"#如何保持专注\" class=\"headerlink\" title=\"如何保持专注\"></a>如何保持专注</h1><p>明白了什么是「专注」，以及专注的克星「打断」。<br>我们可以总结保持专注所需要解决的几个主要问题：</p>\n<ol>\n<li>锻炼专注，缩短冲量的成本</li>\n<li>减少干扰源，避免打断</li>\n<li>注意休息，注意思维体力</li>\n<li>学会管理任务，明确目标</li>\n</ol>\n<p>下面是，一些建议与安利。</p>\n<h2 id=\"「番茄闹钟」类工具\"><a href=\"#「番茄闹钟」类工具\" class=\"headerlink\" title=\"「番茄闹钟」类工具\"></a>「番茄闹钟」类工具</h2><p><strong><a href=\"https://pomotodo.com/\" target=\"_blank\" rel=\"external\">番茄土豆</a></strong><br>我用了最久的一款集成了 GTD 应用，它集成了「番茄闹钟」和「任务管理」的功能。<br>以下是这款产品做的很不错的几点：</p>\n<ol>\n<li>支持多个客户端，囊括了iOS、Android、Mac、Windows以及网页端。</li>\n<li>还支持「时间记录」的功能，一周下来，你可以看看时间都花在哪里了，效率如何。</li>\n<li>支持任务打标签</li>\n</ol>\n<p><strong>此刻</strong><br>一款iOS平台的单纯的「番茄闹钟」，别有任务管理，没有白噪音。只有单纯的「25分钟-5分钟」的循环。<br>当我极简风的情绪来了，就会用这个APP。</p>\n<h2 id=\"「白噪音」类应用\"><a href=\"#「白噪音」类应用\" class=\"headerlink\" title=\"「白噪音」类应用\"></a>「白噪音」类应用</h2><p><strong><a href=\"https://itunes.apple.com/cn/app/chao-xi-bao-chi-zhuan-zhu/id1077776989?mt=8\" target=\"_blank\" rel=\"external\">潮汐</a></strong><br>iOS平台独占，融合了「冥想」「白噪音」「番茄闹钟」的应用。<br>也用过一段时间，是一款难得的优秀作品，只有五种白噪音，清新的界面，很适合调整心情，来装一会逼。</p>\n<p><img src=\"/image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg\" alt=\"潮汐\"><br>(注：界面太美，忍不住贴个图了)</p>\n<h2 id=\"「一副耳机」-加-「一份后摇歌单」-再加-「一双普通的海绵耳塞」\"><a href=\"#「一副耳机」-加-「一份后摇歌单」-再加-「一双普通的海绵耳塞」\" class=\"headerlink\" title=\"「一副耳机」 加 「一份后摇歌单」 再加 「一双普通的海绵耳塞」\"></a>「一副耳机」 加 「一份后摇歌单」 再加 「一双普通的海绵耳塞」</h2><p>当我打开IDE或者文本编译器，准备专注的写几段代码的时候。<br>发现戴上耳机，播放着一张「后摇」歌单，特别能让我专注的思考如何实现功能，编码的效率也提升不少。</p>\n<p><strong>一副耳机</strong><br>这里我不需要讨论耳机的选购，每个人的爱好需求都不一样。选择你自己喜欢的就好。</p>\n<p><strong>一份后摇歌单</strong><br>有些人把后摇看作摇滚乐的一种，虽在音乐界这个叫法有些争议，但我们不需要去管。<br>后摇的一个特点是，所用乐器一般与摇滚乐相同，但节奏、和声、旋律、音色及和弦进行，都有别于传统摇滚。<br>没有歌词，没有人声，打破传统歌曲长度，有些甚至长达二三十分钟。<br>后摇给我的感觉，不像传统类似「班得瑞」那种「轻音乐」，它多了一丝激情，多了一份节奏感，更适合写代码。</p>\n<p>如果你不嫌弃的话，这里有一份不错的网易云音乐的歌单：<a href=\"http://music.163.com/#/share/1337344/122993280\" target=\"_blank\" rel=\"external\">多巴胺作菜，后摇作酒</a></p>\n<p><strong> 再额外推荐点，班得瑞十三张专辑 </strong><br>如果你不喜欢「后摇」，想找一份不错的「轻音乐」歌单，可以试试<a href=\"http://music.163.com/#/artist/album?id=88149\" target=\"_blank\" rel=\"external\">「班得瑞」</a>十三张专辑。<br>班得瑞（Bandari）是瑞士音乐公司AG旗下的一个新纪元音乐项目。<br>其作品以环境音乐、冥想音乐为主，主要以睡眠、减压为主要音乐功能。<br>风格方面，班得瑞的音乐有许多改编自日本和欧美的新世纪音乐、凯尔特音乐、乡村音乐或老式情歌的乐曲。</p>\n<p><strong>一双普通的海绵耳塞</strong><br>耳机戴多了，戴久了，是会严重影响听力的，并且是不可恢复的损伤。<br>「白噪音」的方法并不能滥用，所以你的抗噪音能力较弱的话，可以去淘宝十几块钱买一副普通的海绵耳塞，戴上也可以隔离世界。但就是有点撑耳朵，一开始会不习惯。</p>\n<h2 id=\"「GTD-Go-To-Do-」类工具\"><a href=\"#「GTD-Go-To-Do-」类工具\" class=\"headerlink\" title=\"「GTD (Go To Do)」类工具\"></a>「GTD (Go To Do)」类工具</h2><p><strong><a href=\"https://www.wunderlist.com\" target=\"_blank\" rel=\"external\">Wunderlist</a></strong><br>中文叫「奇妙清单」，一款我从大学就用到现在的GTD应用，对比 Trello，Teambition，这款更适于个人使用。<br>单纯的记录想做的事情，做完了就打钩，打钩的那一声清脆的「叮」还是百听不厌。<br>一个账号通用Android、iOS、Mac、Windows、网页平台。</p>\n<p><strong><a href=\"https://trello.com/\" target=\"_blank\" rel=\"external\">Trello</a></strong><br>更适合团队协作的，「面板式」的任务管理工具。<br>能把任务分为不同的状态，分配给不同的人，定义好时间。<br>项目进度，个人进度一目了然。<br>支持Web、iOS、Android三个平台</p>\n<p><strong><a href=\"https://www.teambition.com/\" target=\"_blank\" rel=\"external\">Teambition</a></strong><br>这也是一款在我大学和小伙伴做项目的就开始用的团队任务协作工具，是国内一家位于上海的优秀团队的产品。<br>同样支持Web、iOS、Android三个平台。<br>有企业版和免费两个版本，如果低于10个人合作的话，Teambition是一个不错的选择。</p>\n<h2 id=\"「记录日志」类工具\"><a href=\"#「记录日志」类工具\" class=\"headerlink\" title=\"「记录日志」类工具\"></a>「记录日志」类工具</h2><p>回顾和总结是一个好习惯。<br>一天一小结，一周一大结，还有季度总结，年度总结。<br>并不是写给谁看，而是写给自己看，记录自己的时间，知道时间花费去哪里了，有哪些产出，有哪些长进。<br>无论你选择怎么样的生活方式，也不应该让不断流逝的时间走得不明不白，不清不楚。</p>\n<p>对我个人来说，记笔记最重要的是两点：</p>\n<ol>\n<li>支持云同步</li>\n<li>支持Markdown</li>\n</ol>\n<p><strong> <a href=\"https://www.yinxiang.com/?from=evernote\" target=\"_blank\" rel=\"external\">印象笔记</a> 结合 <a href=\"https://maxiang.io/\" target=\"_blank\" rel=\"external\">马克飞象</a> </strong><br>很久以前我用「有道云笔记」，后来因为找不到支持 Markdown 的支持加上网易邮箱暴库的原因。就转到了「印象笔记」，然后结合着第三方开发者开发的「马克飞象」，来用 Markdown 语法写了一段时间的日志。<br>总的体验还不错，但是这种方式还是显得有些笨拙，而且不支持其他客户端的编辑。<br>直到遇到了「Day One」的限免。</p>\n<p><strong> <a href=\"http://dayoneapp.com/\" target=\"_blank\" rel=\"external\">Day One</a> </strong><br>又是一款iOS平台独占的优秀应用，对于苹果党来说绝对是强悍的日记应用。只要你手头上有ipad，或者iphone，或者macbook，随时拿起来写点什么。<br>就是因为这种方便性，我在day ones写了有很多突发奇想的idea或者感悟或者感想，以及一些可以用来写作的主题。</p>\n<h2 id=\"「思维导图」类工具\"><a href=\"#「思维导图」类工具\" class=\"headerlink\" title=\"「思维导图」类工具\"></a>「思维导图」类工具</h2><p>1970年，英国的托尼·布詹提出了一种辅助思考的工具——思维导图。<br>它是通过平面上一个主题发散出来相关联对象所形成的中心网状结构的图。<br>由于这种表现方式比单纯的文本更加接近人类思考时的空间想象，越来越多人用于创造性思维过程中。<br>而我用思维脑图来做的比较多的是：</p>\n<ol>\n<li>项目设计、架构设计。</li>\n<li>个人任务整理。</li>\n<li>思考的时候用来记录思维过程。</li>\n<li>做会议笔记、读书笔记。</li>\n</ol>\n<p><strong><a href=\"http://naotu.baidu.com/\" target=\"_blank\" rel=\"external\">百度脑图</a></strong><br>尽管最近的百度口碑都不好，但是无可厚非的是，百度下面的确有些产品是做的不错的，也不能一言蔽之。<br>百度脑图算是一个，比较纯粹的操作方式，加上一个云同步的功能，已经足够大部分需求了。<br>但是唯一让我还不满足的是，没有移动端的支持。<br>又是直到 「MindNode」限免为止…..</p>\n<p><strong><a href=\"http://mindnode.com/\" target=\"_blank\" rel=\"external\">Mindnode</a></strong><br>如 DayOne ，Mindnode 是iOS独占的一款优秀应用，最重要可以三个客户端同步使用。<br>嗯，如果你是个苹果党，也正好不差钱，Mindnode我认为是最好的解决方案。</p>\n<h2 id=\"最后的一个建议，关注健康\"><a href=\"#最后的一个建议，关注健康\" class=\"headerlink\" title=\"最后的一个建议，关注健康\"></a>最后的一个建议，关注健康</h2><p>身体乃革命本钱，人类有区别与其他动物，就是能有反思自己思维的能力。<br>我们以血肉之躯来到世上，在诸如科幻片中可以实现「思想数字化」之前，我们的思想和思维的运作，都要依赖于我们现在的身体。<br>保养好我们的身体，可以让我们更好的完成更多的事情。<br>所以，我们开始站立办公了，解决方案就是：<a href=\"http://www.ikea.com/cn/zh/catalog/products/00193664/\" target=\"_blank\" rel=\"external\">「39块的宜家拉克边桌」</a></p>\n<p><img src=\"/image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg\" alt=\"站立办公\"></p>\n<h1 id=\"最后再啰嗦一下，关于团队效率\"><a href=\"#最后再啰嗦一下，关于团队效率\" class=\"headerlink\" title=\"最后再啰嗦一下，关于团队效率\"></a>最后再啰嗦一下，关于团队效率</h1><p>以上，都是讲述了如何提高个人的工作效率。<br>但是，现实的人类生产工作，都是团队性的，我们寻求在能保证个人效率之外，还需最大兼容到团队的效率。</p>\n<p>这里有一篇文章很好地讲述了一些「团队效率」的观点，也基本符合我现在所在团队的价值观。<br><a href=\"http://m.jiemian.com/article/800398.html\" target=\"_blank\" rel=\"external\">腾讯：管理研发大团队就像10人小分队</a></p>\n<p>我的总结如下：</p>\n<ol>\n<li>角色分明，各司其职</li>\n<li>迭代流程，形成循环</li>\n<li>需求透明，进度透明</li>\n<li>线上数据，随手可得</li>\n<li>沟通沉淀，形成归档</li>\n</ol>\n<p>然后我们也一直在思考如何提高团队的效率，也有辅助一些工具，由于边幅问题。<br>改天另立文章，来安利一些不错的工具。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本篇讲述了以下内容：</p>\n<ol>\n<li>关于什么是专注，如何理解专注，以及如何达到专注。</li>\n<li>要做到专注，需要解决的问题。</li>\n<li>借助工具来解决这些问题，安利了一波。</li>\n<li>简单提及了一下团队效率</li>\n</ol>\n<h1 id=\"关于转载\"><a href=\"#关于转载\" class=\"headerlink\" title=\"关于转载\"></a>关于转载</h1><p>本文默认允许转载，但：</p>\n<ol>\n<li>请务必注明出处：<a href=\"http://huang-jerryc.com/2016/11/27/keep-focus-and-efficiency/\">BlueSun | 《程序员如何保证「专注」与「效率」》</a></li>\n<li>如果你不介意，我希望转载的同时，可以得到一声告知。(Email：<a href=\"mailto:huangjerryc@gmail.com\" target=\"_blank\" rel=\"external\">huangjerryc@gmail.com</a>)</li>\n</ol>\n<p>感谢！</p>\n","excerpt":"","more":"<p>多年前，家母常骂我容易沉迷，沉迷游戏，沉迷小说，沉迷电视剧，沉迷XXX。<br>意思就是说，例如当我在玩游戏的时候，很难打断我，完全沉入进去了，叫吃饭都听不见。<br>在我看来，「沉迷」与「专注」实质描述同一样事物的两个相反词义的词汇。<br>用在主观认为正确的事情上，叫「专注」，专注读书，专注学习，专注搬砖写代码。<br>用在主观认为不正确的事情上，叫「沉迷」，沉迷游戏，沉迷小说，沉迷肥皂电视剧。<br>所以，小孩子千万别「沉迷」，像「沉迷网游」会被爱子心切的家长送去给杨教授进行电击治疗的哦。<br>我们还是来谈谈可以提高生产率的「专注」。</p>\n<h1 id=\"什么是专注\"><a href=\"#什么是专注\" class=\"headerlink\" title=\"什么是专注\"></a>什么是专注</h1><p>简而言之，专注就是注意力分散的对立面。<br>记得大学时候教我英语的老教授说过的一句，<br>「知道为什么你们一直都学不好英语么，你们这一代人生活在一个太多诱惑的世界。」</p>\n<p>每一天，我们坐下来打开电脑，想做点什么正经事情的时候。<br>却又无意中打开微博看看热搜榜，看看林丹出轨，宋冬野吸毒入狱，papi酱和逻辑思维闹分手。<br>又会拿起手机刷刷朋友圈，看看小伙伴自拍照，旅游照，三姑六婆姨妈姑丈的心灵鸡汤。<br>还会打开知乎，看看各种「如何评价XXX」，「XXX是什么样的体验」。</p>\n<p>就像吴晓波每周都会说的「世界如此喧嚣」。<br>现代人生活在一个充满了干扰的世界，社交、邮件、电话、短信、走神、打断，纷至沓来。</p>\n<p>不知道你还记得最近一次解决真正的难题是什么时候吗？<br>你可能是在试图修复一些BUG，或者要弄清楚为什么代码跑不动。<br>时间飞逝，你忘了吃饭、喝水乃至睡觉，一门心思扑在你的任务上。<br>你全身心的投入到单个项目上，如果任何人胆敢打扰你，你就会暴跳如雷。<br>这就是「专注」。<br>就像生活中许多事情一样，专注就像一个「冲量」的游戏，想要达到专注工作的状态很难，但是一旦进入专注状态，就能轻松的保持下去。</p>\n<h2 id=\"冲量\"><a href=\"#冲量\" class=\"headerlink\" title=\"冲量\"></a>冲量</h2><p>「冲量」是一个物理词汇</p>\n<blockquote>\n<p>冲量是作用在物体上的力在时间上的累积，一个随时间改变的力对一个物体的冲量指这个力的作用对时间的积累效果。</p>\n</blockquote>\n<p>我觉得用来形容人类思维从一个「注意力分散」的状态进入到「专注」状态的过程是再好不过的概念了。</p>\n<p>就像我们开车在高速公路上行驶时的提速过程，车在进入高速行驶之前需要更换几个档位，让车提到五档，需要点时间和油耗。一旦开到五档，那就能轻松巡航了。<br>倘若你开在每隔一百米一个红绿灯的道路上，总是不断的起步停车，那么整体的速度会很慢，且油耗高，顺带还给「雾霾」增添多一分贡献。</p>\n<p>又像我们启动电脑程序，第一次打开程序往往需要较长的时间。因为计算机要花一些时间把程序代码写入到内存，之后，你使用软件就更加顺畅了。<br>就像以前写Java的程序员，上班第一件事打开MyEclipse，然后直到下班才关闭。<br>也像你忽悠产品经理，打开网站第一次会慢点，第二次就会飞快了。</p>\n<p>所以，当我们需要对一件事情「专注」的时候，我们需要花一些时间把所有的事务在脑子里过一遍，然后才能达到思维高峰以完成任务。</p>\n<p>如果不幸，你专注期间，产经忽如其来讨论需求，测试忽如其来报BUG，之后你还需要重新回想刚才做到哪里，重新花一些时间来形成「冲量」。就像计算机线程间来回切换所需要花费的成本。<br>被打断的间隔越长，需要继续之前的任务所需要的成本也就越高。<br>忽然想起个段子：「你跟产经讨论了一天，他的需求有了，你的代码呢？」</p>\n<h2 id=\"思维体力\"><a href=\"#思维体力\" class=\"headerlink\" title=\"思维体力\"></a>思维体力</h2><p>我觉得进入专注所需要的「冲量」是可以通过锻炼来缩短的。<br>也就是说每个人进入「专注」状态所需要的时间是不一样的，并且我们可以通过特定技巧和方法来锻炼，进而缩短进入「专注」所需要的成本。</p>\n<p>如果把这个过程比喻为「思维预热」，那么「思维体力」可以用来指的长期保持专注状态的能力。<br>这个能力，因人而异，也因事而异。</p>\n<p>有些人能一下子专注几个小时，例如爱音乐的吉他手可以抱着吉他玩一下午直到腰酸背痛。<br>有些人却只能一下子专注半小时，例如开个会议，直到听到老领导说「我再讲最后几句」。<br>还有些人只能专注前面的十分钟，例如大部分学生，听老教授讲枯燥无味的课。(不排除趣味相投的学生听的津津有味)</p>\n<p>长时间的「专注」，容易让人思维疲劳。<br>不同人对于不同的事情保持「专注」的时间也不一样。<br>明白这样的道理，我们可以通过一些规则或者灵活的方法来让我们的思维可以在「休息」和「运行」的状态有序的切换。</p>\n<p>比如「番茄工作法」。<br>番茄工作法的核心概念也很简单，可以总结成：</p>\n<blockquote>\n<p>一个标准番茄时间是25分钟(工作)，前后两个番茄时间的标准间隔时间是5分钟(休息)。<br>把一个任务所需要完成的时间，细分到以番茄时间来做单位。<br>番茄时间内强迫自己专注到当前任务中，休息时间可以用来处理需要处理的其他事务（回邮件，回短信等等）。<br>以这种「工作」，「休息」的状态来回切换，达到高效率完成工作任务。</p>\n</blockquote>\n<h2 id=\"单线程\"><a href=\"#单线程\" class=\"headerlink\" title=\"单线程\"></a>单线程</h2><p>人的思维，就像一台「单核计算机」，同一个时间，你只能处理一个任务。<br>我们所承担的多个任务都要「环境切换」的成本。<br>当我们从一个任务切换到另外一个任务的时候，我们必须要唤醒某些记忆才可以重新开始工作。</p>\n<p>想必你也试过，一下子想完成多个事情，犹豫再三，决定从某一个任务开始着手，结果在执行这个任务的过程中，心理还想着其他的任务，以至于没有完全投入当前任务，大大降低效率。</p>\n<p>如果把「人脑」比作「CPU」，那么我们需要一些方法来进行「资源调度」，以及「任务管理」。<br>让我们的大脑「明确目标」，专心处理当前任务，而不用去考虑其他没有完成的任务。</p>\n<h1 id=\"如何保持专注\"><a href=\"#如何保持专注\" class=\"headerlink\" title=\"如何保持专注\"></a>如何保持专注</h1><p>明白了什么是「专注」，以及专注的克星「打断」。<br>我们可以总结保持专注所需要解决的几个主要问题：</p>\n<ol>\n<li>锻炼专注，缩短冲量的成本</li>\n<li>减少干扰源，避免打断</li>\n<li>注意休息，注意思维体力</li>\n<li>学会管理任务，明确目标</li>\n</ol>\n<p>下面是，一些建议与安利。</p>\n<h2 id=\"「番茄闹钟」类工具\"><a href=\"#「番茄闹钟」类工具\" class=\"headerlink\" title=\"「番茄闹钟」类工具\"></a>「番茄闹钟」类工具</h2><p><strong><a href=\"https://pomotodo.com/\">番茄土豆</a></strong><br>我用了最久的一款集成了 GTD 应用，它集成了「番茄闹钟」和「任务管理」的功能。<br>以下是这款产品做的很不错的几点：</p>\n<ol>\n<li>支持多个客户端，囊括了iOS、Android、Mac、Windows以及网页端。</li>\n<li>还支持「时间记录」的功能，一周下来，你可以看看时间都花在哪里了，效率如何。</li>\n<li>支持任务打标签</li>\n</ol>\n<p><strong>此刻</strong><br>一款iOS平台的单纯的「番茄闹钟」，别有任务管理，没有白噪音。只有单纯的「25分钟-5分钟」的循环。<br>当我极简风的情绪来了，就会用这个APP。</p>\n<h2 id=\"「白噪音」类应用\"><a href=\"#「白噪音」类应用\" class=\"headerlink\" title=\"「白噪音」类应用\"></a>「白噪音」类应用</h2><p><strong><a href=\"https://itunes.apple.com/cn/app/chao-xi-bao-chi-zhuan-zhu/id1077776989?mt=8\">潮汐</a></strong><br>iOS平台独占，融合了「冥想」「白噪音」「番茄闹钟」的应用。<br>也用过一段时间，是一款难得的优秀作品，只有五种白噪音，清新的界面，很适合调整心情，来装一会逼。</p>\n<p><img src=\"/image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg\" alt=\"潮汐\"><br>(注：界面太美，忍不住贴个图了)</p>\n<h2 id=\"「一副耳机」-加-「一份后摇歌单」-再加-「一双普通的海绵耳塞」\"><a href=\"#「一副耳机」-加-「一份后摇歌单」-再加-「一双普通的海绵耳塞」\" class=\"headerlink\" title=\"「一副耳机」 加 「一份后摇歌单」 再加 「一双普通的海绵耳塞」\"></a>「一副耳机」 加 「一份后摇歌单」 再加 「一双普通的海绵耳塞」</h2><p>当我打开IDE或者文本编译器，准备专注的写几段代码的时候。<br>发现戴上耳机，播放着一张「后摇」歌单，特别能让我专注的思考如何实现功能，编码的效率也提升不少。</p>\n<p><strong>一副耳机</strong><br>这里我不需要讨论耳机的选购，每个人的爱好需求都不一样。选择你自己喜欢的就好。</p>\n<p><strong>一份后摇歌单</strong><br>有些人把后摇看作摇滚乐的一种，虽在音乐界这个叫法有些争议，但我们不需要去管。<br>后摇的一个特点是，所用乐器一般与摇滚乐相同，但节奏、和声、旋律、音色及和弦进行，都有别于传统摇滚。<br>没有歌词，没有人声，打破传统歌曲长度，有些甚至长达二三十分钟。<br>后摇给我的感觉，不像传统类似「班得瑞」那种「轻音乐」，它多了一丝激情，多了一份节奏感，更适合写代码。</p>\n<p>如果你不嫌弃的话，这里有一份不错的网易云音乐的歌单：<a href=\"http://music.163.com/#/share/1337344/122993280\">多巴胺作菜，后摇作酒</a></p>\n<p><strong> 再额外推荐点，班得瑞十三张专辑 </strong><br>如果你不喜欢「后摇」，想找一份不错的「轻音乐」歌单，可以试试<a href=\"http://music.163.com/#/artist/album?id=88149\">「班得瑞」</a>十三张专辑。<br>班得瑞（Bandari）是瑞士音乐公司AG旗下的一个新纪元音乐项目。<br>其作品以环境音乐、冥想音乐为主，主要以睡眠、减压为主要音乐功能。<br>风格方面，班得瑞的音乐有许多改编自日本和欧美的新世纪音乐、凯尔特音乐、乡村音乐或老式情歌的乐曲。</p>\n<p><strong>一双普通的海绵耳塞</strong><br>耳机戴多了，戴久了，是会严重影响听力的，并且是不可恢复的损伤。<br>「白噪音」的方法并不能滥用，所以你的抗噪音能力较弱的话，可以去淘宝十几块钱买一副普通的海绵耳塞，戴上也可以隔离世界。但就是有点撑耳朵，一开始会不习惯。</p>\n<h2 id=\"「GTD-Go-To-Do-」类工具\"><a href=\"#「GTD-Go-To-Do-」类工具\" class=\"headerlink\" title=\"「GTD (Go To Do)」类工具\"></a>「GTD (Go To Do)」类工具</h2><p><strong><a href=\"https://www.wunderlist.com\">Wunderlist</a></strong><br>中文叫「奇妙清单」，一款我从大学就用到现在的GTD应用，对比 Trello，Teambition，这款更适于个人使用。<br>单纯的记录想做的事情，做完了就打钩，打钩的那一声清脆的「叮」还是百听不厌。<br>一个账号通用Android、iOS、Mac、Windows、网页平台。</p>\n<p><strong><a href=\"https://trello.com/\">Trello</a></strong><br>更适合团队协作的，「面板式」的任务管理工具。<br>能把任务分为不同的状态，分配给不同的人，定义好时间。<br>项目进度，个人进度一目了然。<br>支持Web、iOS、Android三个平台</p>\n<p><strong><a href=\"https://www.teambition.com/\">Teambition</a></strong><br>这也是一款在我大学和小伙伴做项目的就开始用的团队任务协作工具，是国内一家位于上海的优秀团队的产品。<br>同样支持Web、iOS、Android三个平台。<br>有企业版和免费两个版本，如果低于10个人合作的话，Teambition是一个不错的选择。</p>\n<h2 id=\"「记录日志」类工具\"><a href=\"#「记录日志」类工具\" class=\"headerlink\" title=\"「记录日志」类工具\"></a>「记录日志」类工具</h2><p>回顾和总结是一个好习惯。<br>一天一小结，一周一大结，还有季度总结，年度总结。<br>并不是写给谁看，而是写给自己看，记录自己的时间，知道时间花费去哪里了，有哪些产出，有哪些长进。<br>无论你选择怎么样的生活方式，也不应该让不断流逝的时间走得不明不白，不清不楚。</p>\n<p>对我个人来说，记笔记最重要的是两点：</p>\n<ol>\n<li>支持云同步</li>\n<li>支持Markdown</li>\n</ol>\n<p><strong> <a href=\"https://www.yinxiang.com/?from=evernote\">印象笔记</a> 结合 <a href=\"https://maxiang.io/\">马克飞象</a> </strong><br>很久以前我用「有道云笔记」，后来因为找不到支持 Markdown 的支持加上网易邮箱暴库的原因。就转到了「印象笔记」，然后结合着第三方开发者开发的「马克飞象」，来用 Markdown 语法写了一段时间的日志。<br>总的体验还不错，但是这种方式还是显得有些笨拙，而且不支持其他客户端的编辑。<br>直到遇到了「Day One」的限免。</p>\n<p><strong> <a href=\"http://dayoneapp.com/\">Day One</a> </strong><br>又是一款iOS平台独占的优秀应用，对于苹果党来说绝对是强悍的日记应用。只要你手头上有ipad，或者iphone，或者macbook，随时拿起来写点什么。<br>就是因为这种方便性，我在day ones写了有很多突发奇想的idea或者感悟或者感想，以及一些可以用来写作的主题。</p>\n<h2 id=\"「思维导图」类工具\"><a href=\"#「思维导图」类工具\" class=\"headerlink\" title=\"「思维导图」类工具\"></a>「思维导图」类工具</h2><p>1970年，英国的托尼·布詹提出了一种辅助思考的工具——思维导图。<br>它是通过平面上一个主题发散出来相关联对象所形成的中心网状结构的图。<br>由于这种表现方式比单纯的文本更加接近人类思考时的空间想象，越来越多人用于创造性思维过程中。<br>而我用思维脑图来做的比较多的是：</p>\n<ol>\n<li>项目设计、架构设计。</li>\n<li>个人任务整理。</li>\n<li>思考的时候用来记录思维过程。</li>\n<li>做会议笔记、读书笔记。</li>\n</ol>\n<p><strong><a href=\"http://naotu.baidu.com/\">百度脑图</a></strong><br>尽管最近的百度口碑都不好，但是无可厚非的是，百度下面的确有些产品是做的不错的，也不能一言蔽之。<br>百度脑图算是一个，比较纯粹的操作方式，加上一个云同步的功能，已经足够大部分需求了。<br>但是唯一让我还不满足的是，没有移动端的支持。<br>又是直到 「MindNode」限免为止…..</p>\n<p><strong><a href=\"http://mindnode.com/\">Mindnode</a></strong><br>如 DayOne ，Mindnode 是iOS独占的一款优秀应用，最重要可以三个客户端同步使用。<br>嗯，如果你是个苹果党，也正好不差钱，Mindnode我认为是最好的解决方案。</p>\n<h2 id=\"最后的一个建议，关注健康\"><a href=\"#最后的一个建议，关注健康\" class=\"headerlink\" title=\"最后的一个建议，关注健康\"></a>最后的一个建议，关注健康</h2><p>身体乃革命本钱，人类有区别与其他动物，就是能有反思自己思维的能力。<br>我们以血肉之躯来到世上，在诸如科幻片中可以实现「思想数字化」之前，我们的思想和思维的运作，都要依赖于我们现在的身体。<br>保养好我们的身体，可以让我们更好的完成更多的事情。<br>所以，我们开始站立办公了，解决方案就是：<a href=\"http://www.ikea.com/cn/zh/catalog/products/00193664/\">「39块的宜家拉克边桌」</a></p>\n<p><img src=\"/image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg\" alt=\"站立办公\"></p>\n<h1 id=\"最后再啰嗦一下，关于团队效率\"><a href=\"#最后再啰嗦一下，关于团队效率\" class=\"headerlink\" title=\"最后再啰嗦一下，关于团队效率\"></a>最后再啰嗦一下，关于团队效率</h1><p>以上，都是讲述了如何提高个人的工作效率。<br>但是，现实的人类生产工作，都是团队性的，我们寻求在能保证个人效率之外，还需最大兼容到团队的效率。</p>\n<p>这里有一篇文章很好地讲述了一些「团队效率」的观点，也基本符合我现在所在团队的价值观。<br><a href=\"http://m.jiemian.com/article/800398.html\">腾讯：管理研发大团队就像10人小分队</a></p>\n<p>我的总结如下：</p>\n<ol>\n<li>角色分明，各司其职</li>\n<li>迭代流程，形成循环</li>\n<li>需求透明，进度透明</li>\n<li>线上数据，随手可得</li>\n<li>沟通沉淀，形成归档</li>\n</ol>\n<p>然后我们也一直在思考如何提高团队的效率，也有辅助一些工具，由于边幅问题。<br>改天另立文章，来安利一些不错的工具。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本篇讲述了以下内容：</p>\n<ol>\n<li>关于什么是专注，如何理解专注，以及如何达到专注。</li>\n<li>要做到专注，需要解决的问题。</li>\n<li>借助工具来解决这些问题，安利了一波。</li>\n<li>简单提及了一下团队效率</li>\n</ol>\n<h1 id=\"关于转载\"><a href=\"#关于转载\" class=\"headerlink\" title=\"关于转载\"></a>关于转载</h1><p>本文默认允许转载，但：</p>\n<ol>\n<li>请务必注明出处：<a href=\"http://huang-jerryc.com/2016/11/27/keep-focus-and-efficiency/\">BlueSun | 《程序员如何保证「专注」与「效率」》</a></li>\n<li>如果你不介意，我希望转载的同时，可以得到一声告知。(Email：<a href=\"mailto:huangjerryc@gmail.com\">huangjerryc@gmail.com</a>)</li>\n</ol>\n<p>感谢！</p>\n"},{"title":"jQuery动画反方向延伸","date":"2013-07-21T15:07:04.000Z","_content":"\nJquery的动画效果都是从左到右，从上到下延伸的。如果要实现反方向延伸呢？\n以下代码实现动画从右到左延伸，读者可以举一反三实现从下往上延伸的动画。\n\n**CSS**：\n```\n#bar {\n    margin-left: 100px;\n    height: 10px;\n    width: 0;\n    background: red;\n}\n```\n\n**jQuery**\n```\n$('#bar').animate({\n    marginLeft: 0,\n    width: 100\n});\n```","source":"_posts/jQuery动画反方向延伸.md","raw":"---\ntitle: jQuery动画反方向延伸\ncategory: 搬砖码农\ndate: 2013-07-21 23:07:04\ntags:\n- 前端\n---\n\nJquery的动画效果都是从左到右，从上到下延伸的。如果要实现反方向延伸呢？\n以下代码实现动画从右到左延伸，读者可以举一反三实现从下往上延伸的动画。\n\n**CSS**：\n```\n#bar {\n    margin-left: 100px;\n    height: 10px;\n    width: 0;\n    background: red;\n}\n```\n\n**jQuery**\n```\n$('#bar').animate({\n    marginLeft: 0,\n    width: 100\n});\n```","slug":"jQuery动画反方向延伸","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8ta005bxwrlargb4gz6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Jquery的动画效果都是从左到右，从上到下延伸的。如果要实现反方向延伸呢？<br>以下代码实现动画从右到左延伸，读者可以举一反三实现从下往上延伸的动画。</p>\n<p><strong>CSS</strong>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#bar &#123;</span><br><span class=\"line\">    margin-left: 100px;</span><br><span class=\"line\">    height: 10px;</span><br><span class=\"line\">    width: 0;</span><br><span class=\"line\">    background: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>jQuery</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#bar&apos;).animate(&#123;</span><br><span class=\"line\">    marginLeft: 0,</span><br><span class=\"line\">    width: 100</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>Jquery的动画效果都是从左到右，从上到下延伸的。如果要实现反方向延伸呢？<br>以下代码实现动画从右到左延伸，读者可以举一反三实现从下往上延伸的动画。</p>\n<p><strong>CSS</strong>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#bar &#123;</span><br><span class=\"line\">    margin-left: 100px;</span><br><span class=\"line\">    height: 10px;</span><br><span class=\"line\">    width: 0;</span><br><span class=\"line\">    background: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>jQuery</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#bar&apos;).animate(&#123;</span><br><span class=\"line\">    marginLeft: 0,</span><br><span class=\"line\">    width: 100</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n"},{"title":"iframe-在IE下透明背景","date":"2013-08-07T05:05:02.000Z","_content":"\niframe 在其他主流浏览器下，默认背景是透明的。但是在IE下要通过设置iframe属性来实现背景透明化。\n代码如下：\n\n```HTML\nframeborder   //边框属性\nallowtransparency  //透明背景属性\nscrolling  //滚动条属性\n\n<iframe frameborder=\"no\" allowtransparency=\"true\" scrolling=\"no\" src=\"text-test1.html\"></iframe>    \n\n```\n","source":"_posts/iframe-在IE下透明背景.md","raw":"---\ntitle: iframe-在IE下透明背景\ncategory: 搬砖码农\ndate: 2013-08-07 13:05:02\ntags:\n- 前端\n---\n\niframe 在其他主流浏览器下，默认背景是透明的。但是在IE下要通过设置iframe属性来实现背景透明化。\n代码如下：\n\n```HTML\nframeborder   //边框属性\nallowtransparency  //透明背景属性\nscrolling  //滚动条属性\n\n<iframe frameborder=\"no\" allowtransparency=\"true\" scrolling=\"no\" src=\"text-test1.html\"></iframe>    \n\n```\n","slug":"iframe-在IE下透明背景","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8tb005exwrlab88p5md","comments":1,"layout":"post","photos":[],"link":"","content":"<p>iframe 在其他主流浏览器下，默认背景是透明的。但是在IE下要通过设置iframe属性来实现背景透明化。<br>代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frameborder   //边框属性</span><br><span class=\"line\">allowtransparency  //透明背景属性</span><br><span class=\"line\">scrolling  //滚动条属性</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">allowtransparency</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">scrolling</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"text-test1.html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>iframe 在其他主流浏览器下，默认背景是透明的。但是在IE下要通过设置iframe属性来实现背景透明化。<br>代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frameborder   //边框属性</span><br><span class=\"line\">allowtransparency  //透明背景属性</span><br><span class=\"line\">scrolling  //滚动条属性</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">allowtransparency</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">scrolling</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"text-test1.html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Gulp 基础与原理","date":"2017-02-28T05:49:00.000Z","_content":"\n\n# Gulp 概述\nGulp 是基于 NodeJS 的项目，一个用作自动化构建的工具，业界一般用来建造前端的工作流。\n\n它的核心原理其实很简单，最主要是通过各种 Transform Stream 来实现文件的处理，然后再进行输出。Transform Streams 是 NodeJS Stream 的一种，是可读又可写的，它会对传给它的对象做一些转换的操作。\n\n> 文件输入 →  Gulp 插件处理 → 文件输出\n\n原则上，gulp 可以针对文件做任何有趣、有创造力事情。\n而自动化构建，只是大家主要比较喜欢使用的方向。\n\nGulp 的特点：\n\n- **自动化** - Gulp 为你的工作流而服务，自动运行那些费事费力任务。\n- **平台透明** - Gulp 被集成到各种 IDE 中，并且除了 NodeJS 之外，其他如 PHP、.NET、Java 平台都可以使用 Gulp。\n- **强大生态系统** - 你可以使用 npm 上 2000+ 的插件来构造你的工作流。\n- **简单** - Gulp 只提供几个 API，这可以很快地学习和上手。\n\n# 使用 Gulp\n## 安装\n\n```\n$ npm install gulp-cli -g // 全局安装 Gulp 命令行工具\n$ npm install gulp -D // 在项目中，作为 devDependencies 依赖安装 gulp\n```\n\n## Gulpfile.js\n在使用 CLI 工具的时候，会执行该文件，它是一个可执行的 NodeJS 文件。原理上，你可以在里面运行任何 NodeJS 代码，然后通过调用 gulp 提供的 API，来执行 gulp 任务。\n`gulpfile.js`  文件一般都会放在项目的根目录中。\n\n一个使用 **[gulp-babel](https://www.npmjs.com/package/gulp-babel2/)** 插件来支持 es2015 语法的案例：\n```\nconst gulp = require('gulp');\nconst babel = require('gulp-babel');\n\ngulp.task('default', () => {\n    gulp.src('src/app.js')\n        .pipe(babel({\n            presets: ['es2015']\n        }))\n        .pipe(gulp.dest('dist'));\n});\n```\n\n# 基本概念与原理\n了解这些概念，对于了解 Gulp 的工作原理，和 API 的使用是很有帮助的。\n\n## 认识 Glob\n\nGlob 是一种用来匹配路径与文件的模式。有点类似于正则表达式，但是语法又有点差异。\n这种模式，被广泛用于命令行、Shell 等场景，大家熟悉的 `.gitignore` 文件也是使用这种模式。\n\n各大语言都有对于 Glob 的实现，例如 Go 和 PHP 的 `Glob` 函数，Python 中的 `glob` 模块。\n而 NodeJS 的实现是 **[minimatch](https://github.com/isaacs/minimatch)**, 而在 Gulp 源码中，就用了对 minimatch 进行封装的 **[node-glob](https://github.com/isaacs/node-glob)** 模块。\nGulp 的 API `gulp.watch` 和 `gulp.src` 都有用到 Glob 来匹配对应的路径和文件。\n下面是部分语法：\n* `*` \n匹配该路径段中 0 个或多个任意字符，\n  如：`js/*.js`， 匹配 js 目录下的所有 js 文件\n* `?` \n  匹配该路径段中 1 个任意字符，\n  如：`js/?.js`，匹配 js 目录下所有名字只有 1 个字的 js\n* `[...]` \n  匹配该路径段中在指定范围内字符，\n  如：`js/a[0-3].js`，匹配 js 目录下 a 开头,第二个字符为 0-3 之间（ 包括0和3 ）的 js（ a03.js不能被匹配到 ）\n\n* `!(pattern|pattern|pattern)` \n  匹配除所给出的模型以外的情况，\n  如：`js/!(a|b).js`，匹配 js 目录下名字中不包含 a ,也不包含 b 的所有文件.\n* `?(pattern|pattern|pattern)` \n  匹配所给出的模型中的 0 个或任意 1 个，\n  如：`js/?(a|a2|b).js`, 匹配 js 目录下 a.js , a2.js , b.js\n\n* `+(pattern|pattern|pattern)` \n  匹配所给出的模型中的 1 个或者多个，\n  如：`js/+(a|a1|b).js`, 匹配 js 目录下 a.js , a1.js , b.js , 或者 a, a1, b 这几个字符的组合的 js , 比如 ab.js\n* `*(pattern|pattern|pattern)`\n  匹配所给出的模型中的 0 个或多个或任意个的组合.\n  如：`js/*(a|a1|b).js`，匹配 js 目录下 a.js, a1.js, b.js 或者 a, a1, b这几个字符的组合的 js , 比如 ab.js\n\n* `@(pattern|pat*|pat?erN)`\n  匹配所给出的模型中的任意 1 个，\n  如：`js/@(a|a1|b)`, 匹配 js 目录下的 a.js, a1.js, b.js\n\n* `**`\n  与 `*` 一样可以匹配任何内容，但 `**`不仅匹配路径中的某一段,而且可以匹配 `a/b/c` 这样带有 `/` 的内容，所以，它还可以匹配子文件夹下的文件. \n  如：`js/**/*.js`，匹配 js 目录下及子文件夹中所有的 js 文件。\n\n更多 Glob 的知识和语法，可以参考：\n[Glob - Wiki](https://www.wikiwand.com/en/Glob_(programming)\n[Glob Primer](https://github.com/isaacs/node-glob#glob-primer)\n\n## 认识 Vinyl\n\n[Vinyl](https://github.com/gulpjs/vinyl) 是 Gulp 自创的一种用来描述一个虚拟文件的类，其中主要包括文件的内容和文件的路径两大信息。vinyl 模块，只是提供了一个类，而实现却交由 `vinyl-fs`\n\n[Vinyl-fs](https://github.com/gulpjs/vinyl-fs)，它主要的工作是接受 glob 模式的参数，然后读取匹配的文件。然后利用 Vinyl 制作一个 Transform Stream，称为 Vinyl Stream 对象，并返回。\n\n在 Gulp 中的 API `gulp.src`、`gulp.watch`、`gulp.dest` 都返回一个 Vinyl Stream 实例对象。Vinyl Stream 实例之间可以通过管道（ `vinyl1.pipe(vinyl2)` ）的形式来互相传输数据。 \n\n从 Gulp 的 [源码](https://github.com/gulpjs/gulp/blob/master/index.js#L25-L41) 中也能看出，这三个 API 都是由 vinyl-fs 提供全部的实现。\n\n再一点是，从这两个模块的实现来看，Gulp 是把文件内容以 Buffer 的形式读到内存中，然后再进行处理的。\n\n## 认识 Orchestrator\n[Orchestartor](https://github.com/robrich/orchestrator)，为 `gulp.task` 提供了全部实现，这可以从 [源码](https://github.com/gulpjs/gulp/blob/master/index.js#L14) 中看出。\n它为 Gulp 提供了任务相关的功能，包括任务注册、任务执行以及相对应的任务进度、错误监控等功能。\n\nOrchestartor 模块，只提供了一个 Orchestartor 类，该类的实例维护着一个 tasks 数组，该数组的内容就是一个我们使用 `gulp.task` 时注册的函数列表，以及函数的依赖和名字。\n通过 [源码](https://github.com/robrich/orchestrator/blob/master/index.js#L54-L57) 中，可以看到 tasks 的数据结构：\n```javascript\n...\nthis.tasks[name] = {\n  fn: fn,   // 任务的函数体\n  dep: dep,   // 任务所依赖的其他任务名称\n  name: name  // 该任务的名称\n};\n...\n```\n\n# Gulp 核心 API\n- gulp.src：获取文件\n- gulp.dest：写入文件\n- gulp.tasks：注册任务\n- gulp.watch：监控文件的改动\n\n## gulp.src\n`gulp.src( globs [, options] )`\n\n接收一个 globs 模式的对象，可以是 Array 或者 String，返回一个 Vinyl Stream 实例。\n而 options 有下面的值：\n  * buffer - Boolean, 控制 `file.contents` 是返回 buffer 还是 stream。\n  * read - Boolean，控制是否读取文件，如果 false，则 `file.contents` 为 `null`\n  * base - String，控制 glob 的 base，默认值是 glob 所有表达式的前置，例如 `client/js/**/*.js`, base 值就为 `client/js/`。而 glob 在保存输出路径的时候，取的是 base 之后的路径。所以可以通过该值，来进行输出路径的改写。\n\n## gulp.dest\n`gulp.dest( path [, options] )`\n\n接收输出路径，返回一个 Vinyl Stream 实例。\n而 options 有以下的值：\n * cwd - String， 默认值 `process.pwd()`，输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。\n * mode -  String，八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。\n\n## gulp.task\n`gulp.task( name [, deps ], fn )`\n\n定义一个使用 Orchestrator 实现的任务（task）。\n参数的描述如下：\n* name - 任务名称\n* deps - 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数\n* fn - 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。\n\n## gulp.watch\n`gulp.watch( glob [, opts ], tasks )`\nor\n`gulp.watch( glob [, opts, cb ] )`\n\n用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务。\n各参数的描述如下：\n* glob - 为要监视的文件 Glob 匹配模式。\n* opts - 为一个可选的配置对象。\n* tasks - 为文件变化后要执行的任务，为一个数组\n\n# 常用插件\n\n- [gulp-load-plugins](https://www.npmjs.com/package/gulp-load-plugins)：自动加载 `package.json` 中的 gulp 插件\n- [gulp-rename](https://www.npmjs.com/package/gulp-rename)： 重命名\n- [gulp-uglify](https://www.npmjs.com/package/gulp-uglify)：文件压缩\n- [gulp-concat](https://www.npmjs.com/package/gulp-concat)：文件合并\n- [gulp-less](https://www.npmjs.com/package/gulp-less)：编译 less\n- [gulp-sass](https://www.npmjs.com/package/gulp-sass)：编译 sass\n- [gulp-clean-css](https://github.com/scniro/gulp-clean-css)：压缩 CSS 文件\n- [gulp-htmlmin](https://github.com/jonschlinkert/gulp-htmlmin)：压缩 HTML 文件\n- [gulp-babel](https://github.com/babel/gulp-babel): 使用 babel 编译 JS 文件\n- [gulp-jshint](https://www.npmjs.com/package/gulp-jshint)：jshint 检查\n- [gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin)：压缩jpg、png、gif等图片\n- [gulp-livereload](https://github.com/vohof/gulp-livereload)：当代码变化时，它可以帮我们自动刷新页面\n\n更多插件，可以搜索[官方插件库](http://gulpjs.com/plugins/)。","source":"_posts/gulp-base.md","raw":"---\ntitle: Gulp 基础与原理\ncategory: 搬砖码农\ndate: 2017-02-28 13:49:00\ntags:\n- 前端构建\n---\n\n\n# Gulp 概述\nGulp 是基于 NodeJS 的项目，一个用作自动化构建的工具，业界一般用来建造前端的工作流。\n\n它的核心原理其实很简单，最主要是通过各种 Transform Stream 来实现文件的处理，然后再进行输出。Transform Streams 是 NodeJS Stream 的一种，是可读又可写的，它会对传给它的对象做一些转换的操作。\n\n> 文件输入 →  Gulp 插件处理 → 文件输出\n\n原则上，gulp 可以针对文件做任何有趣、有创造力事情。\n而自动化构建，只是大家主要比较喜欢使用的方向。\n\nGulp 的特点：\n\n- **自动化** - Gulp 为你的工作流而服务，自动运行那些费事费力任务。\n- **平台透明** - Gulp 被集成到各种 IDE 中，并且除了 NodeJS 之外，其他如 PHP、.NET、Java 平台都可以使用 Gulp。\n- **强大生态系统** - 你可以使用 npm 上 2000+ 的插件来构造你的工作流。\n- **简单** - Gulp 只提供几个 API，这可以很快地学习和上手。\n\n# 使用 Gulp\n## 安装\n\n```\n$ npm install gulp-cli -g // 全局安装 Gulp 命令行工具\n$ npm install gulp -D // 在项目中，作为 devDependencies 依赖安装 gulp\n```\n\n## Gulpfile.js\n在使用 CLI 工具的时候，会执行该文件，它是一个可执行的 NodeJS 文件。原理上，你可以在里面运行任何 NodeJS 代码，然后通过调用 gulp 提供的 API，来执行 gulp 任务。\n`gulpfile.js`  文件一般都会放在项目的根目录中。\n\n一个使用 **[gulp-babel](https://www.npmjs.com/package/gulp-babel2/)** 插件来支持 es2015 语法的案例：\n```\nconst gulp = require('gulp');\nconst babel = require('gulp-babel');\n\ngulp.task('default', () => {\n    gulp.src('src/app.js')\n        .pipe(babel({\n            presets: ['es2015']\n        }))\n        .pipe(gulp.dest('dist'));\n});\n```\n\n# 基本概念与原理\n了解这些概念，对于了解 Gulp 的工作原理，和 API 的使用是很有帮助的。\n\n## 认识 Glob\n\nGlob 是一种用来匹配路径与文件的模式。有点类似于正则表达式，但是语法又有点差异。\n这种模式，被广泛用于命令行、Shell 等场景，大家熟悉的 `.gitignore` 文件也是使用这种模式。\n\n各大语言都有对于 Glob 的实现，例如 Go 和 PHP 的 `Glob` 函数，Python 中的 `glob` 模块。\n而 NodeJS 的实现是 **[minimatch](https://github.com/isaacs/minimatch)**, 而在 Gulp 源码中，就用了对 minimatch 进行封装的 **[node-glob](https://github.com/isaacs/node-glob)** 模块。\nGulp 的 API `gulp.watch` 和 `gulp.src` 都有用到 Glob 来匹配对应的路径和文件。\n下面是部分语法：\n* `*` \n匹配该路径段中 0 个或多个任意字符，\n  如：`js/*.js`， 匹配 js 目录下的所有 js 文件\n* `?` \n  匹配该路径段中 1 个任意字符，\n  如：`js/?.js`，匹配 js 目录下所有名字只有 1 个字的 js\n* `[...]` \n  匹配该路径段中在指定范围内字符，\n  如：`js/a[0-3].js`，匹配 js 目录下 a 开头,第二个字符为 0-3 之间（ 包括0和3 ）的 js（ a03.js不能被匹配到 ）\n\n* `!(pattern|pattern|pattern)` \n  匹配除所给出的模型以外的情况，\n  如：`js/!(a|b).js`，匹配 js 目录下名字中不包含 a ,也不包含 b 的所有文件.\n* `?(pattern|pattern|pattern)` \n  匹配所给出的模型中的 0 个或任意 1 个，\n  如：`js/?(a|a2|b).js`, 匹配 js 目录下 a.js , a2.js , b.js\n\n* `+(pattern|pattern|pattern)` \n  匹配所给出的模型中的 1 个或者多个，\n  如：`js/+(a|a1|b).js`, 匹配 js 目录下 a.js , a1.js , b.js , 或者 a, a1, b 这几个字符的组合的 js , 比如 ab.js\n* `*(pattern|pattern|pattern)`\n  匹配所给出的模型中的 0 个或多个或任意个的组合.\n  如：`js/*(a|a1|b).js`，匹配 js 目录下 a.js, a1.js, b.js 或者 a, a1, b这几个字符的组合的 js , 比如 ab.js\n\n* `@(pattern|pat*|pat?erN)`\n  匹配所给出的模型中的任意 1 个，\n  如：`js/@(a|a1|b)`, 匹配 js 目录下的 a.js, a1.js, b.js\n\n* `**`\n  与 `*` 一样可以匹配任何内容，但 `**`不仅匹配路径中的某一段,而且可以匹配 `a/b/c` 这样带有 `/` 的内容，所以，它还可以匹配子文件夹下的文件. \n  如：`js/**/*.js`，匹配 js 目录下及子文件夹中所有的 js 文件。\n\n更多 Glob 的知识和语法，可以参考：\n[Glob - Wiki](https://www.wikiwand.com/en/Glob_(programming)\n[Glob Primer](https://github.com/isaacs/node-glob#glob-primer)\n\n## 认识 Vinyl\n\n[Vinyl](https://github.com/gulpjs/vinyl) 是 Gulp 自创的一种用来描述一个虚拟文件的类，其中主要包括文件的内容和文件的路径两大信息。vinyl 模块，只是提供了一个类，而实现却交由 `vinyl-fs`\n\n[Vinyl-fs](https://github.com/gulpjs/vinyl-fs)，它主要的工作是接受 glob 模式的参数，然后读取匹配的文件。然后利用 Vinyl 制作一个 Transform Stream，称为 Vinyl Stream 对象，并返回。\n\n在 Gulp 中的 API `gulp.src`、`gulp.watch`、`gulp.dest` 都返回一个 Vinyl Stream 实例对象。Vinyl Stream 实例之间可以通过管道（ `vinyl1.pipe(vinyl2)` ）的形式来互相传输数据。 \n\n从 Gulp 的 [源码](https://github.com/gulpjs/gulp/blob/master/index.js#L25-L41) 中也能看出，这三个 API 都是由 vinyl-fs 提供全部的实现。\n\n再一点是，从这两个模块的实现来看，Gulp 是把文件内容以 Buffer 的形式读到内存中，然后再进行处理的。\n\n## 认识 Orchestrator\n[Orchestartor](https://github.com/robrich/orchestrator)，为 `gulp.task` 提供了全部实现，这可以从 [源码](https://github.com/gulpjs/gulp/blob/master/index.js#L14) 中看出。\n它为 Gulp 提供了任务相关的功能，包括任务注册、任务执行以及相对应的任务进度、错误监控等功能。\n\nOrchestartor 模块，只提供了一个 Orchestartor 类，该类的实例维护着一个 tasks 数组，该数组的内容就是一个我们使用 `gulp.task` 时注册的函数列表，以及函数的依赖和名字。\n通过 [源码](https://github.com/robrich/orchestrator/blob/master/index.js#L54-L57) 中，可以看到 tasks 的数据结构：\n```javascript\n...\nthis.tasks[name] = {\n  fn: fn,   // 任务的函数体\n  dep: dep,   // 任务所依赖的其他任务名称\n  name: name  // 该任务的名称\n};\n...\n```\n\n# Gulp 核心 API\n- gulp.src：获取文件\n- gulp.dest：写入文件\n- gulp.tasks：注册任务\n- gulp.watch：监控文件的改动\n\n## gulp.src\n`gulp.src( globs [, options] )`\n\n接收一个 globs 模式的对象，可以是 Array 或者 String，返回一个 Vinyl Stream 实例。\n而 options 有下面的值：\n  * buffer - Boolean, 控制 `file.contents` 是返回 buffer 还是 stream。\n  * read - Boolean，控制是否读取文件，如果 false，则 `file.contents` 为 `null`\n  * base - String，控制 glob 的 base，默认值是 glob 所有表达式的前置，例如 `client/js/**/*.js`, base 值就为 `client/js/`。而 glob 在保存输出路径的时候，取的是 base 之后的路径。所以可以通过该值，来进行输出路径的改写。\n\n## gulp.dest\n`gulp.dest( path [, options] )`\n\n接收输出路径，返回一个 Vinyl Stream 实例。\n而 options 有以下的值：\n * cwd - String， 默认值 `process.pwd()`，输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。\n * mode -  String，八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。\n\n## gulp.task\n`gulp.task( name [, deps ], fn )`\n\n定义一个使用 Orchestrator 实现的任务（task）。\n参数的描述如下：\n* name - 任务名称\n* deps - 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数\n* fn - 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。\n\n## gulp.watch\n`gulp.watch( glob [, opts ], tasks )`\nor\n`gulp.watch( glob [, opts, cb ] )`\n\n用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务。\n各参数的描述如下：\n* glob - 为要监视的文件 Glob 匹配模式。\n* opts - 为一个可选的配置对象。\n* tasks - 为文件变化后要执行的任务，为一个数组\n\n# 常用插件\n\n- [gulp-load-plugins](https://www.npmjs.com/package/gulp-load-plugins)：自动加载 `package.json` 中的 gulp 插件\n- [gulp-rename](https://www.npmjs.com/package/gulp-rename)： 重命名\n- [gulp-uglify](https://www.npmjs.com/package/gulp-uglify)：文件压缩\n- [gulp-concat](https://www.npmjs.com/package/gulp-concat)：文件合并\n- [gulp-less](https://www.npmjs.com/package/gulp-less)：编译 less\n- [gulp-sass](https://www.npmjs.com/package/gulp-sass)：编译 sass\n- [gulp-clean-css](https://github.com/scniro/gulp-clean-css)：压缩 CSS 文件\n- [gulp-htmlmin](https://github.com/jonschlinkert/gulp-htmlmin)：压缩 HTML 文件\n- [gulp-babel](https://github.com/babel/gulp-babel): 使用 babel 编译 JS 文件\n- [gulp-jshint](https://www.npmjs.com/package/gulp-jshint)：jshint 检查\n- [gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin)：压缩jpg、png、gif等图片\n- [gulp-livereload](https://github.com/vohof/gulp-livereload)：当代码变化时，它可以帮我们自动刷新页面\n\n更多插件，可以搜索[官方插件库](http://gulpjs.com/plugins/)。","slug":"gulp-base","published":1,"updated":"2017-02-28T05:49:57.000Z","_id":"cl270y8te005hxwrlt5kewg59","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Gulp-概述\"><a href=\"#Gulp-概述\" class=\"headerlink\" title=\"Gulp 概述\"></a>Gulp 概述</h1><p>Gulp 是基于 NodeJS 的项目，一个用作自动化构建的工具，业界一般用来建造前端的工作流。</p>\n<p>它的核心原理其实很简单，最主要是通过各种 Transform Stream 来实现文件的处理，然后再进行输出。Transform Streams 是 NodeJS Stream 的一种，是可读又可写的，它会对传给它的对象做一些转换的操作。</p>\n<blockquote>\n<p>文件输入 →  Gulp 插件处理 → 文件输出</p>\n</blockquote>\n<p>原则上，gulp 可以针对文件做任何有趣、有创造力事情。<br>而自动化构建，只是大家主要比较喜欢使用的方向。</p>\n<p>Gulp 的特点：</p>\n<ul>\n<li><strong>自动化</strong> - Gulp 为你的工作流而服务，自动运行那些费事费力任务。</li>\n<li><strong>平台透明</strong> - Gulp 被集成到各种 IDE 中，并且除了 NodeJS 之外，其他如 PHP、.NET、Java 平台都可以使用 Gulp。</li>\n<li><strong>强大生态系统</strong> - 你可以使用 npm 上 2000+ 的插件来构造你的工作流。</li>\n<li><strong>简单</strong> - Gulp 只提供几个 API，这可以很快地学习和上手。</li>\n</ul>\n<h1 id=\"使用-Gulp\"><a href=\"#使用-Gulp\" class=\"headerlink\" title=\"使用 Gulp\"></a>使用 Gulp</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gulp-cli -g // 全局安装 Gulp 命令行工具</span><br><span class=\"line\">$ npm install gulp -D // 在项目中，作为 devDependencies 依赖安装 gulp</span><br></pre></td></tr></table></figure>\n<h2 id=\"Gulpfile-js\"><a href=\"#Gulpfile-js\" class=\"headerlink\" title=\"Gulpfile.js\"></a>Gulpfile.js</h2><p>在使用 CLI 工具的时候，会执行该文件，它是一个可执行的 NodeJS 文件。原理上，你可以在里面运行任何 NodeJS 代码，然后通过调用 gulp 提供的 API，来执行 gulp 任务。<br><code>gulpfile.js</code>  文件一般都会放在项目的根目录中。</p>\n<p>一个使用 <strong><a href=\"https://www.npmjs.com/package/gulp-babel2/\" target=\"_blank\" rel=\"external\">gulp-babel</a></strong> 插件来支持 es2015 语法的案例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const gulp = require(&apos;gulp&apos;);</span><br><span class=\"line\">const babel = require(&apos;gulp-babel&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(&apos;default&apos;, () =&gt; &#123;</span><br><span class=\"line\">    gulp.src(&apos;src/app.js&apos;)</span><br><span class=\"line\">        .pipe(babel(&#123;</span><br><span class=\"line\">            presets: [&apos;es2015&apos;]</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">        .pipe(gulp.dest(&apos;dist&apos;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"基本概念与原理\"><a href=\"#基本概念与原理\" class=\"headerlink\" title=\"基本概念与原理\"></a>基本概念与原理</h1><p>了解这些概念，对于了解 Gulp 的工作原理，和 API 的使用是很有帮助的。</p>\n<h2 id=\"认识-Glob\"><a href=\"#认识-Glob\" class=\"headerlink\" title=\"认识 Glob\"></a>认识 Glob</h2><p>Glob 是一种用来匹配路径与文件的模式。有点类似于正则表达式，但是语法又有点差异。<br>这种模式，被广泛用于命令行、Shell 等场景，大家熟悉的 <code>.gitignore</code> 文件也是使用这种模式。</p>\n<p>各大语言都有对于 Glob 的实现，例如 Go 和 PHP 的 <code>Glob</code> 函数，Python 中的 <code>glob</code> 模块。<br>而 NodeJS 的实现是 <strong><a href=\"https://github.com/isaacs/minimatch\" target=\"_blank\" rel=\"external\">minimatch</a></strong>, 而在 Gulp 源码中，就用了对 minimatch 进行封装的 <strong><a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"external\">node-glob</a></strong> 模块。<br>Gulp 的 API <code>gulp.watch</code> 和 <code>gulp.src</code> 都有用到 Glob 来匹配对应的路径和文件。<br>下面是部分语法：</p>\n<ul>\n<li><code>*</code><br>匹配该路径段中 0 个或多个任意字符，<br>如：<code>js/*.js</code>， 匹配 js 目录下的所有 js 文件</li>\n<li><code>?</code><br>匹配该路径段中 1 个任意字符，<br>如：<code>js/?.js</code>，匹配 js 目录下所有名字只有 1 个字的 js</li>\n<li><p><code>[...]</code><br>匹配该路径段中在指定范围内字符，<br>如：<code>js/a[0-3].js</code>，匹配 js 目录下 a 开头,第二个字符为 0-3 之间（ 包括0和3 ）的 js（ a03.js不能被匹配到 ）</p>\n</li>\n<li><p><code>!(pattern|pattern|pattern)</code><br>匹配除所给出的模型以外的情况，<br>如：<code>js/!(a|b).js</code>，匹配 js 目录下名字中不包含 a ,也不包含 b 的所有文件.</p>\n</li>\n<li><p><code>?(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 0 个或任意 1 个，<br>如：<code>js/?(a|a2|b).js</code>, 匹配 js 目录下 a.js , a2.js , b.js</p>\n</li>\n<li><p><code>+(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 1 个或者多个，<br>如：<code>js/+(a|a1|b).js</code>, 匹配 js 目录下 a.js , a1.js , b.js , 或者 a, a1, b 这几个字符的组合的 js , 比如 ab.js</p>\n</li>\n<li><p><code>*(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 0 个或多个或任意个的组合.<br>如：<code>js/*(a|a1|b).js</code>，匹配 js 目录下 a.js, a1.js, b.js 或者 a, a1, b这几个字符的组合的 js , 比如 ab.js</p>\n</li>\n<li><p><code>@(pattern|pat*|pat?erN)</code><br>匹配所给出的模型中的任意 1 个，<br>如：<code>js/@(a|a1|b)</code>, 匹配 js 目录下的 a.js, a1.js, b.js</p>\n</li>\n<li><p><code>**</code><br>与 <code>*</code> 一样可以匹配任何内容，但 <code>**</code>不仅匹配路径中的某一段,而且可以匹配 <code>a/b/c</code> 这样带有 <code>/</code> 的内容，所以，它还可以匹配子文件夹下的文件.<br>如：<code>js/**/*.js</code>，匹配 js 目录下及子文件夹中所有的 js 文件。</p>\n</li>\n</ul>\n<p>更多 Glob 的知识和语法，可以参考：<br><a href=\"https://www.wikiwand.com/en/Glob_(programming\" target=\"_blank\" rel=\"external\">Glob - Wiki</a><br><a href=\"https://github.com/isaacs/node-glob#glob-primer\" target=\"_blank\" rel=\"external\">Glob Primer</a></p>\n<h2 id=\"认识-Vinyl\"><a href=\"#认识-Vinyl\" class=\"headerlink\" title=\"认识 Vinyl\"></a>认识 Vinyl</h2><p><a href=\"https://github.com/gulpjs/vinyl\" target=\"_blank\" rel=\"external\">Vinyl</a> 是 Gulp 自创的一种用来描述一个虚拟文件的类，其中主要包括文件的内容和文件的路径两大信息。vinyl 模块，只是提供了一个类，而实现却交由 <code>vinyl-fs</code></p>\n<p><a href=\"https://github.com/gulpjs/vinyl-fs\" target=\"_blank\" rel=\"external\">Vinyl-fs</a>，它主要的工作是接受 glob 模式的参数，然后读取匹配的文件。然后利用 Vinyl 制作一个 Transform Stream，称为 Vinyl Stream 对象，并返回。</p>\n<p>在 Gulp 中的 API <code>gulp.src</code>、<code>gulp.watch</code>、<code>gulp.dest</code> 都返回一个 Vinyl Stream 实例对象。Vinyl Stream 实例之间可以通过管道（ <code>vinyl1.pipe(vinyl2)</code> ）的形式来互相传输数据。 </p>\n<p>从 Gulp 的 <a href=\"https://github.com/gulpjs/gulp/blob/master/index.js#L25-L41\" target=\"_blank\" rel=\"external\">源码</a> 中也能看出，这三个 API 都是由 vinyl-fs 提供全部的实现。</p>\n<p>再一点是，从这两个模块的实现来看，Gulp 是把文件内容以 Buffer 的形式读到内存中，然后再进行处理的。</p>\n<h2 id=\"认识-Orchestrator\"><a href=\"#认识-Orchestrator\" class=\"headerlink\" title=\"认识 Orchestrator\"></a>认识 Orchestrator</h2><p><a href=\"https://github.com/robrich/orchestrator\" target=\"_blank\" rel=\"external\">Orchestartor</a>，为 <code>gulp.task</code> 提供了全部实现，这可以从 <a href=\"https://github.com/gulpjs/gulp/blob/master/index.js#L14\" target=\"_blank\" rel=\"external\">源码</a> 中看出。<br>它为 Gulp 提供了任务相关的功能，包括任务注册、任务执行以及相对应的任务进度、错误监控等功能。</p>\n<p>Orchestartor 模块，只提供了一个 Orchestartor 类，该类的实例维护着一个 tasks 数组，该数组的内容就是一个我们使用 <code>gulp.task</code> 时注册的函数列表，以及函数的依赖和名字。<br>通过 <a href=\"https://github.com/robrich/orchestrator/blob/master/index.js#L54-L57\" target=\"_blank\" rel=\"external\">源码</a> 中，可以看到 tasks 的数据结构：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">this</span>.tasks[name] = &#123;</span><br><span class=\"line\">  fn: fn,   <span class=\"comment\">// 任务的函数体</span></span><br><span class=\"line\">  dep: dep,   <span class=\"comment\">// 任务所依赖的其他任务名称</span></span><br><span class=\"line\">  name: name  <span class=\"comment\">// 该任务的名称</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Gulp-核心-API\"><a href=\"#Gulp-核心-API\" class=\"headerlink\" title=\"Gulp 核心 API\"></a>Gulp 核心 API</h1><ul>\n<li>gulp.src：获取文件</li>\n<li>gulp.dest：写入文件</li>\n<li>gulp.tasks：注册任务</li>\n<li>gulp.watch：监控文件的改动</li>\n</ul>\n<h2 id=\"gulp-src\"><a href=\"#gulp-src\" class=\"headerlink\" title=\"gulp.src\"></a>gulp.src</h2><p><code>gulp.src( globs [, options] )</code></p>\n<p>接收一个 globs 模式的对象，可以是 Array 或者 String，返回一个 Vinyl Stream 实例。<br>而 options 有下面的值：</p>\n<ul>\n<li>buffer - Boolean, 控制 <code>file.contents</code> 是返回 buffer 还是 stream。</li>\n<li>read - Boolean，控制是否读取文件，如果 false，则 <code>file.contents</code> 为 <code>null</code></li>\n<li>base - String，控制 glob 的 base，默认值是 glob 所有表达式的前置，例如 <code>client/js/**/*.js</code>, base 值就为 <code>client/js/</code>。而 glob 在保存输出路径的时候，取的是 base 之后的路径。所以可以通过该值，来进行输出路径的改写。</li>\n</ul>\n<h2 id=\"gulp-dest\"><a href=\"#gulp-dest\" class=\"headerlink\" title=\"gulp.dest\"></a>gulp.dest</h2><p><code>gulp.dest( path [, options] )</code></p>\n<p>接收输出路径，返回一个 Vinyl Stream 实例。<br>而 options 有以下的值：</p>\n<ul>\n<li>cwd - String， 默认值 <code>process.pwd()</code>，输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。</li>\n<li>mode -  String，八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。</li>\n</ul>\n<h2 id=\"gulp-task\"><a href=\"#gulp-task\" class=\"headerlink\" title=\"gulp.task\"></a>gulp.task</h2><p><code>gulp.task( name [, deps ], fn )</code></p>\n<p>定义一个使用 Orchestrator 实现的任务（task）。<br>参数的描述如下：</p>\n<ul>\n<li>name - 任务名称</li>\n<li>deps - 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数</li>\n<li>fn - 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。</li>\n</ul>\n<h2 id=\"gulp-watch\"><a href=\"#gulp-watch\" class=\"headerlink\" title=\"gulp.watch\"></a>gulp.watch</h2><p><code>gulp.watch( glob [, opts ], tasks )</code><br>or<br><code>gulp.watch( glob [, opts, cb ] )</code></p>\n<p>用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务。<br>各参数的描述如下：</p>\n<ul>\n<li>glob - 为要监视的文件 Glob 匹配模式。</li>\n<li>opts - 为一个可选的配置对象。</li>\n<li>tasks - 为文件变化后要执行的任务，为一个数组</li>\n</ul>\n<h1 id=\"常用插件\"><a href=\"#常用插件\" class=\"headerlink\" title=\"常用插件\"></a>常用插件</h1><ul>\n<li><a href=\"https://www.npmjs.com/package/gulp-load-plugins\" target=\"_blank\" rel=\"external\">gulp-load-plugins</a>：自动加载 <code>package.json</code> 中的 gulp 插件</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-rename\" target=\"_blank\" rel=\"external\">gulp-rename</a>： 重命名</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-uglify\" target=\"_blank\" rel=\"external\">gulp-uglify</a>：文件压缩</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-concat\" target=\"_blank\" rel=\"external\">gulp-concat</a>：文件合并</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-less\" target=\"_blank\" rel=\"external\">gulp-less</a>：编译 less</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-sass\" target=\"_blank\" rel=\"external\">gulp-sass</a>：编译 sass</li>\n<li><a href=\"https://github.com/scniro/gulp-clean-css\" target=\"_blank\" rel=\"external\">gulp-clean-css</a>：压缩 CSS 文件</li>\n<li><a href=\"https://github.com/jonschlinkert/gulp-htmlmin\" target=\"_blank\" rel=\"external\">gulp-htmlmin</a>：压缩 HTML 文件</li>\n<li><a href=\"https://github.com/babel/gulp-babel\" target=\"_blank\" rel=\"external\">gulp-babel</a>: 使用 babel 编译 JS 文件</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-jshint\" target=\"_blank\" rel=\"external\">gulp-jshint</a>：jshint 检查</li>\n<li><a href=\"https://github.com/sindresorhus/gulp-imagemin\" target=\"_blank\" rel=\"external\">gulp-imagemin</a>：压缩jpg、png、gif等图片</li>\n<li><a href=\"https://github.com/vohof/gulp-livereload\" target=\"_blank\" rel=\"external\">gulp-livereload</a>：当代码变化时，它可以帮我们自动刷新页面</li>\n</ul>\n<p>更多插件，可以搜索<a href=\"http://gulpjs.com/plugins/\" target=\"_blank\" rel=\"external\">官方插件库</a>。</p>\n","excerpt":"","more":"<h1 id=\"Gulp-概述\"><a href=\"#Gulp-概述\" class=\"headerlink\" title=\"Gulp 概述\"></a>Gulp 概述</h1><p>Gulp 是基于 NodeJS 的项目，一个用作自动化构建的工具，业界一般用来建造前端的工作流。</p>\n<p>它的核心原理其实很简单，最主要是通过各种 Transform Stream 来实现文件的处理，然后再进行输出。Transform Streams 是 NodeJS Stream 的一种，是可读又可写的，它会对传给它的对象做一些转换的操作。</p>\n<blockquote>\n<p>文件输入 →  Gulp 插件处理 → 文件输出</p>\n</blockquote>\n<p>原则上，gulp 可以针对文件做任何有趣、有创造力事情。<br>而自动化构建，只是大家主要比较喜欢使用的方向。</p>\n<p>Gulp 的特点：</p>\n<ul>\n<li><strong>自动化</strong> - Gulp 为你的工作流而服务，自动运行那些费事费力任务。</li>\n<li><strong>平台透明</strong> - Gulp 被集成到各种 IDE 中，并且除了 NodeJS 之外，其他如 PHP、.NET、Java 平台都可以使用 Gulp。</li>\n<li><strong>强大生态系统</strong> - 你可以使用 npm 上 2000+ 的插件来构造你的工作流。</li>\n<li><strong>简单</strong> - Gulp 只提供几个 API，这可以很快地学习和上手。</li>\n</ul>\n<h1 id=\"使用-Gulp\"><a href=\"#使用-Gulp\" class=\"headerlink\" title=\"使用 Gulp\"></a>使用 Gulp</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gulp-cli -g // 全局安装 Gulp 命令行工具</span><br><span class=\"line\">$ npm install gulp -D // 在项目中，作为 devDependencies 依赖安装 gulp</span><br></pre></td></tr></table></figure>\n<h2 id=\"Gulpfile-js\"><a href=\"#Gulpfile-js\" class=\"headerlink\" title=\"Gulpfile.js\"></a>Gulpfile.js</h2><p>在使用 CLI 工具的时候，会执行该文件，它是一个可执行的 NodeJS 文件。原理上，你可以在里面运行任何 NodeJS 代码，然后通过调用 gulp 提供的 API，来执行 gulp 任务。<br><code>gulpfile.js</code>  文件一般都会放在项目的根目录中。</p>\n<p>一个使用 <strong><a href=\"https://www.npmjs.com/package/gulp-babel2/\">gulp-babel</a></strong> 插件来支持 es2015 语法的案例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const gulp = require(&apos;gulp&apos;);</span><br><span class=\"line\">const babel = require(&apos;gulp-babel&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(&apos;default&apos;, () =&gt; &#123;</span><br><span class=\"line\">    gulp.src(&apos;src/app.js&apos;)</span><br><span class=\"line\">        .pipe(babel(&#123;</span><br><span class=\"line\">            presets: [&apos;es2015&apos;]</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">        .pipe(gulp.dest(&apos;dist&apos;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"基本概念与原理\"><a href=\"#基本概念与原理\" class=\"headerlink\" title=\"基本概念与原理\"></a>基本概念与原理</h1><p>了解这些概念，对于了解 Gulp 的工作原理，和 API 的使用是很有帮助的。</p>\n<h2 id=\"认识-Glob\"><a href=\"#认识-Glob\" class=\"headerlink\" title=\"认识 Glob\"></a>认识 Glob</h2><p>Glob 是一种用来匹配路径与文件的模式。有点类似于正则表达式，但是语法又有点差异。<br>这种模式，被广泛用于命令行、Shell 等场景，大家熟悉的 <code>.gitignore</code> 文件也是使用这种模式。</p>\n<p>各大语言都有对于 Glob 的实现，例如 Go 和 PHP 的 <code>Glob</code> 函数，Python 中的 <code>glob</code> 模块。<br>而 NodeJS 的实现是 <strong><a href=\"https://github.com/isaacs/minimatch\">minimatch</a></strong>, 而在 Gulp 源码中，就用了对 minimatch 进行封装的 <strong><a href=\"https://github.com/isaacs/node-glob\">node-glob</a></strong> 模块。<br>Gulp 的 API <code>gulp.watch</code> 和 <code>gulp.src</code> 都有用到 Glob 来匹配对应的路径和文件。<br>下面是部分语法：</p>\n<ul>\n<li><code>*</code><br>匹配该路径段中 0 个或多个任意字符，<br>如：<code>js/*.js</code>， 匹配 js 目录下的所有 js 文件</li>\n<li><code>?</code><br>匹配该路径段中 1 个任意字符，<br>如：<code>js/?.js</code>，匹配 js 目录下所有名字只有 1 个字的 js</li>\n<li><p><code>[...]</code><br>匹配该路径段中在指定范围内字符，<br>如：<code>js/a[0-3].js</code>，匹配 js 目录下 a 开头,第二个字符为 0-3 之间（ 包括0和3 ）的 js（ a03.js不能被匹配到 ）</p>\n</li>\n<li><p><code>!(pattern|pattern|pattern)</code><br>匹配除所给出的模型以外的情况，<br>如：<code>js/!(a|b).js</code>，匹配 js 目录下名字中不包含 a ,也不包含 b 的所有文件.</p>\n</li>\n<li><p><code>?(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 0 个或任意 1 个，<br>如：<code>js/?(a|a2|b).js</code>, 匹配 js 目录下 a.js , a2.js , b.js</p>\n</li>\n<li><p><code>+(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 1 个或者多个，<br>如：<code>js/+(a|a1|b).js</code>, 匹配 js 目录下 a.js , a1.js , b.js , 或者 a, a1, b 这几个字符的组合的 js , 比如 ab.js</p>\n</li>\n<li><p><code>*(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 0 个或多个或任意个的组合.<br>如：<code>js/*(a|a1|b).js</code>，匹配 js 目录下 a.js, a1.js, b.js 或者 a, a1, b这几个字符的组合的 js , 比如 ab.js</p>\n</li>\n<li><p><code>@(pattern|pat*|pat?erN)</code><br>匹配所给出的模型中的任意 1 个，<br>如：<code>js/@(a|a1|b)</code>, 匹配 js 目录下的 a.js, a1.js, b.js</p>\n</li>\n<li><p><code>**</code><br>与 <code>*</code> 一样可以匹配任何内容，但 <code>**</code>不仅匹配路径中的某一段,而且可以匹配 <code>a/b/c</code> 这样带有 <code>/</code> 的内容，所以，它还可以匹配子文件夹下的文件.<br>如：<code>js/**/*.js</code>，匹配 js 目录下及子文件夹中所有的 js 文件。</p>\n</li>\n</ul>\n<p>更多 Glob 的知识和语法，可以参考：<br><a href=\"https://www.wikiwand.com/en/Glob_(programming\">Glob - Wiki</a><br><a href=\"https://github.com/isaacs/node-glob#glob-primer\">Glob Primer</a></p>\n<h2 id=\"认识-Vinyl\"><a href=\"#认识-Vinyl\" class=\"headerlink\" title=\"认识 Vinyl\"></a>认识 Vinyl</h2><p><a href=\"https://github.com/gulpjs/vinyl\">Vinyl</a> 是 Gulp 自创的一种用来描述一个虚拟文件的类，其中主要包括文件的内容和文件的路径两大信息。vinyl 模块，只是提供了一个类，而实现却交由 <code>vinyl-fs</code></p>\n<p><a href=\"https://github.com/gulpjs/vinyl-fs\">Vinyl-fs</a>，它主要的工作是接受 glob 模式的参数，然后读取匹配的文件。然后利用 Vinyl 制作一个 Transform Stream，称为 Vinyl Stream 对象，并返回。</p>\n<p>在 Gulp 中的 API <code>gulp.src</code>、<code>gulp.watch</code>、<code>gulp.dest</code> 都返回一个 Vinyl Stream 实例对象。Vinyl Stream 实例之间可以通过管道（ <code>vinyl1.pipe(vinyl2)</code> ）的形式来互相传输数据。 </p>\n<p>从 Gulp 的 <a href=\"https://github.com/gulpjs/gulp/blob/master/index.js#L25-L41\">源码</a> 中也能看出，这三个 API 都是由 vinyl-fs 提供全部的实现。</p>\n<p>再一点是，从这两个模块的实现来看，Gulp 是把文件内容以 Buffer 的形式读到内存中，然后再进行处理的。</p>\n<h2 id=\"认识-Orchestrator\"><a href=\"#认识-Orchestrator\" class=\"headerlink\" title=\"认识 Orchestrator\"></a>认识 Orchestrator</h2><p><a href=\"https://github.com/robrich/orchestrator\">Orchestartor</a>，为 <code>gulp.task</code> 提供了全部实现，这可以从 <a href=\"https://github.com/gulpjs/gulp/blob/master/index.js#L14\">源码</a> 中看出。<br>它为 Gulp 提供了任务相关的功能，包括任务注册、任务执行以及相对应的任务进度、错误监控等功能。</p>\n<p>Orchestartor 模块，只提供了一个 Orchestartor 类，该类的实例维护着一个 tasks 数组，该数组的内容就是一个我们使用 <code>gulp.task</code> 时注册的函数列表，以及函数的依赖和名字。<br>通过 <a href=\"https://github.com/robrich/orchestrator/blob/master/index.js#L54-L57\">源码</a> 中，可以看到 tasks 的数据结构：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">this</span>.tasks[name] = &#123;</span><br><span class=\"line\">  fn: fn,   <span class=\"comment\">// 任务的函数体</span></span><br><span class=\"line\">  dep: dep,   <span class=\"comment\">// 任务所依赖的其他任务名称</span></span><br><span class=\"line\">  name: name  <span class=\"comment\">// 该任务的名称</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Gulp-核心-API\"><a href=\"#Gulp-核心-API\" class=\"headerlink\" title=\"Gulp 核心 API\"></a>Gulp 核心 API</h1><ul>\n<li>gulp.src：获取文件</li>\n<li>gulp.dest：写入文件</li>\n<li>gulp.tasks：注册任务</li>\n<li>gulp.watch：监控文件的改动</li>\n</ul>\n<h2 id=\"gulp-src\"><a href=\"#gulp-src\" class=\"headerlink\" title=\"gulp.src\"></a>gulp.src</h2><p><code>gulp.src( globs [, options] )</code></p>\n<p>接收一个 globs 模式的对象，可以是 Array 或者 String，返回一个 Vinyl Stream 实例。<br>而 options 有下面的值：</p>\n<ul>\n<li>buffer - Boolean, 控制 <code>file.contents</code> 是返回 buffer 还是 stream。</li>\n<li>read - Boolean，控制是否读取文件，如果 false，则 <code>file.contents</code> 为 <code>null</code></li>\n<li>base - String，控制 glob 的 base，默认值是 glob 所有表达式的前置，例如 <code>client/js/**/*.js</code>, base 值就为 <code>client/js/</code>。而 glob 在保存输出路径的时候，取的是 base 之后的路径。所以可以通过该值，来进行输出路径的改写。</li>\n</ul>\n<h2 id=\"gulp-dest\"><a href=\"#gulp-dest\" class=\"headerlink\" title=\"gulp.dest\"></a>gulp.dest</h2><p><code>gulp.dest( path [, options] )</code></p>\n<p>接收输出路径，返回一个 Vinyl Stream 实例。<br>而 options 有以下的值：</p>\n<ul>\n<li>cwd - String， 默认值 <code>process.pwd()</code>，输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。</li>\n<li>mode -  String，八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。</li>\n</ul>\n<h2 id=\"gulp-task\"><a href=\"#gulp-task\" class=\"headerlink\" title=\"gulp.task\"></a>gulp.task</h2><p><code>gulp.task( name [, deps ], fn )</code></p>\n<p>定义一个使用 Orchestrator 实现的任务（task）。<br>参数的描述如下：</p>\n<ul>\n<li>name - 任务名称</li>\n<li>deps - 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数</li>\n<li>fn - 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。</li>\n</ul>\n<h2 id=\"gulp-watch\"><a href=\"#gulp-watch\" class=\"headerlink\" title=\"gulp.watch\"></a>gulp.watch</h2><p><code>gulp.watch( glob [, opts ], tasks )</code><br>or<br><code>gulp.watch( glob [, opts, cb ] )</code></p>\n<p>用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务。<br>各参数的描述如下：</p>\n<ul>\n<li>glob - 为要监视的文件 Glob 匹配模式。</li>\n<li>opts - 为一个可选的配置对象。</li>\n<li>tasks - 为文件变化后要执行的任务，为一个数组</li>\n</ul>\n<h1 id=\"常用插件\"><a href=\"#常用插件\" class=\"headerlink\" title=\"常用插件\"></a>常用插件</h1><ul>\n<li><a href=\"https://www.npmjs.com/package/gulp-load-plugins\">gulp-load-plugins</a>：自动加载 <code>package.json</code> 中的 gulp 插件</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-rename\">gulp-rename</a>： 重命名</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-uglify\">gulp-uglify</a>：文件压缩</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-concat\">gulp-concat</a>：文件合并</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-less\">gulp-less</a>：编译 less</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-sass\">gulp-sass</a>：编译 sass</li>\n<li><a href=\"https://github.com/scniro/gulp-clean-css\">gulp-clean-css</a>：压缩 CSS 文件</li>\n<li><a href=\"https://github.com/jonschlinkert/gulp-htmlmin\">gulp-htmlmin</a>：压缩 HTML 文件</li>\n<li><a href=\"https://github.com/babel/gulp-babel\">gulp-babel</a>: 使用 babel 编译 JS 文件</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-jshint\">gulp-jshint</a>：jshint 检查</li>\n<li><a href=\"https://github.com/sindresorhus/gulp-imagemin\">gulp-imagemin</a>：压缩jpg、png、gif等图片</li>\n<li><a href=\"https://github.com/vohof/gulp-livereload\">gulp-livereload</a>：当代码变化时，它可以帮我们自动刷新页面</li>\n</ul>\n<p>更多插件，可以搜索<a href=\"http://gulpjs.com/plugins/\">官方插件库</a>。</p>\n"},{"title":"你知道「编译」与「解释」的区别吗？","date":"2016-11-19T16:03:00.000Z","_content":"\n最近在看一些编译过程的知识点，看的比较多的是英文文献。\n在这之间经常遇到的两个单词让我着实迷惑：Compiler, Interpreter\n中文翻译分别是：编译器，解释器。\n\n如果有人问我们「你知道什么是编译器么？」，\n我们很有可能首先蔑视一下这个人，然后说：「知道啊，不就编译编程语言的程序嘛！」\n要是别人再追问一句「那你知道解释器么？」，\n这时候很有可能也会说「知道啊。」，但是很难再带有蔑视的语气了。\n要是再问一句「那么编译器和解释器的区别是什么啊？」，\n「呃......」\n\n那么到底什么是「编译器」，什么是「解释器」？\n虽然对于两个词，我们很「耳熟」，但是「能详」么？\n似乎我们并没有认真对待这两个词汇。\n\n# 什么是编译器\n摘自 [Wiki Compiler](https://www.wikiwand.com/en/Compiler) 一段\n>A compiler is a computer program (or a set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language), with the latter often having a binary form known as object code. The most common reason for converting source code is to create an executable program.\n\n大概意思：\n> 编译器是一种计算机程序，负责把一种编程语言编写的源码转换成另外一种计算机代码，后者往往是以二进制的形式被称为目标代码(object code)。这个转换的过程通常的目的是生成可执行的程序。\n\n编译器的产出是「另外一种代码」，然后这些代码等着被别人拿来执行，如果还不能直接被执行，那么还需要再编译或解释一遍，再交由计算机硬件执行。\n编译器，往往是在「执行」之前完成，产出是一种可执行或需要再编译或者解释的「代码」。\n\n# 什么是解释器\n摘自 [Wiki Interpreter](#) 一段\n> In computer science, an interpreter is a computer program that directly executes, i.e. performs, instructions written in a programming or scripting language, without previously compiling them into a machine language program. An interpreter generally uses one of the following strategies for program execution:\n1. parse the source code and perform its behavior directly.\n2. translate source code into some efficient intermediate representation and immediately execute this.\n3. explicitly execute stored precompiled code made by a compiler which is part of the interpreter system.\n\n大概意思：\n> 在计算机科学中，解释器是一种计算机程序，它直接执行由编程语言或脚本语言编写的代码，并不会把源代码**预编译**成机器码。一个解释器，通常会用以下的姿势来执行程序代码：\n1. 分析源代码，并且直接执行。\n2. 把源代码翻译成相对更加高效率的中间码，然后立即执行它。\n3. 执行由解释器内部的编译器预编译后保存的代码\n\n可以把解释器看成一个黑盒子，我们输入源码，它就会实时返回结果。\n不同类型的解释器，黑盒子里面的构造不一样，有些还会集成编译器，缓存编译结果，用来提高执行效率（例如 Chrome V8 也是这么做的）。\n解释器通常是工作在「运行时」，并且对于我们输入的源码，是一行一行的解释然后执行，然后返回结果。\n\n# 分两个维度比较一下\n\n## 表现 Behavior \n* **编译器**把源代码转换成其他的更低级的代码(例如二进制码、机器码)，但是不会执行它。\n* **解释器**会读取源代码，并且直接生成指令让计算机硬件执行，不会输出另外一种代码。\n  \n## 性能 Performance\n* **编译器**会事先用比较多的时间把整个程序的源代码编译成另外一种代码，后者往往较前者更加接近机器码，所以执行的效率会更加高。时间是消耗在预编译的过程中。\n* **解释器**会一行一行的读取源代码，解释，然后立即执行。这中间往往使用相对简单的词法分析、语法分析，压缩解释的时间，最后生成机器码，交由硬件执行。解释器适合比较低级的语言。但是相对于预编译好的代码，效率往往会更低。如何减少解释的次数和复杂性，是提高解释器效率的难题。\n\n# 关于代码，需要知道的几个概念\n\n在看了不少不多关于「编译和解释」的文章之后，我发现下面的词汇是大量出现的。\n知道这些词汇代表的意思，以及对应的层次，能够更好地看懂别人所要表达的意思。\n\n## 高级语言代码 High-Level Code\n高级语言代码，自然是指由高级编程语言编写代码，对计算机的细节有更高层次的抽象。\n相对于低级编程语言（low-level programming language）更接近自然语言（人类的语言）。\n集成一系列的自动工具（垃圾回收，内存管理等），会让程序员延长寿命，更快乐的编写出更简洁，更易读的程序代码。\n\n## 低级语言代码 Low-Level Code \n低级语言代码，指由低级编程语言编写的代码，相对高级语言，少了更多的抽象概念，更加接近于汇编或者机器指令。\n但是这也意味着代码的可移植性很差。\n\n在我看来，高与低，只是一组相对词而已。\n越高级的语言，性能、自由度越不及低级语言。\n但是在抽象、可读可写性、可移植性越比低级语言优秀。\n在以前的年代，C/C++语言相对汇编语言，机器指令来说，肯定是高级语言。\n而到了今天，我们更多人对C语言偏向认知为「低级语言」。\n或许未来世界的开发者，看我们现在所熟悉的Java、PHP、Python、ECMAScript等等，都是「low」到爆的语言。\n\n## 汇编语言 Assembly Language\n汇编语言作为一门低级语言，对应于计算机或者其他可编程的硬件。\n它和计算机的体系结构以及机器指令是强关联的。\n换句话说，就是不同的汇编语言代码对应特定的硬件，所以不用谈可移植性了。\n相对于需要编译和解释的高级语言代码来说，汇编代码只需要翻译成机器码就可以执行了。\n所以汇编语言也往往被称作象征性机器码(symbolic machine code)\n\n## 字节码 Byte Code \n字节码严格来说不算是编程语言，而是高级编程语言为了种种需求（可移植性、可传输性、预编译等）而产生的中间码（Intermediate Code）。\n它是由一堆指令集组成的代码，例如在`javac`编译过后的java源码产生的就是字节码。\n源码在编译的过程中，是需要进行「词法分析 → 语法分析 → 生成目标代码」等过程的，在预编译的过程中，就完成这部分工作，生成字节码。\n然后在后面交由解释器（这里通常指编程语言的虚拟机）解释执行，省去前面预编译的开销。\n\n## 机器码 Machine Code\n机器码是一组可以直接被CPU执行的指令集，\n每一条指令都代表一个特定的任务，或者是加载，或者是跳转，亦或是计算操作等等。\n所有可以直接被CPU执行的程序，都是由这么一系列的指令组成的。\n机器码可是看作是编译过程中，最低级的代码，因外再往下就是交由硬件来执行了。\n当然机器码也是可以被编辑的，但是以人类难以看懂的姿势存在，可读性非常差。\n\n# 从熟悉的编程语言的角度来看看\n\n![从熟悉的编程语言的角度来看](/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif)\n\n从左往右看，\n1. 以 Java 为例，我们在文本编译器写好了 Java 代码，交由「编译器」编译成 Java Bytecode。然后 Bytecode 交由 JVM 来执行，这时候 JVM 充当了「解释器」的角色，在解释 Bytecode 成 Machine Code 的同时执行它，返回结果。\n2. 以 [BASIC](https://www.wikiwand.com/zh/BASIC) 语言（早期的可以由计算机直译的语言） 为例，通过文本编译器编写好，不用经历「编译」的过程，就可以直接交由操作系统内部来进行「解释」然后执行。\n3. 以 C 语言为例，我们在文本编译器编写好源代码，然后运行 `gcc hello.c` 编译出 `hello.out` 文件，该文件由一系列的机器指令组成的机器码，可以直接交由硬件来执行。\n\n# 抽象看本质：人与计算机之间的鸿沟\n无论是最近在看《暗时间》的作者刘未鹏，还是前一段时间听《以产品思维写文章》讲座的阿禅，还是其他的很多聪明的人。\n他们都强调「抽象看本质」的能力，能从事物本身抽象出共通属性，看待本质。\n这也是很多人所说的「跳出这个框框再看」的思维方式。\n\n无论是「编译 Compile」还是「解释 Interpret」。\n本质还是**「人与计算机的交流形式」**，人的语言最终转换成机器语言。\n一句 「Hello World」，经过一些列的「编译」和「解释」，最终转换成一系列包含机器指令的那些0和1，机器傻傻执行完之后，告诉你结果。\n\n就这么一个过程，我们就需要很多的翻译官。\n有些翻译官可以做到同声传译（解释），有些翻译官却只能把我们的意图记下来再全部翻译（编译）给计算机。\n而往往一个翻译官能力有限，也只能把你的语言，翻译成另外一种低级点的语言，再由另外懂这个语言的翻译官来翻译更接近计算机能读得懂的语言。\n\n![人类和计算机的鸿沟.png](/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B531CE953267440FAA32A1DA644BFD68.png)\n\n# 一句话描述「编译」与「解释」？\n不如这张图来得直接：\n\n![一句话描述编译与解释](/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B415AA74BF5438CCEB2FEAEDD002B1BD.jpg)\n\n**编译 Compile**：把整个程序源代码翻译成另外一种代码，然后等待被执行，发生在运行之前，产物是「另一份代码」。\n**解释 Interpret**：把程序源代码一行一行的读懂然后执行，发生在运行时，产物是「运行结果」。\n\n# 参考\nhttp://stackoverflow.com/questions/2377273/how-does-an-interpreter-compiler-work\nhttps://www.wikiwand.com/en/Interpreter_(computing)\nhttps://www.wikiwand.com/en/Compiler\nhttps://www.wikiwand.com/en/Machine_code\nhttps://www.wikiwand.com/en/High-level_programming_language\nhttps://www.wikiwand.com/en/Low-level_programming_language\nhttps://www.wikiwand.com/en/Bytecode\n\n","source":"_posts/do-you-konw-the-different-between-compiler-and-interpreter.md","raw":"---\ntitle: 你知道「编译」与「解释」的区别吗？\ndate: 2016-11-20 00:03:00\ntags:\n- 编译\n- 解释\ncategory: 搬砖码农\n---\n\n最近在看一些编译过程的知识点，看的比较多的是英文文献。\n在这之间经常遇到的两个单词让我着实迷惑：Compiler, Interpreter\n中文翻译分别是：编译器，解释器。\n\n如果有人问我们「你知道什么是编译器么？」，\n我们很有可能首先蔑视一下这个人，然后说：「知道啊，不就编译编程语言的程序嘛！」\n要是别人再追问一句「那你知道解释器么？」，\n这时候很有可能也会说「知道啊。」，但是很难再带有蔑视的语气了。\n要是再问一句「那么编译器和解释器的区别是什么啊？」，\n「呃......」\n\n那么到底什么是「编译器」，什么是「解释器」？\n虽然对于两个词，我们很「耳熟」，但是「能详」么？\n似乎我们并没有认真对待这两个词汇。\n\n# 什么是编译器\n摘自 [Wiki Compiler](https://www.wikiwand.com/en/Compiler) 一段\n>A compiler is a computer program (or a set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language), with the latter often having a binary form known as object code. The most common reason for converting source code is to create an executable program.\n\n大概意思：\n> 编译器是一种计算机程序，负责把一种编程语言编写的源码转换成另外一种计算机代码，后者往往是以二进制的形式被称为目标代码(object code)。这个转换的过程通常的目的是生成可执行的程序。\n\n编译器的产出是「另外一种代码」，然后这些代码等着被别人拿来执行，如果还不能直接被执行，那么还需要再编译或解释一遍，再交由计算机硬件执行。\n编译器，往往是在「执行」之前完成，产出是一种可执行或需要再编译或者解释的「代码」。\n\n# 什么是解释器\n摘自 [Wiki Interpreter](#) 一段\n> In computer science, an interpreter is a computer program that directly executes, i.e. performs, instructions written in a programming or scripting language, without previously compiling them into a machine language program. An interpreter generally uses one of the following strategies for program execution:\n1. parse the source code and perform its behavior directly.\n2. translate source code into some efficient intermediate representation and immediately execute this.\n3. explicitly execute stored precompiled code made by a compiler which is part of the interpreter system.\n\n大概意思：\n> 在计算机科学中，解释器是一种计算机程序，它直接执行由编程语言或脚本语言编写的代码，并不会把源代码**预编译**成机器码。一个解释器，通常会用以下的姿势来执行程序代码：\n1. 分析源代码，并且直接执行。\n2. 把源代码翻译成相对更加高效率的中间码，然后立即执行它。\n3. 执行由解释器内部的编译器预编译后保存的代码\n\n可以把解释器看成一个黑盒子，我们输入源码，它就会实时返回结果。\n不同类型的解释器，黑盒子里面的构造不一样，有些还会集成编译器，缓存编译结果，用来提高执行效率（例如 Chrome V8 也是这么做的）。\n解释器通常是工作在「运行时」，并且对于我们输入的源码，是一行一行的解释然后执行，然后返回结果。\n\n# 分两个维度比较一下\n\n## 表现 Behavior \n* **编译器**把源代码转换成其他的更低级的代码(例如二进制码、机器码)，但是不会执行它。\n* **解释器**会读取源代码，并且直接生成指令让计算机硬件执行，不会输出另外一种代码。\n  \n## 性能 Performance\n* **编译器**会事先用比较多的时间把整个程序的源代码编译成另外一种代码，后者往往较前者更加接近机器码，所以执行的效率会更加高。时间是消耗在预编译的过程中。\n* **解释器**会一行一行的读取源代码，解释，然后立即执行。这中间往往使用相对简单的词法分析、语法分析，压缩解释的时间，最后生成机器码，交由硬件执行。解释器适合比较低级的语言。但是相对于预编译好的代码，效率往往会更低。如何减少解释的次数和复杂性，是提高解释器效率的难题。\n\n# 关于代码，需要知道的几个概念\n\n在看了不少不多关于「编译和解释」的文章之后，我发现下面的词汇是大量出现的。\n知道这些词汇代表的意思，以及对应的层次，能够更好地看懂别人所要表达的意思。\n\n## 高级语言代码 High-Level Code\n高级语言代码，自然是指由高级编程语言编写代码，对计算机的细节有更高层次的抽象。\n相对于低级编程语言（low-level programming language）更接近自然语言（人类的语言）。\n集成一系列的自动工具（垃圾回收，内存管理等），会让程序员延长寿命，更快乐的编写出更简洁，更易读的程序代码。\n\n## 低级语言代码 Low-Level Code \n低级语言代码，指由低级编程语言编写的代码，相对高级语言，少了更多的抽象概念，更加接近于汇编或者机器指令。\n但是这也意味着代码的可移植性很差。\n\n在我看来，高与低，只是一组相对词而已。\n越高级的语言，性能、自由度越不及低级语言。\n但是在抽象、可读可写性、可移植性越比低级语言优秀。\n在以前的年代，C/C++语言相对汇编语言，机器指令来说，肯定是高级语言。\n而到了今天，我们更多人对C语言偏向认知为「低级语言」。\n或许未来世界的开发者，看我们现在所熟悉的Java、PHP、Python、ECMAScript等等，都是「low」到爆的语言。\n\n## 汇编语言 Assembly Language\n汇编语言作为一门低级语言，对应于计算机或者其他可编程的硬件。\n它和计算机的体系结构以及机器指令是强关联的。\n换句话说，就是不同的汇编语言代码对应特定的硬件，所以不用谈可移植性了。\n相对于需要编译和解释的高级语言代码来说，汇编代码只需要翻译成机器码就可以执行了。\n所以汇编语言也往往被称作象征性机器码(symbolic machine code)\n\n## 字节码 Byte Code \n字节码严格来说不算是编程语言，而是高级编程语言为了种种需求（可移植性、可传输性、预编译等）而产生的中间码（Intermediate Code）。\n它是由一堆指令集组成的代码，例如在`javac`编译过后的java源码产生的就是字节码。\n源码在编译的过程中，是需要进行「词法分析 → 语法分析 → 生成目标代码」等过程的，在预编译的过程中，就完成这部分工作，生成字节码。\n然后在后面交由解释器（这里通常指编程语言的虚拟机）解释执行，省去前面预编译的开销。\n\n## 机器码 Machine Code\n机器码是一组可以直接被CPU执行的指令集，\n每一条指令都代表一个特定的任务，或者是加载，或者是跳转，亦或是计算操作等等。\n所有可以直接被CPU执行的程序，都是由这么一系列的指令组成的。\n机器码可是看作是编译过程中，最低级的代码，因外再往下就是交由硬件来执行了。\n当然机器码也是可以被编辑的，但是以人类难以看懂的姿势存在，可读性非常差。\n\n# 从熟悉的编程语言的角度来看看\n\n![从熟悉的编程语言的角度来看](/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif)\n\n从左往右看，\n1. 以 Java 为例，我们在文本编译器写好了 Java 代码，交由「编译器」编译成 Java Bytecode。然后 Bytecode 交由 JVM 来执行，这时候 JVM 充当了「解释器」的角色，在解释 Bytecode 成 Machine Code 的同时执行它，返回结果。\n2. 以 [BASIC](https://www.wikiwand.com/zh/BASIC) 语言（早期的可以由计算机直译的语言） 为例，通过文本编译器编写好，不用经历「编译」的过程，就可以直接交由操作系统内部来进行「解释」然后执行。\n3. 以 C 语言为例，我们在文本编译器编写好源代码，然后运行 `gcc hello.c` 编译出 `hello.out` 文件，该文件由一系列的机器指令组成的机器码，可以直接交由硬件来执行。\n\n# 抽象看本质：人与计算机之间的鸿沟\n无论是最近在看《暗时间》的作者刘未鹏，还是前一段时间听《以产品思维写文章》讲座的阿禅，还是其他的很多聪明的人。\n他们都强调「抽象看本质」的能力，能从事物本身抽象出共通属性，看待本质。\n这也是很多人所说的「跳出这个框框再看」的思维方式。\n\n无论是「编译 Compile」还是「解释 Interpret」。\n本质还是**「人与计算机的交流形式」**，人的语言最终转换成机器语言。\n一句 「Hello World」，经过一些列的「编译」和「解释」，最终转换成一系列包含机器指令的那些0和1，机器傻傻执行完之后，告诉你结果。\n\n就这么一个过程，我们就需要很多的翻译官。\n有些翻译官可以做到同声传译（解释），有些翻译官却只能把我们的意图记下来再全部翻译（编译）给计算机。\n而往往一个翻译官能力有限，也只能把你的语言，翻译成另外一种低级点的语言，再由另外懂这个语言的翻译官来翻译更接近计算机能读得懂的语言。\n\n![人类和计算机的鸿沟.png](/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B531CE953267440FAA32A1DA644BFD68.png)\n\n# 一句话描述「编译」与「解释」？\n不如这张图来得直接：\n\n![一句话描述编译与解释](/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B415AA74BF5438CCEB2FEAEDD002B1BD.jpg)\n\n**编译 Compile**：把整个程序源代码翻译成另外一种代码，然后等待被执行，发生在运行之前，产物是「另一份代码」。\n**解释 Interpret**：把程序源代码一行一行的读懂然后执行，发生在运行时，产物是「运行结果」。\n\n# 参考\nhttp://stackoverflow.com/questions/2377273/how-does-an-interpreter-compiler-work\nhttps://www.wikiwand.com/en/Interpreter_(computing)\nhttps://www.wikiwand.com/en/Compiler\nhttps://www.wikiwand.com/en/Machine_code\nhttps://www.wikiwand.com/en/High-level_programming_language\nhttps://www.wikiwand.com/en/Low-level_programming_language\nhttps://www.wikiwand.com/en/Bytecode\n\n","slug":"do-you-konw-the-different-between-compiler-and-interpreter","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8tg005nxwrlofcm1kzv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近在看一些编译过程的知识点，看的比较多的是英文文献。<br>在这之间经常遇到的两个单词让我着实迷惑：Compiler, Interpreter<br>中文翻译分别是：编译器，解释器。</p>\n<p>如果有人问我们「你知道什么是编译器么？」，<br>我们很有可能首先蔑视一下这个人，然后说：「知道啊，不就编译编程语言的程序嘛！」<br>要是别人再追问一句「那你知道解释器么？」，<br>这时候很有可能也会说「知道啊。」，但是很难再带有蔑视的语气了。<br>要是再问一句「那么编译器和解释器的区别是什么啊？」，<br>「呃……」</p>\n<p>那么到底什么是「编译器」，什么是「解释器」？<br>虽然对于两个词，我们很「耳熟」，但是「能详」么？<br>似乎我们并没有认真对待这两个词汇。</p>\n<h1 id=\"什么是编译器\"><a href=\"#什么是编译器\" class=\"headerlink\" title=\"什么是编译器\"></a>什么是编译器</h1><p>摘自 <a href=\"https://www.wikiwand.com/en/Compiler\" target=\"_blank\" rel=\"external\">Wiki Compiler</a> 一段</p>\n<blockquote>\n<p>A compiler is a computer program (or a set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language), with the latter often having a binary form known as object code. The most common reason for converting source code is to create an executable program.</p>\n</blockquote>\n<p>大概意思：</p>\n<blockquote>\n<p>编译器是一种计算机程序，负责把一种编程语言编写的源码转换成另外一种计算机代码，后者往往是以二进制的形式被称为目标代码(object code)。这个转换的过程通常的目的是生成可执行的程序。</p>\n</blockquote>\n<p>编译器的产出是「另外一种代码」，然后这些代码等着被别人拿来执行，如果还不能直接被执行，那么还需要再编译或解释一遍，再交由计算机硬件执行。<br>编译器，往往是在「执行」之前完成，产出是一种可执行或需要再编译或者解释的「代码」。</p>\n<h1 id=\"什么是解释器\"><a href=\"#什么是解释器\" class=\"headerlink\" title=\"什么是解释器\"></a>什么是解释器</h1><p>摘自 <a href=\"#\">Wiki Interpreter</a> 一段</p>\n<blockquote>\n<p>In computer science, an interpreter is a computer program that directly executes, i.e. performs, instructions written in a programming or scripting language, without previously compiling them into a machine language program. An interpreter generally uses one of the following strategies for program execution:</p>\n<ol>\n<li>parse the source code and perform its behavior directly.</li>\n<li>translate source code into some efficient intermediate representation and immediately execute this.</li>\n<li>explicitly execute stored precompiled code made by a compiler which is part of the interpreter system.</li>\n</ol>\n</blockquote>\n<p>大概意思：</p>\n<blockquote>\n<p>在计算机科学中，解释器是一种计算机程序，它直接执行由编程语言或脚本语言编写的代码，并不会把源代码<strong>预编译</strong>成机器码。一个解释器，通常会用以下的姿势来执行程序代码：</p>\n<ol>\n<li>分析源代码，并且直接执行。</li>\n<li>把源代码翻译成相对更加高效率的中间码，然后立即执行它。</li>\n<li>执行由解释器内部的编译器预编译后保存的代码</li>\n</ol>\n</blockquote>\n<p>可以把解释器看成一个黑盒子，我们输入源码，它就会实时返回结果。<br>不同类型的解释器，黑盒子里面的构造不一样，有些还会集成编译器，缓存编译结果，用来提高执行效率（例如 Chrome V8 也是这么做的）。<br>解释器通常是工作在「运行时」，并且对于我们输入的源码，是一行一行的解释然后执行，然后返回结果。</p>\n<h1 id=\"分两个维度比较一下\"><a href=\"#分两个维度比较一下\" class=\"headerlink\" title=\"分两个维度比较一下\"></a>分两个维度比较一下</h1><h2 id=\"表现-Behavior\"><a href=\"#表现-Behavior\" class=\"headerlink\" title=\"表现 Behavior\"></a>表现 Behavior</h2><ul>\n<li><strong>编译器</strong>把源代码转换成其他的更低级的代码(例如二进制码、机器码)，但是不会执行它。</li>\n<li><strong>解释器</strong>会读取源代码，并且直接生成指令让计算机硬件执行，不会输出另外一种代码。</li>\n</ul>\n<h2 id=\"性能-Performance\"><a href=\"#性能-Performance\" class=\"headerlink\" title=\"性能 Performance\"></a>性能 Performance</h2><ul>\n<li><strong>编译器</strong>会事先用比较多的时间把整个程序的源代码编译成另外一种代码，后者往往较前者更加接近机器码，所以执行的效率会更加高。时间是消耗在预编译的过程中。</li>\n<li><strong>解释器</strong>会一行一行的读取源代码，解释，然后立即执行。这中间往往使用相对简单的词法分析、语法分析，压缩解释的时间，最后生成机器码，交由硬件执行。解释器适合比较低级的语言。但是相对于预编译好的代码，效率往往会更低。如何减少解释的次数和复杂性，是提高解释器效率的难题。</li>\n</ul>\n<h1 id=\"关于代码，需要知道的几个概念\"><a href=\"#关于代码，需要知道的几个概念\" class=\"headerlink\" title=\"关于代码，需要知道的几个概念\"></a>关于代码，需要知道的几个概念</h1><p>在看了不少不多关于「编译和解释」的文章之后，我发现下面的词汇是大量出现的。<br>知道这些词汇代表的意思，以及对应的层次，能够更好地看懂别人所要表达的意思。</p>\n<h2 id=\"高级语言代码-High-Level-Code\"><a href=\"#高级语言代码-High-Level-Code\" class=\"headerlink\" title=\"高级语言代码 High-Level Code\"></a>高级语言代码 High-Level Code</h2><p>高级语言代码，自然是指由高级编程语言编写代码，对计算机的细节有更高层次的抽象。<br>相对于低级编程语言（low-level programming language）更接近自然语言（人类的语言）。<br>集成一系列的自动工具（垃圾回收，内存管理等），会让程序员延长寿命，更快乐的编写出更简洁，更易读的程序代码。</p>\n<h2 id=\"低级语言代码-Low-Level-Code\"><a href=\"#低级语言代码-Low-Level-Code\" class=\"headerlink\" title=\"低级语言代码 Low-Level Code\"></a>低级语言代码 Low-Level Code</h2><p>低级语言代码，指由低级编程语言编写的代码，相对高级语言，少了更多的抽象概念，更加接近于汇编或者机器指令。<br>但是这也意味着代码的可移植性很差。</p>\n<p>在我看来，高与低，只是一组相对词而已。<br>越高级的语言，性能、自由度越不及低级语言。<br>但是在抽象、可读可写性、可移植性越比低级语言优秀。<br>在以前的年代，C/C++语言相对汇编语言，机器指令来说，肯定是高级语言。<br>而到了今天，我们更多人对C语言偏向认知为「低级语言」。<br>或许未来世界的开发者，看我们现在所熟悉的Java、PHP、Python、ECMAScript等等，都是「low」到爆的语言。</p>\n<h2 id=\"汇编语言-Assembly-Language\"><a href=\"#汇编语言-Assembly-Language\" class=\"headerlink\" title=\"汇编语言 Assembly Language\"></a>汇编语言 Assembly Language</h2><p>汇编语言作为一门低级语言，对应于计算机或者其他可编程的硬件。<br>它和计算机的体系结构以及机器指令是强关联的。<br>换句话说，就是不同的汇编语言代码对应特定的硬件，所以不用谈可移植性了。<br>相对于需要编译和解释的高级语言代码来说，汇编代码只需要翻译成机器码就可以执行了。<br>所以汇编语言也往往被称作象征性机器码(symbolic machine code)</p>\n<h2 id=\"字节码-Byte-Code\"><a href=\"#字节码-Byte-Code\" class=\"headerlink\" title=\"字节码 Byte Code\"></a>字节码 Byte Code</h2><p>字节码严格来说不算是编程语言，而是高级编程语言为了种种需求（可移植性、可传输性、预编译等）而产生的中间码（Intermediate Code）。<br>它是由一堆指令集组成的代码，例如在<code>javac</code>编译过后的java源码产生的就是字节码。<br>源码在编译的过程中，是需要进行「词法分析 → 语法分析 → 生成目标代码」等过程的，在预编译的过程中，就完成这部分工作，生成字节码。<br>然后在后面交由解释器（这里通常指编程语言的虚拟机）解释执行，省去前面预编译的开销。</p>\n<h2 id=\"机器码-Machine-Code\"><a href=\"#机器码-Machine-Code\" class=\"headerlink\" title=\"机器码 Machine Code\"></a>机器码 Machine Code</h2><p>机器码是一组可以直接被CPU执行的指令集，<br>每一条指令都代表一个特定的任务，或者是加载，或者是跳转，亦或是计算操作等等。<br>所有可以直接被CPU执行的程序，都是由这么一系列的指令组成的。<br>机器码可是看作是编译过程中，最低级的代码，因外再往下就是交由硬件来执行了。<br>当然机器码也是可以被编辑的，但是以人类难以看懂的姿势存在，可读性非常差。</p>\n<h1 id=\"从熟悉的编程语言的角度来看看\"><a href=\"#从熟悉的编程语言的角度来看看\" class=\"headerlink\" title=\"从熟悉的编程语言的角度来看看\"></a>从熟悉的编程语言的角度来看看</h1><p><img src=\"/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif\" alt=\"从熟悉的编程语言的角度来看\"></p>\n<p>从左往右看，</p>\n<ol>\n<li>以 Java 为例，我们在文本编译器写好了 Java 代码，交由「编译器」编译成 Java Bytecode。然后 Bytecode 交由 JVM 来执行，这时候 JVM 充当了「解释器」的角色，在解释 Bytecode 成 Machine Code 的同时执行它，返回结果。</li>\n<li>以 <a href=\"https://www.wikiwand.com/zh/BASIC\" target=\"_blank\" rel=\"external\">BASIC</a> 语言（早期的可以由计算机直译的语言） 为例，通过文本编译器编写好，不用经历「编译」的过程，就可以直接交由操作系统内部来进行「解释」然后执行。</li>\n<li>以 C 语言为例，我们在文本编译器编写好源代码，然后运行 <code>gcc hello.c</code> 编译出 <code>hello.out</code> 文件，该文件由一系列的机器指令组成的机器码，可以直接交由硬件来执行。</li>\n</ol>\n<h1 id=\"抽象看本质：人与计算机之间的鸿沟\"><a href=\"#抽象看本质：人与计算机之间的鸿沟\" class=\"headerlink\" title=\"抽象看本质：人与计算机之间的鸿沟\"></a>抽象看本质：人与计算机之间的鸿沟</h1><p>无论是最近在看《暗时间》的作者刘未鹏，还是前一段时间听《以产品思维写文章》讲座的阿禅，还是其他的很多聪明的人。<br>他们都强调「抽象看本质」的能力，能从事物本身抽象出共通属性，看待本质。<br>这也是很多人所说的「跳出这个框框再看」的思维方式。</p>\n<p>无论是「编译 Compile」还是「解释 Interpret」。<br>本质还是<strong>「人与计算机的交流形式」</strong>，人的语言最终转换成机器语言。<br>一句 「Hello World」，经过一些列的「编译」和「解释」，最终转换成一系列包含机器指令的那些0和1，机器傻傻执行完之后，告诉你结果。</p>\n<p>就这么一个过程，我们就需要很多的翻译官。<br>有些翻译官可以做到同声传译（解释），有些翻译官却只能把我们的意图记下来再全部翻译（编译）给计算机。<br>而往往一个翻译官能力有限，也只能把你的语言，翻译成另外一种低级点的语言，再由另外懂这个语言的翻译官来翻译更接近计算机能读得懂的语言。</p>\n<p><img src=\"/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B531CE953267440FAA32A1DA644BFD68.png\" alt=\"人类和计算机的鸿沟.png\"></p>\n<h1 id=\"一句话描述「编译」与「解释」？\"><a href=\"#一句话描述「编译」与「解释」？\" class=\"headerlink\" title=\"一句话描述「编译」与「解释」？\"></a>一句话描述「编译」与「解释」？</h1><p>不如这张图来得直接：</p>\n<p><img src=\"/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B415AA74BF5438CCEB2FEAEDD002B1BD.jpg\" alt=\"一句话描述编译与解释\"></p>\n<p><strong>编译 Compile</strong>：把整个程序源代码翻译成另外一种代码，然后等待被执行，发生在运行之前，产物是「另一份代码」。<br><strong>解释 Interpret</strong>：把程序源代码一行一行的读懂然后执行，发生在运行时，产物是「运行结果」。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://stackoverflow.com/questions/2377273/how-does-an-interpreter-compiler-work\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/2377273/how-does-an-interpreter-compiler-work</a><br><a href=\"https://www.wikiwand.com/en/Interpreter_(computing)\" target=\"_blank\" rel=\"external\">https://www.wikiwand.com/en/Interpreter_(computing)</a><br><a href=\"https://www.wikiwand.com/en/Compiler\" target=\"_blank\" rel=\"external\">https://www.wikiwand.com/en/Compiler</a><br><a href=\"https://www.wikiwand.com/en/Machine_code\" target=\"_blank\" rel=\"external\">https://www.wikiwand.com/en/Machine_code</a><br><a href=\"https://www.wikiwand.com/en/High-level_programming_language\" target=\"_blank\" rel=\"external\">https://www.wikiwand.com/en/High-level_programming_language</a><br><a href=\"https://www.wikiwand.com/en/Low-level_programming_language\" target=\"_blank\" rel=\"external\">https://www.wikiwand.com/en/Low-level_programming_language</a><br><a href=\"https://www.wikiwand.com/en/Bytecode\" target=\"_blank\" rel=\"external\">https://www.wikiwand.com/en/Bytecode</a></p>\n","excerpt":"","more":"<p>最近在看一些编译过程的知识点，看的比较多的是英文文献。<br>在这之间经常遇到的两个单词让我着实迷惑：Compiler, Interpreter<br>中文翻译分别是：编译器，解释器。</p>\n<p>如果有人问我们「你知道什么是编译器么？」，<br>我们很有可能首先蔑视一下这个人，然后说：「知道啊，不就编译编程语言的程序嘛！」<br>要是别人再追问一句「那你知道解释器么？」，<br>这时候很有可能也会说「知道啊。」，但是很难再带有蔑视的语气了。<br>要是再问一句「那么编译器和解释器的区别是什么啊？」，<br>「呃……」</p>\n<p>那么到底什么是「编译器」，什么是「解释器」？<br>虽然对于两个词，我们很「耳熟」，但是「能详」么？<br>似乎我们并没有认真对待这两个词汇。</p>\n<h1 id=\"什么是编译器\"><a href=\"#什么是编译器\" class=\"headerlink\" title=\"什么是编译器\"></a>什么是编译器</h1><p>摘自 <a href=\"https://www.wikiwand.com/en/Compiler\">Wiki Compiler</a> 一段</p>\n<blockquote>\n<p>A compiler is a computer program (or a set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language), with the latter often having a binary form known as object code. The most common reason for converting source code is to create an executable program.</p>\n</blockquote>\n<p>大概意思：</p>\n<blockquote>\n<p>编译器是一种计算机程序，负责把一种编程语言编写的源码转换成另外一种计算机代码，后者往往是以二进制的形式被称为目标代码(object code)。这个转换的过程通常的目的是生成可执行的程序。</p>\n</blockquote>\n<p>编译器的产出是「另外一种代码」，然后这些代码等着被别人拿来执行，如果还不能直接被执行，那么还需要再编译或解释一遍，再交由计算机硬件执行。<br>编译器，往往是在「执行」之前完成，产出是一种可执行或需要再编译或者解释的「代码」。</p>\n<h1 id=\"什么是解释器\"><a href=\"#什么是解释器\" class=\"headerlink\" title=\"什么是解释器\"></a>什么是解释器</h1><p>摘自 <a href=\"#\">Wiki Interpreter</a> 一段</p>\n<blockquote>\n<p>In computer science, an interpreter is a computer program that directly executes, i.e. performs, instructions written in a programming or scripting language, without previously compiling them into a machine language program. An interpreter generally uses one of the following strategies for program execution:</p>\n<ol>\n<li>parse the source code and perform its behavior directly.</li>\n<li>translate source code into some efficient intermediate representation and immediately execute this.</li>\n<li>explicitly execute stored precompiled code made by a compiler which is part of the interpreter system.</li>\n</ol>\n</blockquote>\n<p>大概意思：</p>\n<blockquote>\n<p>在计算机科学中，解释器是一种计算机程序，它直接执行由编程语言或脚本语言编写的代码，并不会把源代码<strong>预编译</strong>成机器码。一个解释器，通常会用以下的姿势来执行程序代码：</p>\n<ol>\n<li>分析源代码，并且直接执行。</li>\n<li>把源代码翻译成相对更加高效率的中间码，然后立即执行它。</li>\n<li>执行由解释器内部的编译器预编译后保存的代码</li>\n</ol>\n</blockquote>\n<p>可以把解释器看成一个黑盒子，我们输入源码，它就会实时返回结果。<br>不同类型的解释器，黑盒子里面的构造不一样，有些还会集成编译器，缓存编译结果，用来提高执行效率（例如 Chrome V8 也是这么做的）。<br>解释器通常是工作在「运行时」，并且对于我们输入的源码，是一行一行的解释然后执行，然后返回结果。</p>\n<h1 id=\"分两个维度比较一下\"><a href=\"#分两个维度比较一下\" class=\"headerlink\" title=\"分两个维度比较一下\"></a>分两个维度比较一下</h1><h2 id=\"表现-Behavior\"><a href=\"#表现-Behavior\" class=\"headerlink\" title=\"表现 Behavior\"></a>表现 Behavior</h2><ul>\n<li><strong>编译器</strong>把源代码转换成其他的更低级的代码(例如二进制码、机器码)，但是不会执行它。</li>\n<li><strong>解释器</strong>会读取源代码，并且直接生成指令让计算机硬件执行，不会输出另外一种代码。</li>\n</ul>\n<h2 id=\"性能-Performance\"><a href=\"#性能-Performance\" class=\"headerlink\" title=\"性能 Performance\"></a>性能 Performance</h2><ul>\n<li><strong>编译器</strong>会事先用比较多的时间把整个程序的源代码编译成另外一种代码，后者往往较前者更加接近机器码，所以执行的效率会更加高。时间是消耗在预编译的过程中。</li>\n<li><strong>解释器</strong>会一行一行的读取源代码，解释，然后立即执行。这中间往往使用相对简单的词法分析、语法分析，压缩解释的时间，最后生成机器码，交由硬件执行。解释器适合比较低级的语言。但是相对于预编译好的代码，效率往往会更低。如何减少解释的次数和复杂性，是提高解释器效率的难题。</li>\n</ul>\n<h1 id=\"关于代码，需要知道的几个概念\"><a href=\"#关于代码，需要知道的几个概念\" class=\"headerlink\" title=\"关于代码，需要知道的几个概念\"></a>关于代码，需要知道的几个概念</h1><p>在看了不少不多关于「编译和解释」的文章之后，我发现下面的词汇是大量出现的。<br>知道这些词汇代表的意思，以及对应的层次，能够更好地看懂别人所要表达的意思。</p>\n<h2 id=\"高级语言代码-High-Level-Code\"><a href=\"#高级语言代码-High-Level-Code\" class=\"headerlink\" title=\"高级语言代码 High-Level Code\"></a>高级语言代码 High-Level Code</h2><p>高级语言代码，自然是指由高级编程语言编写代码，对计算机的细节有更高层次的抽象。<br>相对于低级编程语言（low-level programming language）更接近自然语言（人类的语言）。<br>集成一系列的自动工具（垃圾回收，内存管理等），会让程序员延长寿命，更快乐的编写出更简洁，更易读的程序代码。</p>\n<h2 id=\"低级语言代码-Low-Level-Code\"><a href=\"#低级语言代码-Low-Level-Code\" class=\"headerlink\" title=\"低级语言代码 Low-Level Code\"></a>低级语言代码 Low-Level Code</h2><p>低级语言代码，指由低级编程语言编写的代码，相对高级语言，少了更多的抽象概念，更加接近于汇编或者机器指令。<br>但是这也意味着代码的可移植性很差。</p>\n<p>在我看来，高与低，只是一组相对词而已。<br>越高级的语言，性能、自由度越不及低级语言。<br>但是在抽象、可读可写性、可移植性越比低级语言优秀。<br>在以前的年代，C/C++语言相对汇编语言，机器指令来说，肯定是高级语言。<br>而到了今天，我们更多人对C语言偏向认知为「低级语言」。<br>或许未来世界的开发者，看我们现在所熟悉的Java、PHP、Python、ECMAScript等等，都是「low」到爆的语言。</p>\n<h2 id=\"汇编语言-Assembly-Language\"><a href=\"#汇编语言-Assembly-Language\" class=\"headerlink\" title=\"汇编语言 Assembly Language\"></a>汇编语言 Assembly Language</h2><p>汇编语言作为一门低级语言，对应于计算机或者其他可编程的硬件。<br>它和计算机的体系结构以及机器指令是强关联的。<br>换句话说，就是不同的汇编语言代码对应特定的硬件，所以不用谈可移植性了。<br>相对于需要编译和解释的高级语言代码来说，汇编代码只需要翻译成机器码就可以执行了。<br>所以汇编语言也往往被称作象征性机器码(symbolic machine code)</p>\n<h2 id=\"字节码-Byte-Code\"><a href=\"#字节码-Byte-Code\" class=\"headerlink\" title=\"字节码 Byte Code\"></a>字节码 Byte Code</h2><p>字节码严格来说不算是编程语言，而是高级编程语言为了种种需求（可移植性、可传输性、预编译等）而产生的中间码（Intermediate Code）。<br>它是由一堆指令集组成的代码，例如在<code>javac</code>编译过后的java源码产生的就是字节码。<br>源码在编译的过程中，是需要进行「词法分析 → 语法分析 → 生成目标代码」等过程的，在预编译的过程中，就完成这部分工作，生成字节码。<br>然后在后面交由解释器（这里通常指编程语言的虚拟机）解释执行，省去前面预编译的开销。</p>\n<h2 id=\"机器码-Machine-Code\"><a href=\"#机器码-Machine-Code\" class=\"headerlink\" title=\"机器码 Machine Code\"></a>机器码 Machine Code</h2><p>机器码是一组可以直接被CPU执行的指令集，<br>每一条指令都代表一个特定的任务，或者是加载，或者是跳转，亦或是计算操作等等。<br>所有可以直接被CPU执行的程序，都是由这么一系列的指令组成的。<br>机器码可是看作是编译过程中，最低级的代码，因外再往下就是交由硬件来执行了。<br>当然机器码也是可以被编辑的，但是以人类难以看懂的姿势存在，可读性非常差。</p>\n<h1 id=\"从熟悉的编程语言的角度来看看\"><a href=\"#从熟悉的编程语言的角度来看看\" class=\"headerlink\" title=\"从熟悉的编程语言的角度来看看\"></a>从熟悉的编程语言的角度来看看</h1><p><img src=\"/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif\" alt=\"从熟悉的编程语言的角度来看\"></p>\n<p>从左往右看，</p>\n<ol>\n<li>以 Java 为例，我们在文本编译器写好了 Java 代码，交由「编译器」编译成 Java Bytecode。然后 Bytecode 交由 JVM 来执行，这时候 JVM 充当了「解释器」的角色，在解释 Bytecode 成 Machine Code 的同时执行它，返回结果。</li>\n<li>以 <a href=\"https://www.wikiwand.com/zh/BASIC\">BASIC</a> 语言（早期的可以由计算机直译的语言） 为例，通过文本编译器编写好，不用经历「编译」的过程，就可以直接交由操作系统内部来进行「解释」然后执行。</li>\n<li>以 C 语言为例，我们在文本编译器编写好源代码，然后运行 <code>gcc hello.c</code> 编译出 <code>hello.out</code> 文件，该文件由一系列的机器指令组成的机器码，可以直接交由硬件来执行。</li>\n</ol>\n<h1 id=\"抽象看本质：人与计算机之间的鸿沟\"><a href=\"#抽象看本质：人与计算机之间的鸿沟\" class=\"headerlink\" title=\"抽象看本质：人与计算机之间的鸿沟\"></a>抽象看本质：人与计算机之间的鸿沟</h1><p>无论是最近在看《暗时间》的作者刘未鹏，还是前一段时间听《以产品思维写文章》讲座的阿禅，还是其他的很多聪明的人。<br>他们都强调「抽象看本质」的能力，能从事物本身抽象出共通属性，看待本质。<br>这也是很多人所说的「跳出这个框框再看」的思维方式。</p>\n<p>无论是「编译 Compile」还是「解释 Interpret」。<br>本质还是<strong>「人与计算机的交流形式」</strong>，人的语言最终转换成机器语言。<br>一句 「Hello World」，经过一些列的「编译」和「解释」，最终转换成一系列包含机器指令的那些0和1，机器傻傻执行完之后，告诉你结果。</p>\n<p>就这么一个过程，我们就需要很多的翻译官。<br>有些翻译官可以做到同声传译（解释），有些翻译官却只能把我们的意图记下来再全部翻译（编译）给计算机。<br>而往往一个翻译官能力有限，也只能把你的语言，翻译成另外一种低级点的语言，再由另外懂这个语言的翻译官来翻译更接近计算机能读得懂的语言。</p>\n<p><img src=\"/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B531CE953267440FAA32A1DA644BFD68.png\" alt=\"人类和计算机的鸿沟.png\"></p>\n<h1 id=\"一句话描述「编译」与「解释」？\"><a href=\"#一句话描述「编译」与「解释」？\" class=\"headerlink\" title=\"一句话描述「编译」与「解释」？\"></a>一句话描述「编译」与「解释」？</h1><p>不如这张图来得直接：</p>\n<p><img src=\"/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B415AA74BF5438CCEB2FEAEDD002B1BD.jpg\" alt=\"一句话描述编译与解释\"></p>\n<p><strong>编译 Compile</strong>：把整个程序源代码翻译成另外一种代码，然后等待被执行，发生在运行之前，产物是「另一份代码」。<br><strong>解释 Interpret</strong>：把程序源代码一行一行的读懂然后执行，发生在运行时，产物是「运行结果」。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://stackoverflow.com/questions/2377273/how-does-an-interpreter-compiler-work\">http://stackoverflow.com/questions/2377273/how-does-an-interpreter-compiler-work</a><br><a href=\"https://www.wikiwand.com/en/Interpreter_(computing)\">https://www.wikiwand.com/en/Interpreter_(computing)</a><br><a href=\"https://www.wikiwand.com/en/Compiler\">https://www.wikiwand.com/en/Compiler</a><br><a href=\"https://www.wikiwand.com/en/Machine_code\">https://www.wikiwand.com/en/Machine_code</a><br><a href=\"https://www.wikiwand.com/en/High-level_programming_language\">https://www.wikiwand.com/en/High-level_programming_language</a><br><a href=\"https://www.wikiwand.com/en/Low-level_programming_language\">https://www.wikiwand.com/en/Low-level_programming_language</a><br><a href=\"https://www.wikiwand.com/en/Bytecode\">https://www.wikiwand.com/en/Bytecode</a></p>\n"},{"title":"「译」JavaScript框架的探索与变迁","date":"2017-11-01T14:22:25.000Z","_content":"\n## 译者言\n\n近几年可谓是 JavaScript 的大爆炸纪元，各种框架类库层出不穷，它们给前端带来一个又一个的新思想。从以前我们用的 jQuery 直接操作 DOM，到 BackboneJS、Dojo 提供监听器的形式，在到 Ember.js、AngularJS 数据绑定的理念，再到现在的 React、Vue 虚拟 DOM 的思想。都是在当前 Web 应用日益复杂的时代，对于如何处理「应用状态」与「用户界面」之间如何更新的问题，带来更先进的解决方案。\n\n本文是一篇从技术上，以数据变更和UI同步为方向，循序渐进的讲述 JavaScript 框架如何演进过来的。\n\n本篇文章，给了我一个更加高纬度的视角，来看待 JavaScript 这些个框架。\n\n\n## 正文\n\n在 2015 年，JavaScript 框架的选择并不少。在 Angular，Ember，React，Backbone 以及它们众多的竞争者中，有足够多的选择。\n\n虽然可以通过不少方面来对比这些框架的不同，但是最让人感兴趣的是它们分别如何管理状态（state）的。特别的，通过思考这些框架分别如何处理状态变化是很有用的。它们都提供了什么样的工具让你把这些变化呈现给用户？ \n\n如何处理应用状态（app state）与用户界面（user interface）之间的同步，长期以来都是用户界面开发如此复杂的主要原因。现在，我们有几个不同的处理方案。本文探索以下：Ember 的数据绑定，Angular 的脏检查、React 的虚拟DOM以及它与不可变数据结构（immutable data structures）之间的联系。\n\n## 数据映射 Projecting Data\n\n我们首先讨论程序内部的状态与屏幕所看到的内容之间的映射。你把各种诸如 object，arrays，strings，以及 numbers 转换成一颗由诸如 texts、forms、links、buttons 和 images 组成的树状结构。在 Web 中，前者通常指 JavaScript 中的数据结构，而后者指的是 [DOM （Document Object Model）](https://www.w3.org/DOM/)\n\n我们经常称这个过程为渲染（rendering），你可以想象这个过程是从数据模型到用户界面的一个映射。当你把数据渲染成一个模板，你得到的是一个 DOM（或者说 HTML）。\n\n![onchange_base.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/15B722FCBCB7A5D72D240DC5B55F7DDE.svg)\n\n这个过程本身已经足够简单了，数据模型到用户界面之间的映射，并不总是那么的琐碎。它基本只是一个接受输入然后直接输出的函数。\n\n在我们需要考虑数据开始随着时间而变化的时候，这件事就变得更有挑战性了。当用户进行操作或者其它某些操作导致数据产生变化的时候，用户界面需要呈现出这些变化。而且，由于重新构建 DOM 树的代价是极其昂贵的，我们要尽可能产生小的影响。\n\n![onchange_change.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/1D6EF2506F41A57871712CBCAD1463F8.svg)\n\n因为状态产生了变化，这比只是一次性渲染用户界面变得更加难。这就到了以下解决方案开始表演的时候了。\n\n\n\n## 服务器渲染 Server-Side Rendering\n\n> 宇宙是永恒不变的，没有任何变化\n\n在 JavaScript 新纪元之前，你的 Web 应用的任何交互都会触发一趟服务器的环绕旅行。每一个点击和每一个表单提交都会卸载当前页面，一个请求发送到服务器，服务器响应一个新的页面，然后浏览器重新渲染。\n\n![onchange_reload.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_reload.svg)\n\n这种方式不需要前端管理任何的状态（state）。就前端范畴而言，当一些事情发生了(后端返回的数据)，整个过程就结束了。就算有状态，那也只是后端的范畴。前端只是由 HTML 和 CSS 构成，也许有时候会有些 JavaScript 撒在表面调味。\n\n从前端来说，这是一个很简单的实现方式，但也是一个很慢的方式。每一个交互并不仅仅触发UI的重渲染，还涉及服务器的数据查询以及服务端渲染。\n\n大多数人已经不再这样做了，我们可以在服务器端初始化我们的应用，然后转移到前端来做状态的管理（这也是 [isomorphic JavaScript](http://isomorphic.net/) 致力于的。）。已经有人在类似的[更复杂的设计思想](https://signalvnoise.com/posts/3112-how-basecamp-next-got-to-be-so-damn-fast-without-using-much-client-side-ui)中取得成功。\n\n\n\n## JS第一代革命：手动重渲染\n\n> 我不知道哪些需要渲染的，你来告诉我。\n\n第一代革命的 JavaScript 框架，如：Backbone.js, Ext JS 以及 Dojo。第一次在浏览器端引入了数据模型（Data Model）的概念，代替了以前那些直接操作 DOM 的轻量级的脚本代码。这意味着你终于可以在浏览器端管理状态了。当数据模型的上下文改变时，你需要做一些工作，让改变呈现在用户界面中。\n\n这些框架的体系能分离你的模型和界面代码，但同时也留下了一大部分同步的工作给你。你可以监听某类事件的发生，但是你有义务去计算如何重新渲染以及如何落实到用户界面中。\n\n![onchange_manual.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_manual.svg)\n\n基于这种模型，作为开发者，你需要考虑大量的性能问题。由于你能控制什么时候和怎么处理更新，你可以从中做任意的做一些调整。这经常会面临一些权衡：简单的处理导致大面积的页面更新，或者强性能的处理来更新一小块页面。\n\n## Ember.js: 数据绑定\n\n> 由于我在控制你的模型和试图，我会确切知道如何重新渲染。\n\n当应用状态改变的时候，手动处理渲染工作，无可避免的增加了复杂度。很多框架旨在解决这个问题，[Ember.js](https://emberjs.com) 就是其中之一。\n\nEmber，像 Backbone 一样，当数据模型改变的时候会触发某个事件。不同之处在于 Ember 同时提供了一些方法来接收这些事件。你可以把 UI 绑定到数据模型中，这意味着有一个监听器绑定到了 UI 上。该监听器当收到事件的时候，知道如何更新 UI。\n\n![onchange_kvo.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_kvo.svg)\n\n这是一个高效率的机制。尽管设置全部的监听器需要在初始化时多出一些工作，但是之后就能保证同步状态时的最小影响。当状态产生变化时， 只有真正需要更新的部分才会发生改变。\n\n这种方式最大的牺牲是 Ember 需要时刻盯着数据模型。这意味着你需要通过 Ember 的 API 封装你的数据，以及你要更新数据的时候是使用 `foo.set('x',42)` 而不是 `foo.x = 42`，以此类推。\n\n在未来 ES6 的 Proxies 可能会对这种模式产生一定的帮助。它让 Ember 可以通过装饰 object 来绑定那些监听器的代码。这就不用像传统方式那样重写 object 的 setter 方法了。\n\n\n\n## AngularJS：脏检查\n\n> 我不知道什么更新了，所以当更新的时候，我只能检查所有的东西。\n\nAngularJS 类似于 Ember，当状态改变的时候，必须人工去处理。但不同的是，AngularJS 从不同的角度来解决问题。\n\n当你在 Angular 模板中引用你的数据，例如这样的语句 `{{foo.x}}` ，Angular 不仅仅只是渲染数据，而且会这个特定的数据创建一个观察者。如此，只要你的应用中发生任何变化，Angular 都会检查这个观察者检视着的数据是否发生了改变。如果发生了改变，就会重新渲染这个数据对应的用户界面。这个过程称作脏检查（Dirty Checking）。\n\n\n\n![onchange_watch.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_watch.svg)\n\n\n\n这种监听改变的风格最大的好处就是，你可以在你的数据模型中使用任何姿势。Angular 对此没有任何限制，它不关心这个。没有基础的对象需要扩展，也没有 API 需要调用。\n\n但坏处就是现在数据模型没有任何内建的检测手段告诉告诉框架哪些东西发生了改变，框架对是否或者哪里发生了改变没有任何洞察力。这意味着数据模型需要通过外部来监听改变，而 Angular 就是这样子做的：所有观察者在任何时间发生的任何改变，都需要被执行一次。点击事件，HTTP 响应，timeout 方法的触发，对于这些，观察者都需要执行一遍。\n\n经常去执行所有观察者，这听起来像是性能的噩梦，但是它令人惊讶的快。这主要是因为在检查到任何改变之前，没有 DOM 的操作过程，而原生的 JavaScript 引用对象的检查平均消耗的性能是廉价的。但是当你要处理大量的 UI 或者经常性触发重新渲染，那么额外的性能优化手段就变得很有必要了。\n\nEmber 和 Angular 都即将得益于即将到来的标准：ECMAScript7 的 [Object.observe](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe) 功能，很适合 Angular。它提供了原生的 API 给你用来监听对象属性的变化。尽管这样，Angular 不需要支持所有的用例，因为 Angular 的观察者相对于简单的监听对象属性，可以做到的更好。\n\n即将到来的 Angular 2 在检测改变这件事上带来了很多有趣的更新，最近 [Victor Savkin 的一篇文章](http://victorsavkin.com/post/110170125256/change-detection-in-angular-2)有介绍到。\n\n关于这个主题，也可以看：[Victor's ng-conf talk](https://www.youtube.com/watch?v=jvKGQSFQf10&feature=youtu.be)\n\n## React: 虚拟 DOM\n\n> 我不知道到底哪些发生了变化，所以我只能重新渲染所有东西，然后看一下有哪些不同。\n\nReact 有很多有趣的特性，但是我们讨论的最有趣的特性是虚拟 DOM。\n\n像 Angular 一样，React 不会对数据模型进行限制，而是让你使用你认为合适的任何对象和数据结构。那么，它是如何在存在改变的情况下使 UI 保持最新呢？\n\nReact 所做的是有效的把我们带回服务器渲染时代，当时我们还不关心状态变化：每当某处发生改变的时候，它会从头重新渲染整个 UI。这可以显著的简化 UI 的代码。大部分情况，你不会关心如何在 React 中维护状态。就像服务器渲染一样，渲染一次就算了。当组件需要变更时，它只能再次重新渲染。组价的初始化渲染和更细它的数据之间，没有任何区别。\n\n如果故事就这么结束的话，它看起来的确非常低效。然而，React 在重新渲染方面，有点特殊。\n\n当 React 进行重新渲染时，它首先会渲染到虚拟 DOM 中，这不是一个实际的 DOM 对象的图。而是一个轻量级的，有纯粹的 object 和 array 组成的纯 JavaScript 的数据结构，它代表着一个真实的 DOM 对象的图。\n\n然后，一个独立的进程会根据虚拟 DOM 的结构来创建那些在屏幕上显示的真实的 DOM 元素。\n\n\n\n![onchange_vdom_initial.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_vdom_initial.svg)\n\n\n\n之后，当变化发生的时候，一个新的虚拟 DOM 会被从头到尾创建出来。这个新的虚拟 DOM 将映射出数据模型的新的状态。现在 React 在手上有两个虚拟 DOM：一个新的，一个旧的。然后会对两个虚拟 DOM 进行一个对比算法，得出它们之间的一组变化。有且只有这些更改会被应用到真实 DOM 中：此元素已添加，此属性以改变，等等。\n\n\n\n![onchange_vdom_change.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_vdom_change.svg)\n\n\n\n所以 React 起码至少有一个好处，就是你不用追踪变化了。你只需要每次重新渲染整个 UI ，然后无论改变了什么最终都会得到相应的结果。React 的虚拟 DOM 对比算法，能让你做到这一点，并且最大限度的节省昂贵的 DOM 操作。\n\n\n\n## Om: 不可改变的数据结构\n\n> 我确切的知道哪些没有改变。\n\n虽然 React 的虚拟 DOM 相当的块，但是当你的 UI 非常庞大或者经常性渲染的时候（例如：每秒高达 60 次），它依然会面临瓶颈。\n\n问题在于，真的没办法每次都渲染出整个虚拟 DOM，除非你引入一些方法来控制数据模型的改变，就像 Ember 做的一样。\n\n一种控制变化的办法是 [不可改变的，持久化的数据结构](http://en.wikipedia.org/wiki/Persistent_data_structure)。这些看起来似乎很适合使用在 React 的虚拟 DOM 中，正如 David Nolen 在 [Om](https://github.com/omcljs/om) 库中所做的 [工作](http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/) 那样，一个构建于 React 和 [ClojureScript](https://github.com/clojure/clojurescript) 之上的库。\n\n有一点关于不可改变数据结构的是，顾名思义，你永远不能改变它，只能产生新的版本。如果你想改变一个对象的属性，你只能新建一个对象和属性，因为你不能改变已经存在的那一个。由于持久化数据结构的工作方式，这比听起来更加有效率。\n\n这意味着在检测变化方面，当 React 组件都只由不可变数据组成的时候，只有一个逃生窗口：当你重新渲染一个组件时，组件的状态仍然指向上次渲染时的相同数据结构，你就可以跳过这次重新渲染。你可以使用该组件的先前的虚拟 DOM 以及源自该组件的整个组件树。没有必要进一步挖掘，因为在这个状态中所有东西都不可能改变。\n\n\n\n![onchange_immutable.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_immutable.svg)\n\n\n\n就像 Ember 一样，像 Om 的这种库不允许在你的数据中使用旧的 JavaScript 对象图。你必须在不可变数据结构中构建你的数据模型，从而才能在其中得到好处。我会赞同这样的做法，因为这一次你这样做并不是为了取悦框架本身。你这样做只是因为这是一个又简单又好的方式去管理你的应用状态。使用不可变数据结构的主要好处，并不是提升渲染性能，而是简化你的应用结构。\n\n虽然 Om 和 ClojureScript 已经讲 React 和不可变数据结构融合起来，但是他们并不是圈子里面的唯一组合。而仅仅使用 React 和 Facebook 的 [Immutable-js](http://facebook.github.io/immutable-js/) 是完全可能的。这个库的作者 Lee Byron 在最近的一次 React.js 为主题的会议中进行了一个 [精彩的介绍](https://www.youtube.com/embed/I7IdS-PbEgI)。\n\n同时我建议看一下 Rich Hickey's 的 [Persistent Data Structures And Managed References](http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey), 去了解状态管理的方法。\n\n我自己现在一直在为不可变数据数据结构 [写诗](http://blog.deveo.com/immutability-in-ruby-part-1-data-structures/)，但我绝对没有预见到它会进入前端 UI 框架行列。它看起来似乎不遗余力的发生着，而 Angular 的人 [正在为支持这个而努力着](http://victorsavkin.com/post/110170125256/change-detection-in-angular-2)。\n\n\n\n## 总结\n\n检测变化时 UI 开发中的核心问题，而 JavaScript 框架们以各种方式解决这个问题。\n\nEmberJS 能在它们发生变化的时候检测到，因为它控制着你的数据模型 API，并且可以在你调用它的时候触发事件。\n\nAngular.js 是事后进行检测， 它通过重新运行你已经在 UI 中注册的所有数据绑定，来检测它们的值是否已经发生变化。\n\nReact 的检测方法是通过把整个 UI 重新渲染成一个虚拟 DOM，然后和旧的版本进行对比。无论改变了什么，都可以给真实 DOM 打上个补丁。\n\nReact 和 不可变数据结构的组合，对比纯粹的 React 有所增强，通过快速的在组件树中标记不可变的节点。因为组件内的变化是不被允许的。但是，这不是主要出于性能的原因，而是由于它对整个应用程序体系结构有积极的影响。\n\n\n## 原文链接\n\n[Changes and Its detection of JavaScript Framework](http://teropa.info/blog/2015/03/02/change-and-its-detection-in-javascript-frameworks.html)","source":"_posts/change-and-its-detection-in-javascript-frameworks.md","raw":"---\ntitle: 「译」JavaScript框架的探索与变迁\ncategory: 搬砖码农\ndate: 2017-11-01 22:22:25\ntags: \n- javascript\n---\n\n## 译者言\n\n近几年可谓是 JavaScript 的大爆炸纪元，各种框架类库层出不穷，它们给前端带来一个又一个的新思想。从以前我们用的 jQuery 直接操作 DOM，到 BackboneJS、Dojo 提供监听器的形式，在到 Ember.js、AngularJS 数据绑定的理念，再到现在的 React、Vue 虚拟 DOM 的思想。都是在当前 Web 应用日益复杂的时代，对于如何处理「应用状态」与「用户界面」之间如何更新的问题，带来更先进的解决方案。\n\n本文是一篇从技术上，以数据变更和UI同步为方向，循序渐进的讲述 JavaScript 框架如何演进过来的。\n\n本篇文章，给了我一个更加高纬度的视角，来看待 JavaScript 这些个框架。\n\n\n## 正文\n\n在 2015 年，JavaScript 框架的选择并不少。在 Angular，Ember，React，Backbone 以及它们众多的竞争者中，有足够多的选择。\n\n虽然可以通过不少方面来对比这些框架的不同，但是最让人感兴趣的是它们分别如何管理状态（state）的。特别的，通过思考这些框架分别如何处理状态变化是很有用的。它们都提供了什么样的工具让你把这些变化呈现给用户？ \n\n如何处理应用状态（app state）与用户界面（user interface）之间的同步，长期以来都是用户界面开发如此复杂的主要原因。现在，我们有几个不同的处理方案。本文探索以下：Ember 的数据绑定，Angular 的脏检查、React 的虚拟DOM以及它与不可变数据结构（immutable data structures）之间的联系。\n\n## 数据映射 Projecting Data\n\n我们首先讨论程序内部的状态与屏幕所看到的内容之间的映射。你把各种诸如 object，arrays，strings，以及 numbers 转换成一颗由诸如 texts、forms、links、buttons 和 images 组成的树状结构。在 Web 中，前者通常指 JavaScript 中的数据结构，而后者指的是 [DOM （Document Object Model）](https://www.w3.org/DOM/)\n\n我们经常称这个过程为渲染（rendering），你可以想象这个过程是从数据模型到用户界面的一个映射。当你把数据渲染成一个模板，你得到的是一个 DOM（或者说 HTML）。\n\n![onchange_base.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/15B722FCBCB7A5D72D240DC5B55F7DDE.svg)\n\n这个过程本身已经足够简单了，数据模型到用户界面之间的映射，并不总是那么的琐碎。它基本只是一个接受输入然后直接输出的函数。\n\n在我们需要考虑数据开始随着时间而变化的时候，这件事就变得更有挑战性了。当用户进行操作或者其它某些操作导致数据产生变化的时候，用户界面需要呈现出这些变化。而且，由于重新构建 DOM 树的代价是极其昂贵的，我们要尽可能产生小的影响。\n\n![onchange_change.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/1D6EF2506F41A57871712CBCAD1463F8.svg)\n\n因为状态产生了变化，这比只是一次性渲染用户界面变得更加难。这就到了以下解决方案开始表演的时候了。\n\n\n\n## 服务器渲染 Server-Side Rendering\n\n> 宇宙是永恒不变的，没有任何变化\n\n在 JavaScript 新纪元之前，你的 Web 应用的任何交互都会触发一趟服务器的环绕旅行。每一个点击和每一个表单提交都会卸载当前页面，一个请求发送到服务器，服务器响应一个新的页面，然后浏览器重新渲染。\n\n![onchange_reload.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_reload.svg)\n\n这种方式不需要前端管理任何的状态（state）。就前端范畴而言，当一些事情发生了(后端返回的数据)，整个过程就结束了。就算有状态，那也只是后端的范畴。前端只是由 HTML 和 CSS 构成，也许有时候会有些 JavaScript 撒在表面调味。\n\n从前端来说，这是一个很简单的实现方式，但也是一个很慢的方式。每一个交互并不仅仅触发UI的重渲染，还涉及服务器的数据查询以及服务端渲染。\n\n大多数人已经不再这样做了，我们可以在服务器端初始化我们的应用，然后转移到前端来做状态的管理（这也是 [isomorphic JavaScript](http://isomorphic.net/) 致力于的。）。已经有人在类似的[更复杂的设计思想](https://signalvnoise.com/posts/3112-how-basecamp-next-got-to-be-so-damn-fast-without-using-much-client-side-ui)中取得成功。\n\n\n\n## JS第一代革命：手动重渲染\n\n> 我不知道哪些需要渲染的，你来告诉我。\n\n第一代革命的 JavaScript 框架，如：Backbone.js, Ext JS 以及 Dojo。第一次在浏览器端引入了数据模型（Data Model）的概念，代替了以前那些直接操作 DOM 的轻量级的脚本代码。这意味着你终于可以在浏览器端管理状态了。当数据模型的上下文改变时，你需要做一些工作，让改变呈现在用户界面中。\n\n这些框架的体系能分离你的模型和界面代码，但同时也留下了一大部分同步的工作给你。你可以监听某类事件的发生，但是你有义务去计算如何重新渲染以及如何落实到用户界面中。\n\n![onchange_manual.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_manual.svg)\n\n基于这种模型，作为开发者，你需要考虑大量的性能问题。由于你能控制什么时候和怎么处理更新，你可以从中做任意的做一些调整。这经常会面临一些权衡：简单的处理导致大面积的页面更新，或者强性能的处理来更新一小块页面。\n\n## Ember.js: 数据绑定\n\n> 由于我在控制你的模型和试图，我会确切知道如何重新渲染。\n\n当应用状态改变的时候，手动处理渲染工作，无可避免的增加了复杂度。很多框架旨在解决这个问题，[Ember.js](https://emberjs.com) 就是其中之一。\n\nEmber，像 Backbone 一样，当数据模型改变的时候会触发某个事件。不同之处在于 Ember 同时提供了一些方法来接收这些事件。你可以把 UI 绑定到数据模型中，这意味着有一个监听器绑定到了 UI 上。该监听器当收到事件的时候，知道如何更新 UI。\n\n![onchange_kvo.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_kvo.svg)\n\n这是一个高效率的机制。尽管设置全部的监听器需要在初始化时多出一些工作，但是之后就能保证同步状态时的最小影响。当状态产生变化时， 只有真正需要更新的部分才会发生改变。\n\n这种方式最大的牺牲是 Ember 需要时刻盯着数据模型。这意味着你需要通过 Ember 的 API 封装你的数据，以及你要更新数据的时候是使用 `foo.set('x',42)` 而不是 `foo.x = 42`，以此类推。\n\n在未来 ES6 的 Proxies 可能会对这种模式产生一定的帮助。它让 Ember 可以通过装饰 object 来绑定那些监听器的代码。这就不用像传统方式那样重写 object 的 setter 方法了。\n\n\n\n## AngularJS：脏检查\n\n> 我不知道什么更新了，所以当更新的时候，我只能检查所有的东西。\n\nAngularJS 类似于 Ember，当状态改变的时候，必须人工去处理。但不同的是，AngularJS 从不同的角度来解决问题。\n\n当你在 Angular 模板中引用你的数据，例如这样的语句 `{{foo.x}}` ，Angular 不仅仅只是渲染数据，而且会这个特定的数据创建一个观察者。如此，只要你的应用中发生任何变化，Angular 都会检查这个观察者检视着的数据是否发生了改变。如果发生了改变，就会重新渲染这个数据对应的用户界面。这个过程称作脏检查（Dirty Checking）。\n\n\n\n![onchange_watch.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_watch.svg)\n\n\n\n这种监听改变的风格最大的好处就是，你可以在你的数据模型中使用任何姿势。Angular 对此没有任何限制，它不关心这个。没有基础的对象需要扩展，也没有 API 需要调用。\n\n但坏处就是现在数据模型没有任何内建的检测手段告诉告诉框架哪些东西发生了改变，框架对是否或者哪里发生了改变没有任何洞察力。这意味着数据模型需要通过外部来监听改变，而 Angular 就是这样子做的：所有观察者在任何时间发生的任何改变，都需要被执行一次。点击事件，HTTP 响应，timeout 方法的触发，对于这些，观察者都需要执行一遍。\n\n经常去执行所有观察者，这听起来像是性能的噩梦，但是它令人惊讶的快。这主要是因为在检查到任何改变之前，没有 DOM 的操作过程，而原生的 JavaScript 引用对象的检查平均消耗的性能是廉价的。但是当你要处理大量的 UI 或者经常性触发重新渲染，那么额外的性能优化手段就变得很有必要了。\n\nEmber 和 Angular 都即将得益于即将到来的标准：ECMAScript7 的 [Object.observe](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe) 功能，很适合 Angular。它提供了原生的 API 给你用来监听对象属性的变化。尽管这样，Angular 不需要支持所有的用例，因为 Angular 的观察者相对于简单的监听对象属性，可以做到的更好。\n\n即将到来的 Angular 2 在检测改变这件事上带来了很多有趣的更新，最近 [Victor Savkin 的一篇文章](http://victorsavkin.com/post/110170125256/change-detection-in-angular-2)有介绍到。\n\n关于这个主题，也可以看：[Victor's ng-conf talk](https://www.youtube.com/watch?v=jvKGQSFQf10&feature=youtu.be)\n\n## React: 虚拟 DOM\n\n> 我不知道到底哪些发生了变化，所以我只能重新渲染所有东西，然后看一下有哪些不同。\n\nReact 有很多有趣的特性，但是我们讨论的最有趣的特性是虚拟 DOM。\n\n像 Angular 一样，React 不会对数据模型进行限制，而是让你使用你认为合适的任何对象和数据结构。那么，它是如何在存在改变的情况下使 UI 保持最新呢？\n\nReact 所做的是有效的把我们带回服务器渲染时代，当时我们还不关心状态变化：每当某处发生改变的时候，它会从头重新渲染整个 UI。这可以显著的简化 UI 的代码。大部分情况，你不会关心如何在 React 中维护状态。就像服务器渲染一样，渲染一次就算了。当组件需要变更时，它只能再次重新渲染。组价的初始化渲染和更细它的数据之间，没有任何区别。\n\n如果故事就这么结束的话，它看起来的确非常低效。然而，React 在重新渲染方面，有点特殊。\n\n当 React 进行重新渲染时，它首先会渲染到虚拟 DOM 中，这不是一个实际的 DOM 对象的图。而是一个轻量级的，有纯粹的 object 和 array 组成的纯 JavaScript 的数据结构，它代表着一个真实的 DOM 对象的图。\n\n然后，一个独立的进程会根据虚拟 DOM 的结构来创建那些在屏幕上显示的真实的 DOM 元素。\n\n\n\n![onchange_vdom_initial.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_vdom_initial.svg)\n\n\n\n之后，当变化发生的时候，一个新的虚拟 DOM 会被从头到尾创建出来。这个新的虚拟 DOM 将映射出数据模型的新的状态。现在 React 在手上有两个虚拟 DOM：一个新的，一个旧的。然后会对两个虚拟 DOM 进行一个对比算法，得出它们之间的一组变化。有且只有这些更改会被应用到真实 DOM 中：此元素已添加，此属性以改变，等等。\n\n\n\n![onchange_vdom_change.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_vdom_change.svg)\n\n\n\n所以 React 起码至少有一个好处，就是你不用追踪变化了。你只需要每次重新渲染整个 UI ，然后无论改变了什么最终都会得到相应的结果。React 的虚拟 DOM 对比算法，能让你做到这一点，并且最大限度的节省昂贵的 DOM 操作。\n\n\n\n## Om: 不可改变的数据结构\n\n> 我确切的知道哪些没有改变。\n\n虽然 React 的虚拟 DOM 相当的块，但是当你的 UI 非常庞大或者经常性渲染的时候（例如：每秒高达 60 次），它依然会面临瓶颈。\n\n问题在于，真的没办法每次都渲染出整个虚拟 DOM，除非你引入一些方法来控制数据模型的改变，就像 Ember 做的一样。\n\n一种控制变化的办法是 [不可改变的，持久化的数据结构](http://en.wikipedia.org/wiki/Persistent_data_structure)。这些看起来似乎很适合使用在 React 的虚拟 DOM 中，正如 David Nolen 在 [Om](https://github.com/omcljs/om) 库中所做的 [工作](http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/) 那样，一个构建于 React 和 [ClojureScript](https://github.com/clojure/clojurescript) 之上的库。\n\n有一点关于不可改变数据结构的是，顾名思义，你永远不能改变它，只能产生新的版本。如果你想改变一个对象的属性，你只能新建一个对象和属性，因为你不能改变已经存在的那一个。由于持久化数据结构的工作方式，这比听起来更加有效率。\n\n这意味着在检测变化方面，当 React 组件都只由不可变数据组成的时候，只有一个逃生窗口：当你重新渲染一个组件时，组件的状态仍然指向上次渲染时的相同数据结构，你就可以跳过这次重新渲染。你可以使用该组件的先前的虚拟 DOM 以及源自该组件的整个组件树。没有必要进一步挖掘，因为在这个状态中所有东西都不可能改变。\n\n\n\n![onchange_immutable.svg](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_immutable.svg)\n\n\n\n就像 Ember 一样，像 Om 的这种库不允许在你的数据中使用旧的 JavaScript 对象图。你必须在不可变数据结构中构建你的数据模型，从而才能在其中得到好处。我会赞同这样的做法，因为这一次你这样做并不是为了取悦框架本身。你这样做只是因为这是一个又简单又好的方式去管理你的应用状态。使用不可变数据结构的主要好处，并不是提升渲染性能，而是简化你的应用结构。\n\n虽然 Om 和 ClojureScript 已经讲 React 和不可变数据结构融合起来，但是他们并不是圈子里面的唯一组合。而仅仅使用 React 和 Facebook 的 [Immutable-js](http://facebook.github.io/immutable-js/) 是完全可能的。这个库的作者 Lee Byron 在最近的一次 React.js 为主题的会议中进行了一个 [精彩的介绍](https://www.youtube.com/embed/I7IdS-PbEgI)。\n\n同时我建议看一下 Rich Hickey's 的 [Persistent Data Structures And Managed References](http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey), 去了解状态管理的方法。\n\n我自己现在一直在为不可变数据数据结构 [写诗](http://blog.deveo.com/immutability-in-ruby-part-1-data-structures/)，但我绝对没有预见到它会进入前端 UI 框架行列。它看起来似乎不遗余力的发生着，而 Angular 的人 [正在为支持这个而努力着](http://victorsavkin.com/post/110170125256/change-detection-in-angular-2)。\n\n\n\n## 总结\n\n检测变化时 UI 开发中的核心问题，而 JavaScript 框架们以各种方式解决这个问题。\n\nEmberJS 能在它们发生变化的时候检测到，因为它控制着你的数据模型 API，并且可以在你调用它的时候触发事件。\n\nAngular.js 是事后进行检测， 它通过重新运行你已经在 UI 中注册的所有数据绑定，来检测它们的值是否已经发生变化。\n\nReact 的检测方法是通过把整个 UI 重新渲染成一个虚拟 DOM，然后和旧的版本进行对比。无论改变了什么，都可以给真实 DOM 打上个补丁。\n\nReact 和 不可变数据结构的组合，对比纯粹的 React 有所增强，通过快速的在组件树中标记不可变的节点。因为组件内的变化是不被允许的。但是，这不是主要出于性能的原因，而是由于它对整个应用程序体系结构有积极的影响。\n\n\n## 原文链接\n\n[Changes and Its detection of JavaScript Framework](http://teropa.info/blog/2015/03/02/change-and-its-detection-in-javascript-frameworks.html)","slug":"change-and-its-detection-in-javascript-frameworks","published":1,"updated":"2020-12-13T13:47:15.662Z","_id":"cl270y8th005txwrl428ccd7u","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"译者言\"><a href=\"#译者言\" class=\"headerlink\" title=\"译者言\"></a>译者言</h2><p>近几年可谓是 JavaScript 的大爆炸纪元，各种框架类库层出不穷，它们给前端带来一个又一个的新思想。从以前我们用的 jQuery 直接操作 DOM，到 BackboneJS、Dojo 提供监听器的形式，在到 Ember.js、AngularJS 数据绑定的理念，再到现在的 React、Vue 虚拟 DOM 的思想。都是在当前 Web 应用日益复杂的时代，对于如何处理「应用状态」与「用户界面」之间如何更新的问题，带来更先进的解决方案。</p>\n<p>本文是一篇从技术上，以数据变更和UI同步为方向，循序渐进的讲述 JavaScript 框架如何演进过来的。</p>\n<p>本篇文章，给了我一个更加高纬度的视角，来看待 JavaScript 这些个框架。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>在 2015 年，JavaScript 框架的选择并不少。在 Angular，Ember，React，Backbone 以及它们众多的竞争者中，有足够多的选择。</p>\n<p>虽然可以通过不少方面来对比这些框架的不同，但是最让人感兴趣的是它们分别如何管理状态（state）的。特别的，通过思考这些框架分别如何处理状态变化是很有用的。它们都提供了什么样的工具让你把这些变化呈现给用户？ </p>\n<p>如何处理应用状态（app state）与用户界面（user interface）之间的同步，长期以来都是用户界面开发如此复杂的主要原因。现在，我们有几个不同的处理方案。本文探索以下：Ember 的数据绑定，Angular 的脏检查、React 的虚拟DOM以及它与不可变数据结构（immutable data structures）之间的联系。</p>\n<h2 id=\"数据映射-Projecting-Data\"><a href=\"#数据映射-Projecting-Data\" class=\"headerlink\" title=\"数据映射 Projecting Data\"></a>数据映射 Projecting Data</h2><p>我们首先讨论程序内部的状态与屏幕所看到的内容之间的映射。你把各种诸如 object，arrays，strings，以及 numbers 转换成一颗由诸如 texts、forms、links、buttons 和 images 组成的树状结构。在 Web 中，前者通常指 JavaScript 中的数据结构，而后者指的是 <a href=\"https://www.w3.org/DOM/\" target=\"_blank\" rel=\"external\">DOM （Document Object Model）</a></p>\n<p>我们经常称这个过程为渲染（rendering），你可以想象这个过程是从数据模型到用户界面的一个映射。当你把数据渲染成一个模板，你得到的是一个 DOM（或者说 HTML）。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/15B722FCBCB7A5D72D240DC5B55F7DDE.svg\" alt=\"onchange_base.svg\"></p>\n<p>这个过程本身已经足够简单了，数据模型到用户界面之间的映射，并不总是那么的琐碎。它基本只是一个接受输入然后直接输出的函数。</p>\n<p>在我们需要考虑数据开始随着时间而变化的时候，这件事就变得更有挑战性了。当用户进行操作或者其它某些操作导致数据产生变化的时候，用户界面需要呈现出这些变化。而且，由于重新构建 DOM 树的代价是极其昂贵的，我们要尽可能产生小的影响。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/1D6EF2506F41A57871712CBCAD1463F8.svg\" alt=\"onchange_change.svg\"></p>\n<p>因为状态产生了变化，这比只是一次性渲染用户界面变得更加难。这就到了以下解决方案开始表演的时候了。</p>\n<h2 id=\"服务器渲染-Server-Side-Rendering\"><a href=\"#服务器渲染-Server-Side-Rendering\" class=\"headerlink\" title=\"服务器渲染 Server-Side Rendering\"></a>服务器渲染 Server-Side Rendering</h2><blockquote>\n<p>宇宙是永恒不变的，没有任何变化</p>\n</blockquote>\n<p>在 JavaScript 新纪元之前，你的 Web 应用的任何交互都会触发一趟服务器的环绕旅行。每一个点击和每一个表单提交都会卸载当前页面，一个请求发送到服务器，服务器响应一个新的页面，然后浏览器重新渲染。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_reload.svg\" alt=\"onchange_reload.svg\"></p>\n<p>这种方式不需要前端管理任何的状态（state）。就前端范畴而言，当一些事情发生了(后端返回的数据)，整个过程就结束了。就算有状态，那也只是后端的范畴。前端只是由 HTML 和 CSS 构成，也许有时候会有些 JavaScript 撒在表面调味。</p>\n<p>从前端来说，这是一个很简单的实现方式，但也是一个很慢的方式。每一个交互并不仅仅触发UI的重渲染，还涉及服务器的数据查询以及服务端渲染。</p>\n<p>大多数人已经不再这样做了，我们可以在服务器端初始化我们的应用，然后转移到前端来做状态的管理（这也是 <a href=\"http://isomorphic.net/\" target=\"_blank\" rel=\"external\">isomorphic JavaScript</a> 致力于的。）。已经有人在类似的<a href=\"https://signalvnoise.com/posts/3112-how-basecamp-next-got-to-be-so-damn-fast-without-using-much-client-side-ui\" target=\"_blank\" rel=\"external\">更复杂的设计思想</a>中取得成功。</p>\n<h2 id=\"JS第一代革命：手动重渲染\"><a href=\"#JS第一代革命：手动重渲染\" class=\"headerlink\" title=\"JS第一代革命：手动重渲染\"></a>JS第一代革命：手动重渲染</h2><blockquote>\n<p>我不知道哪些需要渲染的，你来告诉我。</p>\n</blockquote>\n<p>第一代革命的 JavaScript 框架，如：Backbone.js, Ext JS 以及 Dojo。第一次在浏览器端引入了数据模型（Data Model）的概念，代替了以前那些直接操作 DOM 的轻量级的脚本代码。这意味着你终于可以在浏览器端管理状态了。当数据模型的上下文改变时，你需要做一些工作，让改变呈现在用户界面中。</p>\n<p>这些框架的体系能分离你的模型和界面代码，但同时也留下了一大部分同步的工作给你。你可以监听某类事件的发生，但是你有义务去计算如何重新渲染以及如何落实到用户界面中。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_manual.svg\" alt=\"onchange_manual.svg\"></p>\n<p>基于这种模型，作为开发者，你需要考虑大量的性能问题。由于你能控制什么时候和怎么处理更新，你可以从中做任意的做一些调整。这经常会面临一些权衡：简单的处理导致大面积的页面更新，或者强性能的处理来更新一小块页面。</p>\n<h2 id=\"Ember-js-数据绑定\"><a href=\"#Ember-js-数据绑定\" class=\"headerlink\" title=\"Ember.js: 数据绑定\"></a>Ember.js: 数据绑定</h2><blockquote>\n<p>由于我在控制你的模型和试图，我会确切知道如何重新渲染。</p>\n</blockquote>\n<p>当应用状态改变的时候，手动处理渲染工作，无可避免的增加了复杂度。很多框架旨在解决这个问题，<a href=\"https://emberjs.com\" target=\"_blank\" rel=\"external\">Ember.js</a> 就是其中之一。</p>\n<p>Ember，像 Backbone 一样，当数据模型改变的时候会触发某个事件。不同之处在于 Ember 同时提供了一些方法来接收这些事件。你可以把 UI 绑定到数据模型中，这意味着有一个监听器绑定到了 UI 上。该监听器当收到事件的时候，知道如何更新 UI。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_kvo.svg\" alt=\"onchange_kvo.svg\"></p>\n<p>这是一个高效率的机制。尽管设置全部的监听器需要在初始化时多出一些工作，但是之后就能保证同步状态时的最小影响。当状态产生变化时， 只有真正需要更新的部分才会发生改变。</p>\n<p>这种方式最大的牺牲是 Ember 需要时刻盯着数据模型。这意味着你需要通过 Ember 的 API 封装你的数据，以及你要更新数据的时候是使用 <code>foo.set(&#39;x&#39;,42)</code> 而不是 <code>foo.x = 42</code>，以此类推。</p>\n<p>在未来 ES6 的 Proxies 可能会对这种模式产生一定的帮助。它让 Ember 可以通过装饰 object 来绑定那些监听器的代码。这就不用像传统方式那样重写 object 的 setter 方法了。</p>\n<h2 id=\"AngularJS：脏检查\"><a href=\"#AngularJS：脏检查\" class=\"headerlink\" title=\"AngularJS：脏检查\"></a>AngularJS：脏检查</h2><blockquote>\n<p>我不知道什么更新了，所以当更新的时候，我只能检查所有的东西。</p>\n</blockquote>\n<p>AngularJS 类似于 Ember，当状态改变的时候，必须人工去处理。但不同的是，AngularJS 从不同的角度来解决问题。</p>\n<p>当你在 Angular 模板中引用你的数据，例如这样的语句 <code></code> ，Angular 不仅仅只是渲染数据，而且会这个特定的数据创建一个观察者。如此，只要你的应用中发生任何变化，Angular 都会检查这个观察者检视着的数据是否发生了改变。如果发生了改变，就会重新渲染这个数据对应的用户界面。这个过程称作脏检查（Dirty Checking）。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_watch.svg\" alt=\"onchange_watch.svg\"></p>\n<p>这种监听改变的风格最大的好处就是，你可以在你的数据模型中使用任何姿势。Angular 对此没有任何限制，它不关心这个。没有基础的对象需要扩展，也没有 API 需要调用。</p>\n<p>但坏处就是现在数据模型没有任何内建的检测手段告诉告诉框架哪些东西发生了改变，框架对是否或者哪里发生了改变没有任何洞察力。这意味着数据模型需要通过外部来监听改变，而 Angular 就是这样子做的：所有观察者在任何时间发生的任何改变，都需要被执行一次。点击事件，HTTP 响应，timeout 方法的触发，对于这些，观察者都需要执行一遍。</p>\n<p>经常去执行所有观察者，这听起来像是性能的噩梦，但是它令人惊讶的快。这主要是因为在检查到任何改变之前，没有 DOM 的操作过程，而原生的 JavaScript 引用对象的检查平均消耗的性能是廉价的。但是当你要处理大量的 UI 或者经常性触发重新渲染，那么额外的性能优化手段就变得很有必要了。</p>\n<p>Ember 和 Angular 都即将得益于即将到来的标准：ECMAScript7 的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\" target=\"_blank\" rel=\"external\">Object.observe</a> 功能，很适合 Angular。它提供了原生的 API 给你用来监听对象属性的变化。尽管这样，Angular 不需要支持所有的用例，因为 Angular 的观察者相对于简单的监听对象属性，可以做到的更好。</p>\n<p>即将到来的 Angular 2 在检测改变这件事上带来了很多有趣的更新，最近 <a href=\"http://victorsavkin.com/post/110170125256/change-detection-in-angular-2\" target=\"_blank\" rel=\"external\">Victor Savkin 的一篇文章</a>有介绍到。</p>\n<p>关于这个主题，也可以看：<a href=\"https://www.youtube.com/watch?v=jvKGQSFQf10&amp;feature=youtu.be\" target=\"_blank\" rel=\"external\">Victor’s ng-conf talk</a></p>\n<h2 id=\"React-虚拟-DOM\"><a href=\"#React-虚拟-DOM\" class=\"headerlink\" title=\"React: 虚拟 DOM\"></a>React: 虚拟 DOM</h2><blockquote>\n<p>我不知道到底哪些发生了变化，所以我只能重新渲染所有东西，然后看一下有哪些不同。</p>\n</blockquote>\n<p>React 有很多有趣的特性，但是我们讨论的最有趣的特性是虚拟 DOM。</p>\n<p>像 Angular 一样，React 不会对数据模型进行限制，而是让你使用你认为合适的任何对象和数据结构。那么，它是如何在存在改变的情况下使 UI 保持最新呢？</p>\n<p>React 所做的是有效的把我们带回服务器渲染时代，当时我们还不关心状态变化：每当某处发生改变的时候，它会从头重新渲染整个 UI。这可以显著的简化 UI 的代码。大部分情况，你不会关心如何在 React 中维护状态。就像服务器渲染一样，渲染一次就算了。当组件需要变更时，它只能再次重新渲染。组价的初始化渲染和更细它的数据之间，没有任何区别。</p>\n<p>如果故事就这么结束的话，它看起来的确非常低效。然而，React 在重新渲染方面，有点特殊。</p>\n<p>当 React 进行重新渲染时，它首先会渲染到虚拟 DOM 中，这不是一个实际的 DOM 对象的图。而是一个轻量级的，有纯粹的 object 和 array 组成的纯 JavaScript 的数据结构，它代表着一个真实的 DOM 对象的图。</p>\n<p>然后，一个独立的进程会根据虚拟 DOM 的结构来创建那些在屏幕上显示的真实的 DOM 元素。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_vdom_initial.svg\" alt=\"onchange_vdom_initial.svg\"></p>\n<p>之后，当变化发生的时候，一个新的虚拟 DOM 会被从头到尾创建出来。这个新的虚拟 DOM 将映射出数据模型的新的状态。现在 React 在手上有两个虚拟 DOM：一个新的，一个旧的。然后会对两个虚拟 DOM 进行一个对比算法，得出它们之间的一组变化。有且只有这些更改会被应用到真实 DOM 中：此元素已添加，此属性以改变，等等。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_vdom_change.svg\" alt=\"onchange_vdom_change.svg\"></p>\n<p>所以 React 起码至少有一个好处，就是你不用追踪变化了。你只需要每次重新渲染整个 UI ，然后无论改变了什么最终都会得到相应的结果。React 的虚拟 DOM 对比算法，能让你做到这一点，并且最大限度的节省昂贵的 DOM 操作。</p>\n<h2 id=\"Om-不可改变的数据结构\"><a href=\"#Om-不可改变的数据结构\" class=\"headerlink\" title=\"Om: 不可改变的数据结构\"></a>Om: 不可改变的数据结构</h2><blockquote>\n<p>我确切的知道哪些没有改变。</p>\n</blockquote>\n<p>虽然 React 的虚拟 DOM 相当的块，但是当你的 UI 非常庞大或者经常性渲染的时候（例如：每秒高达 60 次），它依然会面临瓶颈。</p>\n<p>问题在于，真的没办法每次都渲染出整个虚拟 DOM，除非你引入一些方法来控制数据模型的改变，就像 Ember 做的一样。</p>\n<p>一种控制变化的办法是 <a href=\"http://en.wikipedia.org/wiki/Persistent_data_structure\" target=\"_blank\" rel=\"external\">不可改变的，持久化的数据结构</a>。这些看起来似乎很适合使用在 React 的虚拟 DOM 中，正如 David Nolen 在 <a href=\"https://github.com/omcljs/om\" target=\"_blank\" rel=\"external\">Om</a> 库中所做的 <a href=\"http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/\" target=\"_blank\" rel=\"external\">工作</a> 那样，一个构建于 React 和 <a href=\"https://github.com/clojure/clojurescript\" target=\"_blank\" rel=\"external\">ClojureScript</a> 之上的库。</p>\n<p>有一点关于不可改变数据结构的是，顾名思义，你永远不能改变它，只能产生新的版本。如果你想改变一个对象的属性，你只能新建一个对象和属性，因为你不能改变已经存在的那一个。由于持久化数据结构的工作方式，这比听起来更加有效率。</p>\n<p>这意味着在检测变化方面，当 React 组件都只由不可变数据组成的时候，只有一个逃生窗口：当你重新渲染一个组件时，组件的状态仍然指向上次渲染时的相同数据结构，你就可以跳过这次重新渲染。你可以使用该组件的先前的虚拟 DOM 以及源自该组件的整个组件树。没有必要进一步挖掘，因为在这个状态中所有东西都不可能改变。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_immutable.svg\" alt=\"onchange_immutable.svg\"></p>\n<p>就像 Ember 一样，像 Om 的这种库不允许在你的数据中使用旧的 JavaScript 对象图。你必须在不可变数据结构中构建你的数据模型，从而才能在其中得到好处。我会赞同这样的做法，因为这一次你这样做并不是为了取悦框架本身。你这样做只是因为这是一个又简单又好的方式去管理你的应用状态。使用不可变数据结构的主要好处，并不是提升渲染性能，而是简化你的应用结构。</p>\n<p>虽然 Om 和 ClojureScript 已经讲 React 和不可变数据结构融合起来，但是他们并不是圈子里面的唯一组合。而仅仅使用 React 和 Facebook 的 <a href=\"http://facebook.github.io/immutable-js/\" target=\"_blank\" rel=\"external\">Immutable-js</a> 是完全可能的。这个库的作者 Lee Byron 在最近的一次 React.js 为主题的会议中进行了一个 <a href=\"https://www.youtube.com/embed/I7IdS-PbEgI\" target=\"_blank\" rel=\"external\">精彩的介绍</a>。</p>\n<p>同时我建议看一下 Rich Hickey’s 的 <a href=\"http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey\" target=\"_blank\" rel=\"external\">Persistent Data Structures And Managed References</a>, 去了解状态管理的方法。</p>\n<p>我自己现在一直在为不可变数据数据结构 <a href=\"http://blog.deveo.com/immutability-in-ruby-part-1-data-structures/\" target=\"_blank\" rel=\"external\">写诗</a>，但我绝对没有预见到它会进入前端 UI 框架行列。它看起来似乎不遗余力的发生着，而 Angular 的人 <a href=\"http://victorsavkin.com/post/110170125256/change-detection-in-angular-2\" target=\"_blank\" rel=\"external\">正在为支持这个而努力着</a>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>检测变化时 UI 开发中的核心问题，而 JavaScript 框架们以各种方式解决这个问题。</p>\n<p>EmberJS 能在它们发生变化的时候检测到，因为它控制着你的数据模型 API，并且可以在你调用它的时候触发事件。</p>\n<p>Angular.js 是事后进行检测， 它通过重新运行你已经在 UI 中注册的所有数据绑定，来检测它们的值是否已经发生变化。</p>\n<p>React 的检测方法是通过把整个 UI 重新渲染成一个虚拟 DOM，然后和旧的版本进行对比。无论改变了什么，都可以给真实 DOM 打上个补丁。</p>\n<p>React 和 不可变数据结构的组合，对比纯粹的 React 有所增强，通过快速的在组件树中标记不可变的节点。因为组件内的变化是不被允许的。但是，这不是主要出于性能的原因，而是由于它对整个应用程序体系结构有积极的影响。</p>\n<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><p><a href=\"http://teropa.info/blog/2015/03/02/change-and-its-detection-in-javascript-frameworks.html\" target=\"_blank\" rel=\"external\">Changes and Its detection of JavaScript Framework</a></p>\n","excerpt":"","more":"<h2 id=\"译者言\"><a href=\"#译者言\" class=\"headerlink\" title=\"译者言\"></a>译者言</h2><p>近几年可谓是 JavaScript 的大爆炸纪元，各种框架类库层出不穷，它们给前端带来一个又一个的新思想。从以前我们用的 jQuery 直接操作 DOM，到 BackboneJS、Dojo 提供监听器的形式，在到 Ember.js、AngularJS 数据绑定的理念，再到现在的 React、Vue 虚拟 DOM 的思想。都是在当前 Web 应用日益复杂的时代，对于如何处理「应用状态」与「用户界面」之间如何更新的问题，带来更先进的解决方案。</p>\n<p>本文是一篇从技术上，以数据变更和UI同步为方向，循序渐进的讲述 JavaScript 框架如何演进过来的。</p>\n<p>本篇文章，给了我一个更加高纬度的视角，来看待 JavaScript 这些个框架。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>在 2015 年，JavaScript 框架的选择并不少。在 Angular，Ember，React，Backbone 以及它们众多的竞争者中，有足够多的选择。</p>\n<p>虽然可以通过不少方面来对比这些框架的不同，但是最让人感兴趣的是它们分别如何管理状态（state）的。特别的，通过思考这些框架分别如何处理状态变化是很有用的。它们都提供了什么样的工具让你把这些变化呈现给用户？ </p>\n<p>如何处理应用状态（app state）与用户界面（user interface）之间的同步，长期以来都是用户界面开发如此复杂的主要原因。现在，我们有几个不同的处理方案。本文探索以下：Ember 的数据绑定，Angular 的脏检查、React 的虚拟DOM以及它与不可变数据结构（immutable data structures）之间的联系。</p>\n<h2 id=\"数据映射-Projecting-Data\"><a href=\"#数据映射-Projecting-Data\" class=\"headerlink\" title=\"数据映射 Projecting Data\"></a>数据映射 Projecting Data</h2><p>我们首先讨论程序内部的状态与屏幕所看到的内容之间的映射。你把各种诸如 object，arrays，strings，以及 numbers 转换成一颗由诸如 texts、forms、links、buttons 和 images 组成的树状结构。在 Web 中，前者通常指 JavaScript 中的数据结构，而后者指的是 <a href=\"https://www.w3.org/DOM/\">DOM （Document Object Model）</a></p>\n<p>我们经常称这个过程为渲染（rendering），你可以想象这个过程是从数据模型到用户界面的一个映射。当你把数据渲染成一个模板，你得到的是一个 DOM（或者说 HTML）。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/15B722FCBCB7A5D72D240DC5B55F7DDE.svg\" alt=\"onchange_base.svg\"></p>\n<p>这个过程本身已经足够简单了，数据模型到用户界面之间的映射，并不总是那么的琐碎。它基本只是一个接受输入然后直接输出的函数。</p>\n<p>在我们需要考虑数据开始随着时间而变化的时候，这件事就变得更有挑战性了。当用户进行操作或者其它某些操作导致数据产生变化的时候，用户界面需要呈现出这些变化。而且，由于重新构建 DOM 树的代价是极其昂贵的，我们要尽可能产生小的影响。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/1D6EF2506F41A57871712CBCAD1463F8.svg\" alt=\"onchange_change.svg\"></p>\n<p>因为状态产生了变化，这比只是一次性渲染用户界面变得更加难。这就到了以下解决方案开始表演的时候了。</p>\n<h2 id=\"服务器渲染-Server-Side-Rendering\"><a href=\"#服务器渲染-Server-Side-Rendering\" class=\"headerlink\" title=\"服务器渲染 Server-Side Rendering\"></a>服务器渲染 Server-Side Rendering</h2><blockquote>\n<p>宇宙是永恒不变的，没有任何变化</p>\n</blockquote>\n<p>在 JavaScript 新纪元之前，你的 Web 应用的任何交互都会触发一趟服务器的环绕旅行。每一个点击和每一个表单提交都会卸载当前页面，一个请求发送到服务器，服务器响应一个新的页面，然后浏览器重新渲染。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_reload.svg\" alt=\"onchange_reload.svg\"></p>\n<p>这种方式不需要前端管理任何的状态（state）。就前端范畴而言，当一些事情发生了(后端返回的数据)，整个过程就结束了。就算有状态，那也只是后端的范畴。前端只是由 HTML 和 CSS 构成，也许有时候会有些 JavaScript 撒在表面调味。</p>\n<p>从前端来说，这是一个很简单的实现方式，但也是一个很慢的方式。每一个交互并不仅仅触发UI的重渲染，还涉及服务器的数据查询以及服务端渲染。</p>\n<p>大多数人已经不再这样做了，我们可以在服务器端初始化我们的应用，然后转移到前端来做状态的管理（这也是 <a href=\"http://isomorphic.net/\">isomorphic JavaScript</a> 致力于的。）。已经有人在类似的<a href=\"https://signalvnoise.com/posts/3112-how-basecamp-next-got-to-be-so-damn-fast-without-using-much-client-side-ui\">更复杂的设计思想</a>中取得成功。</p>\n<h2 id=\"JS第一代革命：手动重渲染\"><a href=\"#JS第一代革命：手动重渲染\" class=\"headerlink\" title=\"JS第一代革命：手动重渲染\"></a>JS第一代革命：手动重渲染</h2><blockquote>\n<p>我不知道哪些需要渲染的，你来告诉我。</p>\n</blockquote>\n<p>第一代革命的 JavaScript 框架，如：Backbone.js, Ext JS 以及 Dojo。第一次在浏览器端引入了数据模型（Data Model）的概念，代替了以前那些直接操作 DOM 的轻量级的脚本代码。这意味着你终于可以在浏览器端管理状态了。当数据模型的上下文改变时，你需要做一些工作，让改变呈现在用户界面中。</p>\n<p>这些框架的体系能分离你的模型和界面代码，但同时也留下了一大部分同步的工作给你。你可以监听某类事件的发生，但是你有义务去计算如何重新渲染以及如何落实到用户界面中。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_manual.svg\" alt=\"onchange_manual.svg\"></p>\n<p>基于这种模型，作为开发者，你需要考虑大量的性能问题。由于你能控制什么时候和怎么处理更新，你可以从中做任意的做一些调整。这经常会面临一些权衡：简单的处理导致大面积的页面更新，或者强性能的处理来更新一小块页面。</p>\n<h2 id=\"Ember-js-数据绑定\"><a href=\"#Ember-js-数据绑定\" class=\"headerlink\" title=\"Ember.js: 数据绑定\"></a>Ember.js: 数据绑定</h2><blockquote>\n<p>由于我在控制你的模型和试图，我会确切知道如何重新渲染。</p>\n</blockquote>\n<p>当应用状态改变的时候，手动处理渲染工作，无可避免的增加了复杂度。很多框架旨在解决这个问题，<a href=\"https://emberjs.com\">Ember.js</a> 就是其中之一。</p>\n<p>Ember，像 Backbone 一样，当数据模型改变的时候会触发某个事件。不同之处在于 Ember 同时提供了一些方法来接收这些事件。你可以把 UI 绑定到数据模型中，这意味着有一个监听器绑定到了 UI 上。该监听器当收到事件的时候，知道如何更新 UI。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_kvo.svg\" alt=\"onchange_kvo.svg\"></p>\n<p>这是一个高效率的机制。尽管设置全部的监听器需要在初始化时多出一些工作，但是之后就能保证同步状态时的最小影响。当状态产生变化时， 只有真正需要更新的部分才会发生改变。</p>\n<p>这种方式最大的牺牲是 Ember 需要时刻盯着数据模型。这意味着你需要通过 Ember 的 API 封装你的数据，以及你要更新数据的时候是使用 <code>foo.set(&#39;x&#39;,42)</code> 而不是 <code>foo.x = 42</code>，以此类推。</p>\n<p>在未来 ES6 的 Proxies 可能会对这种模式产生一定的帮助。它让 Ember 可以通过装饰 object 来绑定那些监听器的代码。这就不用像传统方式那样重写 object 的 setter 方法了。</p>\n<h2 id=\"AngularJS：脏检查\"><a href=\"#AngularJS：脏检查\" class=\"headerlink\" title=\"AngularJS：脏检查\"></a>AngularJS：脏检查</h2><blockquote>\n<p>我不知道什么更新了，所以当更新的时候，我只能检查所有的东西。</p>\n</blockquote>\n<p>AngularJS 类似于 Ember，当状态改变的时候，必须人工去处理。但不同的是，AngularJS 从不同的角度来解决问题。</p>\n<p>当你在 Angular 模板中引用你的数据，例如这样的语句 <code></code> ，Angular 不仅仅只是渲染数据，而且会这个特定的数据创建一个观察者。如此，只要你的应用中发生任何变化，Angular 都会检查这个观察者检视着的数据是否发生了改变。如果发生了改变，就会重新渲染这个数据对应的用户界面。这个过程称作脏检查（Dirty Checking）。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_watch.svg\" alt=\"onchange_watch.svg\"></p>\n<p>这种监听改变的风格最大的好处就是，你可以在你的数据模型中使用任何姿势。Angular 对此没有任何限制，它不关心这个。没有基础的对象需要扩展，也没有 API 需要调用。</p>\n<p>但坏处就是现在数据模型没有任何内建的检测手段告诉告诉框架哪些东西发生了改变，框架对是否或者哪里发生了改变没有任何洞察力。这意味着数据模型需要通过外部来监听改变，而 Angular 就是这样子做的：所有观察者在任何时间发生的任何改变，都需要被执行一次。点击事件，HTTP 响应，timeout 方法的触发，对于这些，观察者都需要执行一遍。</p>\n<p>经常去执行所有观察者，这听起来像是性能的噩梦，但是它令人惊讶的快。这主要是因为在检查到任何改变之前，没有 DOM 的操作过程，而原生的 JavaScript 引用对象的检查平均消耗的性能是廉价的。但是当你要处理大量的 UI 或者经常性触发重新渲染，那么额外的性能优化手段就变得很有必要了。</p>\n<p>Ember 和 Angular 都即将得益于即将到来的标准：ECMAScript7 的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\">Object.observe</a> 功能，很适合 Angular。它提供了原生的 API 给你用来监听对象属性的变化。尽管这样，Angular 不需要支持所有的用例，因为 Angular 的观察者相对于简单的监听对象属性，可以做到的更好。</p>\n<p>即将到来的 Angular 2 在检测改变这件事上带来了很多有趣的更新，最近 <a href=\"http://victorsavkin.com/post/110170125256/change-detection-in-angular-2\">Victor Savkin 的一篇文章</a>有介绍到。</p>\n<p>关于这个主题，也可以看：<a href=\"https://www.youtube.com/watch?v=jvKGQSFQf10&amp;feature=youtu.be\">Victor’s ng-conf talk</a></p>\n<h2 id=\"React-虚拟-DOM\"><a href=\"#React-虚拟-DOM\" class=\"headerlink\" title=\"React: 虚拟 DOM\"></a>React: 虚拟 DOM</h2><blockquote>\n<p>我不知道到底哪些发生了变化，所以我只能重新渲染所有东西，然后看一下有哪些不同。</p>\n</blockquote>\n<p>React 有很多有趣的特性，但是我们讨论的最有趣的特性是虚拟 DOM。</p>\n<p>像 Angular 一样，React 不会对数据模型进行限制，而是让你使用你认为合适的任何对象和数据结构。那么，它是如何在存在改变的情况下使 UI 保持最新呢？</p>\n<p>React 所做的是有效的把我们带回服务器渲染时代，当时我们还不关心状态变化：每当某处发生改变的时候，它会从头重新渲染整个 UI。这可以显著的简化 UI 的代码。大部分情况，你不会关心如何在 React 中维护状态。就像服务器渲染一样，渲染一次就算了。当组件需要变更时，它只能再次重新渲染。组价的初始化渲染和更细它的数据之间，没有任何区别。</p>\n<p>如果故事就这么结束的话，它看起来的确非常低效。然而，React 在重新渲染方面，有点特殊。</p>\n<p>当 React 进行重新渲染时，它首先会渲染到虚拟 DOM 中，这不是一个实际的 DOM 对象的图。而是一个轻量级的，有纯粹的 object 和 array 组成的纯 JavaScript 的数据结构，它代表着一个真实的 DOM 对象的图。</p>\n<p>然后，一个独立的进程会根据虚拟 DOM 的结构来创建那些在屏幕上显示的真实的 DOM 元素。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_vdom_initial.svg\" alt=\"onchange_vdom_initial.svg\"></p>\n<p>之后，当变化发生的时候，一个新的虚拟 DOM 会被从头到尾创建出来。这个新的虚拟 DOM 将映射出数据模型的新的状态。现在 React 在手上有两个虚拟 DOM：一个新的，一个旧的。然后会对两个虚拟 DOM 进行一个对比算法，得出它们之间的一组变化。有且只有这些更改会被应用到真实 DOM 中：此元素已添加，此属性以改变，等等。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_vdom_change.svg\" alt=\"onchange_vdom_change.svg\"></p>\n<p>所以 React 起码至少有一个好处，就是你不用追踪变化了。你只需要每次重新渲染整个 UI ，然后无论改变了什么最终都会得到相应的结果。React 的虚拟 DOM 对比算法，能让你做到这一点，并且最大限度的节省昂贵的 DOM 操作。</p>\n<h2 id=\"Om-不可改变的数据结构\"><a href=\"#Om-不可改变的数据结构\" class=\"headerlink\" title=\"Om: 不可改变的数据结构\"></a>Om: 不可改变的数据结构</h2><blockquote>\n<p>我确切的知道哪些没有改变。</p>\n</blockquote>\n<p>虽然 React 的虚拟 DOM 相当的块，但是当你的 UI 非常庞大或者经常性渲染的时候（例如：每秒高达 60 次），它依然会面临瓶颈。</p>\n<p>问题在于，真的没办法每次都渲染出整个虚拟 DOM，除非你引入一些方法来控制数据模型的改变，就像 Ember 做的一样。</p>\n<p>一种控制变化的办法是 <a href=\"http://en.wikipedia.org/wiki/Persistent_data_structure\">不可改变的，持久化的数据结构</a>。这些看起来似乎很适合使用在 React 的虚拟 DOM 中，正如 David Nolen 在 <a href=\"https://github.com/omcljs/om\">Om</a> 库中所做的 <a href=\"http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/\">工作</a> 那样，一个构建于 React 和 <a href=\"https://github.com/clojure/clojurescript\">ClojureScript</a> 之上的库。</p>\n<p>有一点关于不可改变数据结构的是，顾名思义，你永远不能改变它，只能产生新的版本。如果你想改变一个对象的属性，你只能新建一个对象和属性，因为你不能改变已经存在的那一个。由于持久化数据结构的工作方式，这比听起来更加有效率。</p>\n<p>这意味着在检测变化方面，当 React 组件都只由不可变数据组成的时候，只有一个逃生窗口：当你重新渲染一个组件时，组件的状态仍然指向上次渲染时的相同数据结构，你就可以跳过这次重新渲染。你可以使用该组件的先前的虚拟 DOM 以及源自该组件的整个组件树。没有必要进一步挖掘，因为在这个状态中所有东西都不可能改变。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_immutable.svg\" alt=\"onchange_immutable.svg\"></p>\n<p>就像 Ember 一样，像 Om 的这种库不允许在你的数据中使用旧的 JavaScript 对象图。你必须在不可变数据结构中构建你的数据模型，从而才能在其中得到好处。我会赞同这样的做法，因为这一次你这样做并不是为了取悦框架本身。你这样做只是因为这是一个又简单又好的方式去管理你的应用状态。使用不可变数据结构的主要好处，并不是提升渲染性能，而是简化你的应用结构。</p>\n<p>虽然 Om 和 ClojureScript 已经讲 React 和不可变数据结构融合起来，但是他们并不是圈子里面的唯一组合。而仅仅使用 React 和 Facebook 的 <a href=\"http://facebook.github.io/immutable-js/\">Immutable-js</a> 是完全可能的。这个库的作者 Lee Byron 在最近的一次 React.js 为主题的会议中进行了一个 <a href=\"https://www.youtube.com/embed/I7IdS-PbEgI\">精彩的介绍</a>。</p>\n<p>同时我建议看一下 Rich Hickey’s 的 <a href=\"http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey\">Persistent Data Structures And Managed References</a>, 去了解状态管理的方法。</p>\n<p>我自己现在一直在为不可变数据数据结构 <a href=\"http://blog.deveo.com/immutability-in-ruby-part-1-data-structures/\">写诗</a>，但我绝对没有预见到它会进入前端 UI 框架行列。它看起来似乎不遗余力的发生着，而 Angular 的人 <a href=\"http://victorsavkin.com/post/110170125256/change-detection-in-angular-2\">正在为支持这个而努力着</a>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>检测变化时 UI 开发中的核心问题，而 JavaScript 框架们以各种方式解决这个问题。</p>\n<p>EmberJS 能在它们发生变化的时候检测到，因为它控制着你的数据模型 API，并且可以在你调用它的时候触发事件。</p>\n<p>Angular.js 是事后进行检测， 它通过重新运行你已经在 UI 中注册的所有数据绑定，来检测它们的值是否已经发生变化。</p>\n<p>React 的检测方法是通过把整个 UI 重新渲染成一个虚拟 DOM，然后和旧的版本进行对比。无论改变了什么，都可以给真实 DOM 打上个补丁。</p>\n<p>React 和 不可变数据结构的组合，对比纯粹的 React 有所增强，通过快速的在组件树中标记不可变的节点。因为组件内的变化是不被允许的。但是，这不是主要出于性能的原因，而是由于它对整个应用程序体系结构有积极的影响。</p>\n<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><p><a href=\"http://teropa.info/blog/2015/03/02/change-and-its-detection-in-javascript-frameworks.html\">Changes and Its detection of JavaScript Framework</a></p>\n"},{"title":"BeautyWe.js 一套专注于微信小程序的开发范式","date":"2019-06-11T06:22:25.000Z","_content":"\n\n![](https://raw.githubusercontent.com/beautywe/docs/master/docs/assets/images/logo-V4.png)\n\n\n> 官网：[beautywejs.com](http://beautywejs.com)    \n> Repo: [beautywe](https://github.com/beautywe/beautywe)\n\n\n# 一个简单的介绍\n\n**BeautyWe.js 是什么？**\n\n它是一套专注于微信小程序的企业级开发范式，它的愿景是：\n\n> 让企业级的微信小程序项目中的代码，更加简单、漂亮。\n\n**为什么要这样命名呢？**\n\n> Write **beautiful** code for **we**chat mini program by the **beautiful** **we**!\n\n「We」 既是我们的 **We**，也是微信的 **We**，Both beautiful！\n\n**那么它有什么卖点呢？**\n\n1. 专注于微信小程序环境，写原汁原味的微信小程序代码。\n2. 由于只专注于微信小程序，它的源码也很简单。\n3. 插件化的编程方式，让复杂逻辑更容易封装。\n4. 再加上一些配套设施：\n    1. 一些官方插件。\n    2. 一套开箱即用，包含了工程化、项目规范以及微信小程序环境独特问题解决方案的框架。\n    3. 一个CLI工具，帮你快速创建应用，页面，组件等。\n\n**它由以下几部分组成：**\n\n* **一个插件化的核心** - [BeautyWe Core](https://github.com/beautywe/beautywe)    \n    对 App、Page 进行抽象和包装，保持传统微信小程序开发姿势，同时开放部分原生能力，让其具有「可插件化」的能力。\n\n* **一些官方插件** — [BeautyWe Plugins](https://www.npmjs.com/search?q=keywords%3Abeautywe-plugin)    \n    得益于 Core 的「可插件化」特性，封装复杂逻辑，实现可插拔。官方对于常见的需求提供了一些插件：如增强存储、发布/订阅、状态机、Logger、缓存策略等。\n\n* **一套开箱即用的项目框架** - [BeautyWe Framework](https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/contents/framework/introduce)    \n    描述了一种项目的组织形式，开箱即用，集成了 `BeautyWe Core` ，并且提供了如：全局窗口、开发规范、多环境开发、全局配置、NPM 等解决方案。\n\n* **一个CLI工具** - [BeautyWe Cli](https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/remote/cli)    \n    提供快速创建应用、页面、插件，以及项目构建功能的命令行工具。并且还支持自定义的创建模板。\n\n# 一个简单的例子\n\n下载\n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181427)\n\n用 BeautyWe 包装你的应用\n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181445)\n\n之后，你就能使用 BeautyWe Plugin 提供的能力了。\n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181337)\n\n# 开放原生App/Page，支持插件化\n\n`new BtApp({...})` 的执行结果是对原生的应用进行包装，其中包含了「插件化」的处理，然后返回一个新的实例，这个实例适配原生的 `App()` 方法。\n\n下面来讲讲「插件化」到底做了什么事情。\n\n首先，插件化开放了原生 App 的四种能力：\n\n1. **Data 域**\n    把插件的 Data 域合并到原生 App 的 Data 域中，这一块很容易理解。\n    \n2. **原生钩子函数**\n    使原生钩子函数（如 `onShow`, `onLoad`）可插件化。让原生App与多个插件可以同时监听同一个钩子函数。如何工作的，下面会细说。\n    \n3. **事件钩子函数**\n    使事件钩子函数（与 view 层交互的钩子函数），尽管在实现上有一些差异，但是实现原理跟「原生钩子函数」一样的。\n\n4. **自定义方法**\n    让插件能够给使用者提供 API。为了保证插件提供的 API 足够的优雅，支持当调用插件 API 的时候（如 event 插件 `this.event.on(...)`)，API 方法内部仍然能通过 `this` 获取到原生实例。\n\n#### 钩子函数的插件化\n\n原生钩子函数，事件钩子函数我们统一称为「钩子函数」。\n\n对于每一个钩子函数，内部是维护一个以 Series Promise 方式执行的执行队列。\n\n以 `onShow` 为例，将会以这样的形式执行：\n\n> native.onShow → pluginA.onShow → pluginB.onShow → ...\n\n**下面深入一下插件化的原理**：\n\n![beautywe pluggable](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181648)\n\n工作原理是这样的：    \n1. 经过 `new BtApp(...)` 包装，所有的钩子函数，都会有一个独立的执行队列，    \n2. 首先会把原生的各个钩子函数 `push` 到对应的队列中。然后每 `use` 插件的时候，都会分解插件的钩子函数，往对应的队列 `push`。    \n3. 当 `Native App`（原生）触发某个钩子的时候，`BtApp` 会以 Promise Series 的形式按循序执行对应队列里面的函数。    \n4. 特殊的，`onLaunch` 和 `onLoad` 的执行队列中，会在队列顶部插入一个初始化的任务（`initialize`），它会以同步的方式按循序执行 `Initialize Queue` 里面的函数。这正是插件生命周期函数中的 `plugin.initialize`。\n\n这种设计能提供以下功能：\n1. 可插件化。\n    只需要往对应钩子函数的事件队列中插入任务。\n    \n2. 支持异步。\n    由于是以 Promise Series 方式运行的，其中一个任务返回一个 Promise，下一个任务会等待这个任务完成再开始。如果发生错误，会流转到原生的 `onError()` 中。\n    \n3. 解决了微信小程序 `app.js` 中 `getApp() === undefinded `问题。\n    造成这个问题，本质是因为 `App()` 的时候，原生实例未创建。但是由于 Promise 在 event loop 中是一个微任务，被注册在下一次循环。所以 Promise 执行的时候 `App()` 早已经完成了。\n\n# 一些官方插件\n\nBeautyWe 官方提供了一系列的插件：\n\n1. 增强存储: Storage\n2. 数据列表：List Page\n3. 缓存策略：Cache\n4. 日志：Logger\n5. 事件发布/订阅：Event\n6. 状态机：Status\n\n它们的使用很简单，哪里需要插哪里。\n由于篇幅的原因，下面挑几个比较有趣的来讲讲，更多的可以看看官方文档：[BeautyWe](http://beautywejs.com)\n\n## 增强存储 Storage\n\n该功能由 [@beautywe/plugin-storage](https://github.com/beautywe/plugin-storage) 提供。\n\n由于微信小程序原生的数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。\n\n所以该插件在 `wx.getStorage/setStorage` 的基础上，提供了两种扩展能力：\n\n1. 过期控制\n2. 版本隔离\n\n\n**一些简单的例子**\n\n安装\n```javascript\nimport { BtApp } from '@beautywe/core';\nimport storage from '@beautywe/plugin-storage';\n\nconst app = new BtApp();\napp.use(storage());\n```\n\n过期控制\n```javascript\n// 7天后过期\napp.storage.set('name', 'jc', { expire: 7 })；\n```\n\n版本隔离\n```javascript\napp.use({ appVersion: '0.0.1' });\napp.set('name', 'jc');\n\n// 返回 jc\napp.get('name');\n\n// 当版本更新后\napp.use({ appVersion: '0.0.2' });\n\n// 返回 undefined;\napp.get('name');\n```\n\n更多的查看 [@beautywe/plugin-storage 官方文档](https://github.com/beautywe/plugin-storage)\n\n## 数据列表 List Page\n\n对于十分常见的数据列表分页的业务场景，`@beautywe/plugin-listpage` 提供了一套打包方案：\n\n1. 满足常用「数据列表分页」的业务场景\n2. 支持分页\n3. 支持多个数据列表\n4. 自动捕捉下拉重载：`onPullDownRefresh`\n5. 自动捕捉上拉加载：`onReachBottom`\n6. 自带请求锁，防止帕金森氏手抖用户\n7. 简单优雅的 API\n\n\n一个简单的例子：\n\n```javascript\nimport BeautyWe from '@beautywe/core';\nimport listpage from '@beautywe/plugin-listpage';\n\nconst page = new BeautyWe.BtPage();\n\n// 使用 listpage 插件\npage.use(listpage({\n    lists: [{\n        name: 'goods',  // 数据名\n        pageSize: 20,   // 每页多少条数据，默认 10\n\n        // 每一页的数据源，没次加载页面时，会调用函数，然后取返回的数据。\n        fetchPageData({ pageNo, pageSize }) {\n        \n            // 获取数据\n            return API.getGoodsList({ pageNo, pageSize })\n            \n                // 有时候，需要对服务器的数据进行处理，dataCooker 是你定义的函数。\n                .then((rawData) => dataCooker(rawData));\n        },\n    }],\n    enabledPullDownRefresh: true,    // 开启下拉重载， 默认 false\n    enabledReachBottom: true,    // 开启上拉加载， 默认 false\n}));\n\n// goods 数据会被加载到，goods 为上面定义的 name\n// this.data.listPage.goods = {\n//     data: [...],     // 视图层，通过该字段来获取具体的数据\n//     hasMore: true,   // 视图层，通过该字段来识别是否有下一页\n//     currentPage: 1,  // 视图层，通过该字段来识别当前第几页\n//     totalPage: undefined,\n// }\n```\n\n只需要告诉 `listpage` 如何获取数据，它会自动处理「下拉重载」、「上拉翻页」的操作，然后把数据更新到 `this.data.listPage.goods` 下。\n\nView 层只需要描述数据怎么展示：\n\n```html\n<view class=\"good\" wx:for=\"listPage.goods.data\">\n    ...\n</view>\n<view class=\"no-more\" wx:if=\"listPage.goods.hasMore === false\">\n    没有更多了\n</view>\n```\n\n`listpage` 还支持多数据列表等其他更多配置，详情看：[@beautywe/plugin-listpage](https://github.com/beautywe/plugin-listpage)\n\n## 缓存策略 Cache\n\n`@beautywe/plugin-cache` 提供了一个微信小程序端缓存策略，其底层由 [super-cache](https://github.com/JerryC8080/super-cache) 提供支持。\n\n#### 特性\n  1. 提供一套「服务端接口耗时慢，但加载性能要求高」场景的解决方案\n  2. 满足最基本的缓存需求，读取（get）和保存（set）\n  2. 支持针对缓存进行逻辑代理\n  3. 灵活可配置的数据存储方式\n\n#### How it work\n\n一般的请求数据的形式是，页面加载的时候，从服务端获取数据，然后等待数据返回之后，进行页面渲染：\n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181755)\n\n但这种模式，会受到服务端接口耗时，网络环境等因素影响到加载性能。   \n\n对于加载性能要求高的页面（如首页），一般的 Web 开发我们有很多解决方案（如服务端渲染，服务端缓存，SSR 等）。      \n但是也有一些环境不能使用这种技术（如微信小程序）。\n\nSuper Cache 提供了一个中间数据缓存的解决方案：\n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181847)\n\n思路：    \n1. 当你需要获取一个数据的时候，如果有缓存，先把旧的数据给你。\n2. 然后再从服务端获取新的数据，刷新缓存。\n3. 如果一开始没有缓存，则请求服务端数据，再把数据返回。\n4. 下一次请求缓存，从第一步开始。\n\n这种解决方案，舍弃了一点数据的实时性（非第一次请求，只能获取上一次最新数据），大大提高了前端的加载性能。    \n适合的场景：    \n1. 数据实时性要求不高。\n2. 服务端接口耗时长。\n\n#### 使用\n\n```javascript\nimport { BtApp } from '@beautywe/core';\nimport cache from '@beautywe/plugin-cache';\n\nconst app = new BtApp();\napp.use(cache({\n    adapters: [{\n        key: 'name',\n        data() {\n            return API.fetch('xxx/name');\n        }\n    }]\n}));\n```\n\n假设 `API.fetch('xxx/name')` 是请求服务器接口，返回数据：`data_from_server`\n\n那么：\n\n```javascript\napp.cache.get('name').then((value) => {\n    // value: 'data_from_server'  \n});\n```\n\n更多的配置，详情看：[@beautywe/plugin-cache](https://github.com/beautywe/plugin-cache)\n\n\n## 日志 Logger\n\n由 `@beautywe/logger-plugin` 提供的一个轻量的日志处理方案，它支持：\n\n1. 可控的 log level\n2. 自定义前缀\n3. 日志统一处理\n\n#### 使用\n\n```javascript\nimport { BtApp } from '@beautywe/core';\nimport logger from '@beautywe/plugin-logger';\n\nconst page = new BtApp();\n\npage.use(logger({\n    // options\n}));\n```\n\n**API**\n\n```javascript\npage.logger.info('this is info');\npage.logger.warn('this is warn');\npage.logger.error('this is error');\npage.logger.debug('this is debug');\n\n// 输出\n// [info] this is info\n// [warn] this is warn\n// [error] this is error\n// [debug] this is debug\n```\n\n**Level control**\n\n可通过配置来控制哪些 level 该打印：\n\n```javascript\npage.use(logger({\n    level: 'warn',\n}));\n```\n\n那么 `warn` 以上的 log （`info`, `debug`）就不会被打印，这种满足于开发和生成环境对 log 的不同需求。\n\nlevel 等级如下：\n\n```javascript\nLogger.LEVEL = {\n    error: 1,\n    warn: 2,\n    info: 3,\n    debug: 4,\n};\n```\n\n更多的配置，详情看：[@beautywe/plugin-logger](https://github.com/beautywe/plugin-logger)\n\n\n# BeautyWe Framework\n\n`@beautywe/core` 和 `@beautywe/plugin-...` 给小程序提供了：\n\n1. 开放原生，支持插件化 —— by core\n2. 各种插件 —— by plugins\n\n但是，还有很多的开发中实际还会遇到的痛点，是上面两个解决不到的。\n如项目的组织、规范、工程化、配置、多环境等等\n\n这些就是，「BeautyWe Framework」要解决的范畴。\n\n它作为一套开箱即用的项目框架，提供了这些功能：\n\n* 集成 BeautyWe Core\n* NPM 支持\n* 全局窗口\n* 全局 Page，Component\n* 全局配置文件\n* 多环境开发\n* Example Pages\n* 正常项目需要的标配：ES2015+,sass,uglify,watch 等\n* 以及我们认为良好的项目规范（eslint，commit log，目录结构等）\n\n也是由于篇幅原因，挑几个有趣的来讲讲，更多的可以看看官方文档：[BeautyWe](http://beautywejs.com)\n\n## 快速创建\n\n首先安装 `@beautywe/cli`\n\n```shell\n$ npm i @beautywe/cli -g\n```\n\n\n#### 创建应用\n```shell\n$ beautywe new app\n\n> appName: my-app\n> version: 0.0.1\n> appid: 123456\n> 这样可以么:\n> {\n>    \"appName\": \"my-app\",\n>    \"version\": \"0.0.1\",\n>    \"appid\": \"123456\"\n> }\n```\n\n回答几个问题之后，项目就生成了：\n\n```shell\nmy-app\n├── gulpfile.js\n├── package.json\n└── src\n    ├── app.js\n    ├── app.json\n    ├── app.scss\n    ├── assets\n    ├── components\n    ├── config\n    ├── examples\n    ├── libs\n    ├── npm\n    ├── pages\n    └── project.config.json\n```\n\n#### 创建页面、组件、插件\n\n**页面**\n1. 主包页面：`beautywe new page <path|name>`\n2. 分包页面：`beautywe new page --subpkg <subPackageName> <path|name>`\n\n**组件**\n1. `beautywe new component <name>`\n\n**插件**\n1. `beautywe new plugin <name>`\n\n#### 自定义模板\n\n在 `./.templates` 目录中，存放着快速创建命令的创建模板：\n\n```shell\n$ tree .templates\n\n.templates\n├── component\n│   ├── index.js\n│   ├── index.json\n│   ├── index.scss\n│   └── index.wxml\n├── page\n│   ├── index.js\n│   ├── index.json\n│   ├── index.scss\n│   └── index.wxml\n└── plugin\n    └── index.js\n```\n\n可以修改里面的模板，来满足项目级别的自定义模板创建。\n\n## 全局窗口\n\n我们都知道微信小程序是「单窗口」的交互平台，一个页面对应一个窗口。    \n而在业务开发中，往往会有诸如这种述求：\n\n1. 自定义的 toast 样式\n2. 页面底部 copyright\n3. 全局的 loading 样式\n4. 全局的悬浮控件    \n......\n\n稍微不优雅的实现可以是分别做成独立的组件，然后每一个页面都引入进来。    \n这种做法，我们会有很多的重复代码，并且每次新建页面，都要引入一遍，后期维护也会很繁琐。\n\n而「全局窗口」的概念是：**希望所有页面之上有一块地方，全局性的逻辑和交互，可以往里面搁。**\n\n#### global-view 组件\n\n这是一个自定义组件，源码在 `/src/components/global-view`\n\n每个页面的 wxml 只需要在顶层包一层：\n\n```html\n<global-view id=\"global-view\">\n    ...\n</global-view>\n```\n\n需要全局实现的交互、样式、组件，只需要维护这个组件就足够了。\n\n## 全局配置文件\n\n在 `src/config/` 目录中，可以存放各种全局的配置文件，并且支持以 Node.js 的方式运行。（得益于 [Node.js Power 特性](/contents/framework/concept/nodejs-power.md)）。\n\n如 `src/config/logger.js`:\n\n```javascript\nconst env = process.env.RUN_ENV || 'dev';\n\nconst logger = Object.assign({\n    prefix: 'BeautyWe',\n    level: 'debug',\n}, {\n    // 开发环境的配置\n    dev: {\n        level: 'debug',\n    },\n    // 测试环境的配置\n    test: {\n        level: 'info',\n    },\n    // 线上环境的配置\n    prod: {\n        level: 'warn',\n    },\n}[env] || {});\n\nmodule.exports.logger = logger;\n```\n\n然后我们可以这样读取到 config 内容：\n\n```javascript\nimport { logger } from '/config/index';\n\n// logger.level 会根据环境不同而不同。\n```\n\nBeautywe Framework 默认会把 config 集成到 `getApp()` 的示例中：\n\n```javascript\ngetApp().config;\n```\n\n## 多环境开发\n\nBeautyWe Framework 支持多环境开发，其中预设了三套策略：\n* dev\n* test\n* prod\n\n我们可以通过命令来运行这三个构建策略：\n\n```shell\nbeautywe run dev\nbeautywe run test\nbeautywe run prod\n```\n\n## 三套环境的差异\n\nBeautywe Framework 源码默认在两方面使用了多环境：\n\n* 构建任务（`gulpfile.js/env/...`）\n* 全局配置（`src/config/...`）\n\n### 构建任务的差异\n\n| 构建任务 | 说明 |dev | test | prod |\n|---|---|:---:|:---:|:---:|\n| clean | 清除dist文件 | √ | √ | √ |\n| copy | 复制资源文件 | √ | √ | √ |\n| scripts | 编译JS文件 | √ | √ | √ |\n| sass | 编译scss文件 | √ | √ | √ |\n| npm | 编译npm文件 | √ | √ | √ |\n| nodejs-power | 编译Node.js文件 | √ | √ | √ |\n| watch | 监听文件修改 | √ | | |\n| scripts-min | 压缩JS文件 |  |  | √ |\n| sass-min | 压缩scss文件 |  |  | √ |\n| npm-min | 压缩npm文件 | | | √ |\n| image-min | 压缩图片文件 |  |  | √ |\n| clean-example | 清除示例页面 | | | √ |\n\n\n### Node.js Power\n\nBeautywe Framework 的代码有两种运行环境：\n\n1. Node.js 运行环境，如构建任务等。\n2. 微信小程序运行环境，如打包到 `dist` 文件夹的代码。\n\n#### 运行过程\n\n> Node.js Power 本质是一种静态编译的实现。    \n> 把某个文件在 Node.js 环境运行的结果，输出到微信小程序运行环境中，以此来满足特定的需求。\n\nNode.js Power 会把项目中 `src` 目录下类似 `xxx.nodepower.js` 命名的文件，以 Node.js 来运行，    \n然后把运行的结果，以「字面量对象」的形式写到 `dist` 目录下对应的同名文件 `xxx.nodepower.js` 文件去。\n\n以 `src/config/index.nodepower.js` 为例：\n\n```javascript\nconst fs = require('fs');\nconst path = require('path');\n\nconst files = fs.readdirSync(path.join(__dirname));\n\nconst result = {};\n\nfiles\n    .filter(name => name !== 'index.js')\n    .forEach((name) => {\n        Object.assign(result, require(path.join(__dirname, `./${name}`)));\n    });\n\nmodule.exports = result;\n```\n\n该文件，经过 Node.js Power 构建之后:\n\n`dist/config/index.nodepower.js`: \n\n```javascript\nmodule.exports = {\n    \"appInfo\": {\n        \"version\": \"0.0.1\",\n        \"env\": \"test\",\n        \"appid\": \"wx85fc0d03fb0b224d\",\n        \"name\": \"beautywe-framework-test-app\"\n    },\n    \"logger\": {\n        \"prefix\": \"BeautyWe\",\n        \"level\": \"info\"\n    }\n};\n```\n\n这就满足了，随意往 `src/config/` 目录中扩展配置文件，都能被自动打包。\n\nNode.js Power 已经被集成到多环境开发的 dev, test, prod 中去。\n\n当然，你可以手动运行这个构建任务：\n\n```shell\n$ gulp nodejs-power\n```\n\n### NPM\n\nBeautyWe Framework 实现支持 npm 的原理很简单，总结一句话：\n\n> 使用 webpack 打包 `src/npm/index.js` ，以 commonjs 格式输出到 `dist/npm/index.js`\n\n![npm-works](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181936)\n\n这样做的好处：\n\n1. 实现简单。\n2. 让 npm 包能集中管理，每次引入依赖，都好好的想一下，避免泛滥（尤其在多人开发中）。\n3. 使用 `ll dist/npm/index.js` 命令能快速看到项目中的 npm 包使占了多少容量。\n\n#### 新增 npm 依赖\n\n在 `src/npm/index.js` 文件中，进行 export：\n\n```javscript\nexport { default as beautywe } from '@beautywe/core';\n```\n\n然后在其他文件 import：\n\n```javascript\nimport { beautywe } from './npm/index';\n```\n\n# 更多\n\n总的来说，BeautyWe 是一套微信小程序的开发范式。\n\n`core` 和 `plugins` 扩展原生，提供复杂逻辑的封装和插拔式使用。\n\n而 `framework` 则负责提供一整套针对于微信小程序的企业级项目解决方案，开箱即用。\n\n其中还有更多的内容，欢迎浏览官网：[beautywejs.com](http://beautywejs.com)\n\n","source":"_posts/beautywe-intro.md","raw":"---\ntitle: BeautyWe.js 一套专注于微信小程序的开发范式\ncategory: 搬砖码农\ndate: 2019-06-11 14:22:25\ntags: \n- 小程序\n---\n\n\n![](https://raw.githubusercontent.com/beautywe/docs/master/docs/assets/images/logo-V4.png)\n\n\n> 官网：[beautywejs.com](http://beautywejs.com)    \n> Repo: [beautywe](https://github.com/beautywe/beautywe)\n\n\n# 一个简单的介绍\n\n**BeautyWe.js 是什么？**\n\n它是一套专注于微信小程序的企业级开发范式，它的愿景是：\n\n> 让企业级的微信小程序项目中的代码，更加简单、漂亮。\n\n**为什么要这样命名呢？**\n\n> Write **beautiful** code for **we**chat mini program by the **beautiful** **we**!\n\n「We」 既是我们的 **We**，也是微信的 **We**，Both beautiful！\n\n**那么它有什么卖点呢？**\n\n1. 专注于微信小程序环境，写原汁原味的微信小程序代码。\n2. 由于只专注于微信小程序，它的源码也很简单。\n3. 插件化的编程方式，让复杂逻辑更容易封装。\n4. 再加上一些配套设施：\n    1. 一些官方插件。\n    2. 一套开箱即用，包含了工程化、项目规范以及微信小程序环境独特问题解决方案的框架。\n    3. 一个CLI工具，帮你快速创建应用，页面，组件等。\n\n**它由以下几部分组成：**\n\n* **一个插件化的核心** - [BeautyWe Core](https://github.com/beautywe/beautywe)    \n    对 App、Page 进行抽象和包装，保持传统微信小程序开发姿势，同时开放部分原生能力，让其具有「可插件化」的能力。\n\n* **一些官方插件** — [BeautyWe Plugins](https://www.npmjs.com/search?q=keywords%3Abeautywe-plugin)    \n    得益于 Core 的「可插件化」特性，封装复杂逻辑，实现可插拔。官方对于常见的需求提供了一些插件：如增强存储、发布/订阅、状态机、Logger、缓存策略等。\n\n* **一套开箱即用的项目框架** - [BeautyWe Framework](https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/contents/framework/introduce)    \n    描述了一种项目的组织形式，开箱即用，集成了 `BeautyWe Core` ，并且提供了如：全局窗口、开发规范、多环境开发、全局配置、NPM 等解决方案。\n\n* **一个CLI工具** - [BeautyWe Cli](https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/remote/cli)    \n    提供快速创建应用、页面、插件，以及项目构建功能的命令行工具。并且还支持自定义的创建模板。\n\n# 一个简单的例子\n\n下载\n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181427)\n\n用 BeautyWe 包装你的应用\n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181445)\n\n之后，你就能使用 BeautyWe Plugin 提供的能力了。\n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181337)\n\n# 开放原生App/Page，支持插件化\n\n`new BtApp({...})` 的执行结果是对原生的应用进行包装，其中包含了「插件化」的处理，然后返回一个新的实例，这个实例适配原生的 `App()` 方法。\n\n下面来讲讲「插件化」到底做了什么事情。\n\n首先，插件化开放了原生 App 的四种能力：\n\n1. **Data 域**\n    把插件的 Data 域合并到原生 App 的 Data 域中，这一块很容易理解。\n    \n2. **原生钩子函数**\n    使原生钩子函数（如 `onShow`, `onLoad`）可插件化。让原生App与多个插件可以同时监听同一个钩子函数。如何工作的，下面会细说。\n    \n3. **事件钩子函数**\n    使事件钩子函数（与 view 层交互的钩子函数），尽管在实现上有一些差异，但是实现原理跟「原生钩子函数」一样的。\n\n4. **自定义方法**\n    让插件能够给使用者提供 API。为了保证插件提供的 API 足够的优雅，支持当调用插件 API 的时候（如 event 插件 `this.event.on(...)`)，API 方法内部仍然能通过 `this` 获取到原生实例。\n\n#### 钩子函数的插件化\n\n原生钩子函数，事件钩子函数我们统一称为「钩子函数」。\n\n对于每一个钩子函数，内部是维护一个以 Series Promise 方式执行的执行队列。\n\n以 `onShow` 为例，将会以这样的形式执行：\n\n> native.onShow → pluginA.onShow → pluginB.onShow → ...\n\n**下面深入一下插件化的原理**：\n\n![beautywe pluggable](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181648)\n\n工作原理是这样的：    \n1. 经过 `new BtApp(...)` 包装，所有的钩子函数，都会有一个独立的执行队列，    \n2. 首先会把原生的各个钩子函数 `push` 到对应的队列中。然后每 `use` 插件的时候，都会分解插件的钩子函数，往对应的队列 `push`。    \n3. 当 `Native App`（原生）触发某个钩子的时候，`BtApp` 会以 Promise Series 的形式按循序执行对应队列里面的函数。    \n4. 特殊的，`onLaunch` 和 `onLoad` 的执行队列中，会在队列顶部插入一个初始化的任务（`initialize`），它会以同步的方式按循序执行 `Initialize Queue` 里面的函数。这正是插件生命周期函数中的 `plugin.initialize`。\n\n这种设计能提供以下功能：\n1. 可插件化。\n    只需要往对应钩子函数的事件队列中插入任务。\n    \n2. 支持异步。\n    由于是以 Promise Series 方式运行的，其中一个任务返回一个 Promise，下一个任务会等待这个任务完成再开始。如果发生错误，会流转到原生的 `onError()` 中。\n    \n3. 解决了微信小程序 `app.js` 中 `getApp() === undefinded `问题。\n    造成这个问题，本质是因为 `App()` 的时候，原生实例未创建。但是由于 Promise 在 event loop 中是一个微任务，被注册在下一次循环。所以 Promise 执行的时候 `App()` 早已经完成了。\n\n# 一些官方插件\n\nBeautyWe 官方提供了一系列的插件：\n\n1. 增强存储: Storage\n2. 数据列表：List Page\n3. 缓存策略：Cache\n4. 日志：Logger\n5. 事件发布/订阅：Event\n6. 状态机：Status\n\n它们的使用很简单，哪里需要插哪里。\n由于篇幅的原因，下面挑几个比较有趣的来讲讲，更多的可以看看官方文档：[BeautyWe](http://beautywejs.com)\n\n## 增强存储 Storage\n\n该功能由 [@beautywe/plugin-storage](https://github.com/beautywe/plugin-storage) 提供。\n\n由于微信小程序原生的数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。\n\n所以该插件在 `wx.getStorage/setStorage` 的基础上，提供了两种扩展能力：\n\n1. 过期控制\n2. 版本隔离\n\n\n**一些简单的例子**\n\n安装\n```javascript\nimport { BtApp } from '@beautywe/core';\nimport storage from '@beautywe/plugin-storage';\n\nconst app = new BtApp();\napp.use(storage());\n```\n\n过期控制\n```javascript\n// 7天后过期\napp.storage.set('name', 'jc', { expire: 7 })；\n```\n\n版本隔离\n```javascript\napp.use({ appVersion: '0.0.1' });\napp.set('name', 'jc');\n\n// 返回 jc\napp.get('name');\n\n// 当版本更新后\napp.use({ appVersion: '0.0.2' });\n\n// 返回 undefined;\napp.get('name');\n```\n\n更多的查看 [@beautywe/plugin-storage 官方文档](https://github.com/beautywe/plugin-storage)\n\n## 数据列表 List Page\n\n对于十分常见的数据列表分页的业务场景，`@beautywe/plugin-listpage` 提供了一套打包方案：\n\n1. 满足常用「数据列表分页」的业务场景\n2. 支持分页\n3. 支持多个数据列表\n4. 自动捕捉下拉重载：`onPullDownRefresh`\n5. 自动捕捉上拉加载：`onReachBottom`\n6. 自带请求锁，防止帕金森氏手抖用户\n7. 简单优雅的 API\n\n\n一个简单的例子：\n\n```javascript\nimport BeautyWe from '@beautywe/core';\nimport listpage from '@beautywe/plugin-listpage';\n\nconst page = new BeautyWe.BtPage();\n\n// 使用 listpage 插件\npage.use(listpage({\n    lists: [{\n        name: 'goods',  // 数据名\n        pageSize: 20,   // 每页多少条数据，默认 10\n\n        // 每一页的数据源，没次加载页面时，会调用函数，然后取返回的数据。\n        fetchPageData({ pageNo, pageSize }) {\n        \n            // 获取数据\n            return API.getGoodsList({ pageNo, pageSize })\n            \n                // 有时候，需要对服务器的数据进行处理，dataCooker 是你定义的函数。\n                .then((rawData) => dataCooker(rawData));\n        },\n    }],\n    enabledPullDownRefresh: true,    // 开启下拉重载， 默认 false\n    enabledReachBottom: true,    // 开启上拉加载， 默认 false\n}));\n\n// goods 数据会被加载到，goods 为上面定义的 name\n// this.data.listPage.goods = {\n//     data: [...],     // 视图层，通过该字段来获取具体的数据\n//     hasMore: true,   // 视图层，通过该字段来识别是否有下一页\n//     currentPage: 1,  // 视图层，通过该字段来识别当前第几页\n//     totalPage: undefined,\n// }\n```\n\n只需要告诉 `listpage` 如何获取数据，它会自动处理「下拉重载」、「上拉翻页」的操作，然后把数据更新到 `this.data.listPage.goods` 下。\n\nView 层只需要描述数据怎么展示：\n\n```html\n<view class=\"good\" wx:for=\"listPage.goods.data\">\n    ...\n</view>\n<view class=\"no-more\" wx:if=\"listPage.goods.hasMore === false\">\n    没有更多了\n</view>\n```\n\n`listpage` 还支持多数据列表等其他更多配置，详情看：[@beautywe/plugin-listpage](https://github.com/beautywe/plugin-listpage)\n\n## 缓存策略 Cache\n\n`@beautywe/plugin-cache` 提供了一个微信小程序端缓存策略，其底层由 [super-cache](https://github.com/JerryC8080/super-cache) 提供支持。\n\n#### 特性\n  1. 提供一套「服务端接口耗时慢，但加载性能要求高」场景的解决方案\n  2. 满足最基本的缓存需求，读取（get）和保存（set）\n  2. 支持针对缓存进行逻辑代理\n  3. 灵活可配置的数据存储方式\n\n#### How it work\n\n一般的请求数据的形式是，页面加载的时候，从服务端获取数据，然后等待数据返回之后，进行页面渲染：\n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181755)\n\n但这种模式，会受到服务端接口耗时，网络环境等因素影响到加载性能。   \n\n对于加载性能要求高的页面（如首页），一般的 Web 开发我们有很多解决方案（如服务端渲染，服务端缓存，SSR 等）。      \n但是也有一些环境不能使用这种技术（如微信小程序）。\n\nSuper Cache 提供了一个中间数据缓存的解决方案：\n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181847)\n\n思路：    \n1. 当你需要获取一个数据的时候，如果有缓存，先把旧的数据给你。\n2. 然后再从服务端获取新的数据，刷新缓存。\n3. 如果一开始没有缓存，则请求服务端数据，再把数据返回。\n4. 下一次请求缓存，从第一步开始。\n\n这种解决方案，舍弃了一点数据的实时性（非第一次请求，只能获取上一次最新数据），大大提高了前端的加载性能。    \n适合的场景：    \n1. 数据实时性要求不高。\n2. 服务端接口耗时长。\n\n#### 使用\n\n```javascript\nimport { BtApp } from '@beautywe/core';\nimport cache from '@beautywe/plugin-cache';\n\nconst app = new BtApp();\napp.use(cache({\n    adapters: [{\n        key: 'name',\n        data() {\n            return API.fetch('xxx/name');\n        }\n    }]\n}));\n```\n\n假设 `API.fetch('xxx/name')` 是请求服务器接口，返回数据：`data_from_server`\n\n那么：\n\n```javascript\napp.cache.get('name').then((value) => {\n    // value: 'data_from_server'  \n});\n```\n\n更多的配置，详情看：[@beautywe/plugin-cache](https://github.com/beautywe/plugin-cache)\n\n\n## 日志 Logger\n\n由 `@beautywe/logger-plugin` 提供的一个轻量的日志处理方案，它支持：\n\n1. 可控的 log level\n2. 自定义前缀\n3. 日志统一处理\n\n#### 使用\n\n```javascript\nimport { BtApp } from '@beautywe/core';\nimport logger from '@beautywe/plugin-logger';\n\nconst page = new BtApp();\n\npage.use(logger({\n    // options\n}));\n```\n\n**API**\n\n```javascript\npage.logger.info('this is info');\npage.logger.warn('this is warn');\npage.logger.error('this is error');\npage.logger.debug('this is debug');\n\n// 输出\n// [info] this is info\n// [warn] this is warn\n// [error] this is error\n// [debug] this is debug\n```\n\n**Level control**\n\n可通过配置来控制哪些 level 该打印：\n\n```javascript\npage.use(logger({\n    level: 'warn',\n}));\n```\n\n那么 `warn` 以上的 log （`info`, `debug`）就不会被打印，这种满足于开发和生成环境对 log 的不同需求。\n\nlevel 等级如下：\n\n```javascript\nLogger.LEVEL = {\n    error: 1,\n    warn: 2,\n    info: 3,\n    debug: 4,\n};\n```\n\n更多的配置，详情看：[@beautywe/plugin-logger](https://github.com/beautywe/plugin-logger)\n\n\n# BeautyWe Framework\n\n`@beautywe/core` 和 `@beautywe/plugin-...` 给小程序提供了：\n\n1. 开放原生，支持插件化 —— by core\n2. 各种插件 —— by plugins\n\n但是，还有很多的开发中实际还会遇到的痛点，是上面两个解决不到的。\n如项目的组织、规范、工程化、配置、多环境等等\n\n这些就是，「BeautyWe Framework」要解决的范畴。\n\n它作为一套开箱即用的项目框架，提供了这些功能：\n\n* 集成 BeautyWe Core\n* NPM 支持\n* 全局窗口\n* 全局 Page，Component\n* 全局配置文件\n* 多环境开发\n* Example Pages\n* 正常项目需要的标配：ES2015+,sass,uglify,watch 等\n* 以及我们认为良好的项目规范（eslint，commit log，目录结构等）\n\n也是由于篇幅原因，挑几个有趣的来讲讲，更多的可以看看官方文档：[BeautyWe](http://beautywejs.com)\n\n## 快速创建\n\n首先安装 `@beautywe/cli`\n\n```shell\n$ npm i @beautywe/cli -g\n```\n\n\n#### 创建应用\n```shell\n$ beautywe new app\n\n> appName: my-app\n> version: 0.0.1\n> appid: 123456\n> 这样可以么:\n> {\n>    \"appName\": \"my-app\",\n>    \"version\": \"0.0.1\",\n>    \"appid\": \"123456\"\n> }\n```\n\n回答几个问题之后，项目就生成了：\n\n```shell\nmy-app\n├── gulpfile.js\n├── package.json\n└── src\n    ├── app.js\n    ├── app.json\n    ├── app.scss\n    ├── assets\n    ├── components\n    ├── config\n    ├── examples\n    ├── libs\n    ├── npm\n    ├── pages\n    └── project.config.json\n```\n\n#### 创建页面、组件、插件\n\n**页面**\n1. 主包页面：`beautywe new page <path|name>`\n2. 分包页面：`beautywe new page --subpkg <subPackageName> <path|name>`\n\n**组件**\n1. `beautywe new component <name>`\n\n**插件**\n1. `beautywe new plugin <name>`\n\n#### 自定义模板\n\n在 `./.templates` 目录中，存放着快速创建命令的创建模板：\n\n```shell\n$ tree .templates\n\n.templates\n├── component\n│   ├── index.js\n│   ├── index.json\n│   ├── index.scss\n│   └── index.wxml\n├── page\n│   ├── index.js\n│   ├── index.json\n│   ├── index.scss\n│   └── index.wxml\n└── plugin\n    └── index.js\n```\n\n可以修改里面的模板，来满足项目级别的自定义模板创建。\n\n## 全局窗口\n\n我们都知道微信小程序是「单窗口」的交互平台，一个页面对应一个窗口。    \n而在业务开发中，往往会有诸如这种述求：\n\n1. 自定义的 toast 样式\n2. 页面底部 copyright\n3. 全局的 loading 样式\n4. 全局的悬浮控件    \n......\n\n稍微不优雅的实现可以是分别做成独立的组件，然后每一个页面都引入进来。    \n这种做法，我们会有很多的重复代码，并且每次新建页面，都要引入一遍，后期维护也会很繁琐。\n\n而「全局窗口」的概念是：**希望所有页面之上有一块地方，全局性的逻辑和交互，可以往里面搁。**\n\n#### global-view 组件\n\n这是一个自定义组件，源码在 `/src/components/global-view`\n\n每个页面的 wxml 只需要在顶层包一层：\n\n```html\n<global-view id=\"global-view\">\n    ...\n</global-view>\n```\n\n需要全局实现的交互、样式、组件，只需要维护这个组件就足够了。\n\n## 全局配置文件\n\n在 `src/config/` 目录中，可以存放各种全局的配置文件，并且支持以 Node.js 的方式运行。（得益于 [Node.js Power 特性](/contents/framework/concept/nodejs-power.md)）。\n\n如 `src/config/logger.js`:\n\n```javascript\nconst env = process.env.RUN_ENV || 'dev';\n\nconst logger = Object.assign({\n    prefix: 'BeautyWe',\n    level: 'debug',\n}, {\n    // 开发环境的配置\n    dev: {\n        level: 'debug',\n    },\n    // 测试环境的配置\n    test: {\n        level: 'info',\n    },\n    // 线上环境的配置\n    prod: {\n        level: 'warn',\n    },\n}[env] || {});\n\nmodule.exports.logger = logger;\n```\n\n然后我们可以这样读取到 config 内容：\n\n```javascript\nimport { logger } from '/config/index';\n\n// logger.level 会根据环境不同而不同。\n```\n\nBeautywe Framework 默认会把 config 集成到 `getApp()` 的示例中：\n\n```javascript\ngetApp().config;\n```\n\n## 多环境开发\n\nBeautyWe Framework 支持多环境开发，其中预设了三套策略：\n* dev\n* test\n* prod\n\n我们可以通过命令来运行这三个构建策略：\n\n```shell\nbeautywe run dev\nbeautywe run test\nbeautywe run prod\n```\n\n## 三套环境的差异\n\nBeautywe Framework 源码默认在两方面使用了多环境：\n\n* 构建任务（`gulpfile.js/env/...`）\n* 全局配置（`src/config/...`）\n\n### 构建任务的差异\n\n| 构建任务 | 说明 |dev | test | prod |\n|---|---|:---:|:---:|:---:|\n| clean | 清除dist文件 | √ | √ | √ |\n| copy | 复制资源文件 | √ | √ | √ |\n| scripts | 编译JS文件 | √ | √ | √ |\n| sass | 编译scss文件 | √ | √ | √ |\n| npm | 编译npm文件 | √ | √ | √ |\n| nodejs-power | 编译Node.js文件 | √ | √ | √ |\n| watch | 监听文件修改 | √ | | |\n| scripts-min | 压缩JS文件 |  |  | √ |\n| sass-min | 压缩scss文件 |  |  | √ |\n| npm-min | 压缩npm文件 | | | √ |\n| image-min | 压缩图片文件 |  |  | √ |\n| clean-example | 清除示例页面 | | | √ |\n\n\n### Node.js Power\n\nBeautywe Framework 的代码有两种运行环境：\n\n1. Node.js 运行环境，如构建任务等。\n2. 微信小程序运行环境，如打包到 `dist` 文件夹的代码。\n\n#### 运行过程\n\n> Node.js Power 本质是一种静态编译的实现。    \n> 把某个文件在 Node.js 环境运行的结果，输出到微信小程序运行环境中，以此来满足特定的需求。\n\nNode.js Power 会把项目中 `src` 目录下类似 `xxx.nodepower.js` 命名的文件，以 Node.js 来运行，    \n然后把运行的结果，以「字面量对象」的形式写到 `dist` 目录下对应的同名文件 `xxx.nodepower.js` 文件去。\n\n以 `src/config/index.nodepower.js` 为例：\n\n```javascript\nconst fs = require('fs');\nconst path = require('path');\n\nconst files = fs.readdirSync(path.join(__dirname));\n\nconst result = {};\n\nfiles\n    .filter(name => name !== 'index.js')\n    .forEach((name) => {\n        Object.assign(result, require(path.join(__dirname, `./${name}`)));\n    });\n\nmodule.exports = result;\n```\n\n该文件，经过 Node.js Power 构建之后:\n\n`dist/config/index.nodepower.js`: \n\n```javascript\nmodule.exports = {\n    \"appInfo\": {\n        \"version\": \"0.0.1\",\n        \"env\": \"test\",\n        \"appid\": \"wx85fc0d03fb0b224d\",\n        \"name\": \"beautywe-framework-test-app\"\n    },\n    \"logger\": {\n        \"prefix\": \"BeautyWe\",\n        \"level\": \"info\"\n    }\n};\n```\n\n这就满足了，随意往 `src/config/` 目录中扩展配置文件，都能被自动打包。\n\nNode.js Power 已经被集成到多环境开发的 dev, test, prod 中去。\n\n当然，你可以手动运行这个构建任务：\n\n```shell\n$ gulp nodejs-power\n```\n\n### NPM\n\nBeautyWe Framework 实现支持 npm 的原理很简单，总结一句话：\n\n> 使用 webpack 打包 `src/npm/index.js` ，以 commonjs 格式输出到 `dist/npm/index.js`\n\n![npm-works](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181936)\n\n这样做的好处：\n\n1. 实现简单。\n2. 让 npm 包能集中管理，每次引入依赖，都好好的想一下，避免泛滥（尤其在多人开发中）。\n3. 使用 `ll dist/npm/index.js` 命令能快速看到项目中的 npm 包使占了多少容量。\n\n#### 新增 npm 依赖\n\n在 `src/npm/index.js` 文件中，进行 export：\n\n```javscript\nexport { default as beautywe } from '@beautywe/core';\n```\n\n然后在其他文件 import：\n\n```javascript\nimport { beautywe } from './npm/index';\n```\n\n# 更多\n\n总的来说，BeautyWe 是一套微信小程序的开发范式。\n\n`core` 和 `plugins` 扩展原生，提供复杂逻辑的封装和插拔式使用。\n\n而 `framework` 则负责提供一整套针对于微信小程序的企业级项目解决方案，开箱即用。\n\n其中还有更多的内容，欢迎浏览官网：[beautywejs.com](http://beautywejs.com)\n\n","slug":"beautywe-intro","published":1,"updated":"2019-07-17T13:51:15.075Z","_id":"cl270y8tm0060xwrlpvnd9cdk","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://raw.githubusercontent.com/beautywe/docs/master/docs/assets/images/logo-V4.png\" alt></p>\n<blockquote>\n<p>官网：<a href=\"http://beautywejs.com\" target=\"_blank\" rel=\"external\">beautywejs.com</a><br>Repo: <a href=\"https://github.com/beautywe/beautywe\" target=\"_blank\" rel=\"external\">beautywe</a></p>\n</blockquote>\n<h1 id=\"一个简单的介绍\"><a href=\"#一个简单的介绍\" class=\"headerlink\" title=\"一个简单的介绍\"></a>一个简单的介绍</h1><p><strong>BeautyWe.js 是什么？</strong></p>\n<p>它是一套专注于微信小程序的企业级开发范式，它的愿景是：</p>\n<blockquote>\n<p>让企业级的微信小程序项目中的代码，更加简单、漂亮。</p>\n</blockquote>\n<p><strong>为什么要这样命名呢？</strong></p>\n<blockquote>\n<p>Write <strong>beautiful</strong> code for <strong>we</strong>chat mini program by the <strong>beautiful</strong> <strong>we</strong>!</p>\n</blockquote>\n<p>「We」 既是我们的 <strong>We</strong>，也是微信的 <strong>We</strong>，Both beautiful！</p>\n<p><strong>那么它有什么卖点呢？</strong></p>\n<ol>\n<li>专注于微信小程序环境，写原汁原味的微信小程序代码。</li>\n<li>由于只专注于微信小程序，它的源码也很简单。</li>\n<li>插件化的编程方式，让复杂逻辑更容易封装。</li>\n<li>再加上一些配套设施：<ol>\n<li>一些官方插件。</li>\n<li>一套开箱即用，包含了工程化、项目规范以及微信小程序环境独特问题解决方案的框架。</li>\n<li>一个CLI工具，帮你快速创建应用，页面，组件等。</li>\n</ol>\n</li>\n</ol>\n<p><strong>它由以下几部分组成：</strong></p>\n<ul>\n<li><p><strong>一个插件化的核心</strong> - <a href=\"https://github.com/beautywe/beautywe\" target=\"_blank\" rel=\"external\">BeautyWe Core</a><br>  对 App、Page 进行抽象和包装，保持传统微信小程序开发姿势，同时开放部分原生能力，让其具有「可插件化」的能力。</p>\n</li>\n<li><p><strong>一些官方插件</strong> — <a href=\"https://www.npmjs.com/search?q=keywords%3Abeautywe-plugin\" target=\"_blank\" rel=\"external\">BeautyWe Plugins</a><br>  得益于 Core 的「可插件化」特性，封装复杂逻辑，实现可插拔。官方对于常见的需求提供了一些插件：如增强存储、发布/订阅、状态机、Logger、缓存策略等。</p>\n</li>\n<li><p><strong>一套开箱即用的项目框架</strong> - <a href=\"https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/contents/framework/introduce\" target=\"_blank\" rel=\"external\">BeautyWe Framework</a><br>  描述了一种项目的组织形式，开箱即用，集成了 <code>BeautyWe Core</code> ，并且提供了如：全局窗口、开发规范、多环境开发、全局配置、NPM 等解决方案。</p>\n</li>\n<li><p><strong>一个CLI工具</strong> - <a href=\"https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/remote/cli\" target=\"_blank\" rel=\"external\">BeautyWe Cli</a><br>  提供快速创建应用、页面、插件，以及项目构建功能的命令行工具。并且还支持自定义的创建模板。</p>\n</li>\n</ul>\n<h1 id=\"一个简单的例子\"><a href=\"#一个简单的例子\" class=\"headerlink\" title=\"一个简单的例子\"></a>一个简单的例子</h1><p>下载</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181427\" alt></p>\n<p>用 BeautyWe 包装你的应用</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181445\" alt></p>\n<p>之后，你就能使用 BeautyWe Plugin 提供的能力了。</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181337\" alt></p>\n<h1 id=\"开放原生App-Page，支持插件化\"><a href=\"#开放原生App-Page，支持插件化\" class=\"headerlink\" title=\"开放原生App/Page，支持插件化\"></a>开放原生App/Page，支持插件化</h1><p><code>new BtApp({...})</code> 的执行结果是对原生的应用进行包装，其中包含了「插件化」的处理，然后返回一个新的实例，这个实例适配原生的 <code>App()</code> 方法。</p>\n<p>下面来讲讲「插件化」到底做了什么事情。</p>\n<p>首先，插件化开放了原生 App 的四种能力：</p>\n<ol>\n<li><p><strong>Data 域</strong><br> 把插件的 Data 域合并到原生 App 的 Data 域中，这一块很容易理解。</p>\n</li>\n<li><p><strong>原生钩子函数</strong><br> 使原生钩子函数（如 <code>onShow</code>, <code>onLoad</code>）可插件化。让原生App与多个插件可以同时监听同一个钩子函数。如何工作的，下面会细说。</p>\n</li>\n<li><p><strong>事件钩子函数</strong><br> 使事件钩子函数（与 view 层交互的钩子函数），尽管在实现上有一些差异，但是实现原理跟「原生钩子函数」一样的。</p>\n</li>\n<li><p><strong>自定义方法</strong><br> 让插件能够给使用者提供 API。为了保证插件提供的 API 足够的优雅，支持当调用插件 API 的时候（如 event 插件 <code>this.event.on(...)</code>)，API 方法内部仍然能通过 <code>this</code> 获取到原生实例。</p>\n</li>\n</ol>\n<h4 id=\"钩子函数的插件化\"><a href=\"#钩子函数的插件化\" class=\"headerlink\" title=\"钩子函数的插件化\"></a>钩子函数的插件化</h4><p>原生钩子函数，事件钩子函数我们统一称为「钩子函数」。</p>\n<p>对于每一个钩子函数，内部是维护一个以 Series Promise 方式执行的执行队列。</p>\n<p>以 <code>onShow</code> 为例，将会以这样的形式执行：</p>\n<blockquote>\n<p>native.onShow → pluginA.onShow → pluginB.onShow → …</p>\n</blockquote>\n<p><strong>下面深入一下插件化的原理</strong>：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181648\" alt=\"beautywe pluggable\"></p>\n<p>工作原理是这样的：    </p>\n<ol>\n<li>经过 <code>new BtApp(...)</code> 包装，所有的钩子函数，都会有一个独立的执行队列，    </li>\n<li>首先会把原生的各个钩子函数 <code>push</code> 到对应的队列中。然后每 <code>use</code> 插件的时候，都会分解插件的钩子函数，往对应的队列 <code>push</code>。    </li>\n<li>当 <code>Native App</code>（原生）触发某个钩子的时候，<code>BtApp</code> 会以 Promise Series 的形式按循序执行对应队列里面的函数。    </li>\n<li>特殊的，<code>onLaunch</code> 和 <code>onLoad</code> 的执行队列中，会在队列顶部插入一个初始化的任务（<code>initialize</code>），它会以同步的方式按循序执行 <code>Initialize Queue</code> 里面的函数。这正是插件生命周期函数中的 <code>plugin.initialize</code>。</li>\n</ol>\n<p>这种设计能提供以下功能：</p>\n<ol>\n<li><p>可插件化。<br> 只需要往对应钩子函数的事件队列中插入任务。</p>\n</li>\n<li><p>支持异步。<br> 由于是以 Promise Series 方式运行的，其中一个任务返回一个 Promise，下一个任务会等待这个任务完成再开始。如果发生错误，会流转到原生的 <code>onError()</code> 中。</p>\n</li>\n<li><p>解决了微信小程序 <code>app.js</code> 中 <code>getApp() === undefinded</code>问题。<br> 造成这个问题，本质是因为 <code>App()</code> 的时候，原生实例未创建。但是由于 Promise 在 event loop 中是一个微任务，被注册在下一次循环。所以 Promise 执行的时候 <code>App()</code> 早已经完成了。</p>\n</li>\n</ol>\n<h1 id=\"一些官方插件\"><a href=\"#一些官方插件\" class=\"headerlink\" title=\"一些官方插件\"></a>一些官方插件</h1><p>BeautyWe 官方提供了一系列的插件：</p>\n<ol>\n<li>增强存储: Storage</li>\n<li>数据列表：List Page</li>\n<li>缓存策略：Cache</li>\n<li>日志：Logger</li>\n<li>事件发布/订阅：Event</li>\n<li>状态机：Status</li>\n</ol>\n<p>它们的使用很简单，哪里需要插哪里。<br>由于篇幅的原因，下面挑几个比较有趣的来讲讲，更多的可以看看官方文档：<a href=\"http://beautywejs.com\" target=\"_blank\" rel=\"external\">BeautyWe</a></p>\n<h2 id=\"增强存储-Storage\"><a href=\"#增强存储-Storage\" class=\"headerlink\" title=\"增强存储 Storage\"></a>增强存储 Storage</h2><p>该功能由 <a href=\"https://github.com/beautywe/plugin-storage\" target=\"_blank\" rel=\"external\">@beautywe/plugin-storage</a> 提供。</p>\n<p>由于微信小程序原生的数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。</p>\n<p>所以该插件在 <code>wx.getStorage/setStorage</code> 的基础上，提供了两种扩展能力：</p>\n<ol>\n<li>过期控制</li>\n<li>版本隔离</li>\n</ol>\n<p><strong>一些简单的例子</strong></p>\n<p>安装<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; BtApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> storage <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/plugin-storage'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> BtApp();</span><br><span class=\"line\">app.use(storage());</span><br></pre></td></tr></table></figure></p>\n<p>过期控制<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 7天后过期</span></span><br><span class=\"line\">app.storage.set(<span class=\"string\">'name'</span>, <span class=\"string\">'jc'</span>, &#123; <span class=\"attr\">expire</span>: <span class=\"number\">7</span> &#125;)；</span><br></pre></td></tr></table></figure></p>\n<p>版本隔离<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(&#123; <span class=\"attr\">appVersion</span>: <span class=\"string\">'0.0.1'</span> &#125;);</span><br><span class=\"line\">app.set(<span class=\"string\">'name'</span>, <span class=\"string\">'jc'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回 jc</span></span><br><span class=\"line\">app.get(<span class=\"string\">'name'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当版本更新后</span></span><br><span class=\"line\">app.use(&#123; <span class=\"attr\">appVersion</span>: <span class=\"string\">'0.0.2'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回 undefined;</span></span><br><span class=\"line\">app.get(<span class=\"string\">'name'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>更多的查看 <a href=\"https://github.com/beautywe/plugin-storage\" target=\"_blank\" rel=\"external\">@beautywe/plugin-storage 官方文档</a></p>\n<h2 id=\"数据列表-List-Page\"><a href=\"#数据列表-List-Page\" class=\"headerlink\" title=\"数据列表 List Page\"></a>数据列表 List Page</h2><p>对于十分常见的数据列表分页的业务场景，<code>@beautywe/plugin-listpage</code> 提供了一套打包方案：</p>\n<ol>\n<li>满足常用「数据列表分页」的业务场景</li>\n<li>支持分页</li>\n<li>支持多个数据列表</li>\n<li>自动捕捉下拉重载：<code>onPullDownRefresh</code></li>\n<li>自动捕捉上拉加载：<code>onReachBottom</code></li>\n<li>自带请求锁，防止帕金森氏手抖用户</li>\n<li>简单优雅的 API</li>\n</ol>\n<p>一个简单的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> BeautyWe <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> listpage <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/plugin-listpage'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> page = <span class=\"keyword\">new</span> BeautyWe.BtPage();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 listpage 插件</span></span><br><span class=\"line\">page.use(listpage(&#123;</span><br><span class=\"line\">    lists: [&#123;</span><br><span class=\"line\">        name: <span class=\"string\">'goods'</span>,  <span class=\"comment\">// 数据名</span></span><br><span class=\"line\">        pageSize: <span class=\"number\">20</span>,   <span class=\"comment\">// 每页多少条数据，默认 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 每一页的数据源，没次加载页面时，会调用函数，然后取返回的数据。</span></span><br><span class=\"line\">        fetchPageData(&#123; pageNo, pageSize &#125;) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> API.getGoodsList(&#123; pageNo, pageSize &#125;)</span><br><span class=\"line\">            </span><br><span class=\"line\">                <span class=\"comment\">// 有时候，需要对服务器的数据进行处理，dataCooker 是你定义的函数。</span></span><br><span class=\"line\">                .then(<span class=\"function\">(<span class=\"params\">rawData</span>) =&gt;</span> dataCooker(rawData));</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    enabledPullDownRefresh: <span class=\"literal\">true</span>,    <span class=\"comment\">// 开启下拉重载， 默认 false</span></span><br><span class=\"line\">    enabledReachBottom: <span class=\"literal\">true</span>,    <span class=\"comment\">// 开启上拉加载， 默认 false</span></span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// goods 数据会被加载到，goods 为上面定义的 name</span></span><br><span class=\"line\"><span class=\"comment\">// this.data.listPage.goods = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     data: [...],     // 视图层，通过该字段来获取具体的数据</span></span><br><span class=\"line\"><span class=\"comment\">//     hasMore: true,   // 视图层，通过该字段来识别是否有下一页</span></span><br><span class=\"line\"><span class=\"comment\">//     currentPage: 1,  // 视图层，通过该字段来识别当前第几页</span></span><br><span class=\"line\"><span class=\"comment\">//     totalPage: undefined,</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n<p>只需要告诉 <code>listpage</code> 如何获取数据，它会自动处理「下拉重载」、「上拉翻页」的操作，然后把数据更新到 <code>this.data.listPage.goods</code> 下。</p>\n<p>View 层只需要描述数据怎么展示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"good\"</span> <span class=\"attr\">wx:for</span>=<span class=\"string\">\"listPage.goods.data\"</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"no-more\"</span> <span class=\"attr\">wx:if</span>=<span class=\"string\">\"listPage.goods.hasMore === false\"</span>&gt;</span></span><br><span class=\"line\">    没有更多了</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>listpage</code> 还支持多数据列表等其他更多配置，详情看：<a href=\"https://github.com/beautywe/plugin-listpage\" target=\"_blank\" rel=\"external\">@beautywe/plugin-listpage</a></p>\n<h2 id=\"缓存策略-Cache\"><a href=\"#缓存策略-Cache\" class=\"headerlink\" title=\"缓存策略 Cache\"></a>缓存策略 Cache</h2><p><code>@beautywe/plugin-cache</code> 提供了一个微信小程序端缓存策略，其底层由 <a href=\"https://github.com/JerryC8080/super-cache\" target=\"_blank\" rel=\"external\">super-cache</a> 提供支持。</p>\n<h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><ol>\n<li>提供一套「服务端接口耗时慢，但加载性能要求高」场景的解决方案</li>\n<li>满足最基本的缓存需求，读取（get）和保存（set）</li>\n<li>支持针对缓存进行逻辑代理</li>\n<li>灵活可配置的数据存储方式</li>\n</ol>\n<h4 id=\"How-it-work\"><a href=\"#How-it-work\" class=\"headerlink\" title=\"How it work\"></a>How it work</h4><p>一般的请求数据的形式是，页面加载的时候，从服务端获取数据，然后等待数据返回之后，进行页面渲染：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181755\" alt></p>\n<p>但这种模式，会受到服务端接口耗时，网络环境等因素影响到加载性能。   </p>\n<p>对于加载性能要求高的页面（如首页），一般的 Web 开发我们有很多解决方案（如服务端渲染，服务端缓存，SSR 等）。<br>但是也有一些环境不能使用这种技术（如微信小程序）。</p>\n<p>Super Cache 提供了一个中间数据缓存的解决方案：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181847\" alt></p>\n<p>思路：    </p>\n<ol>\n<li>当你需要获取一个数据的时候，如果有缓存，先把旧的数据给你。</li>\n<li>然后再从服务端获取新的数据，刷新缓存。</li>\n<li>如果一开始没有缓存，则请求服务端数据，再把数据返回。</li>\n<li>下一次请求缓存，从第一步开始。</li>\n</ol>\n<p>这种解决方案，舍弃了一点数据的实时性（非第一次请求，只能获取上一次最新数据），大大提高了前端的加载性能。<br>适合的场景：    </p>\n<ol>\n<li>数据实时性要求不高。</li>\n<li>服务端接口耗时长。</li>\n</ol>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; BtApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> cache <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/plugin-cache'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> BtApp();</span><br><span class=\"line\">app.use(cache(&#123;</span><br><span class=\"line\">    adapters: [&#123;</span><br><span class=\"line\">        key: <span class=\"string\">'name'</span>,</span><br><span class=\"line\">        data() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> API.fetch(<span class=\"string\">'xxx/name'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>假设 <code>API.fetch(&#39;xxx/name&#39;)</code> 是请求服务器接口，返回数据：<code>data_from_server</code></p>\n<p>那么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.cache.get(<span class=\"string\">'name'</span>).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// value: 'data_from_server'  </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>更多的配置，详情看：<a href=\"https://github.com/beautywe/plugin-cache\" target=\"_blank\" rel=\"external\">@beautywe/plugin-cache</a></p>\n<h2 id=\"日志-Logger\"><a href=\"#日志-Logger\" class=\"headerlink\" title=\"日志 Logger\"></a>日志 Logger</h2><p>由 <code>@beautywe/logger-plugin</code> 提供的一个轻量的日志处理方案，它支持：</p>\n<ol>\n<li>可控的 log level</li>\n<li>自定义前缀</li>\n<li>日志统一处理</li>\n</ol>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; BtApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logger <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/plugin-logger'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> page = <span class=\"keyword\">new</span> BtApp();</span><br><span class=\"line\"></span><br><span class=\"line\">page.use(logger(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// options</span></span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p><strong>API</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page.logger.info(<span class=\"string\">'this is info'</span>);</span><br><span class=\"line\">page.logger.warn(<span class=\"string\">'this is warn'</span>);</span><br><span class=\"line\">page.logger.error(<span class=\"string\">'this is error'</span>);</span><br><span class=\"line\">page.logger.debug(<span class=\"string\">'this is debug'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"comment\">// [info] this is info</span></span><br><span class=\"line\"><span class=\"comment\">// [warn] this is warn</span></span><br><span class=\"line\"><span class=\"comment\">// [error] this is error</span></span><br><span class=\"line\"><span class=\"comment\">// [debug] this is debug</span></span><br></pre></td></tr></table></figure>\n<p><strong>Level control</strong></p>\n<p>可通过配置来控制哪些 level 该打印：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page.use(logger(&#123;</span><br><span class=\"line\">    level: <span class=\"string\">'warn'</span>,</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>那么 <code>warn</code> 以上的 log （<code>info</code>, <code>debug</code>）就不会被打印，这种满足于开发和生成环境对 log 的不同需求。</p>\n<p>level 等级如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Logger.LEVEL = &#123;</span><br><span class=\"line\">    error: <span class=\"number\">1</span>,</span><br><span class=\"line\">    warn: <span class=\"number\">2</span>,</span><br><span class=\"line\">    info: <span class=\"number\">3</span>,</span><br><span class=\"line\">    debug: <span class=\"number\">4</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>更多的配置，详情看：<a href=\"https://github.com/beautywe/plugin-logger\" target=\"_blank\" rel=\"external\">@beautywe/plugin-logger</a></p>\n<h1 id=\"BeautyWe-Framework\"><a href=\"#BeautyWe-Framework\" class=\"headerlink\" title=\"BeautyWe Framework\"></a>BeautyWe Framework</h1><p><code>@beautywe/core</code> 和 <code>@beautywe/plugin-...</code> 给小程序提供了：</p>\n<ol>\n<li>开放原生，支持插件化 —— by core</li>\n<li>各种插件 —— by plugins</li>\n</ol>\n<p>但是，还有很多的开发中实际还会遇到的痛点，是上面两个解决不到的。<br>如项目的组织、规范、工程化、配置、多环境等等</p>\n<p>这些就是，「BeautyWe Framework」要解决的范畴。</p>\n<p>它作为一套开箱即用的项目框架，提供了这些功能：</p>\n<ul>\n<li>集成 BeautyWe Core</li>\n<li>NPM 支持</li>\n<li>全局窗口</li>\n<li>全局 Page，Component</li>\n<li>全局配置文件</li>\n<li>多环境开发</li>\n<li>Example Pages</li>\n<li>正常项目需要的标配：ES2015+,sass,uglify,watch 等</li>\n<li>以及我们认为良好的项目规范（eslint，commit log，目录结构等）</li>\n</ul>\n<p>也是由于篇幅原因，挑几个有趣的来讲讲，更多的可以看看官方文档：<a href=\"http://beautywejs.com\" target=\"_blank\" rel=\"external\">BeautyWe</a></p>\n<h2 id=\"快速创建\"><a href=\"#快速创建\" class=\"headerlink\" title=\"快速创建\"></a>快速创建</h2><p>首先安装 <code>@beautywe/cli</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm i @beautywe/cli -g</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> beautywe new app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;</span> appName: my-app</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> version: 0.0.1</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> appid: 123456</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> 这样可以么:</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span>    \"appName\": \"my-app\",</span><br><span class=\"line\"><span class=\"meta\">&gt;</span>    \"version\": \"0.0.1\",</span><br><span class=\"line\"><span class=\"meta\">&gt;</span>    \"appid\": \"123456\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>回答几个问题之后，项目就生成了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-app</span><br><span class=\"line\">├── gulpfile.js</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── app.js</span><br><span class=\"line\">    ├── app.json</span><br><span class=\"line\">    ├── app.scss</span><br><span class=\"line\">    ├── assets</span><br><span class=\"line\">    ├── components</span><br><span class=\"line\">    ├── config</span><br><span class=\"line\">    ├── examples</span><br><span class=\"line\">    ├── libs</span><br><span class=\"line\">    ├── npm</span><br><span class=\"line\">    ├── pages</span><br><span class=\"line\">    └── project.config.json</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建页面、组件、插件\"><a href=\"#创建页面、组件、插件\" class=\"headerlink\" title=\"创建页面、组件、插件\"></a>创建页面、组件、插件</h4><p><strong>页面</strong></p>\n<ol>\n<li>主包页面：<code>beautywe new page &lt;path|name&gt;</code></li>\n<li>分包页面：<code>beautywe new page --subpkg &lt;subPackageName&gt; &lt;path|name&gt;</code></li>\n</ol>\n<p><strong>组件</strong></p>\n<ol>\n<li><code>beautywe new component &lt;name&gt;</code></li>\n</ol>\n<p><strong>插件</strong></p>\n<ol>\n<li><code>beautywe new plugin &lt;name&gt;</code></li>\n</ol>\n<h4 id=\"自定义模板\"><a href=\"#自定义模板\" class=\"headerlink\" title=\"自定义模板\"></a>自定义模板</h4><p>在 <code>./.templates</code> 目录中，存放着快速创建命令的创建模板：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tree .templates</span><br><span class=\"line\"></span><br><span class=\"line\">.templates</span><br><span class=\"line\">├── component</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   ├── index.json</span><br><span class=\"line\">│   ├── index.scss</span><br><span class=\"line\">│   └── index.wxml</span><br><span class=\"line\">├── page</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   ├── index.json</span><br><span class=\"line\">│   ├── index.scss</span><br><span class=\"line\">│   └── index.wxml</span><br><span class=\"line\">└── plugin</span><br><span class=\"line\">    └── index.js</span><br></pre></td></tr></table></figure>\n<p>可以修改里面的模板，来满足项目级别的自定义模板创建。</p>\n<h2 id=\"全局窗口\"><a href=\"#全局窗口\" class=\"headerlink\" title=\"全局窗口\"></a>全局窗口</h2><p>我们都知道微信小程序是「单窗口」的交互平台，一个页面对应一个窗口。<br>而在业务开发中，往往会有诸如这种述求：</p>\n<ol>\n<li>自定义的 toast 样式</li>\n<li>页面底部 copyright</li>\n<li>全局的 loading 样式</li>\n<li>全局的悬浮控件<br>……</li>\n</ol>\n<p>稍微不优雅的实现可以是分别做成独立的组件，然后每一个页面都引入进来。<br>这种做法，我们会有很多的重复代码，并且每次新建页面，都要引入一遍，后期维护也会很繁琐。</p>\n<p>而「全局窗口」的概念是：<strong>希望所有页面之上有一块地方，全局性的逻辑和交互，可以往里面搁。</strong></p>\n<h4 id=\"global-view-组件\"><a href=\"#global-view-组件\" class=\"headerlink\" title=\"global-view 组件\"></a>global-view 组件</h4><p>这是一个自定义组件，源码在 <code>/src/components/global-view</code></p>\n<p>每个页面的 wxml 只需要在顶层包一层：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">global-view</span> <span class=\"attr\">id</span>=<span class=\"string\">\"global-view\"</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">global-view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>需要全局实现的交互、样式、组件，只需要维护这个组件就足够了。</p>\n<h2 id=\"全局配置文件\"><a href=\"#全局配置文件\" class=\"headerlink\" title=\"全局配置文件\"></a>全局配置文件</h2><p>在 <code>src/config/</code> 目录中，可以存放各种全局的配置文件，并且支持以 Node.js 的方式运行。（得益于 <a href=\"/contents/framework/concept/nodejs-power.md\">Node.js Power 特性</a>）。</p>\n<p>如 <code>src/config/logger.js</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> env = process.env.RUN_ENV || <span class=\"string\">'dev'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"built_in\">Object</span>.assign(&#123;</span><br><span class=\"line\">    prefix: <span class=\"string\">'BeautyWe'</span>,</span><br><span class=\"line\">    level: <span class=\"string\">'debug'</span>,</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开发环境的配置</span></span><br><span class=\"line\">    dev: &#123;</span><br><span class=\"line\">        level: <span class=\"string\">'debug'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 测试环境的配置</span></span><br><span class=\"line\">    test: &#123;</span><br><span class=\"line\">        level: <span class=\"string\">'info'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 线上环境的配置</span></span><br><span class=\"line\">    prod: &#123;</span><br><span class=\"line\">        level: <span class=\"string\">'warn'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;[env] || &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports.logger = logger;</span><br></pre></td></tr></table></figure>\n<p>然后我们可以这样读取到 config 内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; logger &#125; <span class=\"keyword\">from</span> <span class=\"string\">'/config/index'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// logger.level 会根据环境不同而不同。</span></span><br></pre></td></tr></table></figure>\n<p>Beautywe Framework 默认会把 config 集成到 <code>getApp()</code> 的示例中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getApp().config;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多环境开发\"><a href=\"#多环境开发\" class=\"headerlink\" title=\"多环境开发\"></a>多环境开发</h2><p>BeautyWe Framework 支持多环境开发，其中预设了三套策略：</p>\n<ul>\n<li>dev</li>\n<li>test</li>\n<li>prod</li>\n</ul>\n<p>我们可以通过命令来运行这三个构建策略：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beautywe run dev</span><br><span class=\"line\">beautywe run test</span><br><span class=\"line\">beautywe run prod</span><br></pre></td></tr></table></figure>\n<h2 id=\"三套环境的差异\"><a href=\"#三套环境的差异\" class=\"headerlink\" title=\"三套环境的差异\"></a>三套环境的差异</h2><p>Beautywe Framework 源码默认在两方面使用了多环境：</p>\n<ul>\n<li>构建任务（<code>gulpfile.js/env/...</code>）</li>\n<li>全局配置（<code>src/config/...</code>）</li>\n</ul>\n<h3 id=\"构建任务的差异\"><a href=\"#构建任务的差异\" class=\"headerlink\" title=\"构建任务的差异\"></a>构建任务的差异</h3><table>\n<thead>\n<tr>\n<th>构建任务</th>\n<th>说明</th>\n<th style=\"text-align:center\">dev</th>\n<th style=\"text-align:center\">test</th>\n<th style=\"text-align:center\">prod</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>clean</td>\n<td>清除dist文件</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>copy</td>\n<td>复制资源文件</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>scripts</td>\n<td>编译JS文件</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>sass</td>\n<td>编译scss文件</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>npm</td>\n<td>编译npm文件</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>nodejs-power</td>\n<td>编译Node.js文件</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>watch</td>\n<td>监听文件修改</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>scripts-min</td>\n<td>压缩JS文件</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>sass-min</td>\n<td>压缩scss文件</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>npm-min</td>\n<td>压缩npm文件</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>image-min</td>\n<td>压缩图片文件</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>clean-example</td>\n<td>清除示例页面</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">√</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Node-js-Power\"><a href=\"#Node-js-Power\" class=\"headerlink\" title=\"Node.js Power\"></a>Node.js Power</h3><p>Beautywe Framework 的代码有两种运行环境：</p>\n<ol>\n<li>Node.js 运行环境，如构建任务等。</li>\n<li>微信小程序运行环境，如打包到 <code>dist</code> 文件夹的代码。</li>\n</ol>\n<h4 id=\"运行过程\"><a href=\"#运行过程\" class=\"headerlink\" title=\"运行过程\"></a>运行过程</h4><blockquote>\n<p>Node.js Power 本质是一种静态编译的实现。<br>把某个文件在 Node.js 环境运行的结果，输出到微信小程序运行环境中，以此来满足特定的需求。</p>\n</blockquote>\n<p>Node.js Power 会把项目中 <code>src</code> 目录下类似 <code>xxx.nodepower.js</code> 命名的文件，以 Node.js 来运行，<br>然后把运行的结果，以「字面量对象」的形式写到 <code>dist</code> 目录下对应的同名文件 <code>xxx.nodepower.js</code> 文件去。</p>\n<p>以 <code>src/config/index.nodepower.js</code> 为例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> files = fs.readdirSync(path.join(__dirname));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">files</span><br><span class=\"line\">    .filter(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> name !== <span class=\"string\">'index.js'</span>)</span><br><span class=\"line\">    .forEach(<span class=\"function\">(<span class=\"params\">name</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.assign(result, <span class=\"built_in\">require</span>(path.join(__dirname, <span class=\"string\">`./<span class=\"subst\">$&#123;name&#125;</span>`</span>)));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = result;</span><br></pre></td></tr></table></figure>\n<p>该文件，经过 Node.js Power 构建之后:</p>\n<p><code>dist/config/index.nodepower.js</code>: </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"appInfo\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.0.1\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"env\"</span>: <span class=\"string\">\"test\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"appid\"</span>: <span class=\"string\">\"wx85fc0d03fb0b224d\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"beautywe-framework-test-app\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"logger\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"prefix\"</span>: <span class=\"string\">\"BeautyWe\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"level\"</span>: <span class=\"string\">\"info\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这就满足了，随意往 <code>src/config/</code> 目录中扩展配置文件，都能被自动打包。</p>\n<p>Node.js Power 已经被集成到多环境开发的 dev, test, prod 中去。</p>\n<p>当然，你可以手动运行这个构建任务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gulp nodejs-power</span><br></pre></td></tr></table></figure>\n<h3 id=\"NPM\"><a href=\"#NPM\" class=\"headerlink\" title=\"NPM\"></a>NPM</h3><p>BeautyWe Framework 实现支持 npm 的原理很简单，总结一句话：</p>\n<blockquote>\n<p>使用 webpack 打包 <code>src/npm/index.js</code> ，以 commonjs 格式输出到 <code>dist/npm/index.js</code></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181936\" alt=\"npm-works\"></p>\n<p>这样做的好处：</p>\n<ol>\n<li>实现简单。</li>\n<li>让 npm 包能集中管理，每次引入依赖，都好好的想一下，避免泛滥（尤其在多人开发中）。</li>\n<li>使用 <code>ll dist/npm/index.js</code> 命令能快速看到项目中的 npm 包使占了多少容量。</li>\n</ol>\n<h4 id=\"新增-npm-依赖\"><a href=\"#新增-npm-依赖\" class=\"headerlink\" title=\"新增 npm 依赖\"></a>新增 npm 依赖</h4><p>在 <code>src/npm/index.js</code> 文件中，进行 export：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123; default as beautywe &#125; from &apos;@beautywe/core&apos;;</span><br></pre></td></tr></table></figure>\n<p>然后在其他文件 import：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; beautywe &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./npm/index'</span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"更多\"><a href=\"#更多\" class=\"headerlink\" title=\"更多\"></a>更多</h1><p>总的来说，BeautyWe 是一套微信小程序的开发范式。</p>\n<p><code>core</code> 和 <code>plugins</code> 扩展原生，提供复杂逻辑的封装和插拔式使用。</p>\n<p>而 <code>framework</code> 则负责提供一整套针对于微信小程序的企业级项目解决方案，开箱即用。</p>\n<p>其中还有更多的内容，欢迎浏览官网：<a href=\"http://beautywejs.com\" target=\"_blank\" rel=\"external\">beautywejs.com</a></p>\n","excerpt":"","more":"<p><img src=\"https://raw.githubusercontent.com/beautywe/docs/master/docs/assets/images/logo-V4.png\" alt=\"\"></p>\n<blockquote>\n<p>官网：<a href=\"http://beautywejs.com\">beautywejs.com</a><br>Repo: <a href=\"https://github.com/beautywe/beautywe\">beautywe</a></p>\n</blockquote>\n<h1 id=\"一个简单的介绍\"><a href=\"#一个简单的介绍\" class=\"headerlink\" title=\"一个简单的介绍\"></a>一个简单的介绍</h1><p><strong>BeautyWe.js 是什么？</strong></p>\n<p>它是一套专注于微信小程序的企业级开发范式，它的愿景是：</p>\n<blockquote>\n<p>让企业级的微信小程序项目中的代码，更加简单、漂亮。</p>\n</blockquote>\n<p><strong>为什么要这样命名呢？</strong></p>\n<blockquote>\n<p>Write <strong>beautiful</strong> code for <strong>we</strong>chat mini program by the <strong>beautiful</strong> <strong>we</strong>!</p>\n</blockquote>\n<p>「We」 既是我们的 <strong>We</strong>，也是微信的 <strong>We</strong>，Both beautiful！</p>\n<p><strong>那么它有什么卖点呢？</strong></p>\n<ol>\n<li>专注于微信小程序环境，写原汁原味的微信小程序代码。</li>\n<li>由于只专注于微信小程序，它的源码也很简单。</li>\n<li>插件化的编程方式，让复杂逻辑更容易封装。</li>\n<li>再加上一些配套设施：<ol>\n<li>一些官方插件。</li>\n<li>一套开箱即用，包含了工程化、项目规范以及微信小程序环境独特问题解决方案的框架。</li>\n<li>一个CLI工具，帮你快速创建应用，页面，组件等。</li>\n</ol>\n</li>\n</ol>\n<p><strong>它由以下几部分组成：</strong></p>\n<ul>\n<li><p><strong>一个插件化的核心</strong> - <a href=\"https://github.com/beautywe/beautywe\">BeautyWe Core</a><br>  对 App、Page 进行抽象和包装，保持传统微信小程序开发姿势，同时开放部分原生能力，让其具有「可插件化」的能力。</p>\n</li>\n<li><p><strong>一些官方插件</strong> — <a href=\"https://www.npmjs.com/search?q=keywords%3Abeautywe-plugin\">BeautyWe Plugins</a><br>  得益于 Core 的「可插件化」特性，封装复杂逻辑，实现可插拔。官方对于常见的需求提供了一些插件：如增强存储、发布/订阅、状态机、Logger、缓存策略等。</p>\n</li>\n<li><p><strong>一套开箱即用的项目框架</strong> - <a href=\"https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/contents/framework/introduce\">BeautyWe Framework</a><br>  描述了一种项目的组织形式，开箱即用，集成了 <code>BeautyWe Core</code> ，并且提供了如：全局窗口、开发规范、多环境开发、全局配置、NPM 等解决方案。</p>\n</li>\n<li><p><strong>一个CLI工具</strong> - <a href=\"https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/remote/cli\">BeautyWe Cli</a><br>  提供快速创建应用、页面、插件，以及项目构建功能的命令行工具。并且还支持自定义的创建模板。</p>\n</li>\n</ul>\n<h1 id=\"一个简单的例子\"><a href=\"#一个简单的例子\" class=\"headerlink\" title=\"一个简单的例子\"></a>一个简单的例子</h1><p>下载</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181427\" alt=\"\"></p>\n<p>用 BeautyWe 包装你的应用</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181445\" alt=\"\"></p>\n<p>之后，你就能使用 BeautyWe Plugin 提供的能力了。</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181337\" alt=\"\"></p>\n<h1 id=\"开放原生App-Page，支持插件化\"><a href=\"#开放原生App-Page，支持插件化\" class=\"headerlink\" title=\"开放原生App/Page，支持插件化\"></a>开放原生App/Page，支持插件化</h1><p><code>new BtApp({...})</code> 的执行结果是对原生的应用进行包装，其中包含了「插件化」的处理，然后返回一个新的实例，这个实例适配原生的 <code>App()</code> 方法。</p>\n<p>下面来讲讲「插件化」到底做了什么事情。</p>\n<p>首先，插件化开放了原生 App 的四种能力：</p>\n<ol>\n<li><p><strong>Data 域</strong><br> 把插件的 Data 域合并到原生 App 的 Data 域中，这一块很容易理解。</p>\n</li>\n<li><p><strong>原生钩子函数</strong><br> 使原生钩子函数（如 <code>onShow</code>, <code>onLoad</code>）可插件化。让原生App与多个插件可以同时监听同一个钩子函数。如何工作的，下面会细说。</p>\n</li>\n<li><p><strong>事件钩子函数</strong><br> 使事件钩子函数（与 view 层交互的钩子函数），尽管在实现上有一些差异，但是实现原理跟「原生钩子函数」一样的。</p>\n</li>\n<li><p><strong>自定义方法</strong><br> 让插件能够给使用者提供 API。为了保证插件提供的 API 足够的优雅，支持当调用插件 API 的时候（如 event 插件 <code>this.event.on(...)</code>)，API 方法内部仍然能通过 <code>this</code> 获取到原生实例。</p>\n</li>\n</ol>\n<h4 id=\"钩子函数的插件化\"><a href=\"#钩子函数的插件化\" class=\"headerlink\" title=\"钩子函数的插件化\"></a>钩子函数的插件化</h4><p>原生钩子函数，事件钩子函数我们统一称为「钩子函数」。</p>\n<p>对于每一个钩子函数，内部是维护一个以 Series Promise 方式执行的执行队列。</p>\n<p>以 <code>onShow</code> 为例，将会以这样的形式执行：</p>\n<blockquote>\n<p>native.onShow → pluginA.onShow → pluginB.onShow → …</p>\n</blockquote>\n<p><strong>下面深入一下插件化的原理</strong>：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181648\" alt=\"beautywe pluggable\"></p>\n<p>工作原理是这样的：    </p>\n<ol>\n<li>经过 <code>new BtApp(...)</code> 包装，所有的钩子函数，都会有一个独立的执行队列，    </li>\n<li>首先会把原生的各个钩子函数 <code>push</code> 到对应的队列中。然后每 <code>use</code> 插件的时候，都会分解插件的钩子函数，往对应的队列 <code>push</code>。    </li>\n<li>当 <code>Native App</code>（原生）触发某个钩子的时候，<code>BtApp</code> 会以 Promise Series 的形式按循序执行对应队列里面的函数。    </li>\n<li>特殊的，<code>onLaunch</code> 和 <code>onLoad</code> 的执行队列中，会在队列顶部插入一个初始化的任务（<code>initialize</code>），它会以同步的方式按循序执行 <code>Initialize Queue</code> 里面的函数。这正是插件生命周期函数中的 <code>plugin.initialize</code>。</li>\n</ol>\n<p>这种设计能提供以下功能：</p>\n<ol>\n<li><p>可插件化。<br> 只需要往对应钩子函数的事件队列中插入任务。</p>\n</li>\n<li><p>支持异步。<br> 由于是以 Promise Series 方式运行的，其中一个任务返回一个 Promise，下一个任务会等待这个任务完成再开始。如果发生错误，会流转到原生的 <code>onError()</code> 中。</p>\n</li>\n<li><p>解决了微信小程序 <code>app.js</code> 中 <code>getApp() === undefinded</code>问题。<br> 造成这个问题，本质是因为 <code>App()</code> 的时候，原生实例未创建。但是由于 Promise 在 event loop 中是一个微任务，被注册在下一次循环。所以 Promise 执行的时候 <code>App()</code> 早已经完成了。</p>\n</li>\n</ol>\n<h1 id=\"一些官方插件\"><a href=\"#一些官方插件\" class=\"headerlink\" title=\"一些官方插件\"></a>一些官方插件</h1><p>BeautyWe 官方提供了一系列的插件：</p>\n<ol>\n<li>增强存储: Storage</li>\n<li>数据列表：List Page</li>\n<li>缓存策略：Cache</li>\n<li>日志：Logger</li>\n<li>事件发布/订阅：Event</li>\n<li>状态机：Status</li>\n</ol>\n<p>它们的使用很简单，哪里需要插哪里。<br>由于篇幅的原因，下面挑几个比较有趣的来讲讲，更多的可以看看官方文档：<a href=\"http://beautywejs.com\">BeautyWe</a></p>\n<h2 id=\"增强存储-Storage\"><a href=\"#增强存储-Storage\" class=\"headerlink\" title=\"增强存储 Storage\"></a>增强存储 Storage</h2><p>该功能由 <a href=\"https://github.com/beautywe/plugin-storage\">@beautywe/plugin-storage</a> 提供。</p>\n<p>由于微信小程序原生的数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。</p>\n<p>所以该插件在 <code>wx.getStorage/setStorage</code> 的基础上，提供了两种扩展能力：</p>\n<ol>\n<li>过期控制</li>\n<li>版本隔离</li>\n</ol>\n<p><strong>一些简单的例子</strong></p>\n<p>安装<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; BtApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> storage <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/plugin-storage'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> BtApp();</span><br><span class=\"line\">app.use(storage());</span><br></pre></td></tr></table></figure></p>\n<p>过期控制<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 7天后过期</span></span><br><span class=\"line\">app.storage.set(<span class=\"string\">'name'</span>, <span class=\"string\">'jc'</span>, &#123; <span class=\"attr\">expire</span>: <span class=\"number\">7</span> &#125;)；</span><br></pre></td></tr></table></figure></p>\n<p>版本隔离<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(&#123; <span class=\"attr\">appVersion</span>: <span class=\"string\">'0.0.1'</span> &#125;);</span><br><span class=\"line\">app.set(<span class=\"string\">'name'</span>, <span class=\"string\">'jc'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回 jc</span></span><br><span class=\"line\">app.get(<span class=\"string\">'name'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当版本更新后</span></span><br><span class=\"line\">app.use(&#123; <span class=\"attr\">appVersion</span>: <span class=\"string\">'0.0.2'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回 undefined;</span></span><br><span class=\"line\">app.get(<span class=\"string\">'name'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>更多的查看 <a href=\"https://github.com/beautywe/plugin-storage\">@beautywe/plugin-storage 官方文档</a></p>\n<h2 id=\"数据列表-List-Page\"><a href=\"#数据列表-List-Page\" class=\"headerlink\" title=\"数据列表 List Page\"></a>数据列表 List Page</h2><p>对于十分常见的数据列表分页的业务场景，<code>@beautywe/plugin-listpage</code> 提供了一套打包方案：</p>\n<ol>\n<li>满足常用「数据列表分页」的业务场景</li>\n<li>支持分页</li>\n<li>支持多个数据列表</li>\n<li>自动捕捉下拉重载：<code>onPullDownRefresh</code></li>\n<li>自动捕捉上拉加载：<code>onReachBottom</code></li>\n<li>自带请求锁，防止帕金森氏手抖用户</li>\n<li>简单优雅的 API</li>\n</ol>\n<p>一个简单的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> BeautyWe <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> listpage <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/plugin-listpage'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> page = <span class=\"keyword\">new</span> BeautyWe.BtPage();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 listpage 插件</span></span><br><span class=\"line\">page.use(listpage(&#123;</span><br><span class=\"line\">    lists: [&#123;</span><br><span class=\"line\">        name: <span class=\"string\">'goods'</span>,  <span class=\"comment\">// 数据名</span></span><br><span class=\"line\">        pageSize: <span class=\"number\">20</span>,   <span class=\"comment\">// 每页多少条数据，默认 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 每一页的数据源，没次加载页面时，会调用函数，然后取返回的数据。</span></span><br><span class=\"line\">        fetchPageData(&#123; pageNo, pageSize &#125;) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> API.getGoodsList(&#123; pageNo, pageSize &#125;)</span><br><span class=\"line\">            </span><br><span class=\"line\">                <span class=\"comment\">// 有时候，需要对服务器的数据进行处理，dataCooker 是你定义的函数。</span></span><br><span class=\"line\">                .then(<span class=\"function\">(<span class=\"params\">rawData</span>) =&gt;</span> dataCooker(rawData));</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    enabledPullDownRefresh: <span class=\"literal\">true</span>,    <span class=\"comment\">// 开启下拉重载， 默认 false</span></span><br><span class=\"line\">    enabledReachBottom: <span class=\"literal\">true</span>,    <span class=\"comment\">// 开启上拉加载， 默认 false</span></span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// goods 数据会被加载到，goods 为上面定义的 name</span></span><br><span class=\"line\"><span class=\"comment\">// this.data.listPage.goods = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     data: [...],     // 视图层，通过该字段来获取具体的数据</span></span><br><span class=\"line\"><span class=\"comment\">//     hasMore: true,   // 视图层，通过该字段来识别是否有下一页</span></span><br><span class=\"line\"><span class=\"comment\">//     currentPage: 1,  // 视图层，通过该字段来识别当前第几页</span></span><br><span class=\"line\"><span class=\"comment\">//     totalPage: undefined,</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n<p>只需要告诉 <code>listpage</code> 如何获取数据，它会自动处理「下拉重载」、「上拉翻页」的操作，然后把数据更新到 <code>this.data.listPage.goods</code> 下。</p>\n<p>View 层只需要描述数据怎么展示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"good\"</span> <span class=\"attr\">wx:for</span>=<span class=\"string\">\"listPage.goods.data\"</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"no-more\"</span> <span class=\"attr\">wx:if</span>=<span class=\"string\">\"listPage.goods.hasMore === false\"</span>&gt;</span></span><br><span class=\"line\">    没有更多了</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>listpage</code> 还支持多数据列表等其他更多配置，详情看：<a href=\"https://github.com/beautywe/plugin-listpage\">@beautywe/plugin-listpage</a></p>\n<h2 id=\"缓存策略-Cache\"><a href=\"#缓存策略-Cache\" class=\"headerlink\" title=\"缓存策略 Cache\"></a>缓存策略 Cache</h2><p><code>@beautywe/plugin-cache</code> 提供了一个微信小程序端缓存策略，其底层由 <a href=\"https://github.com/JerryC8080/super-cache\">super-cache</a> 提供支持。</p>\n<h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><ol>\n<li>提供一套「服务端接口耗时慢，但加载性能要求高」场景的解决方案</li>\n<li>满足最基本的缓存需求，读取（get）和保存（set）</li>\n<li>支持针对缓存进行逻辑代理</li>\n<li>灵活可配置的数据存储方式</li>\n</ol>\n<h4 id=\"How-it-work\"><a href=\"#How-it-work\" class=\"headerlink\" title=\"How it work\"></a>How it work</h4><p>一般的请求数据的形式是，页面加载的时候，从服务端获取数据，然后等待数据返回之后，进行页面渲染：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181755\" alt=\"\"></p>\n<p>但这种模式，会受到服务端接口耗时，网络环境等因素影响到加载性能。   </p>\n<p>对于加载性能要求高的页面（如首页），一般的 Web 开发我们有很多解决方案（如服务端渲染，服务端缓存，SSR 等）。<br>但是也有一些环境不能使用这种技术（如微信小程序）。</p>\n<p>Super Cache 提供了一个中间数据缓存的解决方案：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181847\" alt=\"\"></p>\n<p>思路：    </p>\n<ol>\n<li>当你需要获取一个数据的时候，如果有缓存，先把旧的数据给你。</li>\n<li>然后再从服务端获取新的数据，刷新缓存。</li>\n<li>如果一开始没有缓存，则请求服务端数据，再把数据返回。</li>\n<li>下一次请求缓存，从第一步开始。</li>\n</ol>\n<p>这种解决方案，舍弃了一点数据的实时性（非第一次请求，只能获取上一次最新数据），大大提高了前端的加载性能。<br>适合的场景：    </p>\n<ol>\n<li>数据实时性要求不高。</li>\n<li>服务端接口耗时长。</li>\n</ol>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; BtApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> cache <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/plugin-cache'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> BtApp();</span><br><span class=\"line\">app.use(cache(&#123;</span><br><span class=\"line\">    adapters: [&#123;</span><br><span class=\"line\">        key: <span class=\"string\">'name'</span>,</span><br><span class=\"line\">        data() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> API.fetch(<span class=\"string\">'xxx/name'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>假设 <code>API.fetch(&#39;xxx/name&#39;)</code> 是请求服务器接口，返回数据：<code>data_from_server</code></p>\n<p>那么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.cache.get(<span class=\"string\">'name'</span>).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// value: 'data_from_server'  </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>更多的配置，详情看：<a href=\"https://github.com/beautywe/plugin-cache\">@beautywe/plugin-cache</a></p>\n<h2 id=\"日志-Logger\"><a href=\"#日志-Logger\" class=\"headerlink\" title=\"日志 Logger\"></a>日志 Logger</h2><p>由 <code>@beautywe/logger-plugin</code> 提供的一个轻量的日志处理方案，它支持：</p>\n<ol>\n<li>可控的 log level</li>\n<li>自定义前缀</li>\n<li>日志统一处理</li>\n</ol>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; BtApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> logger <span class=\"keyword\">from</span> <span class=\"string\">'@beautywe/plugin-logger'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> page = <span class=\"keyword\">new</span> BtApp();</span><br><span class=\"line\"></span><br><span class=\"line\">page.use(logger(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// options</span></span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p><strong>API</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page.logger.info(<span class=\"string\">'this is info'</span>);</span><br><span class=\"line\">page.logger.warn(<span class=\"string\">'this is warn'</span>);</span><br><span class=\"line\">page.logger.error(<span class=\"string\">'this is error'</span>);</span><br><span class=\"line\">page.logger.debug(<span class=\"string\">'this is debug'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"comment\">// [info] this is info</span></span><br><span class=\"line\"><span class=\"comment\">// [warn] this is warn</span></span><br><span class=\"line\"><span class=\"comment\">// [error] this is error</span></span><br><span class=\"line\"><span class=\"comment\">// [debug] this is debug</span></span><br></pre></td></tr></table></figure>\n<p><strong>Level control</strong></p>\n<p>可通过配置来控制哪些 level 该打印：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page.use(logger(&#123;</span><br><span class=\"line\">    level: <span class=\"string\">'warn'</span>,</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>那么 <code>warn</code> 以上的 log （<code>info</code>, <code>debug</code>）就不会被打印，这种满足于开发和生成环境对 log 的不同需求。</p>\n<p>level 等级如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Logger.LEVEL = &#123;</span><br><span class=\"line\">    error: <span class=\"number\">1</span>,</span><br><span class=\"line\">    warn: <span class=\"number\">2</span>,</span><br><span class=\"line\">    info: <span class=\"number\">3</span>,</span><br><span class=\"line\">    debug: <span class=\"number\">4</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>更多的配置，详情看：<a href=\"https://github.com/beautywe/plugin-logger\">@beautywe/plugin-logger</a></p>\n<h1 id=\"BeautyWe-Framework\"><a href=\"#BeautyWe-Framework\" class=\"headerlink\" title=\"BeautyWe Framework\"></a>BeautyWe Framework</h1><p><code>@beautywe/core</code> 和 <code>@beautywe/plugin-...</code> 给小程序提供了：</p>\n<ol>\n<li>开放原生，支持插件化 —— by core</li>\n<li>各种插件 —— by plugins</li>\n</ol>\n<p>但是，还有很多的开发中实际还会遇到的痛点，是上面两个解决不到的。<br>如项目的组织、规范、工程化、配置、多环境等等</p>\n<p>这些就是，「BeautyWe Framework」要解决的范畴。</p>\n<p>它作为一套开箱即用的项目框架，提供了这些功能：</p>\n<ul>\n<li>集成 BeautyWe Core</li>\n<li>NPM 支持</li>\n<li>全局窗口</li>\n<li>全局 Page，Component</li>\n<li>全局配置文件</li>\n<li>多环境开发</li>\n<li>Example Pages</li>\n<li>正常项目需要的标配：ES2015+,sass,uglify,watch 等</li>\n<li>以及我们认为良好的项目规范（eslint，commit log，目录结构等）</li>\n</ul>\n<p>也是由于篇幅原因，挑几个有趣的来讲讲，更多的可以看看官方文档：<a href=\"http://beautywejs.com\">BeautyWe</a></p>\n<h2 id=\"快速创建\"><a href=\"#快速创建\" class=\"headerlink\" title=\"快速创建\"></a>快速创建</h2><p>首先安装 <code>@beautywe/cli</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> npm i @beautywe/cli -g</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> beautywe new app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;</span> appName: my-app</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> version: 0.0.1</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> appid: 123456</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> 这样可以么:</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span>    \"appName\": \"my-app\",</span><br><span class=\"line\"><span class=\"meta\">&gt;</span>    \"version\": \"0.0.1\",</span><br><span class=\"line\"><span class=\"meta\">&gt;</span>    \"appid\": \"123456\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>回答几个问题之后，项目就生成了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-app</span><br><span class=\"line\">├── gulpfile.js</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── app.js</span><br><span class=\"line\">    ├── app.json</span><br><span class=\"line\">    ├── app.scss</span><br><span class=\"line\">    ├── assets</span><br><span class=\"line\">    ├── components</span><br><span class=\"line\">    ├── config</span><br><span class=\"line\">    ├── examples</span><br><span class=\"line\">    ├── libs</span><br><span class=\"line\">    ├── npm</span><br><span class=\"line\">    ├── pages</span><br><span class=\"line\">    └── project.config.json</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建页面、组件、插件\"><a href=\"#创建页面、组件、插件\" class=\"headerlink\" title=\"创建页面、组件、插件\"></a>创建页面、组件、插件</h4><p><strong>页面</strong></p>\n<ol>\n<li>主包页面：<code>beautywe new page &lt;path|name&gt;</code></li>\n<li>分包页面：<code>beautywe new page --subpkg &lt;subPackageName&gt; &lt;path|name&gt;</code></li>\n</ol>\n<p><strong>组件</strong></p>\n<ol>\n<li><code>beautywe new component &lt;name&gt;</code></li>\n</ol>\n<p><strong>插件</strong></p>\n<ol>\n<li><code>beautywe new plugin &lt;name&gt;</code></li>\n</ol>\n<h4 id=\"自定义模板\"><a href=\"#自定义模板\" class=\"headerlink\" title=\"自定义模板\"></a>自定义模板</h4><p>在 <code>./.templates</code> 目录中，存放着快速创建命令的创建模板：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tree .templates</span><br><span class=\"line\"></span><br><span class=\"line\">.templates</span><br><span class=\"line\">├── component</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   ├── index.json</span><br><span class=\"line\">│   ├── index.scss</span><br><span class=\"line\">│   └── index.wxml</span><br><span class=\"line\">├── page</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   ├── index.json</span><br><span class=\"line\">│   ├── index.scss</span><br><span class=\"line\">│   └── index.wxml</span><br><span class=\"line\">└── plugin</span><br><span class=\"line\">    └── index.js</span><br></pre></td></tr></table></figure>\n<p>可以修改里面的模板，来满足项目级别的自定义模板创建。</p>\n<h2 id=\"全局窗口\"><a href=\"#全局窗口\" class=\"headerlink\" title=\"全局窗口\"></a>全局窗口</h2><p>我们都知道微信小程序是「单窗口」的交互平台，一个页面对应一个窗口。<br>而在业务开发中，往往会有诸如这种述求：</p>\n<ol>\n<li>自定义的 toast 样式</li>\n<li>页面底部 copyright</li>\n<li>全局的 loading 样式</li>\n<li>全局的悬浮控件<br>……</li>\n</ol>\n<p>稍微不优雅的实现可以是分别做成独立的组件，然后每一个页面都引入进来。<br>这种做法，我们会有很多的重复代码，并且每次新建页面，都要引入一遍，后期维护也会很繁琐。</p>\n<p>而「全局窗口」的概念是：<strong>希望所有页面之上有一块地方，全局性的逻辑和交互，可以往里面搁。</strong></p>\n<h4 id=\"global-view-组件\"><a href=\"#global-view-组件\" class=\"headerlink\" title=\"global-view 组件\"></a>global-view 组件</h4><p>这是一个自定义组件，源码在 <code>/src/components/global-view</code></p>\n<p>每个页面的 wxml 只需要在顶层包一层：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">global-view</span> <span class=\"attr\">id</span>=<span class=\"string\">\"global-view\"</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">global-view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>需要全局实现的交互、样式、组件，只需要维护这个组件就足够了。</p>\n<h2 id=\"全局配置文件\"><a href=\"#全局配置文件\" class=\"headerlink\" title=\"全局配置文件\"></a>全局配置文件</h2><p>在 <code>src/config/</code> 目录中，可以存放各种全局的配置文件，并且支持以 Node.js 的方式运行。（得益于 <a href=\"/contents/framework/concept/nodejs-power.md\">Node.js Power 特性</a>）。</p>\n<p>如 <code>src/config/logger.js</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> env = process.env.RUN_ENV || <span class=\"string\">'dev'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"built_in\">Object</span>.assign(&#123;</span><br><span class=\"line\">    prefix: <span class=\"string\">'BeautyWe'</span>,</span><br><span class=\"line\">    level: <span class=\"string\">'debug'</span>,</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开发环境的配置</span></span><br><span class=\"line\">    dev: &#123;</span><br><span class=\"line\">        level: <span class=\"string\">'debug'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 测试环境的配置</span></span><br><span class=\"line\">    test: &#123;</span><br><span class=\"line\">        level: <span class=\"string\">'info'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 线上环境的配置</span></span><br><span class=\"line\">    prod: &#123;</span><br><span class=\"line\">        level: <span class=\"string\">'warn'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;[env] || &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports.logger = logger;</span><br></pre></td></tr></table></figure>\n<p>然后我们可以这样读取到 config 内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; logger &#125; <span class=\"keyword\">from</span> <span class=\"string\">'/config/index'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// logger.level 会根据环境不同而不同。</span></span><br></pre></td></tr></table></figure>\n<p>Beautywe Framework 默认会把 config 集成到 <code>getApp()</code> 的示例中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getApp().config;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多环境开发\"><a href=\"#多环境开发\" class=\"headerlink\" title=\"多环境开发\"></a>多环境开发</h2><p>BeautyWe Framework 支持多环境开发，其中预设了三套策略：</p>\n<ul>\n<li>dev</li>\n<li>test</li>\n<li>prod</li>\n</ul>\n<p>我们可以通过命令来运行这三个构建策略：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beautywe run dev</span><br><span class=\"line\">beautywe run test</span><br><span class=\"line\">beautywe run prod</span><br></pre></td></tr></table></figure>\n<h2 id=\"三套环境的差异\"><a href=\"#三套环境的差异\" class=\"headerlink\" title=\"三套环境的差异\"></a>三套环境的差异</h2><p>Beautywe Framework 源码默认在两方面使用了多环境：</p>\n<ul>\n<li>构建任务（<code>gulpfile.js/env/...</code>）</li>\n<li>全局配置（<code>src/config/...</code>）</li>\n</ul>\n<h3 id=\"构建任务的差异\"><a href=\"#构建任务的差异\" class=\"headerlink\" title=\"构建任务的差异\"></a>构建任务的差异</h3><table>\n<thead>\n<tr>\n<th>构建任务</th>\n<th>说明</th>\n<th style=\"text-align:center\">dev</th>\n<th style=\"text-align:center\">test</th>\n<th style=\"text-align:center\">prod</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>clean</td>\n<td>清除dist文件</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>copy</td>\n<td>复制资源文件</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>scripts</td>\n<td>编译JS文件</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>sass</td>\n<td>编译scss文件</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>npm</td>\n<td>编译npm文件</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>nodejs-power</td>\n<td>编译Node.js文件</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>watch</td>\n<td>监听文件修改</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>scripts-min</td>\n<td>压缩JS文件</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>sass-min</td>\n<td>压缩scss文件</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>npm-min</td>\n<td>压缩npm文件</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>image-min</td>\n<td>压缩图片文件</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td>clean-example</td>\n<td>清除示例页面</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">√</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Node-js-Power\"><a href=\"#Node-js-Power\" class=\"headerlink\" title=\"Node.js Power\"></a>Node.js Power</h3><p>Beautywe Framework 的代码有两种运行环境：</p>\n<ol>\n<li>Node.js 运行环境，如构建任务等。</li>\n<li>微信小程序运行环境，如打包到 <code>dist</code> 文件夹的代码。</li>\n</ol>\n<h4 id=\"运行过程\"><a href=\"#运行过程\" class=\"headerlink\" title=\"运行过程\"></a>运行过程</h4><blockquote>\n<p>Node.js Power 本质是一种静态编译的实现。<br>把某个文件在 Node.js 环境运行的结果，输出到微信小程序运行环境中，以此来满足特定的需求。</p>\n</blockquote>\n<p>Node.js Power 会把项目中 <code>src</code> 目录下类似 <code>xxx.nodepower.js</code> 命名的文件，以 Node.js 来运行，<br>然后把运行的结果，以「字面量对象」的形式写到 <code>dist</code> 目录下对应的同名文件 <code>xxx.nodepower.js</code> 文件去。</p>\n<p>以 <code>src/config/index.nodepower.js</code> 为例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> files = fs.readdirSync(path.join(__dirname));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">files</span><br><span class=\"line\">    .filter(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> name !== <span class=\"string\">'index.js'</span>)</span><br><span class=\"line\">    .forEach(<span class=\"function\">(<span class=\"params\">name</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.assign(result, <span class=\"built_in\">require</span>(path.join(__dirname, <span class=\"string\">`./<span class=\"subst\">$&#123;name&#125;</span>`</span>)));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = result;</span><br></pre></td></tr></table></figure>\n<p>该文件，经过 Node.js Power 构建之后:</p>\n<p><code>dist/config/index.nodepower.js</code>: </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"appInfo\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.0.1\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"env\"</span>: <span class=\"string\">\"test\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"appid\"</span>: <span class=\"string\">\"wx85fc0d03fb0b224d\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"beautywe-framework-test-app\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"logger\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"prefix\"</span>: <span class=\"string\">\"BeautyWe\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"level\"</span>: <span class=\"string\">\"info\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这就满足了，随意往 <code>src/config/</code> 目录中扩展配置文件，都能被自动打包。</p>\n<p>Node.js Power 已经被集成到多环境开发的 dev, test, prod 中去。</p>\n<p>当然，你可以手动运行这个构建任务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gulp nodejs-power</span><br></pre></td></tr></table></figure>\n<h3 id=\"NPM\"><a href=\"#NPM\" class=\"headerlink\" title=\"NPM\"></a>NPM</h3><p>BeautyWe Framework 实现支持 npm 的原理很简单，总结一句话：</p>\n<blockquote>\n<p>使用 webpack 打包 <code>src/npm/index.js</code> ，以 commonjs 格式输出到 <code>dist/npm/index.js</code></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181936\" alt=\"npm-works\"></p>\n<p>这样做的好处：</p>\n<ol>\n<li>实现简单。</li>\n<li>让 npm 包能集中管理，每次引入依赖，都好好的想一下，避免泛滥（尤其在多人开发中）。</li>\n<li>使用 <code>ll dist/npm/index.js</code> 命令能快速看到项目中的 npm 包使占了多少容量。</li>\n</ol>\n<h4 id=\"新增-npm-依赖\"><a href=\"#新增-npm-依赖\" class=\"headerlink\" title=\"新增 npm 依赖\"></a>新增 npm 依赖</h4><p>在 <code>src/npm/index.js</code> 文件中，进行 export：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123; default as beautywe &#125; from &apos;@beautywe/core&apos;;</span><br></pre></td></tr></table></figure>\n<p>然后在其他文件 import：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; beautywe &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./npm/index'</span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"更多\"><a href=\"#更多\" class=\"headerlink\" title=\"更多\"></a>更多</h1><p>总的来说，BeautyWe 是一套微信小程序的开发范式。</p>\n<p><code>core</code> 和 <code>plugins</code> 扩展原生，提供复杂逻辑的封装和插拔式使用。</p>\n<p>而 <code>framework</code> 则负责提供一整套针对于微信小程序的企业级项目解决方案，开箱即用。</p>\n<p>其中还有更多的内容，欢迎浏览官网：<a href=\"http://beautywejs.com\">beautywejs.com</a></p>\n"},{"title":"关于 OKR 的一些方法论","date":"2019-07-06T14:53:00.000Z","_content":"\n# 前言\n\nOKR 是由前 Intel CEO，[安迪·葛洛夫](https://www.wikiwand.com/zh-hk/%E5%AE%89%E8%BF%AA%C2%B7%E8%91%9B%E6%B4%9B%E5%A4%AB) 构建的基本框架。\n\n全称是：「Objective - Key Result」，既强调「目标」与衡量目标的「关键结果」\n\n它是一套管理目标，让目标能落地的工具。\n它在硅谷科技公司中广为人知，并被世界各地的许多组织采用。\n它可以应用在组织中，也可以应用在个人的生活中，就像一种思考的模式。\n\n过去两年多的 OKR 实践，有一些体会。\n作为一个程序员，会自然的去寻找一个工具的最佳实践。\n\n于是，有了这篇文章。\n\n# 基本原理\n\nOKR 原理很简单。\n\n要用好 OKR，我的理解，需要把握三个核心：\n\n* 目标\n* 关键结果\n* 过程管理\n\n它们分别回答了三个问题：\n\n* 应该做什么？\n* 如何衡量做到了？\n* 怎么落地？\n\n然后，思考 OKR，我认为还需要 cover 到两点：\n\n* 看得到的结果\n* 说得出的价值\n\n**先抛一个不好的例子**\n\n来自于我曾经定过的一个 OKR：\n\n> O: 持续学习，提高自身战斗力\n> - KR1: CSS3 学习，阅读《CSS揭秘》产出阅读笔记。\n> - KR2: 提高英文阅读能力，阅读《Security Your NodeJS Application》，产出一篇译文。\n> - KR3: 对 Eggjs 或 Vue2 框架的源码进行解读，产出一篇源码解析。\n\n我想先按顺序来讲讲「目标」、「关键结果」、「过程管理」。\n然后，再回过头来，看看这个例子为啥糟糕，可以怎样修改。\n\n### 目标 Objective\n\n> 欲望让我们起航，但只有专注、规划和学习才能到达成功的彼岸\n\n##### 组织的诞生\n\n回到最初的时候，一个组织的诞生，绝大多数情况是由于一两个人的想法，然后以此为中心，开始聚拢更多有共同目标的人加入进来。\n\n1976年，乔布斯成功说服沃茲尼克組裝机器之后再拿去推销，他们的另一位朋友韦恩随后加入，三人在1976年4月1日成立苹果电脑公司。最初，Apple 仅仅是在卖组装电脑。\n\n1996年，佩奇和布林在学校开始一项关于搜索的研究项目，开发出了搜索引擎 PageRank，后续改名 Google。最初，Google 仅仅是一个搜索引擎。\n\n##### 组织的使命\n\n随着组织发展，人员壮大，这个能聚拢人的目标，必须要看得远。然后这个目标提升到用另一个词来形容 —「使命」。\n\nApple 的使命：「藉推广公平的资料使用惯例，建立用户对互联网之信任和信心」\nGoogle 的使命：「整合全球信息，使人人皆可访问和收益」\n阿里巴巴的使命：「让天下没有难做的生意」\n有赞的使命：「帮助每一位重视产品和服务的商家成功」\n以及最近我们团队的前端技术委员的使命：「以极致的技术高效支撑业务」\n\n使命描述一般都很简洁，并且容易记忆，像一句广告词，能深深的刻在脑海里。\n在工作中遇到问题的时候，这个使命就会一下子从脑海里蹦出来指引你找到答案。\n\n其实在某个市场闲逛都有可能让你意识到这个市场有某个问题需要解决，而帮市场解决这个问题，就是一个使命。\n\n##### 阶段性的目标\n\n为了一步步的达成「使命」，我们需要有目标。相对于使命，它粒度更小，且有时间限制。\n\n所以，目标（Objective）应该：\n* 是阶段性的\n* 是有优先级的\n* 它需要能明确方向且鼓舞人心\n\n目标，是 OKR 中最重要，最需要想清楚，最首要确定的。\n在这里，需要回答：你有什么？你要什么？你能放弃什么？\n\n##### 重要与紧急\n\n「鱼与熊掌不可得兼」，所以我们要有所取舍，事情排个优先级。\n「重要-紧急象限」是一个不错的指导工具，第一次看到它是在柯维《高效能人士的7个习惯》中的第三个习惯「要事第一」。\n\n![重要-紧急](https://img.yzcdn.cn/public_files/2019/07/06/e5ce3614f98f98d538944350bd505993.png)\n\n但在实施的过程中中很有可能会遇到这样一个问题，紧急不重要的事情很紧急，总需要花时间和精力去处理它。然后重要不紧急的事情，会常常分配不到时间和精力。\n\n**那么就让重要不紧急的事情也变得紧急起来。**\n\n##### 目标需要自上而下的关联\n\n如果基础的商业问题没有解决，不论实现多少产品功能，团队整体的绩效一定会大打折扣。\n\n在一个组织中，如果没有充分的理解上一层的目标，就很容易跑偏，没有真正在刀刃上使力，造成效率上的浪费。\n\n达到充分的理解目标，是有难度的，对人的眼界、目标理解能力有很高的要求。这不仅仅是执行者责任，更是管理者的责任。\n\n\n### 关键结果 Key Result\n\n##### 衡量目标是否达成\n\n目标定下来了，如果不去执行和落地，那么它永远就只是一个目标。如何去衡量目标是否达到了，就是「关键结果」的任务。\n\n在互联网产品中，通常可以量化的条件有：用户增长、用户激活、收入增长、产品性能、产品质量。\n\n作为技术团队，会更加集中注意力在产品性能和产品质量上面，那么如何去找到这些方向的衡量指标，就要从实际出发了。\n\n比如我们团队会用「质量系数 = BUG数/估时」，来感受一个项目的质量情况。虽然它会有些漏洞，但如果建立在互相信任的基础上，可以提供一定的参考价值。\n\n##### 有些挑战性\n\n> 当达到成结果的时候，我们应该是欢呼雀跃般的兴奋，而不是理所应当的淡定。\n\n定下一个关键结果之后，问一下自己，有多少信心可以完成。如果信心爆棚，就把目标定高些。如果信心不足，就把目标调低些。因为 OKR 的意义不在于完成目标，更重要的是它能挖掘团队以及个人的潜力。\n\n如果觉得有必要的话，我们可以建立一个「信心指数」，用来帮助确定结果有足够的挑战性而不会让人失去信心。这个指数的开始值最好是 50%，然后通过过程管理来动态变更和追踪。\n\n比如去年我负责的一个「优化微信小程序加载性能」项目中的关键结果：\n\n* 首屏加载时间 3s 内\n\n未优化的加载时间是 6s+，回顾当时对目标的信心指数的话，大概是 20%。虽然最后因为部分不可控因素没有达到这个目标，只能维持在 3s-4s 之间。但是这个过程中能让人费尽脑汁的找到各种方法，大幅的提升了除首屏加载以外其他方面的加载体验，这也是额外的收获。\n\n作为管理者，你要清楚的知道哪些人推一推会有更高的产出，哪些人实际执行情况会出现问题，要能看得到看得懂目前组织的目标和进度，并与成员进行同步。\n\n### 过程管理\n\nOKR 定下来了，在期限内，就要奔着目标努力奋进。尽管中途发现问题，也尽量不要在中途更改 OKR，让我们尽力跑完计划的阶段再回来总结。我们也可以把时间维度切小，比如把年度切分为半年度，把半年度切分为季度。\n\n并且，目标定下来之后，要经常定期共同回顾，共同看见。而不是定下来了，就放在那里，否则过程中团队发生了问题，成员遇到了困难，很大可能会不被看到。\n\n比较好的形式是每周都一起坐下来看看，每个人分享一下成果，或者说说遇到的困难，看能不能得到其他人的帮助。这个过程，能及时的看到问题，也能让成员对目标有更强的参与感。\n\n那么，OKR应该以什么方式来呈现？《OKR工作法》一书中提供了一种参考：「四象限呈现形式」\n\n![四象限呈现](https://img.yzcdn.cn/public_files/2019/07/06/989bdd617bc44bab7dcfdd18120ac8a8.jpeg)\n\n* 第一象限：本周3-4件最重要的事情，并且进行优先级的排序\n* 第二象限：把OKR内容罗列出来，关注和更新每一项KR的信心指数\n* 第三象限：未来中长段时间中的计划，能让我们稍微看远一些。\n* 第四象限：关注那些影响目标的关键因素会不会掉链子，例如团队状态，系统状态等。也可以用红蓝黄颜色表示出来。\n\n# 回过头看看那个糟糕的例子\n\n糟糕的例子：\n\n> O: 持续学习，提高自身战斗力\n> - KR1:CSS3 学习，阅读《CSS揭秘》 产出阅读笔记。\n> - KR2:提高英文阅读能力，阅读《Security Your NodeJS Application》，产出一篇译文。\n> - KR3: Vue2 框架的源码进行解读，产出一篇源码解析。\n\n这个例子的背景是我 2017 年 4 月份加入到有赞，当时定的试用期内的其中一个目标。那时是我第一次认识和使用 OKR，只是单纯的把自身的技能提升计划给罗列了出来，看起来更像是一个 Todo List\n\n现在回过头来看这一份 OKR，有不少问题：\n\n1. 目标没有描述出来价值，提升了自身战斗力，然后呢？并没有自上而下的关联团队和组织的目标。所以从目标上，就已经走偏了。\n2. 假设目标正确，KR 也没有起到能衡量目标是否达成的作用。例如 KR1 完成了，对目标的推进，并没有说服力。\n3. 最后把 OKR 用成了 Todo List。\n\n那么我们从目标开始分析，当时作为一个新人加入到一个新的团队，对团队的技术栈和项目都很陌生，需要填补部分空白，快速上手。所以提升自身实力的底层诉求是：快速上手，胜任开发工作。\n\n然后怎么衡量目的达到了呢？我们可以通过项目质量直接衡量，通过项目的熟悉程度来间接衡量。\n\n修正后：\n\n> O: 快速上手，以专业的姿态胜任开发工作。\n>   * KR1: 质量系数平均在 0.3 以内。（质量系数 = BUG数/估时）\n>   * KR2: 代码评审评分平均 3.5 以上。（我们有 Code Review 机制，并且有评分环节）\n>   * KR3: 所参与项目评分在 4 以上。（项目也有评分环节）\n>   * KR4: 进行两次的项目分享。\n\n那么如果达到这些关键结果，要通过学习框架，还是研究项目，还是熟悉业务，那就是根据实际迎刃而解的事情了。\n\n# 最后\n\n> 凡事预则立，不预则废 ——《礼记·中庸》\n\n最后要注意的是，OKR 只是一个工具，当你有一个目标，它会给你一种落实目标的方法论。而如果一开始目标没有想清楚，想明白，那就很容易在错的路上越走越远。\n\n每个团队都会有不同的风格，和不同的实际情况。理解方法和工具的原理，明白这么做是为了解决什么问题，然后再调整定制真正适合此时此刻的团队，才是最好的方法。","source":"_posts/about-okr.md","raw":"---\ntitle: 关于 OKR 的一些方法论\ncategory: 三省吾身\ndate: 2019-07-06 22:53\n---\n\n# 前言\n\nOKR 是由前 Intel CEO，[安迪·葛洛夫](https://www.wikiwand.com/zh-hk/%E5%AE%89%E8%BF%AA%C2%B7%E8%91%9B%E6%B4%9B%E5%A4%AB) 构建的基本框架。\n\n全称是：「Objective - Key Result」，既强调「目标」与衡量目标的「关键结果」\n\n它是一套管理目标，让目标能落地的工具。\n它在硅谷科技公司中广为人知，并被世界各地的许多组织采用。\n它可以应用在组织中，也可以应用在个人的生活中，就像一种思考的模式。\n\n过去两年多的 OKR 实践，有一些体会。\n作为一个程序员，会自然的去寻找一个工具的最佳实践。\n\n于是，有了这篇文章。\n\n# 基本原理\n\nOKR 原理很简单。\n\n要用好 OKR，我的理解，需要把握三个核心：\n\n* 目标\n* 关键结果\n* 过程管理\n\n它们分别回答了三个问题：\n\n* 应该做什么？\n* 如何衡量做到了？\n* 怎么落地？\n\n然后，思考 OKR，我认为还需要 cover 到两点：\n\n* 看得到的结果\n* 说得出的价值\n\n**先抛一个不好的例子**\n\n来自于我曾经定过的一个 OKR：\n\n> O: 持续学习，提高自身战斗力\n> - KR1: CSS3 学习，阅读《CSS揭秘》产出阅读笔记。\n> - KR2: 提高英文阅读能力，阅读《Security Your NodeJS Application》，产出一篇译文。\n> - KR3: 对 Eggjs 或 Vue2 框架的源码进行解读，产出一篇源码解析。\n\n我想先按顺序来讲讲「目标」、「关键结果」、「过程管理」。\n然后，再回过头来，看看这个例子为啥糟糕，可以怎样修改。\n\n### 目标 Objective\n\n> 欲望让我们起航，但只有专注、规划和学习才能到达成功的彼岸\n\n##### 组织的诞生\n\n回到最初的时候，一个组织的诞生，绝大多数情况是由于一两个人的想法，然后以此为中心，开始聚拢更多有共同目标的人加入进来。\n\n1976年，乔布斯成功说服沃茲尼克組裝机器之后再拿去推销，他们的另一位朋友韦恩随后加入，三人在1976年4月1日成立苹果电脑公司。最初，Apple 仅仅是在卖组装电脑。\n\n1996年，佩奇和布林在学校开始一项关于搜索的研究项目，开发出了搜索引擎 PageRank，后续改名 Google。最初，Google 仅仅是一个搜索引擎。\n\n##### 组织的使命\n\n随着组织发展，人员壮大，这个能聚拢人的目标，必须要看得远。然后这个目标提升到用另一个词来形容 —「使命」。\n\nApple 的使命：「藉推广公平的资料使用惯例，建立用户对互联网之信任和信心」\nGoogle 的使命：「整合全球信息，使人人皆可访问和收益」\n阿里巴巴的使命：「让天下没有难做的生意」\n有赞的使命：「帮助每一位重视产品和服务的商家成功」\n以及最近我们团队的前端技术委员的使命：「以极致的技术高效支撑业务」\n\n使命描述一般都很简洁，并且容易记忆，像一句广告词，能深深的刻在脑海里。\n在工作中遇到问题的时候，这个使命就会一下子从脑海里蹦出来指引你找到答案。\n\n其实在某个市场闲逛都有可能让你意识到这个市场有某个问题需要解决，而帮市场解决这个问题，就是一个使命。\n\n##### 阶段性的目标\n\n为了一步步的达成「使命」，我们需要有目标。相对于使命，它粒度更小，且有时间限制。\n\n所以，目标（Objective）应该：\n* 是阶段性的\n* 是有优先级的\n* 它需要能明确方向且鼓舞人心\n\n目标，是 OKR 中最重要，最需要想清楚，最首要确定的。\n在这里，需要回答：你有什么？你要什么？你能放弃什么？\n\n##### 重要与紧急\n\n「鱼与熊掌不可得兼」，所以我们要有所取舍，事情排个优先级。\n「重要-紧急象限」是一个不错的指导工具，第一次看到它是在柯维《高效能人士的7个习惯》中的第三个习惯「要事第一」。\n\n![重要-紧急](https://img.yzcdn.cn/public_files/2019/07/06/e5ce3614f98f98d538944350bd505993.png)\n\n但在实施的过程中中很有可能会遇到这样一个问题，紧急不重要的事情很紧急，总需要花时间和精力去处理它。然后重要不紧急的事情，会常常分配不到时间和精力。\n\n**那么就让重要不紧急的事情也变得紧急起来。**\n\n##### 目标需要自上而下的关联\n\n如果基础的商业问题没有解决，不论实现多少产品功能，团队整体的绩效一定会大打折扣。\n\n在一个组织中，如果没有充分的理解上一层的目标，就很容易跑偏，没有真正在刀刃上使力，造成效率上的浪费。\n\n达到充分的理解目标，是有难度的，对人的眼界、目标理解能力有很高的要求。这不仅仅是执行者责任，更是管理者的责任。\n\n\n### 关键结果 Key Result\n\n##### 衡量目标是否达成\n\n目标定下来了，如果不去执行和落地，那么它永远就只是一个目标。如何去衡量目标是否达到了，就是「关键结果」的任务。\n\n在互联网产品中，通常可以量化的条件有：用户增长、用户激活、收入增长、产品性能、产品质量。\n\n作为技术团队，会更加集中注意力在产品性能和产品质量上面，那么如何去找到这些方向的衡量指标，就要从实际出发了。\n\n比如我们团队会用「质量系数 = BUG数/估时」，来感受一个项目的质量情况。虽然它会有些漏洞，但如果建立在互相信任的基础上，可以提供一定的参考价值。\n\n##### 有些挑战性\n\n> 当达到成结果的时候，我们应该是欢呼雀跃般的兴奋，而不是理所应当的淡定。\n\n定下一个关键结果之后，问一下自己，有多少信心可以完成。如果信心爆棚，就把目标定高些。如果信心不足，就把目标调低些。因为 OKR 的意义不在于完成目标，更重要的是它能挖掘团队以及个人的潜力。\n\n如果觉得有必要的话，我们可以建立一个「信心指数」，用来帮助确定结果有足够的挑战性而不会让人失去信心。这个指数的开始值最好是 50%，然后通过过程管理来动态变更和追踪。\n\n比如去年我负责的一个「优化微信小程序加载性能」项目中的关键结果：\n\n* 首屏加载时间 3s 内\n\n未优化的加载时间是 6s+，回顾当时对目标的信心指数的话，大概是 20%。虽然最后因为部分不可控因素没有达到这个目标，只能维持在 3s-4s 之间。但是这个过程中能让人费尽脑汁的找到各种方法，大幅的提升了除首屏加载以外其他方面的加载体验，这也是额外的收获。\n\n作为管理者，你要清楚的知道哪些人推一推会有更高的产出，哪些人实际执行情况会出现问题，要能看得到看得懂目前组织的目标和进度，并与成员进行同步。\n\n### 过程管理\n\nOKR 定下来了，在期限内，就要奔着目标努力奋进。尽管中途发现问题，也尽量不要在中途更改 OKR，让我们尽力跑完计划的阶段再回来总结。我们也可以把时间维度切小，比如把年度切分为半年度，把半年度切分为季度。\n\n并且，目标定下来之后，要经常定期共同回顾，共同看见。而不是定下来了，就放在那里，否则过程中团队发生了问题，成员遇到了困难，很大可能会不被看到。\n\n比较好的形式是每周都一起坐下来看看，每个人分享一下成果，或者说说遇到的困难，看能不能得到其他人的帮助。这个过程，能及时的看到问题，也能让成员对目标有更强的参与感。\n\n那么，OKR应该以什么方式来呈现？《OKR工作法》一书中提供了一种参考：「四象限呈现形式」\n\n![四象限呈现](https://img.yzcdn.cn/public_files/2019/07/06/989bdd617bc44bab7dcfdd18120ac8a8.jpeg)\n\n* 第一象限：本周3-4件最重要的事情，并且进行优先级的排序\n* 第二象限：把OKR内容罗列出来，关注和更新每一项KR的信心指数\n* 第三象限：未来中长段时间中的计划，能让我们稍微看远一些。\n* 第四象限：关注那些影响目标的关键因素会不会掉链子，例如团队状态，系统状态等。也可以用红蓝黄颜色表示出来。\n\n# 回过头看看那个糟糕的例子\n\n糟糕的例子：\n\n> O: 持续学习，提高自身战斗力\n> - KR1:CSS3 学习，阅读《CSS揭秘》 产出阅读笔记。\n> - KR2:提高英文阅读能力，阅读《Security Your NodeJS Application》，产出一篇译文。\n> - KR3: Vue2 框架的源码进行解读，产出一篇源码解析。\n\n这个例子的背景是我 2017 年 4 月份加入到有赞，当时定的试用期内的其中一个目标。那时是我第一次认识和使用 OKR，只是单纯的把自身的技能提升计划给罗列了出来，看起来更像是一个 Todo List\n\n现在回过头来看这一份 OKR，有不少问题：\n\n1. 目标没有描述出来价值，提升了自身战斗力，然后呢？并没有自上而下的关联团队和组织的目标。所以从目标上，就已经走偏了。\n2. 假设目标正确，KR 也没有起到能衡量目标是否达成的作用。例如 KR1 完成了，对目标的推进，并没有说服力。\n3. 最后把 OKR 用成了 Todo List。\n\n那么我们从目标开始分析，当时作为一个新人加入到一个新的团队，对团队的技术栈和项目都很陌生，需要填补部分空白，快速上手。所以提升自身实力的底层诉求是：快速上手，胜任开发工作。\n\n然后怎么衡量目的达到了呢？我们可以通过项目质量直接衡量，通过项目的熟悉程度来间接衡量。\n\n修正后：\n\n> O: 快速上手，以专业的姿态胜任开发工作。\n>   * KR1: 质量系数平均在 0.3 以内。（质量系数 = BUG数/估时）\n>   * KR2: 代码评审评分平均 3.5 以上。（我们有 Code Review 机制，并且有评分环节）\n>   * KR3: 所参与项目评分在 4 以上。（项目也有评分环节）\n>   * KR4: 进行两次的项目分享。\n\n那么如果达到这些关键结果，要通过学习框架，还是研究项目，还是熟悉业务，那就是根据实际迎刃而解的事情了。\n\n# 最后\n\n> 凡事预则立，不预则废 ——《礼记·中庸》\n\n最后要注意的是，OKR 只是一个工具，当你有一个目标，它会给你一种落实目标的方法论。而如果一开始目标没有想清楚，想明白，那就很容易在错的路上越走越远。\n\n每个团队都会有不同的风格，和不同的实际情况。理解方法和工具的原理，明白这么做是为了解决什么问题，然后再调整定制真正适合此时此刻的团队，才是最好的方法。","slug":"about-okr","published":1,"updated":"2019-07-06T15:10:30.994Z","_id":"cl270y8tn0063xwrlflkldp80","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>OKR 是由前 Intel CEO，<a href=\"https://www.wikiwand.com/zh-hk/%E5%AE%89%E8%BF%AA%C2%B7%E8%91%9B%E6%B4%9B%E5%A4%AB\" target=\"_blank\" rel=\"external\">安迪·葛洛夫</a> 构建的基本框架。</p>\n<p>全称是：「Objective - Key Result」，既强调「目标」与衡量目标的「关键结果」</p>\n<p>它是一套管理目标，让目标能落地的工具。<br>它在硅谷科技公司中广为人知，并被世界各地的许多组织采用。<br>它可以应用在组织中，也可以应用在个人的生活中，就像一种思考的模式。</p>\n<p>过去两年多的 OKR 实践，有一些体会。<br>作为一个程序员，会自然的去寻找一个工具的最佳实践。</p>\n<p>于是，有了这篇文章。</p>\n<h1 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h1><p>OKR 原理很简单。</p>\n<p>要用好 OKR，我的理解，需要把握三个核心：</p>\n<ul>\n<li>目标</li>\n<li>关键结果</li>\n<li>过程管理</li>\n</ul>\n<p>它们分别回答了三个问题：</p>\n<ul>\n<li>应该做什么？</li>\n<li>如何衡量做到了？</li>\n<li>怎么落地？</li>\n</ul>\n<p>然后，思考 OKR，我认为还需要 cover 到两点：</p>\n<ul>\n<li>看得到的结果</li>\n<li>说得出的价值</li>\n</ul>\n<p><strong>先抛一个不好的例子</strong></p>\n<p>来自于我曾经定过的一个 OKR：</p>\n<blockquote>\n<p>O: 持续学习，提高自身战斗力</p>\n<ul>\n<li>KR1: CSS3 学习，阅读《CSS揭秘》产出阅读笔记。</li>\n<li>KR2: 提高英文阅读能力，阅读《Security Your NodeJS Application》，产出一篇译文。</li>\n<li>KR3: 对 Eggjs 或 Vue2 框架的源码进行解读，产出一篇源码解析。</li>\n</ul>\n</blockquote>\n<p>我想先按顺序来讲讲「目标」、「关键结果」、「过程管理」。<br>然后，再回过头来，看看这个例子为啥糟糕，可以怎样修改。</p>\n<h3 id=\"目标-Objective\"><a href=\"#目标-Objective\" class=\"headerlink\" title=\"目标 Objective\"></a>目标 Objective</h3><blockquote>\n<p>欲望让我们起航，但只有专注、规划和学习才能到达成功的彼岸</p>\n</blockquote>\n<h5 id=\"组织的诞生\"><a href=\"#组织的诞生\" class=\"headerlink\" title=\"组织的诞生\"></a>组织的诞生</h5><p>回到最初的时候，一个组织的诞生，绝大多数情况是由于一两个人的想法，然后以此为中心，开始聚拢更多有共同目标的人加入进来。</p>\n<p>1976年，乔布斯成功说服沃茲尼克組裝机器之后再拿去推销，他们的另一位朋友韦恩随后加入，三人在1976年4月1日成立苹果电脑公司。最初，Apple 仅仅是在卖组装电脑。</p>\n<p>1996年，佩奇和布林在学校开始一项关于搜索的研究项目，开发出了搜索引擎 PageRank，后续改名 Google。最初，Google 仅仅是一个搜索引擎。</p>\n<h5 id=\"组织的使命\"><a href=\"#组织的使命\" class=\"headerlink\" title=\"组织的使命\"></a>组织的使命</h5><p>随着组织发展，人员壮大，这个能聚拢人的目标，必须要看得远。然后这个目标提升到用另一个词来形容 —「使命」。</p>\n<p>Apple 的使命：「藉推广公平的资料使用惯例，建立用户对互联网之信任和信心」<br>Google 的使命：「整合全球信息，使人人皆可访问和收益」<br>阿里巴巴的使命：「让天下没有难做的生意」<br>有赞的使命：「帮助每一位重视产品和服务的商家成功」<br>以及最近我们团队的前端技术委员的使命：「以极致的技术高效支撑业务」</p>\n<p>使命描述一般都很简洁，并且容易记忆，像一句广告词，能深深的刻在脑海里。<br>在工作中遇到问题的时候，这个使命就会一下子从脑海里蹦出来指引你找到答案。</p>\n<p>其实在某个市场闲逛都有可能让你意识到这个市场有某个问题需要解决，而帮市场解决这个问题，就是一个使命。</p>\n<h5 id=\"阶段性的目标\"><a href=\"#阶段性的目标\" class=\"headerlink\" title=\"阶段性的目标\"></a>阶段性的目标</h5><p>为了一步步的达成「使命」，我们需要有目标。相对于使命，它粒度更小，且有时间限制。</p>\n<p>所以，目标（Objective）应该：</p>\n<ul>\n<li>是阶段性的</li>\n<li>是有优先级的</li>\n<li>它需要能明确方向且鼓舞人心</li>\n</ul>\n<p>目标，是 OKR 中最重要，最需要想清楚，最首要确定的。<br>在这里，需要回答：你有什么？你要什么？你能放弃什么？</p>\n<h5 id=\"重要与紧急\"><a href=\"#重要与紧急\" class=\"headerlink\" title=\"重要与紧急\"></a>重要与紧急</h5><p>「鱼与熊掌不可得兼」，所以我们要有所取舍，事情排个优先级。<br>「重要-紧急象限」是一个不错的指导工具，第一次看到它是在柯维《高效能人士的7个习惯》中的第三个习惯「要事第一」。</p>\n<p><img src=\"https://img.yzcdn.cn/public_files/2019/07/06/e5ce3614f98f98d538944350bd505993.png\" alt=\"重要-紧急\"></p>\n<p>但在实施的过程中中很有可能会遇到这样一个问题，紧急不重要的事情很紧急，总需要花时间和精力去处理它。然后重要不紧急的事情，会常常分配不到时间和精力。</p>\n<p><strong>那么就让重要不紧急的事情也变得紧急起来。</strong></p>\n<h5 id=\"目标需要自上而下的关联\"><a href=\"#目标需要自上而下的关联\" class=\"headerlink\" title=\"目标需要自上而下的关联\"></a>目标需要自上而下的关联</h5><p>如果基础的商业问题没有解决，不论实现多少产品功能，团队整体的绩效一定会大打折扣。</p>\n<p>在一个组织中，如果没有充分的理解上一层的目标，就很容易跑偏，没有真正在刀刃上使力，造成效率上的浪费。</p>\n<p>达到充分的理解目标，是有难度的，对人的眼界、目标理解能力有很高的要求。这不仅仅是执行者责任，更是管理者的责任。</p>\n<h3 id=\"关键结果-Key-Result\"><a href=\"#关键结果-Key-Result\" class=\"headerlink\" title=\"关键结果 Key Result\"></a>关键结果 Key Result</h3><h5 id=\"衡量目标是否达成\"><a href=\"#衡量目标是否达成\" class=\"headerlink\" title=\"衡量目标是否达成\"></a>衡量目标是否达成</h5><p>目标定下来了，如果不去执行和落地，那么它永远就只是一个目标。如何去衡量目标是否达到了，就是「关键结果」的任务。</p>\n<p>在互联网产品中，通常可以量化的条件有：用户增长、用户激活、收入增长、产品性能、产品质量。</p>\n<p>作为技术团队，会更加集中注意力在产品性能和产品质量上面，那么如何去找到这些方向的衡量指标，就要从实际出发了。</p>\n<p>比如我们团队会用「质量系数 = BUG数/估时」，来感受一个项目的质量情况。虽然它会有些漏洞，但如果建立在互相信任的基础上，可以提供一定的参考价值。</p>\n<h5 id=\"有些挑战性\"><a href=\"#有些挑战性\" class=\"headerlink\" title=\"有些挑战性\"></a>有些挑战性</h5><blockquote>\n<p>当达到成结果的时候，我们应该是欢呼雀跃般的兴奋，而不是理所应当的淡定。</p>\n</blockquote>\n<p>定下一个关键结果之后，问一下自己，有多少信心可以完成。如果信心爆棚，就把目标定高些。如果信心不足，就把目标调低些。因为 OKR 的意义不在于完成目标，更重要的是它能挖掘团队以及个人的潜力。</p>\n<p>如果觉得有必要的话，我们可以建立一个「信心指数」，用来帮助确定结果有足够的挑战性而不会让人失去信心。这个指数的开始值最好是 50%，然后通过过程管理来动态变更和追踪。</p>\n<p>比如去年我负责的一个「优化微信小程序加载性能」项目中的关键结果：</p>\n<ul>\n<li>首屏加载时间 3s 内</li>\n</ul>\n<p>未优化的加载时间是 6s+，回顾当时对目标的信心指数的话，大概是 20%。虽然最后因为部分不可控因素没有达到这个目标，只能维持在 3s-4s 之间。但是这个过程中能让人费尽脑汁的找到各种方法，大幅的提升了除首屏加载以外其他方面的加载体验，这也是额外的收获。</p>\n<p>作为管理者，你要清楚的知道哪些人推一推会有更高的产出，哪些人实际执行情况会出现问题，要能看得到看得懂目前组织的目标和进度，并与成员进行同步。</p>\n<h3 id=\"过程管理\"><a href=\"#过程管理\" class=\"headerlink\" title=\"过程管理\"></a>过程管理</h3><p>OKR 定下来了，在期限内，就要奔着目标努力奋进。尽管中途发现问题，也尽量不要在中途更改 OKR，让我们尽力跑完计划的阶段再回来总结。我们也可以把时间维度切小，比如把年度切分为半年度，把半年度切分为季度。</p>\n<p>并且，目标定下来之后，要经常定期共同回顾，共同看见。而不是定下来了，就放在那里，否则过程中团队发生了问题，成员遇到了困难，很大可能会不被看到。</p>\n<p>比较好的形式是每周都一起坐下来看看，每个人分享一下成果，或者说说遇到的困难，看能不能得到其他人的帮助。这个过程，能及时的看到问题，也能让成员对目标有更强的参与感。</p>\n<p>那么，OKR应该以什么方式来呈现？《OKR工作法》一书中提供了一种参考：「四象限呈现形式」</p>\n<p><img src=\"https://img.yzcdn.cn/public_files/2019/07/06/989bdd617bc44bab7dcfdd18120ac8a8.jpeg\" alt=\"四象限呈现\"></p>\n<ul>\n<li>第一象限：本周3-4件最重要的事情，并且进行优先级的排序</li>\n<li>第二象限：把OKR内容罗列出来，关注和更新每一项KR的信心指数</li>\n<li>第三象限：未来中长段时间中的计划，能让我们稍微看远一些。</li>\n<li>第四象限：关注那些影响目标的关键因素会不会掉链子，例如团队状态，系统状态等。也可以用红蓝黄颜色表示出来。</li>\n</ul>\n<h1 id=\"回过头看看那个糟糕的例子\"><a href=\"#回过头看看那个糟糕的例子\" class=\"headerlink\" title=\"回过头看看那个糟糕的例子\"></a>回过头看看那个糟糕的例子</h1><p>糟糕的例子：</p>\n<blockquote>\n<p>O: 持续学习，提高自身战斗力</p>\n<ul>\n<li>KR1:CSS3 学习，阅读《CSS揭秘》 产出阅读笔记。</li>\n<li>KR2:提高英文阅读能力，阅读《Security Your NodeJS Application》，产出一篇译文。</li>\n<li>KR3: Vue2 框架的源码进行解读，产出一篇源码解析。</li>\n</ul>\n</blockquote>\n<p>这个例子的背景是我 2017 年 4 月份加入到有赞，当时定的试用期内的其中一个目标。那时是我第一次认识和使用 OKR，只是单纯的把自身的技能提升计划给罗列了出来，看起来更像是一个 Todo List</p>\n<p>现在回过头来看这一份 OKR，有不少问题：</p>\n<ol>\n<li>目标没有描述出来价值，提升了自身战斗力，然后呢？并没有自上而下的关联团队和组织的目标。所以从目标上，就已经走偏了。</li>\n<li>假设目标正确，KR 也没有起到能衡量目标是否达成的作用。例如 KR1 完成了，对目标的推进，并没有说服力。</li>\n<li>最后把 OKR 用成了 Todo List。</li>\n</ol>\n<p>那么我们从目标开始分析，当时作为一个新人加入到一个新的团队，对团队的技术栈和项目都很陌生，需要填补部分空白，快速上手。所以提升自身实力的底层诉求是：快速上手，胜任开发工作。</p>\n<p>然后怎么衡量目的达到了呢？我们可以通过项目质量直接衡量，通过项目的熟悉程度来间接衡量。</p>\n<p>修正后：</p>\n<blockquote>\n<p>O: 快速上手，以专业的姿态胜任开发工作。</p>\n<ul>\n<li>KR1: 质量系数平均在 0.3 以内。（质量系数 = BUG数/估时）</li>\n<li>KR2: 代码评审评分平均 3.5 以上。（我们有 Code Review 机制，并且有评分环节）</li>\n<li>KR3: 所参与项目评分在 4 以上。（项目也有评分环节）</li>\n<li>KR4: 进行两次的项目分享。</li>\n</ul>\n</blockquote>\n<p>那么如果达到这些关键结果，要通过学习框架，还是研究项目，还是熟悉业务，那就是根据实际迎刃而解的事情了。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><blockquote>\n<p>凡事预则立，不预则废 ——《礼记·中庸》</p>\n</blockquote>\n<p>最后要注意的是，OKR 只是一个工具，当你有一个目标，它会给你一种落实目标的方法论。而如果一开始目标没有想清楚，想明白，那就很容易在错的路上越走越远。</p>\n<p>每个团队都会有不同的风格，和不同的实际情况。理解方法和工具的原理，明白这么做是为了解决什么问题，然后再调整定制真正适合此时此刻的团队，才是最好的方法。</p>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>OKR 是由前 Intel CEO，<a href=\"https://www.wikiwand.com/zh-hk/%E5%AE%89%E8%BF%AA%C2%B7%E8%91%9B%E6%B4%9B%E5%A4%AB\">安迪·葛洛夫</a> 构建的基本框架。</p>\n<p>全称是：「Objective - Key Result」，既强调「目标」与衡量目标的「关键结果」</p>\n<p>它是一套管理目标，让目标能落地的工具。<br>它在硅谷科技公司中广为人知，并被世界各地的许多组织采用。<br>它可以应用在组织中，也可以应用在个人的生活中，就像一种思考的模式。</p>\n<p>过去两年多的 OKR 实践，有一些体会。<br>作为一个程序员，会自然的去寻找一个工具的最佳实践。</p>\n<p>于是，有了这篇文章。</p>\n<h1 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h1><p>OKR 原理很简单。</p>\n<p>要用好 OKR，我的理解，需要把握三个核心：</p>\n<ul>\n<li>目标</li>\n<li>关键结果</li>\n<li>过程管理</li>\n</ul>\n<p>它们分别回答了三个问题：</p>\n<ul>\n<li>应该做什么？</li>\n<li>如何衡量做到了？</li>\n<li>怎么落地？</li>\n</ul>\n<p>然后，思考 OKR，我认为还需要 cover 到两点：</p>\n<ul>\n<li>看得到的结果</li>\n<li>说得出的价值</li>\n</ul>\n<p><strong>先抛一个不好的例子</strong></p>\n<p>来自于我曾经定过的一个 OKR：</p>\n<blockquote>\n<p>O: 持续学习，提高自身战斗力</p>\n<ul>\n<li>KR1: CSS3 学习，阅读《CSS揭秘》产出阅读笔记。</li>\n<li>KR2: 提高英文阅读能力，阅读《Security Your NodeJS Application》，产出一篇译文。</li>\n<li>KR3: 对 Eggjs 或 Vue2 框架的源码进行解读，产出一篇源码解析。</li>\n</ul>\n</blockquote>\n<p>我想先按顺序来讲讲「目标」、「关键结果」、「过程管理」。<br>然后，再回过头来，看看这个例子为啥糟糕，可以怎样修改。</p>\n<h3 id=\"目标-Objective\"><a href=\"#目标-Objective\" class=\"headerlink\" title=\"目标 Objective\"></a>目标 Objective</h3><blockquote>\n<p>欲望让我们起航，但只有专注、规划和学习才能到达成功的彼岸</p>\n</blockquote>\n<h5 id=\"组织的诞生\"><a href=\"#组织的诞生\" class=\"headerlink\" title=\"组织的诞生\"></a>组织的诞生</h5><p>回到最初的时候，一个组织的诞生，绝大多数情况是由于一两个人的想法，然后以此为中心，开始聚拢更多有共同目标的人加入进来。</p>\n<p>1976年，乔布斯成功说服沃茲尼克組裝机器之后再拿去推销，他们的另一位朋友韦恩随后加入，三人在1976年4月1日成立苹果电脑公司。最初，Apple 仅仅是在卖组装电脑。</p>\n<p>1996年，佩奇和布林在学校开始一项关于搜索的研究项目，开发出了搜索引擎 PageRank，后续改名 Google。最初，Google 仅仅是一个搜索引擎。</p>\n<h5 id=\"组织的使命\"><a href=\"#组织的使命\" class=\"headerlink\" title=\"组织的使命\"></a>组织的使命</h5><p>随着组织发展，人员壮大，这个能聚拢人的目标，必须要看得远。然后这个目标提升到用另一个词来形容 —「使命」。</p>\n<p>Apple 的使命：「藉推广公平的资料使用惯例，建立用户对互联网之信任和信心」<br>Google 的使命：「整合全球信息，使人人皆可访问和收益」<br>阿里巴巴的使命：「让天下没有难做的生意」<br>有赞的使命：「帮助每一位重视产品和服务的商家成功」<br>以及最近我们团队的前端技术委员的使命：「以极致的技术高效支撑业务」</p>\n<p>使命描述一般都很简洁，并且容易记忆，像一句广告词，能深深的刻在脑海里。<br>在工作中遇到问题的时候，这个使命就会一下子从脑海里蹦出来指引你找到答案。</p>\n<p>其实在某个市场闲逛都有可能让你意识到这个市场有某个问题需要解决，而帮市场解决这个问题，就是一个使命。</p>\n<h5 id=\"阶段性的目标\"><a href=\"#阶段性的目标\" class=\"headerlink\" title=\"阶段性的目标\"></a>阶段性的目标</h5><p>为了一步步的达成「使命」，我们需要有目标。相对于使命，它粒度更小，且有时间限制。</p>\n<p>所以，目标（Objective）应该：</p>\n<ul>\n<li>是阶段性的</li>\n<li>是有优先级的</li>\n<li>它需要能明确方向且鼓舞人心</li>\n</ul>\n<p>目标，是 OKR 中最重要，最需要想清楚，最首要确定的。<br>在这里，需要回答：你有什么？你要什么？你能放弃什么？</p>\n<h5 id=\"重要与紧急\"><a href=\"#重要与紧急\" class=\"headerlink\" title=\"重要与紧急\"></a>重要与紧急</h5><p>「鱼与熊掌不可得兼」，所以我们要有所取舍，事情排个优先级。<br>「重要-紧急象限」是一个不错的指导工具，第一次看到它是在柯维《高效能人士的7个习惯》中的第三个习惯「要事第一」。</p>\n<p><img src=\"https://img.yzcdn.cn/public_files/2019/07/06/e5ce3614f98f98d538944350bd505993.png\" alt=\"重要-紧急\"></p>\n<p>但在实施的过程中中很有可能会遇到这样一个问题，紧急不重要的事情很紧急，总需要花时间和精力去处理它。然后重要不紧急的事情，会常常分配不到时间和精力。</p>\n<p><strong>那么就让重要不紧急的事情也变得紧急起来。</strong></p>\n<h5 id=\"目标需要自上而下的关联\"><a href=\"#目标需要自上而下的关联\" class=\"headerlink\" title=\"目标需要自上而下的关联\"></a>目标需要自上而下的关联</h5><p>如果基础的商业问题没有解决，不论实现多少产品功能，团队整体的绩效一定会大打折扣。</p>\n<p>在一个组织中，如果没有充分的理解上一层的目标，就很容易跑偏，没有真正在刀刃上使力，造成效率上的浪费。</p>\n<p>达到充分的理解目标，是有难度的，对人的眼界、目标理解能力有很高的要求。这不仅仅是执行者责任，更是管理者的责任。</p>\n<h3 id=\"关键结果-Key-Result\"><a href=\"#关键结果-Key-Result\" class=\"headerlink\" title=\"关键结果 Key Result\"></a>关键结果 Key Result</h3><h5 id=\"衡量目标是否达成\"><a href=\"#衡量目标是否达成\" class=\"headerlink\" title=\"衡量目标是否达成\"></a>衡量目标是否达成</h5><p>目标定下来了，如果不去执行和落地，那么它永远就只是一个目标。如何去衡量目标是否达到了，就是「关键结果」的任务。</p>\n<p>在互联网产品中，通常可以量化的条件有：用户增长、用户激活、收入增长、产品性能、产品质量。</p>\n<p>作为技术团队，会更加集中注意力在产品性能和产品质量上面，那么如何去找到这些方向的衡量指标，就要从实际出发了。</p>\n<p>比如我们团队会用「质量系数 = BUG数/估时」，来感受一个项目的质量情况。虽然它会有些漏洞，但如果建立在互相信任的基础上，可以提供一定的参考价值。</p>\n<h5 id=\"有些挑战性\"><a href=\"#有些挑战性\" class=\"headerlink\" title=\"有些挑战性\"></a>有些挑战性</h5><blockquote>\n<p>当达到成结果的时候，我们应该是欢呼雀跃般的兴奋，而不是理所应当的淡定。</p>\n</blockquote>\n<p>定下一个关键结果之后，问一下自己，有多少信心可以完成。如果信心爆棚，就把目标定高些。如果信心不足，就把目标调低些。因为 OKR 的意义不在于完成目标，更重要的是它能挖掘团队以及个人的潜力。</p>\n<p>如果觉得有必要的话，我们可以建立一个「信心指数」，用来帮助确定结果有足够的挑战性而不会让人失去信心。这个指数的开始值最好是 50%，然后通过过程管理来动态变更和追踪。</p>\n<p>比如去年我负责的一个「优化微信小程序加载性能」项目中的关键结果：</p>\n<ul>\n<li>首屏加载时间 3s 内</li>\n</ul>\n<p>未优化的加载时间是 6s+，回顾当时对目标的信心指数的话，大概是 20%。虽然最后因为部分不可控因素没有达到这个目标，只能维持在 3s-4s 之间。但是这个过程中能让人费尽脑汁的找到各种方法，大幅的提升了除首屏加载以外其他方面的加载体验，这也是额外的收获。</p>\n<p>作为管理者，你要清楚的知道哪些人推一推会有更高的产出，哪些人实际执行情况会出现问题，要能看得到看得懂目前组织的目标和进度，并与成员进行同步。</p>\n<h3 id=\"过程管理\"><a href=\"#过程管理\" class=\"headerlink\" title=\"过程管理\"></a>过程管理</h3><p>OKR 定下来了，在期限内，就要奔着目标努力奋进。尽管中途发现问题，也尽量不要在中途更改 OKR，让我们尽力跑完计划的阶段再回来总结。我们也可以把时间维度切小，比如把年度切分为半年度，把半年度切分为季度。</p>\n<p>并且，目标定下来之后，要经常定期共同回顾，共同看见。而不是定下来了，就放在那里，否则过程中团队发生了问题，成员遇到了困难，很大可能会不被看到。</p>\n<p>比较好的形式是每周都一起坐下来看看，每个人分享一下成果，或者说说遇到的困难，看能不能得到其他人的帮助。这个过程，能及时的看到问题，也能让成员对目标有更强的参与感。</p>\n<p>那么，OKR应该以什么方式来呈现？《OKR工作法》一书中提供了一种参考：「四象限呈现形式」</p>\n<p><img src=\"https://img.yzcdn.cn/public_files/2019/07/06/989bdd617bc44bab7dcfdd18120ac8a8.jpeg\" alt=\"四象限呈现\"></p>\n<ul>\n<li>第一象限：本周3-4件最重要的事情，并且进行优先级的排序</li>\n<li>第二象限：把OKR内容罗列出来，关注和更新每一项KR的信心指数</li>\n<li>第三象限：未来中长段时间中的计划，能让我们稍微看远一些。</li>\n<li>第四象限：关注那些影响目标的关键因素会不会掉链子，例如团队状态，系统状态等。也可以用红蓝黄颜色表示出来。</li>\n</ul>\n<h1 id=\"回过头看看那个糟糕的例子\"><a href=\"#回过头看看那个糟糕的例子\" class=\"headerlink\" title=\"回过头看看那个糟糕的例子\"></a>回过头看看那个糟糕的例子</h1><p>糟糕的例子：</p>\n<blockquote>\n<p>O: 持续学习，提高自身战斗力</p>\n<ul>\n<li>KR1:CSS3 学习，阅读《CSS揭秘》 产出阅读笔记。</li>\n<li>KR2:提高英文阅读能力，阅读《Security Your NodeJS Application》，产出一篇译文。</li>\n<li>KR3: Vue2 框架的源码进行解读，产出一篇源码解析。</li>\n</ul>\n</blockquote>\n<p>这个例子的背景是我 2017 年 4 月份加入到有赞，当时定的试用期内的其中一个目标。那时是我第一次认识和使用 OKR，只是单纯的把自身的技能提升计划给罗列了出来，看起来更像是一个 Todo List</p>\n<p>现在回过头来看这一份 OKR，有不少问题：</p>\n<ol>\n<li>目标没有描述出来价值，提升了自身战斗力，然后呢？并没有自上而下的关联团队和组织的目标。所以从目标上，就已经走偏了。</li>\n<li>假设目标正确，KR 也没有起到能衡量目标是否达成的作用。例如 KR1 完成了，对目标的推进，并没有说服力。</li>\n<li>最后把 OKR 用成了 Todo List。</li>\n</ol>\n<p>那么我们从目标开始分析，当时作为一个新人加入到一个新的团队，对团队的技术栈和项目都很陌生，需要填补部分空白，快速上手。所以提升自身实力的底层诉求是：快速上手，胜任开发工作。</p>\n<p>然后怎么衡量目的达到了呢？我们可以通过项目质量直接衡量，通过项目的熟悉程度来间接衡量。</p>\n<p>修正后：</p>\n<blockquote>\n<p>O: 快速上手，以专业的姿态胜任开发工作。</p>\n<ul>\n<li>KR1: 质量系数平均在 0.3 以内。（质量系数 = BUG数/估时）</li>\n<li>KR2: 代码评审评分平均 3.5 以上。（我们有 Code Review 机制，并且有评分环节）</li>\n<li>KR3: 所参与项目评分在 4 以上。（项目也有评分环节）</li>\n<li>KR4: 进行两次的项目分享。</li>\n</ul>\n</blockquote>\n<p>那么如果达到这些关键结果，要通过学习框架，还是研究项目，还是熟悉业务，那就是根据实际迎刃而解的事情了。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><blockquote>\n<p>凡事预则立，不预则废 ——《礼记·中庸》</p>\n</blockquote>\n<p>最后要注意的是，OKR 只是一个工具，当你有一个目标，它会给你一种落实目标的方法论。而如果一开始目标没有想清楚，想明白，那就很容易在错的路上越走越远。</p>\n<p>每个团队都会有不同的风格，和不同的实际情况。理解方法和工具的原理，明白这么做是为了解决什么问题，然后再调整定制真正适合此时此刻的团队，才是最好的方法。</p>\n"},{"title":"记一次「关于沟通」的培训","date":"2019-04-13T09:39:00.000Z","_content":"\n周末参与了公司给TL们安排的一个主题为《高效沟通》的课程，为期两天。\n以往自己对「沟通」自我感觉良好，完全凭借感觉来，只要跟对方能表达清楚自己的想法，足矣。\n两天下来，重新开始认识，「沟通」，其实是一门很深的学问。\n这篇像是笔记，也像是我对「沟通」这门学问的重新认识。\n\n# 萨提亚模型\n> 沟通中需要认识到谈话者的状态\n\n![萨提亚沟通模型](/image/blog/about-communicate/DraggedImage.png)\n\n「萨提亚模型」是由美国家庭治疗专家 Virginia Satir 女士所创建的理论体系。这种体系起初是被运用在家庭心理治疗方面。但是在诸多的家庭治疗理论中，萨提亚模型一直是难以归类的，有的教科书将之列为「沟通学派」，有的纳入「人本学派」。究其原因，就是萨提亚模型不强调病态的。\n\n一言蔽之就是：萨提亚模型，不仅仅适用于心理治疗，在人与人沟通中，也能提升我们的认知。\n\n这个模型有两个重要的理论：\n1. **冰山理论**\n2. **应对姿态**\n\n## 冰山理论\n\n![冰山理论](/image/blog/about-communicate/DraggedImage-1.png)\n\n一个人的「自我」就像一座冰山一样，别人所看到的只是冰山一角。\n外在的「行为」和「应对方式」，我们是能很快的看得到的。\n但是内在的「感受」、「观点」、「期待」、「渴望」是没那么容易知道的。\n\n有一个例子特别好：    \n\n> 一对年轻夫妻，丈夫的职业是培训师，很能赚钱，但是经常需要出差。她的妻子就经常抱怨他不常回来陪伴她，觉得丈夫不爱他。但是丈夫很纳闷，常常陪伴妻子的话，自己就不能好好的工作了。\n> 后来丈夫跟妻子好好谈过之后，才发现，妻子抱怨的原因是因为「安全感」不足。因为丈夫很能赚钱，长期不在身边的话，怕会在外面找小三。\n> 那么事情就好办了，丈夫索性把所有的收入都给老婆管了。\n\n从这个例子中，其实我们来套一下冰山理论：\n* 行为：丈夫常常出差\n* 应对方式：埋怨、吵架\n* 观点：有钱的男人长期在外面，容易找小三\n* 期待：多点回家，陪陪老婆\n* 渴望：安全感\n\n其实妻子内心深处渴望的是一个「安全感」，从最深处的渴望下手，只要能满足对方的深层次的渴望，问题就引刃而解了。\n\n## 沟通姿态\n根据萨提亚模型，人有五种的沟通姿态：\n* 指责型\n* 讨好型\n* 超理智型\n* 打岔型\n* 表里一致型\n\n而这五种的沟通姿态表现在对三个沟通要素的关注度不同：\n* 自我\n* 他人\n* 情景\n\n### 指责型\n> 关注「自我」、「情景」，忽略「他人」\n\n指责型的人常常忽略他人，习惯于攻击和批判，将责任推给别人。“都是你的错”，“你到底怎么搞的”是他们的口头语。\n\n### 讨好型\n> 关注「他人」、「情景」，忽略「自我」\n\n讨好型的人忽略自己，内在价值感比较低。言语中经常流露出“这都是我的错”，“我想要让你高兴”之类的话。行为上则过度和善，习惯于道歉和乞怜。\n\n### 超理智型\n> 关注「情景」、忽略「他人」、「自我」\n\n超理智型的人极端客观，只关心事情，忽略与个人或情绪。常常给人的感觉是冷漠、冷淡。\n\n### 打岔型\n> 啥也不关注\n\n打岔型的人则永远不抓重点，不直接回答问题或根本文不对题。总是可以打破各种绝望的氛围，把注意力从任何有压力的话题上转移开\n\n当然，没有人永远是单纯的一种沟通姿态的。而我自己就是那种「有时讨好有时指责有时超理智，而有时候会打岔转移话题」。\n\n# 沟通的核心技能\n在沟通中，有四种重要的技能：\n* 「积极聆听」\n* 「有效提问」\n* 「清晰表达」\n* 「反馈」\n\n## 积极聆听\n在别人说话的时候，积极的聆听，这个过程从你的言行和脸部表情，都能给到对方正向的反馈。\n\n## 有效提问\n沟通过程中，你往往能通过提问来控制话题的方向、了解对方的想法、增强对方的自信、甚至好的问题能引起对方深层次的思考。\n提问可以有一个练习的套路：「目标」→「现状」→「方案」→「行动」\n例如\n\n* 询问目标：你认为怎样的结果是满意的？\n* 询问现状：请问你已经尝试了哪些方案了？\n* 询问方案：还可以采取哪些措施？\n* 询问心动：接下来打算做什么？\n\n## 清晰表达\n\n在表达中，我们常常会遇到那种前后说了一大通，最后其实只表达了一个意思的人。也有些人表达混乱，思路不清晰的。\n\n这里也有一个可练习的表达套路：\n1. 「观点 Point」\n2. 「原因 Reason」\n3. 「举例 Example」\n4. 「复述观点 Point again」or 「提出请求 Proposal」\n\n例如：\n1. 提出观点：为了我们更高效的完成目标，我的想法是…\n2. 说明原因：我下这个结论是因为…\n3. 举个栗子：如果达成了，我们会有这些提升…\n4. 提出请求：如果你也同意的话，我希望能得到这些帮助…\n\n## 反馈\n\n很喜欢对反馈的一种看法：「反馈是一种礼物！」\n尤其是建设性的反馈，更能使自己或对方有所进步。\n那么如何提出一个有建设性的反馈，这也有一个练习的套路：\n1. 「行为 Action」\n2. 「影响 Impact」\n3. 「行动 Do」\n\n例如：\n1. 行为：兄弟，厕所的墙上贴着「禁止吸烟」的。\n2. 影响：厕所的通风很差的，烟味会久久散不去的，想象一下屎味烟味混杂的厕所，客户来到公司，印象很差的。而且对别人身体也不健康，是吧。\n3. 行动：你不知道，其实公司在走廊上是有专门的吸烟区的，在那里风景又好，岂不是更舒畅。\n\n\n# 最后\n「沟通」既是一门学问，也是一门艺术。\n尽然有各种理论和研究，但最后还是为「实践」服务。\n我认为，以上纯属理论，要真正落实到实际应用，还需要多多锻炼，以及应景发挥，还要基于现实来好好感悟。\n另外，如果有兴趣继续深入研究的话，这里有一个书单：\n* 《金字塔原理》\n* 《天资差异》\n* 《类型与原型》\n\n","source":"_posts/about-communicate.md","raw":"---\ntitle: 记一次「关于沟通」的培训\ncategory: 三省吾身\ndate: 2019-04-13 17:39:00\ntags: \n---\n\n周末参与了公司给TL们安排的一个主题为《高效沟通》的课程，为期两天。\n以往自己对「沟通」自我感觉良好，完全凭借感觉来，只要跟对方能表达清楚自己的想法，足矣。\n两天下来，重新开始认识，「沟通」，其实是一门很深的学问。\n这篇像是笔记，也像是我对「沟通」这门学问的重新认识。\n\n# 萨提亚模型\n> 沟通中需要认识到谈话者的状态\n\n![萨提亚沟通模型](/image/blog/about-communicate/DraggedImage.png)\n\n「萨提亚模型」是由美国家庭治疗专家 Virginia Satir 女士所创建的理论体系。这种体系起初是被运用在家庭心理治疗方面。但是在诸多的家庭治疗理论中，萨提亚模型一直是难以归类的，有的教科书将之列为「沟通学派」，有的纳入「人本学派」。究其原因，就是萨提亚模型不强调病态的。\n\n一言蔽之就是：萨提亚模型，不仅仅适用于心理治疗，在人与人沟通中，也能提升我们的认知。\n\n这个模型有两个重要的理论：\n1. **冰山理论**\n2. **应对姿态**\n\n## 冰山理论\n\n![冰山理论](/image/blog/about-communicate/DraggedImage-1.png)\n\n一个人的「自我」就像一座冰山一样，别人所看到的只是冰山一角。\n外在的「行为」和「应对方式」，我们是能很快的看得到的。\n但是内在的「感受」、「观点」、「期待」、「渴望」是没那么容易知道的。\n\n有一个例子特别好：    \n\n> 一对年轻夫妻，丈夫的职业是培训师，很能赚钱，但是经常需要出差。她的妻子就经常抱怨他不常回来陪伴她，觉得丈夫不爱他。但是丈夫很纳闷，常常陪伴妻子的话，自己就不能好好的工作了。\n> 后来丈夫跟妻子好好谈过之后，才发现，妻子抱怨的原因是因为「安全感」不足。因为丈夫很能赚钱，长期不在身边的话，怕会在外面找小三。\n> 那么事情就好办了，丈夫索性把所有的收入都给老婆管了。\n\n从这个例子中，其实我们来套一下冰山理论：\n* 行为：丈夫常常出差\n* 应对方式：埋怨、吵架\n* 观点：有钱的男人长期在外面，容易找小三\n* 期待：多点回家，陪陪老婆\n* 渴望：安全感\n\n其实妻子内心深处渴望的是一个「安全感」，从最深处的渴望下手，只要能满足对方的深层次的渴望，问题就引刃而解了。\n\n## 沟通姿态\n根据萨提亚模型，人有五种的沟通姿态：\n* 指责型\n* 讨好型\n* 超理智型\n* 打岔型\n* 表里一致型\n\n而这五种的沟通姿态表现在对三个沟通要素的关注度不同：\n* 自我\n* 他人\n* 情景\n\n### 指责型\n> 关注「自我」、「情景」，忽略「他人」\n\n指责型的人常常忽略他人，习惯于攻击和批判，将责任推给别人。“都是你的错”，“你到底怎么搞的”是他们的口头语。\n\n### 讨好型\n> 关注「他人」、「情景」，忽略「自我」\n\n讨好型的人忽略自己，内在价值感比较低。言语中经常流露出“这都是我的错”，“我想要让你高兴”之类的话。行为上则过度和善，习惯于道歉和乞怜。\n\n### 超理智型\n> 关注「情景」、忽略「他人」、「自我」\n\n超理智型的人极端客观，只关心事情，忽略与个人或情绪。常常给人的感觉是冷漠、冷淡。\n\n### 打岔型\n> 啥也不关注\n\n打岔型的人则永远不抓重点，不直接回答问题或根本文不对题。总是可以打破各种绝望的氛围，把注意力从任何有压力的话题上转移开\n\n当然，没有人永远是单纯的一种沟通姿态的。而我自己就是那种「有时讨好有时指责有时超理智，而有时候会打岔转移话题」。\n\n# 沟通的核心技能\n在沟通中，有四种重要的技能：\n* 「积极聆听」\n* 「有效提问」\n* 「清晰表达」\n* 「反馈」\n\n## 积极聆听\n在别人说话的时候，积极的聆听，这个过程从你的言行和脸部表情，都能给到对方正向的反馈。\n\n## 有效提问\n沟通过程中，你往往能通过提问来控制话题的方向、了解对方的想法、增强对方的自信、甚至好的问题能引起对方深层次的思考。\n提问可以有一个练习的套路：「目标」→「现状」→「方案」→「行动」\n例如\n\n* 询问目标：你认为怎样的结果是满意的？\n* 询问现状：请问你已经尝试了哪些方案了？\n* 询问方案：还可以采取哪些措施？\n* 询问心动：接下来打算做什么？\n\n## 清晰表达\n\n在表达中，我们常常会遇到那种前后说了一大通，最后其实只表达了一个意思的人。也有些人表达混乱，思路不清晰的。\n\n这里也有一个可练习的表达套路：\n1. 「观点 Point」\n2. 「原因 Reason」\n3. 「举例 Example」\n4. 「复述观点 Point again」or 「提出请求 Proposal」\n\n例如：\n1. 提出观点：为了我们更高效的完成目标，我的想法是…\n2. 说明原因：我下这个结论是因为…\n3. 举个栗子：如果达成了，我们会有这些提升…\n4. 提出请求：如果你也同意的话，我希望能得到这些帮助…\n\n## 反馈\n\n很喜欢对反馈的一种看法：「反馈是一种礼物！」\n尤其是建设性的反馈，更能使自己或对方有所进步。\n那么如何提出一个有建设性的反馈，这也有一个练习的套路：\n1. 「行为 Action」\n2. 「影响 Impact」\n3. 「行动 Do」\n\n例如：\n1. 行为：兄弟，厕所的墙上贴着「禁止吸烟」的。\n2. 影响：厕所的通风很差的，烟味会久久散不去的，想象一下屎味烟味混杂的厕所，客户来到公司，印象很差的。而且对别人身体也不健康，是吧。\n3. 行动：你不知道，其实公司在走廊上是有专门的吸烟区的，在那里风景又好，岂不是更舒畅。\n\n\n# 最后\n「沟通」既是一门学问，也是一门艺术。\n尽然有各种理论和研究，但最后还是为「实践」服务。\n我认为，以上纯属理论，要真正落实到实际应用，还需要多多锻炼，以及应景发挥，还要基于现实来好好感悟。\n另外，如果有兴趣继续深入研究的话，这里有一个书单：\n* 《金字塔原理》\n* 《天资差异》\n* 《类型与原型》\n\n","slug":"about-communicate","published":1,"updated":"2019-04-13T09:45:45.626Z","_id":"cl270y8tn0065xwrljz7ulpt4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>周末参与了公司给TL们安排的一个主题为《高效沟通》的课程，为期两天。<br>以往自己对「沟通」自我感觉良好，完全凭借感觉来，只要跟对方能表达清楚自己的想法，足矣。<br>两天下来，重新开始认识，「沟通」，其实是一门很深的学问。<br>这篇像是笔记，也像是我对「沟通」这门学问的重新认识。</p>\n<h1 id=\"萨提亚模型\"><a href=\"#萨提亚模型\" class=\"headerlink\" title=\"萨提亚模型\"></a>萨提亚模型</h1><blockquote>\n<p>沟通中需要认识到谈话者的状态</p>\n</blockquote>\n<p><img src=\"/image/blog/about-communicate/DraggedImage.png\" alt=\"萨提亚沟通模型\"></p>\n<p>「萨提亚模型」是由美国家庭治疗专家 Virginia Satir 女士所创建的理论体系。这种体系起初是被运用在家庭心理治疗方面。但是在诸多的家庭治疗理论中，萨提亚模型一直是难以归类的，有的教科书将之列为「沟通学派」，有的纳入「人本学派」。究其原因，就是萨提亚模型不强调病态的。</p>\n<p>一言蔽之就是：萨提亚模型，不仅仅适用于心理治疗，在人与人沟通中，也能提升我们的认知。</p>\n<p>这个模型有两个重要的理论：</p>\n<ol>\n<li><strong>冰山理论</strong></li>\n<li><strong>应对姿态</strong></li>\n</ol>\n<h2 id=\"冰山理论\"><a href=\"#冰山理论\" class=\"headerlink\" title=\"冰山理论\"></a>冰山理论</h2><p><img src=\"/image/blog/about-communicate/DraggedImage-1.png\" alt=\"冰山理论\"></p>\n<p>一个人的「自我」就像一座冰山一样，别人所看到的只是冰山一角。<br>外在的「行为」和「应对方式」，我们是能很快的看得到的。<br>但是内在的「感受」、「观点」、「期待」、「渴望」是没那么容易知道的。</p>\n<p>有一个例子特别好：    </p>\n<blockquote>\n<p>一对年轻夫妻，丈夫的职业是培训师，很能赚钱，但是经常需要出差。她的妻子就经常抱怨他不常回来陪伴她，觉得丈夫不爱他。但是丈夫很纳闷，常常陪伴妻子的话，自己就不能好好的工作了。<br>后来丈夫跟妻子好好谈过之后，才发现，妻子抱怨的原因是因为「安全感」不足。因为丈夫很能赚钱，长期不在身边的话，怕会在外面找小三。<br>那么事情就好办了，丈夫索性把所有的收入都给老婆管了。</p>\n</blockquote>\n<p>从这个例子中，其实我们来套一下冰山理论：</p>\n<ul>\n<li>行为：丈夫常常出差</li>\n<li>应对方式：埋怨、吵架</li>\n<li>观点：有钱的男人长期在外面，容易找小三</li>\n<li>期待：多点回家，陪陪老婆</li>\n<li>渴望：安全感</li>\n</ul>\n<p>其实妻子内心深处渴望的是一个「安全感」，从最深处的渴望下手，只要能满足对方的深层次的渴望，问题就引刃而解了。</p>\n<h2 id=\"沟通姿态\"><a href=\"#沟通姿态\" class=\"headerlink\" title=\"沟通姿态\"></a>沟通姿态</h2><p>根据萨提亚模型，人有五种的沟通姿态：</p>\n<ul>\n<li>指责型</li>\n<li>讨好型</li>\n<li>超理智型</li>\n<li>打岔型</li>\n<li>表里一致型</li>\n</ul>\n<p>而这五种的沟通姿态表现在对三个沟通要素的关注度不同：</p>\n<ul>\n<li>自我</li>\n<li>他人</li>\n<li>情景</li>\n</ul>\n<h3 id=\"指责型\"><a href=\"#指责型\" class=\"headerlink\" title=\"指责型\"></a>指责型</h3><blockquote>\n<p>关注「自我」、「情景」，忽略「他人」</p>\n</blockquote>\n<p>指责型的人常常忽略他人，习惯于攻击和批判，将责任推给别人。“都是你的错”，“你到底怎么搞的”是他们的口头语。</p>\n<h3 id=\"讨好型\"><a href=\"#讨好型\" class=\"headerlink\" title=\"讨好型\"></a>讨好型</h3><blockquote>\n<p>关注「他人」、「情景」，忽略「自我」</p>\n</blockquote>\n<p>讨好型的人忽略自己，内在价值感比较低。言语中经常流露出“这都是我的错”，“我想要让你高兴”之类的话。行为上则过度和善，习惯于道歉和乞怜。</p>\n<h3 id=\"超理智型\"><a href=\"#超理智型\" class=\"headerlink\" title=\"超理智型\"></a>超理智型</h3><blockquote>\n<p>关注「情景」、忽略「他人」、「自我」</p>\n</blockquote>\n<p>超理智型的人极端客观，只关心事情，忽略与个人或情绪。常常给人的感觉是冷漠、冷淡。</p>\n<h3 id=\"打岔型\"><a href=\"#打岔型\" class=\"headerlink\" title=\"打岔型\"></a>打岔型</h3><blockquote>\n<p>啥也不关注</p>\n</blockquote>\n<p>打岔型的人则永远不抓重点，不直接回答问题或根本文不对题。总是可以打破各种绝望的氛围，把注意力从任何有压力的话题上转移开</p>\n<p>当然，没有人永远是单纯的一种沟通姿态的。而我自己就是那种「有时讨好有时指责有时超理智，而有时候会打岔转移话题」。</p>\n<h1 id=\"沟通的核心技能\"><a href=\"#沟通的核心技能\" class=\"headerlink\" title=\"沟通的核心技能\"></a>沟通的核心技能</h1><p>在沟通中，有四种重要的技能：</p>\n<ul>\n<li>「积极聆听」</li>\n<li>「有效提问」</li>\n<li>「清晰表达」</li>\n<li>「反馈」</li>\n</ul>\n<h2 id=\"积极聆听\"><a href=\"#积极聆听\" class=\"headerlink\" title=\"积极聆听\"></a>积极聆听</h2><p>在别人说话的时候，积极的聆听，这个过程从你的言行和脸部表情，都能给到对方正向的反馈。</p>\n<h2 id=\"有效提问\"><a href=\"#有效提问\" class=\"headerlink\" title=\"有效提问\"></a>有效提问</h2><p>沟通过程中，你往往能通过提问来控制话题的方向、了解对方的想法、增强对方的自信、甚至好的问题能引起对方深层次的思考。<br>提问可以有一个练习的套路：「目标」→「现状」→「方案」→「行动」<br>例如</p>\n<ul>\n<li>询问目标：你认为怎样的结果是满意的？</li>\n<li>询问现状：请问你已经尝试了哪些方案了？</li>\n<li>询问方案：还可以采取哪些措施？</li>\n<li>询问心动：接下来打算做什么？</li>\n</ul>\n<h2 id=\"清晰表达\"><a href=\"#清晰表达\" class=\"headerlink\" title=\"清晰表达\"></a>清晰表达</h2><p>在表达中，我们常常会遇到那种前后说了一大通，最后其实只表达了一个意思的人。也有些人表达混乱，思路不清晰的。</p>\n<p>这里也有一个可练习的表达套路：</p>\n<ol>\n<li>「观点 Point」</li>\n<li>「原因 Reason」</li>\n<li>「举例 Example」</li>\n<li>「复述观点 Point again」or 「提出请求 Proposal」</li>\n</ol>\n<p>例如：</p>\n<ol>\n<li>提出观点：为了我们更高效的完成目标，我的想法是…</li>\n<li>说明原因：我下这个结论是因为…</li>\n<li>举个栗子：如果达成了，我们会有这些提升…</li>\n<li>提出请求：如果你也同意的话，我希望能得到这些帮助…</li>\n</ol>\n<h2 id=\"反馈\"><a href=\"#反馈\" class=\"headerlink\" title=\"反馈\"></a>反馈</h2><p>很喜欢对反馈的一种看法：「反馈是一种礼物！」<br>尤其是建设性的反馈，更能使自己或对方有所进步。<br>那么如何提出一个有建设性的反馈，这也有一个练习的套路：</p>\n<ol>\n<li>「行为 Action」</li>\n<li>「影响 Impact」</li>\n<li>「行动 Do」</li>\n</ol>\n<p>例如：</p>\n<ol>\n<li>行为：兄弟，厕所的墙上贴着「禁止吸烟」的。</li>\n<li>影响：厕所的通风很差的，烟味会久久散不去的，想象一下屎味烟味混杂的厕所，客户来到公司，印象很差的。而且对别人身体也不健康，是吧。</li>\n<li>行动：你不知道，其实公司在走廊上是有专门的吸烟区的，在那里风景又好，岂不是更舒畅。</li>\n</ol>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>「沟通」既是一门学问，也是一门艺术。<br>尽然有各种理论和研究，但最后还是为「实践」服务。<br>我认为，以上纯属理论，要真正落实到实际应用，还需要多多锻炼，以及应景发挥，还要基于现实来好好感悟。<br>另外，如果有兴趣继续深入研究的话，这里有一个书单：</p>\n<ul>\n<li>《金字塔原理》</li>\n<li>《天资差异》</li>\n<li>《类型与原型》</li>\n</ul>\n","excerpt":"","more":"<p>周末参与了公司给TL们安排的一个主题为《高效沟通》的课程，为期两天。<br>以往自己对「沟通」自我感觉良好，完全凭借感觉来，只要跟对方能表达清楚自己的想法，足矣。<br>两天下来，重新开始认识，「沟通」，其实是一门很深的学问。<br>这篇像是笔记，也像是我对「沟通」这门学问的重新认识。</p>\n<h1 id=\"萨提亚模型\"><a href=\"#萨提亚模型\" class=\"headerlink\" title=\"萨提亚模型\"></a>萨提亚模型</h1><blockquote>\n<p>沟通中需要认识到谈话者的状态</p>\n</blockquote>\n<p><img src=\"/image/blog/about-communicate/DraggedImage.png\" alt=\"萨提亚沟通模型\"></p>\n<p>「萨提亚模型」是由美国家庭治疗专家 Virginia Satir 女士所创建的理论体系。这种体系起初是被运用在家庭心理治疗方面。但是在诸多的家庭治疗理论中，萨提亚模型一直是难以归类的，有的教科书将之列为「沟通学派」，有的纳入「人本学派」。究其原因，就是萨提亚模型不强调病态的。</p>\n<p>一言蔽之就是：萨提亚模型，不仅仅适用于心理治疗，在人与人沟通中，也能提升我们的认知。</p>\n<p>这个模型有两个重要的理论：</p>\n<ol>\n<li><strong>冰山理论</strong></li>\n<li><strong>应对姿态</strong></li>\n</ol>\n<h2 id=\"冰山理论\"><a href=\"#冰山理论\" class=\"headerlink\" title=\"冰山理论\"></a>冰山理论</h2><p><img src=\"/image/blog/about-communicate/DraggedImage-1.png\" alt=\"冰山理论\"></p>\n<p>一个人的「自我」就像一座冰山一样，别人所看到的只是冰山一角。<br>外在的「行为」和「应对方式」，我们是能很快的看得到的。<br>但是内在的「感受」、「观点」、「期待」、「渴望」是没那么容易知道的。</p>\n<p>有一个例子特别好：    </p>\n<blockquote>\n<p>一对年轻夫妻，丈夫的职业是培训师，很能赚钱，但是经常需要出差。她的妻子就经常抱怨他不常回来陪伴她，觉得丈夫不爱他。但是丈夫很纳闷，常常陪伴妻子的话，自己就不能好好的工作了。<br>后来丈夫跟妻子好好谈过之后，才发现，妻子抱怨的原因是因为「安全感」不足。因为丈夫很能赚钱，长期不在身边的话，怕会在外面找小三。<br>那么事情就好办了，丈夫索性把所有的收入都给老婆管了。</p>\n</blockquote>\n<p>从这个例子中，其实我们来套一下冰山理论：</p>\n<ul>\n<li>行为：丈夫常常出差</li>\n<li>应对方式：埋怨、吵架</li>\n<li>观点：有钱的男人长期在外面，容易找小三</li>\n<li>期待：多点回家，陪陪老婆</li>\n<li>渴望：安全感</li>\n</ul>\n<p>其实妻子内心深处渴望的是一个「安全感」，从最深处的渴望下手，只要能满足对方的深层次的渴望，问题就引刃而解了。</p>\n<h2 id=\"沟通姿态\"><a href=\"#沟通姿态\" class=\"headerlink\" title=\"沟通姿态\"></a>沟通姿态</h2><p>根据萨提亚模型，人有五种的沟通姿态：</p>\n<ul>\n<li>指责型</li>\n<li>讨好型</li>\n<li>超理智型</li>\n<li>打岔型</li>\n<li>表里一致型</li>\n</ul>\n<p>而这五种的沟通姿态表现在对三个沟通要素的关注度不同：</p>\n<ul>\n<li>自我</li>\n<li>他人</li>\n<li>情景</li>\n</ul>\n<h3 id=\"指责型\"><a href=\"#指责型\" class=\"headerlink\" title=\"指责型\"></a>指责型</h3><blockquote>\n<p>关注「自我」、「情景」，忽略「他人」</p>\n</blockquote>\n<p>指责型的人常常忽略他人，习惯于攻击和批判，将责任推给别人。“都是你的错”，“你到底怎么搞的”是他们的口头语。</p>\n<h3 id=\"讨好型\"><a href=\"#讨好型\" class=\"headerlink\" title=\"讨好型\"></a>讨好型</h3><blockquote>\n<p>关注「他人」、「情景」，忽略「自我」</p>\n</blockquote>\n<p>讨好型的人忽略自己，内在价值感比较低。言语中经常流露出“这都是我的错”，“我想要让你高兴”之类的话。行为上则过度和善，习惯于道歉和乞怜。</p>\n<h3 id=\"超理智型\"><a href=\"#超理智型\" class=\"headerlink\" title=\"超理智型\"></a>超理智型</h3><blockquote>\n<p>关注「情景」、忽略「他人」、「自我」</p>\n</blockquote>\n<p>超理智型的人极端客观，只关心事情，忽略与个人或情绪。常常给人的感觉是冷漠、冷淡。</p>\n<h3 id=\"打岔型\"><a href=\"#打岔型\" class=\"headerlink\" title=\"打岔型\"></a>打岔型</h3><blockquote>\n<p>啥也不关注</p>\n</blockquote>\n<p>打岔型的人则永远不抓重点，不直接回答问题或根本文不对题。总是可以打破各种绝望的氛围，把注意力从任何有压力的话题上转移开</p>\n<p>当然，没有人永远是单纯的一种沟通姿态的。而我自己就是那种「有时讨好有时指责有时超理智，而有时候会打岔转移话题」。</p>\n<h1 id=\"沟通的核心技能\"><a href=\"#沟通的核心技能\" class=\"headerlink\" title=\"沟通的核心技能\"></a>沟通的核心技能</h1><p>在沟通中，有四种重要的技能：</p>\n<ul>\n<li>「积极聆听」</li>\n<li>「有效提问」</li>\n<li>「清晰表达」</li>\n<li>「反馈」</li>\n</ul>\n<h2 id=\"积极聆听\"><a href=\"#积极聆听\" class=\"headerlink\" title=\"积极聆听\"></a>积极聆听</h2><p>在别人说话的时候，积极的聆听，这个过程从你的言行和脸部表情，都能给到对方正向的反馈。</p>\n<h2 id=\"有效提问\"><a href=\"#有效提问\" class=\"headerlink\" title=\"有效提问\"></a>有效提问</h2><p>沟通过程中，你往往能通过提问来控制话题的方向、了解对方的想法、增强对方的自信、甚至好的问题能引起对方深层次的思考。<br>提问可以有一个练习的套路：「目标」→「现状」→「方案」→「行动」<br>例如</p>\n<ul>\n<li>询问目标：你认为怎样的结果是满意的？</li>\n<li>询问现状：请问你已经尝试了哪些方案了？</li>\n<li>询问方案：还可以采取哪些措施？</li>\n<li>询问心动：接下来打算做什么？</li>\n</ul>\n<h2 id=\"清晰表达\"><a href=\"#清晰表达\" class=\"headerlink\" title=\"清晰表达\"></a>清晰表达</h2><p>在表达中，我们常常会遇到那种前后说了一大通，最后其实只表达了一个意思的人。也有些人表达混乱，思路不清晰的。</p>\n<p>这里也有一个可练习的表达套路：</p>\n<ol>\n<li>「观点 Point」</li>\n<li>「原因 Reason」</li>\n<li>「举例 Example」</li>\n<li>「复述观点 Point again」or 「提出请求 Proposal」</li>\n</ol>\n<p>例如：</p>\n<ol>\n<li>提出观点：为了我们更高效的完成目标，我的想法是…</li>\n<li>说明原因：我下这个结论是因为…</li>\n<li>举个栗子：如果达成了，我们会有这些提升…</li>\n<li>提出请求：如果你也同意的话，我希望能得到这些帮助…</li>\n</ol>\n<h2 id=\"反馈\"><a href=\"#反馈\" class=\"headerlink\" title=\"反馈\"></a>反馈</h2><p>很喜欢对反馈的一种看法：「反馈是一种礼物！」<br>尤其是建设性的反馈，更能使自己或对方有所进步。<br>那么如何提出一个有建设性的反馈，这也有一个练习的套路：</p>\n<ol>\n<li>「行为 Action」</li>\n<li>「影响 Impact」</li>\n<li>「行动 Do」</li>\n</ol>\n<p>例如：</p>\n<ol>\n<li>行为：兄弟，厕所的墙上贴着「禁止吸烟」的。</li>\n<li>影响：厕所的通风很差的，烟味会久久散不去的，想象一下屎味烟味混杂的厕所，客户来到公司，印象很差的。而且对别人身体也不健康，是吧。</li>\n<li>行动：你不知道，其实公司在走廊上是有专门的吸烟区的，在那里风景又好，岂不是更舒畅。</li>\n</ol>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>「沟通」既是一门学问，也是一门艺术。<br>尽然有各种理论和研究，但最后还是为「实践」服务。<br>我认为，以上纯属理论，要真正落实到实际应用，还需要多多锻炼，以及应景发挥，还要基于现实来好好感悟。<br>另外，如果有兴趣继续深入研究的话，这里有一个书单：</p>\n<ul>\n<li>《金字塔原理》</li>\n<li>《天资差异》</li>\n<li>《类型与原型》</li>\n</ul>\n"},{"title":"一个失眠夜的胡思乱想","date":"2019-08-16T19:26:25.000Z","_content":"\n现在是凌晨 2:06，今晚喝了两瓶科罗娜。\n以为喝了酒能好好睡，结果，还是失眠了。\n\n是兴奋也罢，是焦虑也罢。既然明天不用上班，那么就让这个失眠夜来的更放纵些。\n\n刚才躺在床上，竟然在构想起自己的退休生活。\n希望自己的退休生活，会更有趣些，在衣食上没有基本的担忧，身体虽然有些毛病，但还是能健康的活着，然后和老伴持续的二人世界。有一个独立的孩子，有空可以来看看我们。以及有一两个能持续以恒的爱好。然后，还顺利的养成了终身学习的习惯，作为一个 fasion 的老头。\n\n培养个啥兴趣好呢？回顾过去的众多爱好，找一个能持续发展的。就拿音乐来说，假如我能把音乐这件事学深了，学广了，把玩几门乐器，就算是个糟老头，也能搞搞创作吧。然后有些积蓄，结合着年轻时的阅历和朋友，也能做些小生意吧？又或者也能做做教育吧？\n\n顺着思考如何去过上喜欢的退休生活，似乎有了个更长远的目标，时间跨度更大的目标。\n\n于是乎，才意识到这几年来，只凭借着年少轻狂的那股劲在奔跑，却没有一个可以长远追逐的愿景。\n\n以至于，在碰到人生大事上，如结婚、买房、小孩这些问题上，却有了一种却步感。在碰到职业发展瓶颈上，会满满的焦虑感。还常常回忆过去，留恋过去。\n\n看过一个说法：20 岁年轻人和 50 岁老人做计划，年轻人最多只能做 2 年计划，老人却可以做 5 年甚至 10 年计划。因为 5 年，对年轻人来说是他生命的 1/4，而对老人来说只是他生命的 1/10。 唯一忧桑的是，老人所剩的生命时间不敌年轻的。\n\n从这个例子来看，我认为人类对时间的感受，是相对的，并且是可变化的。\n那么假如年轻人能够去模拟感受老人对时间维度的感受，是不是也能做出更长远些的计划？然后更加淡定？\n\n倘若把时间维度拉长，如果 30 年后来看今天，却稍稍有一种豁达的感觉。虽然离想清楚，想明白，还有些距离。\n\n这样回去看，所谓的中年危机，互联网 35 岁命劫，在一个更长远的时间跨度中，也只能是件小事情，那么一跨，就过去了。\n\n那么如何回来看当下？\n毕竟我还是 27 岁的年龄，那就应该在这个时期，去好好感受属于这个时期的生活。\n好好去感受职场，持续提高个体价值，给这个社会输出贡献，以换取个体生活条件。\n好好去感受生活，结婚、买房、生子、赡养老人，去感受人生这个阶段必须经历的生活。\n还有，好好爱惜身体，毕竟生命只有一次。\n\n在历史长流的维度来看，一个人就几十年光景的寿命，诞生、成长、衰老，然后回归自然。\n那么，这短短的生命，该怎么演绎？\n第一，感谢父母亲把我们带到这个世界上。\n第二，去好好感受生命的整个周期。\n\n现在是凌晨 3:16，祝晚安。","source":"_posts/a-thinking-on-insomnia-night.md","raw":"---\ntitle: 一个失眠夜的胡思乱想\ncategory: 三省吾身\ndate: 2019-08-17 03:26:25\ntags:\n---\n\n现在是凌晨 2:06，今晚喝了两瓶科罗娜。\n以为喝了酒能好好睡，结果，还是失眠了。\n\n是兴奋也罢，是焦虑也罢。既然明天不用上班，那么就让这个失眠夜来的更放纵些。\n\n刚才躺在床上，竟然在构想起自己的退休生活。\n希望自己的退休生活，会更有趣些，在衣食上没有基本的担忧，身体虽然有些毛病，但还是能健康的活着，然后和老伴持续的二人世界。有一个独立的孩子，有空可以来看看我们。以及有一两个能持续以恒的爱好。然后，还顺利的养成了终身学习的习惯，作为一个 fasion 的老头。\n\n培养个啥兴趣好呢？回顾过去的众多爱好，找一个能持续发展的。就拿音乐来说，假如我能把音乐这件事学深了，学广了，把玩几门乐器，就算是个糟老头，也能搞搞创作吧。然后有些积蓄，结合着年轻时的阅历和朋友，也能做些小生意吧？又或者也能做做教育吧？\n\n顺着思考如何去过上喜欢的退休生活，似乎有了个更长远的目标，时间跨度更大的目标。\n\n于是乎，才意识到这几年来，只凭借着年少轻狂的那股劲在奔跑，却没有一个可以长远追逐的愿景。\n\n以至于，在碰到人生大事上，如结婚、买房、小孩这些问题上，却有了一种却步感。在碰到职业发展瓶颈上，会满满的焦虑感。还常常回忆过去，留恋过去。\n\n看过一个说法：20 岁年轻人和 50 岁老人做计划，年轻人最多只能做 2 年计划，老人却可以做 5 年甚至 10 年计划。因为 5 年，对年轻人来说是他生命的 1/4，而对老人来说只是他生命的 1/10。 唯一忧桑的是，老人所剩的生命时间不敌年轻的。\n\n从这个例子来看，我认为人类对时间的感受，是相对的，并且是可变化的。\n那么假如年轻人能够去模拟感受老人对时间维度的感受，是不是也能做出更长远些的计划？然后更加淡定？\n\n倘若把时间维度拉长，如果 30 年后来看今天，却稍稍有一种豁达的感觉。虽然离想清楚，想明白，还有些距离。\n\n这样回去看，所谓的中年危机，互联网 35 岁命劫，在一个更长远的时间跨度中，也只能是件小事情，那么一跨，就过去了。\n\n那么如何回来看当下？\n毕竟我还是 27 岁的年龄，那就应该在这个时期，去好好感受属于这个时期的生活。\n好好去感受职场，持续提高个体价值，给这个社会输出贡献，以换取个体生活条件。\n好好去感受生活，结婚、买房、生子、赡养老人，去感受人生这个阶段必须经历的生活。\n还有，好好爱惜身体，毕竟生命只有一次。\n\n在历史长流的维度来看，一个人就几十年光景的寿命，诞生、成长、衰老，然后回归自然。\n那么，这短短的生命，该怎么演绎？\n第一，感谢父母亲把我们带到这个世界上。\n第二，去好好感受生命的整个周期。\n\n现在是凌晨 3:16，祝晚安。","slug":"a-thinking-on-insomnia-night","published":1,"updated":"2022-04-20T03:43:19.489Z","_id":"cl270y8to0067xwrl79za6edf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>现在是凌晨 2:06，今晚喝了两瓶科罗娜。<br>以为喝了酒能好好睡，结果，还是失眠了。</p>\n<p>是兴奋也罢，是焦虑也罢。既然明天不用上班，那么就让这个失眠夜来的更放纵些。</p>\n<p>刚才躺在床上，竟然在构想起自己的退休生活。<br>希望自己的退休生活，会更有趣些，在衣食上没有基本的担忧，身体虽然有些毛病，但还是能健康的活着，然后和老伴持续的二人世界。有一个独立的孩子，有空可以来看看我们。以及有一两个能持续以恒的爱好。然后，还顺利的养成了终身学习的习惯，作为一个 fasion 的老头。</p>\n<p>培养个啥兴趣好呢？回顾过去的众多爱好，找一个能持续发展的。就拿音乐来说，假如我能把音乐这件事学深了，学广了，把玩几门乐器，就算是个糟老头，也能搞搞创作吧。然后有些积蓄，结合着年轻时的阅历和朋友，也能做些小生意吧？又或者也能做做教育吧？</p>\n<p>顺着思考如何去过上喜欢的退休生活，似乎有了个更长远的目标，时间跨度更大的目标。</p>\n<p>于是乎，才意识到这几年来，只凭借着年少轻狂的那股劲在奔跑，却没有一个可以长远追逐的愿景。</p>\n<p>以至于，在碰到人生大事上，如结婚、买房、小孩这些问题上，却有了一种却步感。在碰到职业发展瓶颈上，会满满的焦虑感。还常常回忆过去，留恋过去。</p>\n<p>看过一个说法：20 岁年轻人和 50 岁老人做计划，年轻人最多只能做 2 年计划，老人却可以做 5 年甚至 10 年计划。因为 5 年，对年轻人来说是他生命的 1&#x2F;4，而对老人来说只是他生命的 1&#x2F;10。 唯一忧桑的是，老人所剩的生命时间不敌年轻的。</p>\n<p>从这个例子来看，我认为人类对时间的感受，是相对的，并且是可变化的。<br>那么假如年轻人能够去模拟感受老人对时间维度的感受，是不是也能做出更长远些的计划？然后更加淡定？</p>\n<p>倘若把时间维度拉长，如果 30 年后来看今天，却稍稍有一种豁达的感觉。虽然离想清楚，想明白，还有些距离。</p>\n<p>这样回去看，所谓的中年危机，互联网 35 岁命劫，在一个更长远的时间跨度中，也只能是件小事情，那么一跨，就过去了。</p>\n<p>那么如何回来看当下？<br>毕竟我还是 27 岁的年龄，那就应该在这个时期，去好好感受属于这个时期的生活。<br>好好去感受职场，持续提高个体价值，给这个社会输出贡献，以换取个体生活条件。<br>好好去感受生活，结婚、买房、生子、赡养老人，去感受人生这个阶段必须经历的生活。<br>还有，好好爱惜身体，毕竟生命只有一次。</p>\n<p>在历史长流的维度来看，一个人就几十年光景的寿命，诞生、成长、衰老，然后回归自然。<br>那么，这短短的生命，该怎么演绎？<br>第一，感谢父母亲把我们带到这个世界上。<br>第二，去好好感受生命的整个周期。</p>\n<p>现在是凌晨 3:16，祝晚安。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>现在是凌晨 2:06，今晚喝了两瓶科罗娜。<br>以为喝了酒能好好睡，结果，还是失眠了。</p>\n<p>是兴奋也罢，是焦虑也罢。既然明天不用上班，那么就让这个失眠夜来的更放纵些。</p>\n<p>刚才躺在床上，竟然在构想起自己的退休生活。<br>希望自己的退休生活，会更有趣些，在衣食上没有基本的担忧，身体虽然有些毛病，但还是能健康的活着，然后和老伴持续的二人世界。有一个独立的孩子，有空可以来看看我们。以及有一两个能持续以恒的爱好。然后，还顺利的养成了终身学习的习惯，作为一个 fasion 的老头。</p>\n<p>培养个啥兴趣好呢？回顾过去的众多爱好，找一个能持续发展的。就拿音乐来说，假如我能把音乐这件事学深了，学广了，把玩几门乐器，就算是个糟老头，也能搞搞创作吧。然后有些积蓄，结合着年轻时的阅历和朋友，也能做些小生意吧？又或者也能做做教育吧？</p>\n<p>顺着思考如何去过上喜欢的退休生活，似乎有了个更长远的目标，时间跨度更大的目标。</p>\n<p>于是乎，才意识到这几年来，只凭借着年少轻狂的那股劲在奔跑，却没有一个可以长远追逐的愿景。</p>\n<p>以至于，在碰到人生大事上，如结婚、买房、小孩这些问题上，却有了一种却步感。在碰到职业发展瓶颈上，会满满的焦虑感。还常常回忆过去，留恋过去。</p>\n<p>看过一个说法：20 岁年轻人和 50 岁老人做计划，年轻人最多只能做 2 年计划，老人却可以做 5 年甚至 10 年计划。因为 5 年，对年轻人来说是他生命的 1&#x2F;4，而对老人来说只是他生命的 1&#x2F;10。 唯一忧桑的是，老人所剩的生命时间不敌年轻的。</p>\n<p>从这个例子来看，我认为人类对时间的感受，是相对的，并且是可变化的。<br>那么假如年轻人能够去模拟感受老人对时间维度的感受，是不是也能做出更长远些的计划？然后更加淡定？</p>\n<p>倘若把时间维度拉长，如果 30 年后来看今天，却稍稍有一种豁达的感觉。虽然离想清楚，想明白，还有些距离。</p>\n<p>这样回去看，所谓的中年危机，互联网 35 岁命劫，在一个更长远的时间跨度中，也只能是件小事情，那么一跨，就过去了。</p>\n<p>那么如何回来看当下？<br>毕竟我还是 27 岁的年龄，那就应该在这个时期，去好好感受属于这个时期的生活。<br>好好去感受职场，持续提高个体价值，给这个社会输出贡献，以换取个体生活条件。<br>好好去感受生活，结婚、买房、生子、赡养老人，去感受人生这个阶段必须经历的生活。<br>还有，好好爱惜身体，毕竟生命只有一次。</p>\n<p>在历史长流的维度来看，一个人就几十年光景的寿命，诞生、成长、衰老，然后回归自然。<br>那么，这短短的生命，该怎么演绎？<br>第一，感谢父母亲把我们带到这个世界上。<br>第二，去好好感受生命的整个周期。</p>\n<p>现在是凌晨 3:16，祝晚安。</p>\n"},{"title":"Session原理","date":"2015-07-14T15:22:25.000Z","_content":"\n## 无状态的 HTTP 协议\n还记得每当入门一门 Web 端语言的进行服务器端开发的时候，仅次于「Hello World」的 demo 就是「登录功能」了。实现登录功能很简单，验证客户端发送过来的账户和密码，如果通过验证就把用户塞进 session 中，然后在后续的访问中，只需检测 session 是否有这个用户就能知道用户是否登录了。Session 的中文翻译为：「会话」，只属于某一个客户端和某一个服务器端沟通的工具。但，计算机网络老师又说了，HTTP 协议是无状态的，怎么能记录用户的登录状态呢？\n鉴于 HTTP 是无状态协议，之前已认证成功的用户状态是无法通过协议层面保存下来的，既，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他和其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。\n\n## 利用 Cookie 管理 Session\n\n![Session 管理及 Cookie 状态管理](/image/blog/79702-5660ac4cb51f6257.jpg)\n\n* 步骤 1：客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。\n\n* 步骤 2：服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份验证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID。\n\n* 步骤 3：客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。\n\n## 为 Cookie 服务的 HTTP 首部字段\n> \n* Set-Cookie\n* Cookie\n\n#### Set-Cookie\n服务器管理状态使用到的字段，用于响应首部\n一则响应首部的 Set-Cookie 字段：\n```\nSet-Cookie: status=enable; expires= Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;\n```\nSet-Cookie 字段的属性：\n\n| 属性 | 说明 |\n| ----|-----|\n|NAME=VALUE | 赋予 Cookie 的名称和其值（必须项）|\n|expires=DATE | Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）|\n|path=PATH | 将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的目录）|\n|domain=域名 | 作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）|\n| Secure | 仅在 HTTPS 安全通信时才会发送 Cookie|\n|HttpOnly| 加以限制，使 Cookie 不能被 Javascript 脚本访问\n\n#### Cookie\n首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。\n\n","source":"_posts/Session原理.md","raw":"---\ntitle: Session原理\ncategory: 搬砖码农\ndate: 2015-07-14 23:22:25\ntags: \n- session\n- cookie\n---\n\n## 无状态的 HTTP 协议\n还记得每当入门一门 Web 端语言的进行服务器端开发的时候，仅次于「Hello World」的 demo 就是「登录功能」了。实现登录功能很简单，验证客户端发送过来的账户和密码，如果通过验证就把用户塞进 session 中，然后在后续的访问中，只需检测 session 是否有这个用户就能知道用户是否登录了。Session 的中文翻译为：「会话」，只属于某一个客户端和某一个服务器端沟通的工具。但，计算机网络老师又说了，HTTP 协议是无状态的，怎么能记录用户的登录状态呢？\n鉴于 HTTP 是无状态协议，之前已认证成功的用户状态是无法通过协议层面保存下来的，既，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他和其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。\n\n## 利用 Cookie 管理 Session\n\n![Session 管理及 Cookie 状态管理](/image/blog/79702-5660ac4cb51f6257.jpg)\n\n* 步骤 1：客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。\n\n* 步骤 2：服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份验证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID。\n\n* 步骤 3：客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。\n\n## 为 Cookie 服务的 HTTP 首部字段\n> \n* Set-Cookie\n* Cookie\n\n#### Set-Cookie\n服务器管理状态使用到的字段，用于响应首部\n一则响应首部的 Set-Cookie 字段：\n```\nSet-Cookie: status=enable; expires= Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;\n```\nSet-Cookie 字段的属性：\n\n| 属性 | 说明 |\n| ----|-----|\n|NAME=VALUE | 赋予 Cookie 的名称和其值（必须项）|\n|expires=DATE | Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）|\n|path=PATH | 将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的目录）|\n|domain=域名 | 作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）|\n| Secure | 仅在 HTTPS 安全通信时才会发送 Cookie|\n|HttpOnly| 加以限制，使 Cookie 不能被 Javascript 脚本访问\n\n#### Cookie\n首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。\n\n","slug":"Session原理","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8tu0069xwrlqqi43tdu","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"无状态的-HTTP-协议\"><a href=\"#无状态的-HTTP-协议\" class=\"headerlink\" title=\"无状态的 HTTP 协议\"></a>无状态的 HTTP 协议</h2><p>还记得每当入门一门 Web 端语言的进行服务器端开发的时候，仅次于「Hello World」的 demo 就是「登录功能」了。实现登录功能很简单，验证客户端发送过来的账户和密码，如果通过验证就把用户塞进 session 中，然后在后续的访问中，只需检测 session 是否有这个用户就能知道用户是否登录了。Session 的中文翻译为：「会话」，只属于某一个客户端和某一个服务器端沟通的工具。但，计算机网络老师又说了，HTTP 协议是无状态的，怎么能记录用户的登录状态呢？<br>鉴于 HTTP 是无状态协议，之前已认证成功的用户状态是无法通过协议层面保存下来的，既，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他和其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。</p>\n<h2 id=\"利用-Cookie-管理-Session\"><a href=\"#利用-Cookie-管理-Session\" class=\"headerlink\" title=\"利用 Cookie 管理 Session\"></a>利用 Cookie 管理 Session</h2><p><img src=\"/image/blog/79702-5660ac4cb51f6257.jpg\" alt=\"Session 管理及 Cookie 状态管理\"></p>\n<ul>\n<li><p>步骤 1：客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。</p>\n</li>\n<li><p>步骤 2：服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份验证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID。</p>\n</li>\n<li><p>步骤 3：客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</p>\n</li>\n</ul>\n<h2 id=\"为-Cookie-服务的-HTTP-首部字段\"><a href=\"#为-Cookie-服务的-HTTP-首部字段\" class=\"headerlink\" title=\"为 Cookie 服务的 HTTP 首部字段\"></a>为 Cookie 服务的 HTTP 首部字段</h2><blockquote>\n</blockquote>\n<ul>\n<li>Set-Cookie</li>\n<li>Cookie</li>\n</ul>\n<h4 id=\"Set-Cookie\"><a href=\"#Set-Cookie\" class=\"headerlink\" title=\"Set-Cookie\"></a>Set-Cookie</h4><p>服务器管理状态使用到的字段，用于响应首部<br>一则响应首部的 Set-Cookie 字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: status=enable; expires= Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;</span><br></pre></td></tr></table></figure></p>\n<p>Set-Cookie 字段的属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NAME=VALUE</td>\n<td>赋予 Cookie 的名称和其值（必须项）</td>\n</tr>\n<tr>\n<td>expires=DATE</td>\n<td>Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td>\n</tr>\n<tr>\n<td>path=PATH</td>\n<td>将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的目录）</td>\n</tr>\n<tr>\n<td>domain=域名</td>\n<td>作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）</td>\n</tr>\n<tr>\n<td>Secure</td>\n<td>仅在 HTTPS 安全通信时才会发送 Cookie</td>\n</tr>\n<tr>\n<td>HttpOnly</td>\n<td>加以限制，使 Cookie 不能被 Javascript 脚本访问</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p>\n","excerpt":"","more":"<h2 id=\"无状态的-HTTP-协议\"><a href=\"#无状态的-HTTP-协议\" class=\"headerlink\" title=\"无状态的 HTTP 协议\"></a>无状态的 HTTP 协议</h2><p>还记得每当入门一门 Web 端语言的进行服务器端开发的时候，仅次于「Hello World」的 demo 就是「登录功能」了。实现登录功能很简单，验证客户端发送过来的账户和密码，如果通过验证就把用户塞进 session 中，然后在后续的访问中，只需检测 session 是否有这个用户就能知道用户是否登录了。Session 的中文翻译为：「会话」，只属于某一个客户端和某一个服务器端沟通的工具。但，计算机网络老师又说了，HTTP 协议是无状态的，怎么能记录用户的登录状态呢？<br>鉴于 HTTP 是无状态协议，之前已认证成功的用户状态是无法通过协议层面保存下来的，既，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他和其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。</p>\n<h2 id=\"利用-Cookie-管理-Session\"><a href=\"#利用-Cookie-管理-Session\" class=\"headerlink\" title=\"利用 Cookie 管理 Session\"></a>利用 Cookie 管理 Session</h2><p><img src=\"/image/blog/79702-5660ac4cb51f6257.jpg\" alt=\"Session 管理及 Cookie 状态管理\"></p>\n<ul>\n<li><p>步骤 1：客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。</p>\n</li>\n<li><p>步骤 2：服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份验证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID。</p>\n</li>\n<li><p>步骤 3：客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</p>\n</li>\n</ul>\n<h2 id=\"为-Cookie-服务的-HTTP-首部字段\"><a href=\"#为-Cookie-服务的-HTTP-首部字段\" class=\"headerlink\" title=\"为 Cookie 服务的 HTTP 首部字段\"></a>为 Cookie 服务的 HTTP 首部字段</h2><blockquote>\n</blockquote>\n<ul>\n<li>Set-Cookie</li>\n<li>Cookie</li>\n</ul>\n<h4 id=\"Set-Cookie\"><a href=\"#Set-Cookie\" class=\"headerlink\" title=\"Set-Cookie\"></a>Set-Cookie</h4><p>服务器管理状态使用到的字段，用于响应首部<br>一则响应首部的 Set-Cookie 字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: status=enable; expires= Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;</span><br></pre></td></tr></table></figure></p>\n<p>Set-Cookie 字段的属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NAME=VALUE</td>\n<td>赋予 Cookie 的名称和其值（必须项）</td>\n</tr>\n<tr>\n<td>expires=DATE</td>\n<td>Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td>\n</tr>\n<tr>\n<td>path=PATH</td>\n<td>将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的目录）</td>\n</tr>\n<tr>\n<td>domain=域名</td>\n<td>作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）</td>\n</tr>\n<tr>\n<td>Secure</td>\n<td>仅在 HTTPS 安全通信时才会发送 Cookie</td>\n</tr>\n<tr>\n<td>HttpOnly</td>\n<td>加以限制，使 Cookie 不能被 Javascript 脚本访问</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p>\n"},{"title":"SOAP，WebService的枢纽","date":"2015-01-11T16:02:38.000Z","_content":"\n## 前言\n\n前两天，室友给我发了一套代码......\n\n![](/image/blog/79702-e7cf075365536286.jpeg)\n![](/image/blog/79702-e7cf075365536286.jpeg)\n\n一段对话下来，我心中多个疑问：SOAP是什么？node调用java接口？\n\n一向懒散的我，不知为何却对些问题有点兴趣，平常我们处理不同应用程序之间的通讯，都是以RESTful API的方式的，基于HTTP协议，互相传输JSON格式的数据以达到程序间的交流。现在却有一个称SOAP的东东，可以直接调用程序的接口？\n\n## SOAP，何方妖孽？\n\n*   SOAP（Simple Object Access Protocol 简单对象访问协议）\n*   SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。\n*   SOAP 独立于平台、语言，且简单和可扩展\n\n## SOAP 怎么来的？\n\n此标准由IBM、Microsoft、UserLand和DevelopMentor在1998年共同提出，并得到IBM，莲花（Lotus），康柏（Compaq）等公司的支持，于2000年提交给万维网联盟（World Wide Web Consortium；W3C），目前SOAP 1.1版是业界共同的标准，属于第二代的XML协定（第一代具主要代表性的技术为XML-RPC以及WDDX）。\n\n## SOAP 的 好搭档：WSDL、Web Service\n\n为了能了解SOAP的做的事，你首先需要了解和SOAP一同工作的两个同事。\n\n**Web Service** 是一套应用程序的组件，也可以说是对外接口，它使用SOAP这一套标准，提供公共服务给别的程序调用。\n\n**WSDL** 是基于XML语言的，用来描述web service的消息格式和协议细节，以及如何访问它们。它的全称是：Web Service Description Language web服务描述语言。\n\n## SOAP是怎么工作的？\n\n在了解了SOAP、WSDL、Web Service的定义之后，我们就来窥探一下它们三个是怎么P的？\n\n**假设**现在有两个应用程序，分别用两种语言进行开发的，一个是用nodejs开发的程序，一个是用java开发的程序。而java程序其中有一个方法(getUser)可以查询数据库中的某用户的信息。那么在nodejs程序请求java程序的(getUser)方法获取某用户信息的流程是怎么走的？\n\n我在应用程序的层面上解释一下这个流程，\n\n请看下图，然后我再对每一个步骤说明：\n\n![](/image/blog/79702-5d2b1c9e8970c3ea.jpeg)\n\n首先java程序会把`getUser()`做成Web Service，然后要提供对这个service的描述文档，那便是WSDL文件。nodejs程序要调用的方法以及参数的信息都存放在遵循了SOAP标准的WSDL文件中，所以要访问远端的web service，必须先获得对方提供的WSDL。\n\n步骤一：nodejs程序通过http请求，获取到java程序提供的WSDL文件。nodejs程序得到这个WSDL文件之后，就会对它进行解析，得知java程序提供了`getUser()`，而且也知道这个方法需要的参数是`string`类型的且变量名`userUUID`。\n\n步骤二：在nodejs程序知道java程序有`getUser()`这个方法之后，它通过http请求，发送SOAP信息到java程序，java程序得到这个SOAP信息之后，进行解析，知道了nodejs程序需要请求`getUser()`方法，且提供了所需要的参数。\n\n步骤三：java程序对nodejs的请求进行逻辑处理，查询数据库，然后把结果翻译成SOAP信息，再通过http协议发送到nodejs程序。\n\n本例中，nodejs程序和java程序沟通的SOAP实例：\n\nSOAP 请求：\n\n    POST /InStock HTTP/1.1\n    Host: www.example.org\n    Content-Type: application/soap+xml; charset=utf-8\n    Content-Length: nnn\n\n    <?xml version=\"1.0\"?>\n    <soap:Envelope\n    xmlns:soap=\"http://www.w3.org/2001/12/soap-envelope\"\n    soap:encodingStyle=\"http://www.w3.org/2001/12/soap-encoding\">\n\n      <soap:Body xmlns:m=\"http://www.example.org/stock\">\n        <m:getUser>\n          <m:userUUID>123456789</m:userUUID>\n        </m:getUser>\n      </soap:Body>\n\n    </soap:Envelope>`</pre>\n\n    SOAP 响应：\n\n    <pre>`HTTP/1.1 200 OK\n    Content-Type: application/soap+xml; charset=utf-8\n    Content-Length: nnn\n\n    <?xml version=\"1.0\"?>\n    <soap:Envelope\n    xmlns:soap=\"http://www.w3.org/2001/12/soap-envelope\"\n    soap:encodingStyle=\"http://www.w3.org/2001/12/soap-encoding\">\n\n      <soap:Body xmlns:m=\"http://www.example.org/stock\">\n        <m:getUserResponse>\n          <m:userName>JerryC</m:userName>\n        </m:getUserResponse>\n      </soap:Body>\n\n    </soap:Envelope>\n\n综上，程序之间的调用，无论进行请求还是返回结果，每一次都需要构造一则SOAP信息，固然SOAP便是程序之间沟通的语言。\n\n## node开发中的soap\n\n我是一名nodejs开发者，知道有这么一种程序之间交流信息的协议之后，很自然就想知道用nodejs怎么使用这个协议。\n\nnodejs针对SOAP也有不少的第三方模块：\n\n*   [node-soap](https://github.com/milewise/node-soap)\n*   [douche](https://github.com/kr1sp1n/douche)\n*   [soapjs](https://github.com/jmoyers/soapjs)\n....\n[更多nodejs的SOAP第三方模块](https://nodejsmodules.org/tags/soap)\n\n其中，node-soap是最受欢迎的(根据github上star数量)，也是我最喜欢的。\n\n##### 本文写作参考：\n\n[http://www.w3school.com.cn/soap/index.asp](http://www.w3school.com.cn/soap/index.asp)\n[http://zh.wikipedia.org/wiki/SOAP](http://zh.wikipedia.org/wiki/SOAP)\n","source":"_posts/SOAP-Web-Service的枢纽.md","raw":"---\ntitle: SOAP，WebService的枢纽\ndate: 2015-01-12 00:02:38\ntags:\n- Nodejs\n- Javascript\n- SOAP\ncategory: 搬砖码农\n---\n\n## 前言\n\n前两天，室友给我发了一套代码......\n\n![](/image/blog/79702-e7cf075365536286.jpeg)\n![](/image/blog/79702-e7cf075365536286.jpeg)\n\n一段对话下来，我心中多个疑问：SOAP是什么？node调用java接口？\n\n一向懒散的我，不知为何却对些问题有点兴趣，平常我们处理不同应用程序之间的通讯，都是以RESTful API的方式的，基于HTTP协议，互相传输JSON格式的数据以达到程序间的交流。现在却有一个称SOAP的东东，可以直接调用程序的接口？\n\n## SOAP，何方妖孽？\n\n*   SOAP（Simple Object Access Protocol 简单对象访问协议）\n*   SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。\n*   SOAP 独立于平台、语言，且简单和可扩展\n\n## SOAP 怎么来的？\n\n此标准由IBM、Microsoft、UserLand和DevelopMentor在1998年共同提出，并得到IBM，莲花（Lotus），康柏（Compaq）等公司的支持，于2000年提交给万维网联盟（World Wide Web Consortium；W3C），目前SOAP 1.1版是业界共同的标准，属于第二代的XML协定（第一代具主要代表性的技术为XML-RPC以及WDDX）。\n\n## SOAP 的 好搭档：WSDL、Web Service\n\n为了能了解SOAP的做的事，你首先需要了解和SOAP一同工作的两个同事。\n\n**Web Service** 是一套应用程序的组件，也可以说是对外接口，它使用SOAP这一套标准，提供公共服务给别的程序调用。\n\n**WSDL** 是基于XML语言的，用来描述web service的消息格式和协议细节，以及如何访问它们。它的全称是：Web Service Description Language web服务描述语言。\n\n## SOAP是怎么工作的？\n\n在了解了SOAP、WSDL、Web Service的定义之后，我们就来窥探一下它们三个是怎么P的？\n\n**假设**现在有两个应用程序，分别用两种语言进行开发的，一个是用nodejs开发的程序，一个是用java开发的程序。而java程序其中有一个方法(getUser)可以查询数据库中的某用户的信息。那么在nodejs程序请求java程序的(getUser)方法获取某用户信息的流程是怎么走的？\n\n我在应用程序的层面上解释一下这个流程，\n\n请看下图，然后我再对每一个步骤说明：\n\n![](/image/blog/79702-5d2b1c9e8970c3ea.jpeg)\n\n首先java程序会把`getUser()`做成Web Service，然后要提供对这个service的描述文档，那便是WSDL文件。nodejs程序要调用的方法以及参数的信息都存放在遵循了SOAP标准的WSDL文件中，所以要访问远端的web service，必须先获得对方提供的WSDL。\n\n步骤一：nodejs程序通过http请求，获取到java程序提供的WSDL文件。nodejs程序得到这个WSDL文件之后，就会对它进行解析，得知java程序提供了`getUser()`，而且也知道这个方法需要的参数是`string`类型的且变量名`userUUID`。\n\n步骤二：在nodejs程序知道java程序有`getUser()`这个方法之后，它通过http请求，发送SOAP信息到java程序，java程序得到这个SOAP信息之后，进行解析，知道了nodejs程序需要请求`getUser()`方法，且提供了所需要的参数。\n\n步骤三：java程序对nodejs的请求进行逻辑处理，查询数据库，然后把结果翻译成SOAP信息，再通过http协议发送到nodejs程序。\n\n本例中，nodejs程序和java程序沟通的SOAP实例：\n\nSOAP 请求：\n\n    POST /InStock HTTP/1.1\n    Host: www.example.org\n    Content-Type: application/soap+xml; charset=utf-8\n    Content-Length: nnn\n\n    <?xml version=\"1.0\"?>\n    <soap:Envelope\n    xmlns:soap=\"http://www.w3.org/2001/12/soap-envelope\"\n    soap:encodingStyle=\"http://www.w3.org/2001/12/soap-encoding\">\n\n      <soap:Body xmlns:m=\"http://www.example.org/stock\">\n        <m:getUser>\n          <m:userUUID>123456789</m:userUUID>\n        </m:getUser>\n      </soap:Body>\n\n    </soap:Envelope>`</pre>\n\n    SOAP 响应：\n\n    <pre>`HTTP/1.1 200 OK\n    Content-Type: application/soap+xml; charset=utf-8\n    Content-Length: nnn\n\n    <?xml version=\"1.0\"?>\n    <soap:Envelope\n    xmlns:soap=\"http://www.w3.org/2001/12/soap-envelope\"\n    soap:encodingStyle=\"http://www.w3.org/2001/12/soap-encoding\">\n\n      <soap:Body xmlns:m=\"http://www.example.org/stock\">\n        <m:getUserResponse>\n          <m:userName>JerryC</m:userName>\n        </m:getUserResponse>\n      </soap:Body>\n\n    </soap:Envelope>\n\n综上，程序之间的调用，无论进行请求还是返回结果，每一次都需要构造一则SOAP信息，固然SOAP便是程序之间沟通的语言。\n\n## node开发中的soap\n\n我是一名nodejs开发者，知道有这么一种程序之间交流信息的协议之后，很自然就想知道用nodejs怎么使用这个协议。\n\nnodejs针对SOAP也有不少的第三方模块：\n\n*   [node-soap](https://github.com/milewise/node-soap)\n*   [douche](https://github.com/kr1sp1n/douche)\n*   [soapjs](https://github.com/jmoyers/soapjs)\n....\n[更多nodejs的SOAP第三方模块](https://nodejsmodules.org/tags/soap)\n\n其中，node-soap是最受欢迎的(根据github上star数量)，也是我最喜欢的。\n\n##### 本文写作参考：\n\n[http://www.w3school.com.cn/soap/index.asp](http://www.w3school.com.cn/soap/index.asp)\n[http://zh.wikipedia.org/wiki/SOAP](http://zh.wikipedia.org/wiki/SOAP)\n","slug":"SOAP-Web-Service的枢纽","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8tv006dxwrlun9le3ci","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前两天，室友给我发了一套代码……</p>\n<p><img src=\"/image/blog/79702-e7cf075365536286.jpeg\" alt><br><img src=\"/image/blog/79702-e7cf075365536286.jpeg\" alt></p>\n<p>一段对话下来，我心中多个疑问：SOAP是什么？node调用java接口？</p>\n<p>一向懒散的我，不知为何却对些问题有点兴趣，平常我们处理不同应用程序之间的通讯，都是以RESTful API的方式的，基于HTTP协议，互相传输JSON格式的数据以达到程序间的交流。现在却有一个称SOAP的东东，可以直接调用程序的接口？</p>\n<h2 id=\"SOAP，何方妖孽？\"><a href=\"#SOAP，何方妖孽？\" class=\"headerlink\" title=\"SOAP，何方妖孽？\"></a>SOAP，何方妖孽？</h2><ul>\n<li>SOAP（Simple Object Access Protocol 简单对象访问协议）</li>\n<li>SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。</li>\n<li>SOAP 独立于平台、语言，且简单和可扩展</li>\n</ul>\n<h2 id=\"SOAP-怎么来的？\"><a href=\"#SOAP-怎么来的？\" class=\"headerlink\" title=\"SOAP 怎么来的？\"></a>SOAP 怎么来的？</h2><p>此标准由IBM、Microsoft、UserLand和DevelopMentor在1998年共同提出，并得到IBM，莲花（Lotus），康柏（Compaq）等公司的支持，于2000年提交给万维网联盟（World Wide Web Consortium；W3C），目前SOAP 1.1版是业界共同的标准，属于第二代的XML协定（第一代具主要代表性的技术为XML-RPC以及WDDX）。</p>\n<h2 id=\"SOAP-的-好搭档：WSDL、Web-Service\"><a href=\"#SOAP-的-好搭档：WSDL、Web-Service\" class=\"headerlink\" title=\"SOAP 的 好搭档：WSDL、Web Service\"></a>SOAP 的 好搭档：WSDL、Web Service</h2><p>为了能了解SOAP的做的事，你首先需要了解和SOAP一同工作的两个同事。</p>\n<p><strong>Web Service</strong> 是一套应用程序的组件，也可以说是对外接口，它使用SOAP这一套标准，提供公共服务给别的程序调用。</p>\n<p><strong>WSDL</strong> 是基于XML语言的，用来描述web service的消息格式和协议细节，以及如何访问它们。它的全称是：Web Service Description Language web服务描述语言。</p>\n<h2 id=\"SOAP是怎么工作的？\"><a href=\"#SOAP是怎么工作的？\" class=\"headerlink\" title=\"SOAP是怎么工作的？\"></a>SOAP是怎么工作的？</h2><p>在了解了SOAP、WSDL、Web Service的定义之后，我们就来窥探一下它们三个是怎么P的？</p>\n<p><strong>假设</strong>现在有两个应用程序，分别用两种语言进行开发的，一个是用nodejs开发的程序，一个是用java开发的程序。而java程序其中有一个方法(getUser)可以查询数据库中的某用户的信息。那么在nodejs程序请求java程序的(getUser)方法获取某用户信息的流程是怎么走的？</p>\n<p>我在应用程序的层面上解释一下这个流程，</p>\n<p>请看下图，然后我再对每一个步骤说明：</p>\n<p><img src=\"/image/blog/79702-5d2b1c9e8970c3ea.jpeg\" alt></p>\n<p>首先java程序会把<code>getUser()</code>做成Web Service，然后要提供对这个service的描述文档，那便是WSDL文件。nodejs程序要调用的方法以及参数的信息都存放在遵循了SOAP标准的WSDL文件中，所以要访问远端的web service，必须先获得对方提供的WSDL。</p>\n<p>步骤一：nodejs程序通过http请求，获取到java程序提供的WSDL文件。nodejs程序得到这个WSDL文件之后，就会对它进行解析，得知java程序提供了<code>getUser()</code>，而且也知道这个方法需要的参数是<code>string</code>类型的且变量名<code>userUUID</code>。</p>\n<p>步骤二：在nodejs程序知道java程序有<code>getUser()</code>这个方法之后，它通过http请求，发送SOAP信息到java程序，java程序得到这个SOAP信息之后，进行解析，知道了nodejs程序需要请求<code>getUser()</code>方法，且提供了所需要的参数。</p>\n<p>步骤三：java程序对nodejs的请求进行逻辑处理，查询数据库，然后把结果翻译成SOAP信息，再通过http协议发送到nodejs程序。</p>\n<p>本例中，nodejs程序和java程序沟通的SOAP实例：</p>\n<p>SOAP 请求：</p>\n<pre><code>POST /InStock HTTP/1.1\nHost: www.example.org\nContent-Type: application/soap+xml; charset=utf-8\nContent-Length: nnn\n\n&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;soap:Envelope\nxmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;\nsoap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;\n\n  &lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;\n    &lt;m:getUser&gt;\n      &lt;m:userUUID&gt;123456789&lt;/m:userUUID&gt;\n    &lt;/m:getUser&gt;\n  &lt;/soap:Body&gt;\n\n&lt;/soap:Envelope&gt;`&lt;/pre&gt;\n\nSOAP 响应：\n\n&lt;pre&gt;`HTTP/1.1 200 OK\nContent-Type: application/soap+xml; charset=utf-8\nContent-Length: nnn\n\n&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;soap:Envelope\nxmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;\nsoap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;\n\n  &lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;\n    &lt;m:getUserResponse&gt;\n      &lt;m:userName&gt;JerryC&lt;/m:userName&gt;\n    &lt;/m:getUserResponse&gt;\n  &lt;/soap:Body&gt;\n\n&lt;/soap:Envelope&gt;\n</code></pre><p>综上，程序之间的调用，无论进行请求还是返回结果，每一次都需要构造一则SOAP信息，固然SOAP便是程序之间沟通的语言。</p>\n<h2 id=\"node开发中的soap\"><a href=\"#node开发中的soap\" class=\"headerlink\" title=\"node开发中的soap\"></a>node开发中的soap</h2><p>我是一名nodejs开发者，知道有这么一种程序之间交流信息的协议之后，很自然就想知道用nodejs怎么使用这个协议。</p>\n<p>nodejs针对SOAP也有不少的第三方模块：</p>\n<ul>\n<li><a href=\"https://github.com/milewise/node-soap\" target=\"_blank\" rel=\"external\">node-soap</a></li>\n<li><a href=\"https://github.com/kr1sp1n/douche\" target=\"_blank\" rel=\"external\">douche</a></li>\n<li><a href=\"https://github.com/jmoyers/soapjs\" target=\"_blank\" rel=\"external\">soapjs</a><br>….<br><a href=\"https://nodejsmodules.org/tags/soap\" target=\"_blank\" rel=\"external\">更多nodejs的SOAP第三方模块</a></li>\n</ul>\n<p>其中，node-soap是最受欢迎的(根据github上star数量)，也是我最喜欢的。</p>\n<h5 id=\"本文写作参考：\"><a href=\"#本文写作参考：\" class=\"headerlink\" title=\"本文写作参考：\"></a>本文写作参考：</h5><p><a href=\"http://www.w3school.com.cn/soap/index.asp\" target=\"_blank\" rel=\"external\">http://www.w3school.com.cn/soap/index.asp</a><br><a href=\"http://zh.wikipedia.org/wiki/SOAP\" target=\"_blank\" rel=\"external\">http://zh.wikipedia.org/wiki/SOAP</a></p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前两天，室友给我发了一套代码……</p>\n<p><img src=\"/image/blog/79702-e7cf075365536286.jpeg\" alt=\"\"><br><img src=\"/image/blog/79702-e7cf075365536286.jpeg\" alt=\"\"></p>\n<p>一段对话下来，我心中多个疑问：SOAP是什么？node调用java接口？</p>\n<p>一向懒散的我，不知为何却对些问题有点兴趣，平常我们处理不同应用程序之间的通讯，都是以RESTful API的方式的，基于HTTP协议，互相传输JSON格式的数据以达到程序间的交流。现在却有一个称SOAP的东东，可以直接调用程序的接口？</p>\n<h2 id=\"SOAP，何方妖孽？\"><a href=\"#SOAP，何方妖孽？\" class=\"headerlink\" title=\"SOAP，何方妖孽？\"></a>SOAP，何方妖孽？</h2><ul>\n<li>SOAP（Simple Object Access Protocol 简单对象访问协议）</li>\n<li>SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。</li>\n<li>SOAP 独立于平台、语言，且简单和可扩展</li>\n</ul>\n<h2 id=\"SOAP-怎么来的？\"><a href=\"#SOAP-怎么来的？\" class=\"headerlink\" title=\"SOAP 怎么来的？\"></a>SOAP 怎么来的？</h2><p>此标准由IBM、Microsoft、UserLand和DevelopMentor在1998年共同提出，并得到IBM，莲花（Lotus），康柏（Compaq）等公司的支持，于2000年提交给万维网联盟（World Wide Web Consortium；W3C），目前SOAP 1.1版是业界共同的标准，属于第二代的XML协定（第一代具主要代表性的技术为XML-RPC以及WDDX）。</p>\n<h2 id=\"SOAP-的-好搭档：WSDL、Web-Service\"><a href=\"#SOAP-的-好搭档：WSDL、Web-Service\" class=\"headerlink\" title=\"SOAP 的 好搭档：WSDL、Web Service\"></a>SOAP 的 好搭档：WSDL、Web Service</h2><p>为了能了解SOAP的做的事，你首先需要了解和SOAP一同工作的两个同事。</p>\n<p><strong>Web Service</strong> 是一套应用程序的组件，也可以说是对外接口，它使用SOAP这一套标准，提供公共服务给别的程序调用。</p>\n<p><strong>WSDL</strong> 是基于XML语言的，用来描述web service的消息格式和协议细节，以及如何访问它们。它的全称是：Web Service Description Language web服务描述语言。</p>\n<h2 id=\"SOAP是怎么工作的？\"><a href=\"#SOAP是怎么工作的？\" class=\"headerlink\" title=\"SOAP是怎么工作的？\"></a>SOAP是怎么工作的？</h2><p>在了解了SOAP、WSDL、Web Service的定义之后，我们就来窥探一下它们三个是怎么P的？</p>\n<p><strong>假设</strong>现在有两个应用程序，分别用两种语言进行开发的，一个是用nodejs开发的程序，一个是用java开发的程序。而java程序其中有一个方法(getUser)可以查询数据库中的某用户的信息。那么在nodejs程序请求java程序的(getUser)方法获取某用户信息的流程是怎么走的？</p>\n<p>我在应用程序的层面上解释一下这个流程，</p>\n<p>请看下图，然后我再对每一个步骤说明：</p>\n<p><img src=\"/image/blog/79702-5d2b1c9e8970c3ea.jpeg\" alt=\"\"></p>\n<p>首先java程序会把<code>getUser()</code>做成Web Service，然后要提供对这个service的描述文档，那便是WSDL文件。nodejs程序要调用的方法以及参数的信息都存放在遵循了SOAP标准的WSDL文件中，所以要访问远端的web service，必须先获得对方提供的WSDL。</p>\n<p>步骤一：nodejs程序通过http请求，获取到java程序提供的WSDL文件。nodejs程序得到这个WSDL文件之后，就会对它进行解析，得知java程序提供了<code>getUser()</code>，而且也知道这个方法需要的参数是<code>string</code>类型的且变量名<code>userUUID</code>。</p>\n<p>步骤二：在nodejs程序知道java程序有<code>getUser()</code>这个方法之后，它通过http请求，发送SOAP信息到java程序，java程序得到这个SOAP信息之后，进行解析，知道了nodejs程序需要请求<code>getUser()</code>方法，且提供了所需要的参数。</p>\n<p>步骤三：java程序对nodejs的请求进行逻辑处理，查询数据库，然后把结果翻译成SOAP信息，再通过http协议发送到nodejs程序。</p>\n<p>本例中，nodejs程序和java程序沟通的SOAP实例：</p>\n<p>SOAP 请求：</p>\n<pre><code>POST /InStock HTTP/1.1\nHost: www.example.org\nContent-Type: application/soap+xml; charset=utf-8\nContent-Length: nnn\n\n&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;soap:Envelope\nxmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;\nsoap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;\n\n  &lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;\n    &lt;m:getUser&gt;\n      &lt;m:userUUID&gt;123456789&lt;/m:userUUID&gt;\n    &lt;/m:getUser&gt;\n  &lt;/soap:Body&gt;\n\n&lt;/soap:Envelope&gt;`&lt;/pre&gt;\n\nSOAP 响应：\n\n&lt;pre&gt;`HTTP/1.1 200 OK\nContent-Type: application/soap+xml; charset=utf-8\nContent-Length: nnn\n\n&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;soap:Envelope\nxmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;\nsoap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;\n\n  &lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;\n    &lt;m:getUserResponse&gt;\n      &lt;m:userName&gt;JerryC&lt;/m:userName&gt;\n    &lt;/m:getUserResponse&gt;\n  &lt;/soap:Body&gt;\n\n&lt;/soap:Envelope&gt;\n</code></pre><p>综上，程序之间的调用，无论进行请求还是返回结果，每一次都需要构造一则SOAP信息，固然SOAP便是程序之间沟通的语言。</p>\n<h2 id=\"node开发中的soap\"><a href=\"#node开发中的soap\" class=\"headerlink\" title=\"node开发中的soap\"></a>node开发中的soap</h2><p>我是一名nodejs开发者，知道有这么一种程序之间交流信息的协议之后，很自然就想知道用nodejs怎么使用这个协议。</p>\n<p>nodejs针对SOAP也有不少的第三方模块：</p>\n<ul>\n<li><a href=\"https://github.com/milewise/node-soap\">node-soap</a></li>\n<li><a href=\"https://github.com/kr1sp1n/douche\">douche</a></li>\n<li><a href=\"https://github.com/jmoyers/soapjs\">soapjs</a><br>….<br><a href=\"https://nodejsmodules.org/tags/soap\">更多nodejs的SOAP第三方模块</a></li>\n</ul>\n<p>其中，node-soap是最受欢迎的(根据github上star数量)，也是我最喜欢的。</p>\n<h5 id=\"本文写作参考：\"><a href=\"#本文写作参考：\" class=\"headerlink\" title=\"本文写作参考：\"></a>本文写作参考：</h5><p><a href=\"http://www.w3school.com.cn/soap/index.asp\">http://www.w3school.com.cn/soap/index.asp</a><br><a href=\"http://zh.wikipedia.org/wiki/SOAP\">http://zh.wikipedia.org/wiki/SOAP</a></p>\n"},{"title":"NodeJS中被忽略的内存","date":"2016-04-14T12:19:02.000Z","_content":"\n> 如朴灵说过，Node对内存泄露十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用奔溃。\n\n虽然从很久以前就知道内存问题是不容忽视的，但是日常开发的时候并没有碰到性能上的瓶颈，直到最近做了一个百万PV级的营销项目，由于访问量，并发量都达到了一个量级。一些细小的、平时没注意到的问题被放大，这才映入眼帘，开始注意到了内存问题。殊不知Node对内存的泄露是如此的敏感。\n为此，赶紧去补习了一下V8中的内存处理机制。\n那么，V8中的内存机制是怎么样的？\n\n## V8的内存机制\n\n### 内存的限制\n\nNode中并不像其他后端语言中，对内存的使用没有多少限制。在Node中使用内存，只能使用到系统的一部分内存，64位系统下约为1.4GB，32位系统下约为0.7GB。这归咎于Node使用了本来运行在浏览器的V8引擎。\n\nV8引擎的设计之初只是运行在浏览器中，而在浏览器的一般应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。\n\n虽然服务端操作大内存也不是常见的需求，但是万一有这样的需求，还是可以解除限制的。\n在启动node程序的时候，可以传递两个参数来调整内存限制的大小。\n\n```\nnode --max-nex-space-size=1024 app.js // 单位为KB\nnode --max-old-space-size=2000 app.js // 单位为MB\n```\n\n这两条命令分别对应Node内存堆中的「新生代」和「老生代」\n\n### 不受内存限制的特例\n\n在Node中，使用Buffer可以读取超过V8内存限制的大文件。原因是Buffer对象不同于其他对象，它不经过V8的内存分配机制。这在于Node并不同于浏览器的应用场景。在浏览器中，JavaScript直接处理字符串即可满足绝大多数的业务需求，而Node则需要处理网络流和文件I/O流，操作字符串远远不能满足传输的性能需求。\n\n### 内存的分配\n\n> 一切JavaScript对象都用堆来存储\n\n当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的对空闲内存不够分配新的对象，讲继续申请堆内存，直到堆的大小超过V8的限制为止。\n\n![V8的堆示意图](/image/blog/memory-in-nodejs/V8的堆示意图.png)\n\n## V8的垃圾回收机制\n\n### 分代式垃圾回收\n\nV8的垃圾回收策略主要基于「分代式垃圾回收机制」，基于这个机制，V8把内存分为「新生代(New Space)」和 「老生代 (Old Space)」。\n新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。\n前面提及到的`--max-old-space-size`命令就是设置老生代内存空间的最大值，而`--max-new-space-size`命令则可以设置新生代内存空间的大小。\n\n![V8的分代示意图](/image/blog/memory-in-nodejs/V8的分代示意图.png)\n\n#### 为什么要分成新老两代？\n\n垃圾回收算法有很多种，但是并没有一种是胜任所有的场景，在实际的应用中，需要根据对象的生存周期长短不一，而使用不同的算法，已达到最好的效果。在V8中，按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同的内存施以更高效的算法。\n\n### 新生代中的垃圾回收\n\n在新生代中，主要通过**Scavenge**算法进行垃圾回收。\n\n#### Scavenge\n\n在Scavenge算法中，它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另外一个处于闲置状态。处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。当我们分配对象时，先是从From空间中分配。当开始进行垃圾回收时，会检查From空间中存活的对象，这些存活的对象会被复制到To空间中，而非存活的对象占用的空间会被释放。完成复制后，From空间和To空间角色互换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。\n\n![V8的堆内存示意图](/image/blog/memory-in-nodejs/V8的堆内存示意图.png)\n\n##### 在新生代中的对象怎样才能到老生代中？\n\n在新生代存活周期长的对象会被移动到老生代中，主要符合两个条件中的一个：\n\n**1. 对象是否经历过Scavenge回收。**\n对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果已经经历过了，则将该对象从From空间中复制到老生代空间中。\n\n**2. To空间的内存占比超过25%限制。**\n当对象从From空间复制到To空间时，如果To空间已经使用超过25%，则这个对象直接复制到老生代中。这么做的原因在于这次Scavenge回收完成后，这个To空间会变成From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。\n\n### 老生代中的垃圾回收\n\n对于老生代的对象，由于存活对象占比较大比重，使用Scavenge算法显然不科学。一来复制的对象太多会导致效率问题，二来需要浪费多一倍的空间。所以，V8在老生代中主要采用「Mark-Sweep」算法与「Mark-Compact」算法相结合的方式进行垃圾回收。\n\n#### Mark-Sweep\n\nMark-Sweep是标记清除的意思，分为标记和清除两个阶段。在标记阶段遍历堆中的所有对象，并标记存活的对象，在随后的清除阶段中，只清除标记之外的对象。\n\n![Mark-Sweep在老生代空间中标记后的示意图](/image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png)\n\n但是Mark-Sweep有一个很严重的问题，就是进行一次标记清除回收之后，内存会变得碎片化。如果需要分配一个大对象，这时候就无法完成分配了。这时候就该Mark-Compact出场了。\n\n#### Mark-Compact\n\nMark-Compact是标记整理的意思，是在Mark-Sweep基础上演变而来。Mark-Compact在标记存活对象之后，在整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。\n\n![Mark-Compact完成标记并移动存活对象后的示意图](/image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png)\n\n#### Incremental Marking\n\n鉴于Node单线程的特性，V8每次垃圾回收的时候，都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复应用逻辑，被称为「全停顿」。在分代垃圾回收中，一次小垃圾回收只收集新生代，且存活对象也相对较少，即使全停顿也没有多大的影响。但是在老生代中，存活对象较多，垃圾回收的标记、清理、整理都需要长时间的停顿，这样会严重影响到系统的性能。\n所以「增量标记 (Incrememtal Marking)」被提出来。它从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，拆分为许多小「步进」，每做完一「步进」就让JavaScript应用逻辑执行一小会，垃圾回收与应用逻辑这样交替执行直到标记阶段完成。\n\n## 内存泄露排查的工具\n\n### [node-heapdump](https://github.com/bnoordhuis/node-heapdump)\n\n它允许对V8堆内存抓取快照，用于事后分析。\n在程序中引入\n\n```javascript\nvar heapdump = require(\"node-heapdump\");\n```\n\n之后可以通过向服务器发送SIGUSR2信号，让node-heapdump抓拍一份堆内存的快照：\n\n```\n$ kill -USR2 <pid>\n```\n\n这份抓拍的快照会默认存放在文件目录下，这是一份大JSON文件，可以通过Chrome的开发者工具打开查看。\n\n![Chrome Profile](/image/blog/memory-in-nodejs/Chrome Profile.jpg)\n\n### [node-memwatch](https://github.com/lloyd/node-memwatch)\n\n> 需要注意，node-memwatch只是支持到node v0.12.x为止，当使用更高的版本的时候，就会安装不上，这时候可以使用[node-watch-next](https://github.com/marcominetti/node-memwatch) 替代，一摸一样的API。\n\n不同于node-heapdump，它提供了两个事件监听器，用来提供内存泄露的以及垃圾回收的信息：\n\n1. **stats事件**：每次进行全堆回收时，会触发改时间，传递内存的统计信息\n2. **leak事件**：经过五次垃圾回收之后，内存仍没有被释放的对象，会触发leak事件，传递相关的信息。\n\n### [node-profiler](https://profiler.alinode.aliyun.com/)\n\nnode-profiler 是 alinode团队出品的一个与node-heapdump类似的抓取内存堆快照的工具，不同的是，node-profiler的实现不一样，使用起来更便捷。附上他们的教程：[如何使用Node Profiler](https://github.com/ali-sdk/node-profiler/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Node-Profiler)\n\n### [alinode](https://alinode.aliyun.com/)\n\nalinode官方如似说：\n\n> alinode 是阿里云出品的 Node.js 应用服务解决方案，是一套基于社区 Node 改进的运行时环境和服务平台。在社区的基础上我们内建了强大的支持功能，帮助开发者迅速洞见性能细节，快速定位疑难杂症，直探问题根源。\n\n## 以上内容参考自\n\n[A tour of V8: Garbage Collection](http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)\n[V8 之旅： 垃圾回收器](http://newhtml.net/v8-garbage-collection/)\n[《深入浅出Node.js》](https://book.douban.com/subject/25768396/)\n","source":"_posts/NodeJS中被忽略的内存.md","raw":"---\ntitle: NodeJS中被忽略的内存\ncategory: 搬砖码农\ndate: 2016-04-14 20:19:02\ntags:\n- 前端\n- Nodejs\n- 内存\n---\n\n> 如朴灵说过，Node对内存泄露十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用奔溃。\n\n虽然从很久以前就知道内存问题是不容忽视的，但是日常开发的时候并没有碰到性能上的瓶颈，直到最近做了一个百万PV级的营销项目，由于访问量，并发量都达到了一个量级。一些细小的、平时没注意到的问题被放大，这才映入眼帘，开始注意到了内存问题。殊不知Node对内存的泄露是如此的敏感。\n为此，赶紧去补习了一下V8中的内存处理机制。\n那么，V8中的内存机制是怎么样的？\n\n## V8的内存机制\n\n### 内存的限制\n\nNode中并不像其他后端语言中，对内存的使用没有多少限制。在Node中使用内存，只能使用到系统的一部分内存，64位系统下约为1.4GB，32位系统下约为0.7GB。这归咎于Node使用了本来运行在浏览器的V8引擎。\n\nV8引擎的设计之初只是运行在浏览器中，而在浏览器的一般应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。\n\n虽然服务端操作大内存也不是常见的需求，但是万一有这样的需求，还是可以解除限制的。\n在启动node程序的时候，可以传递两个参数来调整内存限制的大小。\n\n```\nnode --max-nex-space-size=1024 app.js // 单位为KB\nnode --max-old-space-size=2000 app.js // 单位为MB\n```\n\n这两条命令分别对应Node内存堆中的「新生代」和「老生代」\n\n### 不受内存限制的特例\n\n在Node中，使用Buffer可以读取超过V8内存限制的大文件。原因是Buffer对象不同于其他对象，它不经过V8的内存分配机制。这在于Node并不同于浏览器的应用场景。在浏览器中，JavaScript直接处理字符串即可满足绝大多数的业务需求，而Node则需要处理网络流和文件I/O流，操作字符串远远不能满足传输的性能需求。\n\n### 内存的分配\n\n> 一切JavaScript对象都用堆来存储\n\n当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的对空闲内存不够分配新的对象，讲继续申请堆内存，直到堆的大小超过V8的限制为止。\n\n![V8的堆示意图](/image/blog/memory-in-nodejs/V8的堆示意图.png)\n\n## V8的垃圾回收机制\n\n### 分代式垃圾回收\n\nV8的垃圾回收策略主要基于「分代式垃圾回收机制」，基于这个机制，V8把内存分为「新生代(New Space)」和 「老生代 (Old Space)」。\n新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。\n前面提及到的`--max-old-space-size`命令就是设置老生代内存空间的最大值，而`--max-new-space-size`命令则可以设置新生代内存空间的大小。\n\n![V8的分代示意图](/image/blog/memory-in-nodejs/V8的分代示意图.png)\n\n#### 为什么要分成新老两代？\n\n垃圾回收算法有很多种，但是并没有一种是胜任所有的场景，在实际的应用中，需要根据对象的生存周期长短不一，而使用不同的算法，已达到最好的效果。在V8中，按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同的内存施以更高效的算法。\n\n### 新生代中的垃圾回收\n\n在新生代中，主要通过**Scavenge**算法进行垃圾回收。\n\n#### Scavenge\n\n在Scavenge算法中，它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另外一个处于闲置状态。处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。当我们分配对象时，先是从From空间中分配。当开始进行垃圾回收时，会检查From空间中存活的对象，这些存活的对象会被复制到To空间中，而非存活的对象占用的空间会被释放。完成复制后，From空间和To空间角色互换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。\n\n![V8的堆内存示意图](/image/blog/memory-in-nodejs/V8的堆内存示意图.png)\n\n##### 在新生代中的对象怎样才能到老生代中？\n\n在新生代存活周期长的对象会被移动到老生代中，主要符合两个条件中的一个：\n\n**1. 对象是否经历过Scavenge回收。**\n对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果已经经历过了，则将该对象从From空间中复制到老生代空间中。\n\n**2. To空间的内存占比超过25%限制。**\n当对象从From空间复制到To空间时，如果To空间已经使用超过25%，则这个对象直接复制到老生代中。这么做的原因在于这次Scavenge回收完成后，这个To空间会变成From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。\n\n### 老生代中的垃圾回收\n\n对于老生代的对象，由于存活对象占比较大比重，使用Scavenge算法显然不科学。一来复制的对象太多会导致效率问题，二来需要浪费多一倍的空间。所以，V8在老生代中主要采用「Mark-Sweep」算法与「Mark-Compact」算法相结合的方式进行垃圾回收。\n\n#### Mark-Sweep\n\nMark-Sweep是标记清除的意思，分为标记和清除两个阶段。在标记阶段遍历堆中的所有对象，并标记存活的对象，在随后的清除阶段中，只清除标记之外的对象。\n\n![Mark-Sweep在老生代空间中标记后的示意图](/image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png)\n\n但是Mark-Sweep有一个很严重的问题，就是进行一次标记清除回收之后，内存会变得碎片化。如果需要分配一个大对象，这时候就无法完成分配了。这时候就该Mark-Compact出场了。\n\n#### Mark-Compact\n\nMark-Compact是标记整理的意思，是在Mark-Sweep基础上演变而来。Mark-Compact在标记存活对象之后，在整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。\n\n![Mark-Compact完成标记并移动存活对象后的示意图](/image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png)\n\n#### Incremental Marking\n\n鉴于Node单线程的特性，V8每次垃圾回收的时候，都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复应用逻辑，被称为「全停顿」。在分代垃圾回收中，一次小垃圾回收只收集新生代，且存活对象也相对较少，即使全停顿也没有多大的影响。但是在老生代中，存活对象较多，垃圾回收的标记、清理、整理都需要长时间的停顿，这样会严重影响到系统的性能。\n所以「增量标记 (Incrememtal Marking)」被提出来。它从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，拆分为许多小「步进」，每做完一「步进」就让JavaScript应用逻辑执行一小会，垃圾回收与应用逻辑这样交替执行直到标记阶段完成。\n\n## 内存泄露排查的工具\n\n### [node-heapdump](https://github.com/bnoordhuis/node-heapdump)\n\n它允许对V8堆内存抓取快照，用于事后分析。\n在程序中引入\n\n```javascript\nvar heapdump = require(\"node-heapdump\");\n```\n\n之后可以通过向服务器发送SIGUSR2信号，让node-heapdump抓拍一份堆内存的快照：\n\n```\n$ kill -USR2 <pid>\n```\n\n这份抓拍的快照会默认存放在文件目录下，这是一份大JSON文件，可以通过Chrome的开发者工具打开查看。\n\n![Chrome Profile](/image/blog/memory-in-nodejs/Chrome Profile.jpg)\n\n### [node-memwatch](https://github.com/lloyd/node-memwatch)\n\n> 需要注意，node-memwatch只是支持到node v0.12.x为止，当使用更高的版本的时候，就会安装不上，这时候可以使用[node-watch-next](https://github.com/marcominetti/node-memwatch) 替代，一摸一样的API。\n\n不同于node-heapdump，它提供了两个事件监听器，用来提供内存泄露的以及垃圾回收的信息：\n\n1. **stats事件**：每次进行全堆回收时，会触发改时间，传递内存的统计信息\n2. **leak事件**：经过五次垃圾回收之后，内存仍没有被释放的对象，会触发leak事件，传递相关的信息。\n\n### [node-profiler](https://profiler.alinode.aliyun.com/)\n\nnode-profiler 是 alinode团队出品的一个与node-heapdump类似的抓取内存堆快照的工具，不同的是，node-profiler的实现不一样，使用起来更便捷。附上他们的教程：[如何使用Node Profiler](https://github.com/ali-sdk/node-profiler/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Node-Profiler)\n\n### [alinode](https://alinode.aliyun.com/)\n\nalinode官方如似说：\n\n> alinode 是阿里云出品的 Node.js 应用服务解决方案，是一套基于社区 Node 改进的运行时环境和服务平台。在社区的基础上我们内建了强大的支持功能，帮助开发者迅速洞见性能细节，快速定位疑难杂症，直探问题根源。\n\n## 以上内容参考自\n\n[A tour of V8: Garbage Collection](http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)\n[V8 之旅： 垃圾回收器](http://newhtml.net/v8-garbage-collection/)\n[《深入浅出Node.js》](https://book.douban.com/subject/25768396/)\n","slug":"NodeJS中被忽略的内存","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8tw006ixwrlpih485fu","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>如朴灵说过，Node对内存泄露十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用奔溃。</p>\n</blockquote>\n<p>虽然从很久以前就知道内存问题是不容忽视的，但是日常开发的时候并没有碰到性能上的瓶颈，直到最近做了一个百万PV级的营销项目，由于访问量，并发量都达到了一个量级。一些细小的、平时没注意到的问题被放大，这才映入眼帘，开始注意到了内存问题。殊不知Node对内存的泄露是如此的敏感。<br>为此，赶紧去补习了一下V8中的内存处理机制。<br>那么，V8中的内存机制是怎么样的？</p>\n<h2 id=\"V8的内存机制\"><a href=\"#V8的内存机制\" class=\"headerlink\" title=\"V8的内存机制\"></a>V8的内存机制</h2><h3 id=\"内存的限制\"><a href=\"#内存的限制\" class=\"headerlink\" title=\"内存的限制\"></a>内存的限制</h3><p>Node中并不像其他后端语言中，对内存的使用没有多少限制。在Node中使用内存，只能使用到系统的一部分内存，64位系统下约为1.4GB，32位系统下约为0.7GB。这归咎于Node使用了本来运行在浏览器的V8引擎。</p>\n<p>V8引擎的设计之初只是运行在浏览器中，而在浏览器的一般应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。</p>\n<p>虽然服务端操作大内存也不是常见的需求，但是万一有这样的需求，还是可以解除限制的。<br>在启动node程序的时候，可以传递两个参数来调整内存限制的大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node --max-nex-space-size=1024 app.js // 单位为KB</span><br><span class=\"line\">node --max-old-space-size=2000 app.js // 单位为MB</span><br></pre></td></tr></table></figure>\n<p>这两条命令分别对应Node内存堆中的「新生代」和「老生代」</p>\n<h3 id=\"不受内存限制的特例\"><a href=\"#不受内存限制的特例\" class=\"headerlink\" title=\"不受内存限制的特例\"></a>不受内存限制的特例</h3><p>在Node中，使用Buffer可以读取超过V8内存限制的大文件。原因是Buffer对象不同于其他对象，它不经过V8的内存分配机制。这在于Node并不同于浏览器的应用场景。在浏览器中，JavaScript直接处理字符串即可满足绝大多数的业务需求，而Node则需要处理网络流和文件I/O流，操作字符串远远不能满足传输的性能需求。</p>\n<h3 id=\"内存的分配\"><a href=\"#内存的分配\" class=\"headerlink\" title=\"内存的分配\"></a>内存的分配</h3><blockquote>\n<p>一切JavaScript对象都用堆来存储</p>\n</blockquote>\n<p>当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的对空闲内存不够分配新的对象，讲继续申请堆内存，直到堆的大小超过V8的限制为止。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/V8的堆示意图.png\" alt=\"V8的堆示意图\"></p>\n<h2 id=\"V8的垃圾回收机制\"><a href=\"#V8的垃圾回收机制\" class=\"headerlink\" title=\"V8的垃圾回收机制\"></a>V8的垃圾回收机制</h2><h3 id=\"分代式垃圾回收\"><a href=\"#分代式垃圾回收\" class=\"headerlink\" title=\"分代式垃圾回收\"></a>分代式垃圾回收</h3><p>V8的垃圾回收策略主要基于「分代式垃圾回收机制」，基于这个机制，V8把内存分为「新生代(New Space)」和 「老生代 (Old Space)」。<br>新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。<br>前面提及到的<code>--max-old-space-size</code>命令就是设置老生代内存空间的最大值，而<code>--max-new-space-size</code>命令则可以设置新生代内存空间的大小。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/V8的分代示意图.png\" alt=\"V8的分代示意图\"></p>\n<h4 id=\"为什么要分成新老两代？\"><a href=\"#为什么要分成新老两代？\" class=\"headerlink\" title=\"为什么要分成新老两代？\"></a>为什么要分成新老两代？</h4><p>垃圾回收算法有很多种，但是并没有一种是胜任所有的场景，在实际的应用中，需要根据对象的生存周期长短不一，而使用不同的算法，已达到最好的效果。在V8中，按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同的内存施以更高效的算法。</p>\n<h3 id=\"新生代中的垃圾回收\"><a href=\"#新生代中的垃圾回收\" class=\"headerlink\" title=\"新生代中的垃圾回收\"></a>新生代中的垃圾回收</h3><p>在新生代中，主要通过<strong>Scavenge</strong>算法进行垃圾回收。</p>\n<h4 id=\"Scavenge\"><a href=\"#Scavenge\" class=\"headerlink\" title=\"Scavenge\"></a>Scavenge</h4><p>在Scavenge算法中，它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另外一个处于闲置状态。处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。当我们分配对象时，先是从From空间中分配。当开始进行垃圾回收时，会检查From空间中存活的对象，这些存活的对象会被复制到To空间中，而非存活的对象占用的空间会被释放。完成复制后，From空间和To空间角色互换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/V8的堆内存示意图.png\" alt=\"V8的堆内存示意图\"></p>\n<h5 id=\"在新生代中的对象怎样才能到老生代中？\"><a href=\"#在新生代中的对象怎样才能到老生代中？\" class=\"headerlink\" title=\"在新生代中的对象怎样才能到老生代中？\"></a>在新生代中的对象怎样才能到老生代中？</h5><p>在新生代存活周期长的对象会被移动到老生代中，主要符合两个条件中的一个：</p>\n<p><strong>1. 对象是否经历过Scavenge回收。</strong><br>对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果已经经历过了，则将该对象从From空间中复制到老生代空间中。</p>\n<p><strong>2. To空间的内存占比超过25%限制。</strong><br>当对象从From空间复制到To空间时，如果To空间已经使用超过25%，则这个对象直接复制到老生代中。这么做的原因在于这次Scavenge回收完成后，这个To空间会变成From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</p>\n<h3 id=\"老生代中的垃圾回收\"><a href=\"#老生代中的垃圾回收\" class=\"headerlink\" title=\"老生代中的垃圾回收\"></a>老生代中的垃圾回收</h3><p>对于老生代的对象，由于存活对象占比较大比重，使用Scavenge算法显然不科学。一来复制的对象太多会导致效率问题，二来需要浪费多一倍的空间。所以，V8在老生代中主要采用「Mark-Sweep」算法与「Mark-Compact」算法相结合的方式进行垃圾回收。</p>\n<h4 id=\"Mark-Sweep\"><a href=\"#Mark-Sweep\" class=\"headerlink\" title=\"Mark-Sweep\"></a>Mark-Sweep</h4><p>Mark-Sweep是标记清除的意思，分为标记和清除两个阶段。在标记阶段遍历堆中的所有对象，并标记存活的对象，在随后的清除阶段中，只清除标记之外的对象。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png\" alt=\"Mark-Sweep在老生代空间中标记后的示意图\"></p>\n<p>但是Mark-Sweep有一个很严重的问题，就是进行一次标记清除回收之后，内存会变得碎片化。如果需要分配一个大对象，这时候就无法完成分配了。这时候就该Mark-Compact出场了。</p>\n<h4 id=\"Mark-Compact\"><a href=\"#Mark-Compact\" class=\"headerlink\" title=\"Mark-Compact\"></a>Mark-Compact</h4><p>Mark-Compact是标记整理的意思，是在Mark-Sweep基础上演变而来。Mark-Compact在标记存活对象之后，在整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png\" alt=\"Mark-Compact完成标记并移动存活对象后的示意图\"></p>\n<h4 id=\"Incremental-Marking\"><a href=\"#Incremental-Marking\" class=\"headerlink\" title=\"Incremental Marking\"></a>Incremental Marking</h4><p>鉴于Node单线程的特性，V8每次垃圾回收的时候，都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复应用逻辑，被称为「全停顿」。在分代垃圾回收中，一次小垃圾回收只收集新生代，且存活对象也相对较少，即使全停顿也没有多大的影响。但是在老生代中，存活对象较多，垃圾回收的标记、清理、整理都需要长时间的停顿，这样会严重影响到系统的性能。<br>所以「增量标记 (Incrememtal Marking)」被提出来。它从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，拆分为许多小「步进」，每做完一「步进」就让JavaScript应用逻辑执行一小会，垃圾回收与应用逻辑这样交替执行直到标记阶段完成。</p>\n<h2 id=\"内存泄露排查的工具\"><a href=\"#内存泄露排查的工具\" class=\"headerlink\" title=\"内存泄露排查的工具\"></a>内存泄露排查的工具</h2><h3 id=\"node-heapdump\"><a href=\"#node-heapdump\" class=\"headerlink\" title=\"node-heapdump\"></a><a href=\"https://github.com/bnoordhuis/node-heapdump\" target=\"_blank\" rel=\"external\">node-heapdump</a></h3><p>它允许对V8堆内存抓取快照，用于事后分析。<br>在程序中引入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> heapdump = <span class=\"built_in\">require</span>(<span class=\"string\">\"node-heapdump\"</span>);</span><br></pre></td></tr></table></figure>\n<p>之后可以通过向服务器发送SIGUSR2信号，让node-heapdump抓拍一份堆内存的快照：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kill -USR2 &lt;pid&gt;</span><br></pre></td></tr></table></figure>\n<p>这份抓拍的快照会默认存放在文件目录下，这是一份大JSON文件，可以通过Chrome的开发者工具打开查看。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/Chrome Profile.jpg\" alt=\"Chrome Profile\"></p>\n<h3 id=\"node-memwatch\"><a href=\"#node-memwatch\" class=\"headerlink\" title=\"node-memwatch\"></a><a href=\"https://github.com/lloyd/node-memwatch\" target=\"_blank\" rel=\"external\">node-memwatch</a></h3><blockquote>\n<p>需要注意，node-memwatch只是支持到node v0.12.x为止，当使用更高的版本的时候，就会安装不上，这时候可以使用<a href=\"https://github.com/marcominetti/node-memwatch\" target=\"_blank\" rel=\"external\">node-watch-next</a> 替代，一摸一样的API。</p>\n</blockquote>\n<p>不同于node-heapdump，它提供了两个事件监听器，用来提供内存泄露的以及垃圾回收的信息：</p>\n<ol>\n<li><strong>stats事件</strong>：每次进行全堆回收时，会触发改时间，传递内存的统计信息</li>\n<li><strong>leak事件</strong>：经过五次垃圾回收之后，内存仍没有被释放的对象，会触发leak事件，传递相关的信息。</li>\n</ol>\n<h3 id=\"node-profiler\"><a href=\"#node-profiler\" class=\"headerlink\" title=\"node-profiler\"></a><a href=\"https://profiler.alinode.aliyun.com/\" target=\"_blank\" rel=\"external\">node-profiler</a></h3><p>node-profiler 是 alinode团队出品的一个与node-heapdump类似的抓取内存堆快照的工具，不同的是，node-profiler的实现不一样，使用起来更便捷。附上他们的教程：<a href=\"https://github.com/ali-sdk/node-profiler/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Node-Profiler\" target=\"_blank\" rel=\"external\">如何使用Node Profiler</a></p>\n<h3 id=\"alinode\"><a href=\"#alinode\" class=\"headerlink\" title=\"alinode\"></a><a href=\"https://alinode.aliyun.com/\" target=\"_blank\" rel=\"external\">alinode</a></h3><p>alinode官方如似说：</p>\n<blockquote>\n<p>alinode 是阿里云出品的 Node.js 应用服务解决方案，是一套基于社区 Node 改进的运行时环境和服务平台。在社区的基础上我们内建了强大的支持功能，帮助开发者迅速洞见性能细节，快速定位疑难杂症，直探问题根源。</p>\n</blockquote>\n<h2 id=\"以上内容参考自\"><a href=\"#以上内容参考自\" class=\"headerlink\" title=\"以上内容参考自\"></a>以上内容参考自</h2><p><a href=\"http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection\" target=\"_blank\" rel=\"external\">A tour of V8: Garbage Collection</a><br><a href=\"http://newhtml.net/v8-garbage-collection/\" target=\"_blank\" rel=\"external\">V8 之旅： 垃圾回收器</a><br><a href=\"https://book.douban.com/subject/25768396/\" target=\"_blank\" rel=\"external\">《深入浅出Node.js》</a></p>\n","excerpt":"","more":"<blockquote>\n<p>如朴灵说过，Node对内存泄露十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用奔溃。</p>\n</blockquote>\n<p>虽然从很久以前就知道内存问题是不容忽视的，但是日常开发的时候并没有碰到性能上的瓶颈，直到最近做了一个百万PV级的营销项目，由于访问量，并发量都达到了一个量级。一些细小的、平时没注意到的问题被放大，这才映入眼帘，开始注意到了内存问题。殊不知Node对内存的泄露是如此的敏感。<br>为此，赶紧去补习了一下V8中的内存处理机制。<br>那么，V8中的内存机制是怎么样的？</p>\n<h2 id=\"V8的内存机制\"><a href=\"#V8的内存机制\" class=\"headerlink\" title=\"V8的内存机制\"></a>V8的内存机制</h2><h3 id=\"内存的限制\"><a href=\"#内存的限制\" class=\"headerlink\" title=\"内存的限制\"></a>内存的限制</h3><p>Node中并不像其他后端语言中，对内存的使用没有多少限制。在Node中使用内存，只能使用到系统的一部分内存，64位系统下约为1.4GB，32位系统下约为0.7GB。这归咎于Node使用了本来运行在浏览器的V8引擎。</p>\n<p>V8引擎的设计之初只是运行在浏览器中，而在浏览器的一般应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。</p>\n<p>虽然服务端操作大内存也不是常见的需求，但是万一有这样的需求，还是可以解除限制的。<br>在启动node程序的时候，可以传递两个参数来调整内存限制的大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node --max-nex-space-size=1024 app.js // 单位为KB</span><br><span class=\"line\">node --max-old-space-size=2000 app.js // 单位为MB</span><br></pre></td></tr></table></figure>\n<p>这两条命令分别对应Node内存堆中的「新生代」和「老生代」</p>\n<h3 id=\"不受内存限制的特例\"><a href=\"#不受内存限制的特例\" class=\"headerlink\" title=\"不受内存限制的特例\"></a>不受内存限制的特例</h3><p>在Node中，使用Buffer可以读取超过V8内存限制的大文件。原因是Buffer对象不同于其他对象，它不经过V8的内存分配机制。这在于Node并不同于浏览器的应用场景。在浏览器中，JavaScript直接处理字符串即可满足绝大多数的业务需求，而Node则需要处理网络流和文件I/O流，操作字符串远远不能满足传输的性能需求。</p>\n<h3 id=\"内存的分配\"><a href=\"#内存的分配\" class=\"headerlink\" title=\"内存的分配\"></a>内存的分配</h3><blockquote>\n<p>一切JavaScript对象都用堆来存储</p>\n</blockquote>\n<p>当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的对空闲内存不够分配新的对象，讲继续申请堆内存，直到堆的大小超过V8的限制为止。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/V8的堆示意图.png\" alt=\"V8的堆示意图\"></p>\n<h2 id=\"V8的垃圾回收机制\"><a href=\"#V8的垃圾回收机制\" class=\"headerlink\" title=\"V8的垃圾回收机制\"></a>V8的垃圾回收机制</h2><h3 id=\"分代式垃圾回收\"><a href=\"#分代式垃圾回收\" class=\"headerlink\" title=\"分代式垃圾回收\"></a>分代式垃圾回收</h3><p>V8的垃圾回收策略主要基于「分代式垃圾回收机制」，基于这个机制，V8把内存分为「新生代(New Space)」和 「老生代 (Old Space)」。<br>新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。<br>前面提及到的<code>--max-old-space-size</code>命令就是设置老生代内存空间的最大值，而<code>--max-new-space-size</code>命令则可以设置新生代内存空间的大小。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/V8的分代示意图.png\" alt=\"V8的分代示意图\"></p>\n<h4 id=\"为什么要分成新老两代？\"><a href=\"#为什么要分成新老两代？\" class=\"headerlink\" title=\"为什么要分成新老两代？\"></a>为什么要分成新老两代？</h4><p>垃圾回收算法有很多种，但是并没有一种是胜任所有的场景，在实际的应用中，需要根据对象的生存周期长短不一，而使用不同的算法，已达到最好的效果。在V8中，按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同的内存施以更高效的算法。</p>\n<h3 id=\"新生代中的垃圾回收\"><a href=\"#新生代中的垃圾回收\" class=\"headerlink\" title=\"新生代中的垃圾回收\"></a>新生代中的垃圾回收</h3><p>在新生代中，主要通过<strong>Scavenge</strong>算法进行垃圾回收。</p>\n<h4 id=\"Scavenge\"><a href=\"#Scavenge\" class=\"headerlink\" title=\"Scavenge\"></a>Scavenge</h4><p>在Scavenge算法中，它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另外一个处于闲置状态。处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。当我们分配对象时，先是从From空间中分配。当开始进行垃圾回收时，会检查From空间中存活的对象，这些存活的对象会被复制到To空间中，而非存活的对象占用的空间会被释放。完成复制后，From空间和To空间角色互换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/V8的堆内存示意图.png\" alt=\"V8的堆内存示意图\"></p>\n<h5 id=\"在新生代中的对象怎样才能到老生代中？\"><a href=\"#在新生代中的对象怎样才能到老生代中？\" class=\"headerlink\" title=\"在新生代中的对象怎样才能到老生代中？\"></a>在新生代中的对象怎样才能到老生代中？</h5><p>在新生代存活周期长的对象会被移动到老生代中，主要符合两个条件中的一个：</p>\n<p><strong>1. 对象是否经历过Scavenge回收。</strong><br>对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果已经经历过了，则将该对象从From空间中复制到老生代空间中。</p>\n<p><strong>2. To空间的内存占比超过25%限制。</strong><br>当对象从From空间复制到To空间时，如果To空间已经使用超过25%，则这个对象直接复制到老生代中。这么做的原因在于这次Scavenge回收完成后，这个To空间会变成From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</p>\n<h3 id=\"老生代中的垃圾回收\"><a href=\"#老生代中的垃圾回收\" class=\"headerlink\" title=\"老生代中的垃圾回收\"></a>老生代中的垃圾回收</h3><p>对于老生代的对象，由于存活对象占比较大比重，使用Scavenge算法显然不科学。一来复制的对象太多会导致效率问题，二来需要浪费多一倍的空间。所以，V8在老生代中主要采用「Mark-Sweep」算法与「Mark-Compact」算法相结合的方式进行垃圾回收。</p>\n<h4 id=\"Mark-Sweep\"><a href=\"#Mark-Sweep\" class=\"headerlink\" title=\"Mark-Sweep\"></a>Mark-Sweep</h4><p>Mark-Sweep是标记清除的意思，分为标记和清除两个阶段。在标记阶段遍历堆中的所有对象，并标记存活的对象，在随后的清除阶段中，只清除标记之外的对象。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png\" alt=\"Mark-Sweep在老生代空间中标记后的示意图\"></p>\n<p>但是Mark-Sweep有一个很严重的问题，就是进行一次标记清除回收之后，内存会变得碎片化。如果需要分配一个大对象，这时候就无法完成分配了。这时候就该Mark-Compact出场了。</p>\n<h4 id=\"Mark-Compact\"><a href=\"#Mark-Compact\" class=\"headerlink\" title=\"Mark-Compact\"></a>Mark-Compact</h4><p>Mark-Compact是标记整理的意思，是在Mark-Sweep基础上演变而来。Mark-Compact在标记存活对象之后，在整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png\" alt=\"Mark-Compact完成标记并移动存活对象后的示意图\"></p>\n<h4 id=\"Incremental-Marking\"><a href=\"#Incremental-Marking\" class=\"headerlink\" title=\"Incremental Marking\"></a>Incremental Marking</h4><p>鉴于Node单线程的特性，V8每次垃圾回收的时候，都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复应用逻辑，被称为「全停顿」。在分代垃圾回收中，一次小垃圾回收只收集新生代，且存活对象也相对较少，即使全停顿也没有多大的影响。但是在老生代中，存活对象较多，垃圾回收的标记、清理、整理都需要长时间的停顿，这样会严重影响到系统的性能。<br>所以「增量标记 (Incrememtal Marking)」被提出来。它从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，拆分为许多小「步进」，每做完一「步进」就让JavaScript应用逻辑执行一小会，垃圾回收与应用逻辑这样交替执行直到标记阶段完成。</p>\n<h2 id=\"内存泄露排查的工具\"><a href=\"#内存泄露排查的工具\" class=\"headerlink\" title=\"内存泄露排查的工具\"></a>内存泄露排查的工具</h2><h3 id=\"node-heapdump\"><a href=\"#node-heapdump\" class=\"headerlink\" title=\"node-heapdump\"></a><a href=\"https://github.com/bnoordhuis/node-heapdump\">node-heapdump</a></h3><p>它允许对V8堆内存抓取快照，用于事后分析。<br>在程序中引入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> heapdump = <span class=\"built_in\">require</span>(<span class=\"string\">\"node-heapdump\"</span>);</span><br></pre></td></tr></table></figure>\n<p>之后可以通过向服务器发送SIGUSR2信号，让node-heapdump抓拍一份堆内存的快照：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kill -USR2 &lt;pid&gt;</span><br></pre></td></tr></table></figure>\n<p>这份抓拍的快照会默认存放在文件目录下，这是一份大JSON文件，可以通过Chrome的开发者工具打开查看。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/Chrome Profile.jpg\" alt=\"Chrome Profile\"></p>\n<h3 id=\"node-memwatch\"><a href=\"#node-memwatch\" class=\"headerlink\" title=\"node-memwatch\"></a><a href=\"https://github.com/lloyd/node-memwatch\">node-memwatch</a></h3><blockquote>\n<p>需要注意，node-memwatch只是支持到node v0.12.x为止，当使用更高的版本的时候，就会安装不上，这时候可以使用<a href=\"https://github.com/marcominetti/node-memwatch\">node-watch-next</a> 替代，一摸一样的API。</p>\n</blockquote>\n<p>不同于node-heapdump，它提供了两个事件监听器，用来提供内存泄露的以及垃圾回收的信息：</p>\n<ol>\n<li><strong>stats事件</strong>：每次进行全堆回收时，会触发改时间，传递内存的统计信息</li>\n<li><strong>leak事件</strong>：经过五次垃圾回收之后，内存仍没有被释放的对象，会触发leak事件，传递相关的信息。</li>\n</ol>\n<h3 id=\"node-profiler\"><a href=\"#node-profiler\" class=\"headerlink\" title=\"node-profiler\"></a><a href=\"https://profiler.alinode.aliyun.com/\">node-profiler</a></h3><p>node-profiler 是 alinode团队出品的一个与node-heapdump类似的抓取内存堆快照的工具，不同的是，node-profiler的实现不一样，使用起来更便捷。附上他们的教程：<a href=\"https://github.com/ali-sdk/node-profiler/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Node-Profiler\">如何使用Node Profiler</a></p>\n<h3 id=\"alinode\"><a href=\"#alinode\" class=\"headerlink\" title=\"alinode\"></a><a href=\"https://alinode.aliyun.com/\">alinode</a></h3><p>alinode官方如似说：</p>\n<blockquote>\n<p>alinode 是阿里云出品的 Node.js 应用服务解决方案，是一套基于社区 Node 改进的运行时环境和服务平台。在社区的基础上我们内建了强大的支持功能，帮助开发者迅速洞见性能细节，快速定位疑难杂症，直探问题根源。</p>\n</blockquote>\n<h2 id=\"以上内容参考自\"><a href=\"#以上内容参考自\" class=\"headerlink\" title=\"以上内容参考自\"></a>以上内容参考自</h2><p><a href=\"http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection\">A tour of V8: Garbage Collection</a><br><a href=\"http://newhtml.net/v8-garbage-collection/\">V8 之旅： 垃圾回收器</a><br><a href=\"https://book.douban.com/subject/25768396/\">《深入浅出Node.js》</a></p>\n"},{"title":"My Nodejs Tool Kit","date":"2015-01-29T11:06:30.000Z","_content":"\n\n## [Cheerio](https://github.com/cheeriojs/cheerio)\n> Fast, flexible, and lean implementation of core jQuery designed specifically for the server.\n\nCheerio，说它是服务器端的jQuery一点也不为过，在github上也是大受欢迎，star数达4500有余，至目前为止，已经有923次commit。它兼容jQuery绝大部分的库，以至于你只需要一句`$ = require('cheerio').load(YOUR_HTML_CONTENT);`，便可以像在前端用jQuery一样的舒畅，愉快。\nBy the way，和Cheerio类似的框架还有：[jsdom](https://github.com/tmpvar/jsdom)，一个受欢迎程度略低于Cheerio，但是它有2,147多的commit，可见维护者之诚意。\n\n## [Waterline](https://github.com/balderdashy/waterline)\n>An adapter-based ORM for Node.js with support for mysql, mongo, postgres, redis, and more\n\nWaterline是从Sails框架衍生出来的Nodejs平台下的ORM，除了支持常见的mysql、mongodb，还支持PostgreSQL、Redis、Memory、Disk等等 \n\n## [Bookshelf](https://github.com/tgriesser/bookshelf)\n>A Node.js ORM for PostgreSQL, MySQL and SQLite3 in the style of Backbone.js\n\n与Waterline类似，但作为同类产品且被Ghost选择标配之一的Bookshelf必然有它的特别之处，仍待君细细品来。\n\n## [Node-Soap](https://github.com/vpulim/node-soap)\n> A SOAP client and server for node.js.\n\n对于REST，大家必然熟悉，就算不熟悉，也是久仰其大名，或者是略有耳闻。REST简单而直观，把HTTP协议利用到了极限，在这种思想指导下，它甚至用HTTP请求的头信息来指明资源的表示形式，用HTTP的错误机制来返回访问资源的错误。但在R.T. Fielding博士在他的论文里提出REST之前，又是谁来承担Web Service这份差使呢？\nSOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。它基于 XML 格式，在绝大多数情况下，使用HTTP协议传输WSDL请求。\n而node-soap模块，则允许在node环境中，接入其他程序语言 (诸如 ASP.net、Java 等) 开发的WebService。也能够在node中开发基于SOAP的WebService供其他程序调用。\n当然，在大多数情况下，过去SOAP能做的事，REST也是能做到的，且REST更加优雅，简单。以我的水平，我也是想不清楚SOAP依然存在的必然性，但是有那么一句话：「存在，就是合理的」。既然，它存在，也有人用到，那么在合作开发中和SOAP相遇也是有可能性的，相信那是我们的缘分。\n如果你有兴趣，听一下我和SOAP邂逅的故事：[SOAP，Web service的枢纽](http://www.jianshu.com/p/5443f90e36de)\n\n## [Passport](https://github.com/jaredhanson/passport)\n> Simple, unobtrusive authentication for Node.js.\n\n如果你的站点想快速建立passport-user结构的用户系统，且能够简单的接入流行的第三方登录，用passport就没错了。它不但提供了本站登录的解决方案，还有一大堆第三方登录的策略，见:[Strategies](https://github.com/jaredhanson/passport/wiki/Strategies#providers)\n如果你用Sails的话，这里还有一个承接Sails和passport的模块：[sails-generate-auth](https://github.com/kasperisager/sails-generate-auth)\n\n## [Bluebird](https://github.com/petkaantonov/bluebird)\n> Bluebird is a full featured promise library with unmatched performance.\n\nJavascript 的世界有一种痛叫「callback hell」，中文翻译过来叫「回调地狱」，如果能承受得了她带来的痛楚，且继续爱着她，这是「真爱」。Promise的概念，能够让你与javascript好好爱的深沉。\n实现Promise的库有很多，我知道的有：\n* Q\n* when\n* bluebird\n* jQuery的deferred\n* javascript自带的Promise（一些高级浏览器内置的Promise对象）\n\n其中，我用的比较顺手的当属bluebird，它也是时下最优秀博客系统Ghost的标配之一。\n如果你想深入了解Promise的概念，可以点这里：[Promises: The Sync Problem](http://blog.getify.com/promises-part-1/)\n如果你想珍惜时间，珍惜生命，这里有中文版：[深入理解Promise五部曲](http://segmentfault.com/blog/kk_470661)\n\n## [Lodash](https://github.com/lodash/lodash)\n> A JavaScript utility library delivering consistency, modularity, performance, & extras.\n\n我想称它为Javascript的瑞士军刀，或者是一个蓝色工具箱。lodash提供了一系列相当不错的跟函数式编程相关的方法。函数式编程就像搭积木一样，像_.identity、_.partial、_.compose、splat、unsplat等都是职责单一的函数。别看它们简单，把它们当作积木看待，它们释放的是无尽的活力。 越是简单的东西，蕴藏的越是更为无限的可能性。\n\n## [Node.bcrypt.js](https://github.com/ncb000gt/node.bcrypt.js)\n> bcrypt for NodeJs\n\nbcrypt，是一个跨平台的文件加密工具。由它加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。然而，所提供的所有字符都具有十分重要的意义。密码越强大，您的数据就越安全。而node.bcrypt.js则是披上Nodejs斗篷的bcrypt，它的62.2%是C++代码，而Javascript代码只有30.3%。\n\n## [Moment](https://github.com/moment/moment)\n> Parse, validate, manipulate, and display dates in javascript.\n\nMoment是一个轻量级用于处理日期的工具，除了对日期进行格式化以外，你还能够对日期进行操作，验证，解析。其在github的star数有1.9W+，比众所周知的Express(github star是1.7w+)还多一点。这么优秀的框架实在是相见恨晚。\n\n## [Skipper](https://github.com/balderdashy/skipper)\n> Streaming multi-uploads for Sails/Express - supports disk, S3, gridfs, and custom file adapters\n\nSkipper是一款Sails衍生的处理多文件上传的组件，支持上传文件到本地或者远端服务器，如果默认adapter没有你需要的服务，你还能够自定义一套adapter满足你的需求。就像我为了把文件上传到又拍云而定制了的adapter： [skipper-upyun](https://github.com/JerryC8080/skipper-upyun)\n\n## [Node-fs-extra](https://github.com/jprichardson/node-fs-extra)\n> Node.js: extra methods for the fs object.\n\nNode-fs-extra提供了一些额外的fs没有的函数，如果Nodejs自带的fs模块，还不能满足你在进行文件操作的使用，或者用着不顺心。不妨来node-fs-extra找一下有没有你想要的解决方案。\n\n## [Mocha](https://github.com/mochajs/mocha)\n> mocha - simple, flexible, fun javascript test framework for node.js & the browser. (BDD, TDD, QUnit styles via interfaces)\n\nNodejs单元测试哪家强？   \nmocha，mocha，似魔鬼的步伐~~yo!\n\n## [Should](https://github.com/tj/should.js)\n> BDD style assertions for node.js -- test framework agnostic\n\nBDD风格的断言模块，旨在让编程像说白话（至少在测试断言上）。\n\n## [Supertest](https://github.com/tj/supertest)\n> Super-agent driven library for testing node.js HTTP servers using a fluent API\n\n如果测试的时候，需要HTTP请求呢？找Supertest吧，和Should同一个作者，TJ大神，你值得信赖。\n\n## [PM2](https://github.com/Unitech/PM2)\n> Production process manager for Node.JS applications. Perfectly designed for microservice architecture.\n\nNodejs单线程的特性，意味着，如果你的某一行代码阻塞了，你的整个程序都会崩溃。人非圣贤，孰能无过，没有人能保证自己的写的代码永无BUG（难道要在文件头加上无BUG神兽？）。在生产环境下，如果程序挂了怎么办？让它自动重启呗。\nPM2就是一款解决这种问题的工具，当然，作为一个进程管理器，它的作用不仅仅如此。\n\n## [Markdown-js](https://github.com/evilstreak/markdown-js)\n>A Markdown parser for javascript\n\nMarkdown时下越来越受欢迎了，实质上markdown最终是转换成HTML格式才能显示于网页的。而markdown-js则是把markdown格式的文本转化成HTML格式的工具。但是，如果从HTML格式的文本转化成Markdown格式的文本呢？markdown-js好像不支持，那就用[to-markdown](https://github.com/domchristie/to-markdown)吧。\n\n## 后话\n本文的描述及用语，仅基于本人目前的水平而写，难免有所局限和措辞不当之处。如果有BUG或者不当之处，欢迎指出与吐槽。\n\n\n","source":"_posts/My-Nodejs-Tool-Kit.md","raw":"---\ntitle: My Nodejs Tool Kit\ndate: 2015-01-29 19:06:30\ntags: \n- Nodejs\n- Javascript\n- Tool Kit\ncategory: 搬砖码农\n---\n\n\n## [Cheerio](https://github.com/cheeriojs/cheerio)\n> Fast, flexible, and lean implementation of core jQuery designed specifically for the server.\n\nCheerio，说它是服务器端的jQuery一点也不为过，在github上也是大受欢迎，star数达4500有余，至目前为止，已经有923次commit。它兼容jQuery绝大部分的库，以至于你只需要一句`$ = require('cheerio').load(YOUR_HTML_CONTENT);`，便可以像在前端用jQuery一样的舒畅，愉快。\nBy the way，和Cheerio类似的框架还有：[jsdom](https://github.com/tmpvar/jsdom)，一个受欢迎程度略低于Cheerio，但是它有2,147多的commit，可见维护者之诚意。\n\n## [Waterline](https://github.com/balderdashy/waterline)\n>An adapter-based ORM for Node.js with support for mysql, mongo, postgres, redis, and more\n\nWaterline是从Sails框架衍生出来的Nodejs平台下的ORM，除了支持常见的mysql、mongodb，还支持PostgreSQL、Redis、Memory、Disk等等 \n\n## [Bookshelf](https://github.com/tgriesser/bookshelf)\n>A Node.js ORM for PostgreSQL, MySQL and SQLite3 in the style of Backbone.js\n\n与Waterline类似，但作为同类产品且被Ghost选择标配之一的Bookshelf必然有它的特别之处，仍待君细细品来。\n\n## [Node-Soap](https://github.com/vpulim/node-soap)\n> A SOAP client and server for node.js.\n\n对于REST，大家必然熟悉，就算不熟悉，也是久仰其大名，或者是略有耳闻。REST简单而直观，把HTTP协议利用到了极限，在这种思想指导下，它甚至用HTTP请求的头信息来指明资源的表示形式，用HTTP的错误机制来返回访问资源的错误。但在R.T. Fielding博士在他的论文里提出REST之前，又是谁来承担Web Service这份差使呢？\nSOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。它基于 XML 格式，在绝大多数情况下，使用HTTP协议传输WSDL请求。\n而node-soap模块，则允许在node环境中，接入其他程序语言 (诸如 ASP.net、Java 等) 开发的WebService。也能够在node中开发基于SOAP的WebService供其他程序调用。\n当然，在大多数情况下，过去SOAP能做的事，REST也是能做到的，且REST更加优雅，简单。以我的水平，我也是想不清楚SOAP依然存在的必然性，但是有那么一句话：「存在，就是合理的」。既然，它存在，也有人用到，那么在合作开发中和SOAP相遇也是有可能性的，相信那是我们的缘分。\n如果你有兴趣，听一下我和SOAP邂逅的故事：[SOAP，Web service的枢纽](http://www.jianshu.com/p/5443f90e36de)\n\n## [Passport](https://github.com/jaredhanson/passport)\n> Simple, unobtrusive authentication for Node.js.\n\n如果你的站点想快速建立passport-user结构的用户系统，且能够简单的接入流行的第三方登录，用passport就没错了。它不但提供了本站登录的解决方案，还有一大堆第三方登录的策略，见:[Strategies](https://github.com/jaredhanson/passport/wiki/Strategies#providers)\n如果你用Sails的话，这里还有一个承接Sails和passport的模块：[sails-generate-auth](https://github.com/kasperisager/sails-generate-auth)\n\n## [Bluebird](https://github.com/petkaantonov/bluebird)\n> Bluebird is a full featured promise library with unmatched performance.\n\nJavascript 的世界有一种痛叫「callback hell」，中文翻译过来叫「回调地狱」，如果能承受得了她带来的痛楚，且继续爱着她，这是「真爱」。Promise的概念，能够让你与javascript好好爱的深沉。\n实现Promise的库有很多，我知道的有：\n* Q\n* when\n* bluebird\n* jQuery的deferred\n* javascript自带的Promise（一些高级浏览器内置的Promise对象）\n\n其中，我用的比较顺手的当属bluebird，它也是时下最优秀博客系统Ghost的标配之一。\n如果你想深入了解Promise的概念，可以点这里：[Promises: The Sync Problem](http://blog.getify.com/promises-part-1/)\n如果你想珍惜时间，珍惜生命，这里有中文版：[深入理解Promise五部曲](http://segmentfault.com/blog/kk_470661)\n\n## [Lodash](https://github.com/lodash/lodash)\n> A JavaScript utility library delivering consistency, modularity, performance, & extras.\n\n我想称它为Javascript的瑞士军刀，或者是一个蓝色工具箱。lodash提供了一系列相当不错的跟函数式编程相关的方法。函数式编程就像搭积木一样，像_.identity、_.partial、_.compose、splat、unsplat等都是职责单一的函数。别看它们简单，把它们当作积木看待，它们释放的是无尽的活力。 越是简单的东西，蕴藏的越是更为无限的可能性。\n\n## [Node.bcrypt.js](https://github.com/ncb000gt/node.bcrypt.js)\n> bcrypt for NodeJs\n\nbcrypt，是一个跨平台的文件加密工具。由它加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。然而，所提供的所有字符都具有十分重要的意义。密码越强大，您的数据就越安全。而node.bcrypt.js则是披上Nodejs斗篷的bcrypt，它的62.2%是C++代码，而Javascript代码只有30.3%。\n\n## [Moment](https://github.com/moment/moment)\n> Parse, validate, manipulate, and display dates in javascript.\n\nMoment是一个轻量级用于处理日期的工具，除了对日期进行格式化以外，你还能够对日期进行操作，验证，解析。其在github的star数有1.9W+，比众所周知的Express(github star是1.7w+)还多一点。这么优秀的框架实在是相见恨晚。\n\n## [Skipper](https://github.com/balderdashy/skipper)\n> Streaming multi-uploads for Sails/Express - supports disk, S3, gridfs, and custom file adapters\n\nSkipper是一款Sails衍生的处理多文件上传的组件，支持上传文件到本地或者远端服务器，如果默认adapter没有你需要的服务，你还能够自定义一套adapter满足你的需求。就像我为了把文件上传到又拍云而定制了的adapter： [skipper-upyun](https://github.com/JerryC8080/skipper-upyun)\n\n## [Node-fs-extra](https://github.com/jprichardson/node-fs-extra)\n> Node.js: extra methods for the fs object.\n\nNode-fs-extra提供了一些额外的fs没有的函数，如果Nodejs自带的fs模块，还不能满足你在进行文件操作的使用，或者用着不顺心。不妨来node-fs-extra找一下有没有你想要的解决方案。\n\n## [Mocha](https://github.com/mochajs/mocha)\n> mocha - simple, flexible, fun javascript test framework for node.js & the browser. (BDD, TDD, QUnit styles via interfaces)\n\nNodejs单元测试哪家强？   \nmocha，mocha，似魔鬼的步伐~~yo!\n\n## [Should](https://github.com/tj/should.js)\n> BDD style assertions for node.js -- test framework agnostic\n\nBDD风格的断言模块，旨在让编程像说白话（至少在测试断言上）。\n\n## [Supertest](https://github.com/tj/supertest)\n> Super-agent driven library for testing node.js HTTP servers using a fluent API\n\n如果测试的时候，需要HTTP请求呢？找Supertest吧，和Should同一个作者，TJ大神，你值得信赖。\n\n## [PM2](https://github.com/Unitech/PM2)\n> Production process manager for Node.JS applications. Perfectly designed for microservice architecture.\n\nNodejs单线程的特性，意味着，如果你的某一行代码阻塞了，你的整个程序都会崩溃。人非圣贤，孰能无过，没有人能保证自己的写的代码永无BUG（难道要在文件头加上无BUG神兽？）。在生产环境下，如果程序挂了怎么办？让它自动重启呗。\nPM2就是一款解决这种问题的工具，当然，作为一个进程管理器，它的作用不仅仅如此。\n\n## [Markdown-js](https://github.com/evilstreak/markdown-js)\n>A Markdown parser for javascript\n\nMarkdown时下越来越受欢迎了，实质上markdown最终是转换成HTML格式才能显示于网页的。而markdown-js则是把markdown格式的文本转化成HTML格式的工具。但是，如果从HTML格式的文本转化成Markdown格式的文本呢？markdown-js好像不支持，那就用[to-markdown](https://github.com/domchristie/to-markdown)吧。\n\n## 后话\n本文的描述及用语，仅基于本人目前的水平而写，难免有所局限和措辞不当之处。如果有BUG或者不当之处，欢迎指出与吐槽。\n\n\n","slug":"My-Nodejs-Tool-Kit","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8tx006oxwrlbblj1alm","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Cheerio\"><a href=\"#Cheerio\" class=\"headerlink\" title=\"Cheerio\"></a><a href=\"https://github.com/cheeriojs/cheerio\" target=\"_blank\" rel=\"external\">Cheerio</a></h2><blockquote>\n<p>Fast, flexible, and lean implementation of core jQuery designed specifically for the server.</p>\n</blockquote>\n<p>Cheerio，说它是服务器端的jQuery一点也不为过，在github上也是大受欢迎，star数达4500有余，至目前为止，已经有923次commit。它兼容jQuery绝大部分的库，以至于你只需要一句<code>$ = require(&#39;cheerio&#39;).load(YOUR_HTML_CONTENT);</code>，便可以像在前端用jQuery一样的舒畅，愉快。<br>By the way，和Cheerio类似的框架还有：<a href=\"https://github.com/tmpvar/jsdom\" target=\"_blank\" rel=\"external\">jsdom</a>，一个受欢迎程度略低于Cheerio，但是它有2,147多的commit，可见维护者之诚意。</p>\n<h2 id=\"Waterline\"><a href=\"#Waterline\" class=\"headerlink\" title=\"Waterline\"></a><a href=\"https://github.com/balderdashy/waterline\" target=\"_blank\" rel=\"external\">Waterline</a></h2><blockquote>\n<p>An adapter-based ORM for Node.js with support for mysql, mongo, postgres, redis, and more</p>\n</blockquote>\n<p>Waterline是从Sails框架衍生出来的Nodejs平台下的ORM，除了支持常见的mysql、mongodb，还支持PostgreSQL、Redis、Memory、Disk等等 </p>\n<h2 id=\"Bookshelf\"><a href=\"#Bookshelf\" class=\"headerlink\" title=\"Bookshelf\"></a><a href=\"https://github.com/tgriesser/bookshelf\" target=\"_blank\" rel=\"external\">Bookshelf</a></h2><blockquote>\n<p>A Node.js ORM for PostgreSQL, MySQL and SQLite3 in the style of Backbone.js</p>\n</blockquote>\n<p>与Waterline类似，但作为同类产品且被Ghost选择标配之一的Bookshelf必然有它的特别之处，仍待君细细品来。</p>\n<h2 id=\"Node-Soap\"><a href=\"#Node-Soap\" class=\"headerlink\" title=\"Node-Soap\"></a><a href=\"https://github.com/vpulim/node-soap\" target=\"_blank\" rel=\"external\">Node-Soap</a></h2><blockquote>\n<p>A SOAP client and server for node.js.</p>\n</blockquote>\n<p>对于REST，大家必然熟悉，就算不熟悉，也是久仰其大名，或者是略有耳闻。REST简单而直观，把HTTP协议利用到了极限，在这种思想指导下，它甚至用HTTP请求的头信息来指明资源的表示形式，用HTTP的错误机制来返回访问资源的错误。但在R.T. Fielding博士在他的论文里提出REST之前，又是谁来承担Web Service这份差使呢？<br>SOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。它基于 XML 格式，在绝大多数情况下，使用HTTP协议传输WSDL请求。<br>而node-soap模块，则允许在node环境中，接入其他程序语言 (诸如 ASP.net、Java 等) 开发的WebService。也能够在node中开发基于SOAP的WebService供其他程序调用。<br>当然，在大多数情况下，过去SOAP能做的事，REST也是能做到的，且REST更加优雅，简单。以我的水平，我也是想不清楚SOAP依然存在的必然性，但是有那么一句话：「存在，就是合理的」。既然，它存在，也有人用到，那么在合作开发中和SOAP相遇也是有可能性的，相信那是我们的缘分。<br>如果你有兴趣，听一下我和SOAP邂逅的故事：<a href=\"http://www.jianshu.com/p/5443f90e36de\" target=\"_blank\" rel=\"external\">SOAP，Web service的枢纽</a></p>\n<h2 id=\"Passport\"><a href=\"#Passport\" class=\"headerlink\" title=\"Passport\"></a><a href=\"https://github.com/jaredhanson/passport\" target=\"_blank\" rel=\"external\">Passport</a></h2><blockquote>\n<p>Simple, unobtrusive authentication for Node.js.</p>\n</blockquote>\n<p>如果你的站点想快速建立passport-user结构的用户系统，且能够简单的接入流行的第三方登录，用passport就没错了。它不但提供了本站登录的解决方案，还有一大堆第三方登录的策略，见:<a href=\"https://github.com/jaredhanson/passport/wiki/Strategies#providers\" target=\"_blank\" rel=\"external\">Strategies</a><br>如果你用Sails的话，这里还有一个承接Sails和passport的模块：<a href=\"https://github.com/kasperisager/sails-generate-auth\" target=\"_blank\" rel=\"external\">sails-generate-auth</a></p>\n<h2 id=\"Bluebird\"><a href=\"#Bluebird\" class=\"headerlink\" title=\"Bluebird\"></a><a href=\"https://github.com/petkaantonov/bluebird\" target=\"_blank\" rel=\"external\">Bluebird</a></h2><blockquote>\n<p>Bluebird is a full featured promise library with unmatched performance.</p>\n</blockquote>\n<p>Javascript 的世界有一种痛叫「callback hell」，中文翻译过来叫「回调地狱」，如果能承受得了她带来的痛楚，且继续爱着她，这是「真爱」。Promise的概念，能够让你与javascript好好爱的深沉。<br>实现Promise的库有很多，我知道的有：</p>\n<ul>\n<li>Q</li>\n<li>when</li>\n<li>bluebird</li>\n<li>jQuery的deferred</li>\n<li>javascript自带的Promise（一些高级浏览器内置的Promise对象）</li>\n</ul>\n<p>其中，我用的比较顺手的当属bluebird，它也是时下最优秀博客系统Ghost的标配之一。<br>如果你想深入了解Promise的概念，可以点这里：<a href=\"http://blog.getify.com/promises-part-1/\" target=\"_blank\" rel=\"external\">Promises: The Sync Problem</a><br>如果你想珍惜时间，珍惜生命，这里有中文版：<a href=\"http://segmentfault.com/blog/kk_470661\" target=\"_blank\" rel=\"external\">深入理解Promise五部曲</a></p>\n<h2 id=\"Lodash\"><a href=\"#Lodash\" class=\"headerlink\" title=\"Lodash\"></a><a href=\"https://github.com/lodash/lodash\" target=\"_blank\" rel=\"external\">Lodash</a></h2><blockquote>\n<p>A JavaScript utility library delivering consistency, modularity, performance, &amp; extras.</p>\n</blockquote>\n<p>我想称它为Javascript的瑞士军刀，或者是一个蓝色工具箱。lodash提供了一系列相当不错的跟函数式编程相关的方法。函数式编程就像搭积木一样，像<em>.identity、</em>.partial、_.compose、splat、unsplat等都是职责单一的函数。别看它们简单，把它们当作积木看待，它们释放的是无尽的活力。 越是简单的东西，蕴藏的越是更为无限的可能性。</p>\n<h2 id=\"Node-bcrypt-js\"><a href=\"#Node-bcrypt-js\" class=\"headerlink\" title=\"Node.bcrypt.js\"></a><a href=\"https://github.com/ncb000gt/node.bcrypt.js\" target=\"_blank\" rel=\"external\">Node.bcrypt.js</a></h2><blockquote>\n<p>bcrypt for NodeJs</p>\n</blockquote>\n<p>bcrypt，是一个跨平台的文件加密工具。由它加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。然而，所提供的所有字符都具有十分重要的意义。密码越强大，您的数据就越安全。而node.bcrypt.js则是披上Nodejs斗篷的bcrypt，它的62.2%是C++代码，而Javascript代码只有30.3%。</p>\n<h2 id=\"Moment\"><a href=\"#Moment\" class=\"headerlink\" title=\"Moment\"></a><a href=\"https://github.com/moment/moment\" target=\"_blank\" rel=\"external\">Moment</a></h2><blockquote>\n<p>Parse, validate, manipulate, and display dates in javascript.</p>\n</blockquote>\n<p>Moment是一个轻量级用于处理日期的工具，除了对日期进行格式化以外，你还能够对日期进行操作，验证，解析。其在github的star数有1.9W+，比众所周知的Express(github star是1.7w+)还多一点。这么优秀的框架实在是相见恨晚。</p>\n<h2 id=\"Skipper\"><a href=\"#Skipper\" class=\"headerlink\" title=\"Skipper\"></a><a href=\"https://github.com/balderdashy/skipper\" target=\"_blank\" rel=\"external\">Skipper</a></h2><blockquote>\n<p>Streaming multi-uploads for Sails/Express - supports disk, S3, gridfs, and custom file adapters</p>\n</blockquote>\n<p>Skipper是一款Sails衍生的处理多文件上传的组件，支持上传文件到本地或者远端服务器，如果默认adapter没有你需要的服务，你还能够自定义一套adapter满足你的需求。就像我为了把文件上传到又拍云而定制了的adapter： <a href=\"https://github.com/JerryC8080/skipper-upyun\" target=\"_blank\" rel=\"external\">skipper-upyun</a></p>\n<h2 id=\"Node-fs-extra\"><a href=\"#Node-fs-extra\" class=\"headerlink\" title=\"Node-fs-extra\"></a><a href=\"https://github.com/jprichardson/node-fs-extra\" target=\"_blank\" rel=\"external\">Node-fs-extra</a></h2><blockquote>\n<p>Node.js: extra methods for the fs object.</p>\n</blockquote>\n<p>Node-fs-extra提供了一些额外的fs没有的函数，如果Nodejs自带的fs模块，还不能满足你在进行文件操作的使用，或者用着不顺心。不妨来node-fs-extra找一下有没有你想要的解决方案。</p>\n<h2 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a><a href=\"https://github.com/mochajs/mocha\" target=\"_blank\" rel=\"external\">Mocha</a></h2><blockquote>\n<p>mocha - simple, flexible, fun javascript test framework for node.js &amp; the browser. (BDD, TDD, QUnit styles via interfaces)</p>\n</blockquote>\n<p>Nodejs单元测试哪家强？<br>mocha，mocha，似魔鬼的步伐~~yo!</p>\n<h2 id=\"Should\"><a href=\"#Should\" class=\"headerlink\" title=\"Should\"></a><a href=\"https://github.com/tj/should.js\" target=\"_blank\" rel=\"external\">Should</a></h2><blockquote>\n<p>BDD style assertions for node.js – test framework agnostic</p>\n</blockquote>\n<p>BDD风格的断言模块，旨在让编程像说白话（至少在测试断言上）。</p>\n<h2 id=\"Supertest\"><a href=\"#Supertest\" class=\"headerlink\" title=\"Supertest\"></a><a href=\"https://github.com/tj/supertest\" target=\"_blank\" rel=\"external\">Supertest</a></h2><blockquote>\n<p>Super-agent driven library for testing node.js HTTP servers using a fluent API</p>\n</blockquote>\n<p>如果测试的时候，需要HTTP请求呢？找Supertest吧，和Should同一个作者，TJ大神，你值得信赖。</p>\n<h2 id=\"PM2\"><a href=\"#PM2\" class=\"headerlink\" title=\"PM2\"></a><a href=\"https://github.com/Unitech/PM2\" target=\"_blank\" rel=\"external\">PM2</a></h2><blockquote>\n<p>Production process manager for Node.JS applications. Perfectly designed for microservice architecture.</p>\n</blockquote>\n<p>Nodejs单线程的特性，意味着，如果你的某一行代码阻塞了，你的整个程序都会崩溃。人非圣贤，孰能无过，没有人能保证自己的写的代码永无BUG（难道要在文件头加上无BUG神兽？）。在生产环境下，如果程序挂了怎么办？让它自动重启呗。<br>PM2就是一款解决这种问题的工具，当然，作为一个进程管理器，它的作用不仅仅如此。</p>\n<h2 id=\"Markdown-js\"><a href=\"#Markdown-js\" class=\"headerlink\" title=\"Markdown-js\"></a><a href=\"https://github.com/evilstreak/markdown-js\" target=\"_blank\" rel=\"external\">Markdown-js</a></h2><blockquote>\n<p>A Markdown parser for javascript</p>\n</blockquote>\n<p>Markdown时下越来越受欢迎了，实质上markdown最终是转换成HTML格式才能显示于网页的。而markdown-js则是把markdown格式的文本转化成HTML格式的工具。但是，如果从HTML格式的文本转化成Markdown格式的文本呢？markdown-js好像不支持，那就用<a href=\"https://github.com/domchristie/to-markdown\" target=\"_blank\" rel=\"external\">to-markdown</a>吧。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>本文的描述及用语，仅基于本人目前的水平而写，难免有所局限和措辞不当之处。如果有BUG或者不当之处，欢迎指出与吐槽。</p>\n","excerpt":"","more":"<h2 id=\"Cheerio\"><a href=\"#Cheerio\" class=\"headerlink\" title=\"Cheerio\"></a><a href=\"https://github.com/cheeriojs/cheerio\">Cheerio</a></h2><blockquote>\n<p>Fast, flexible, and lean implementation of core jQuery designed specifically for the server.</p>\n</blockquote>\n<p>Cheerio，说它是服务器端的jQuery一点也不为过，在github上也是大受欢迎，star数达4500有余，至目前为止，已经有923次commit。它兼容jQuery绝大部分的库，以至于你只需要一句<code>$ = require(&#39;cheerio&#39;).load(YOUR_HTML_CONTENT);</code>，便可以像在前端用jQuery一样的舒畅，愉快。<br>By the way，和Cheerio类似的框架还有：<a href=\"https://github.com/tmpvar/jsdom\">jsdom</a>，一个受欢迎程度略低于Cheerio，但是它有2,147多的commit，可见维护者之诚意。</p>\n<h2 id=\"Waterline\"><a href=\"#Waterline\" class=\"headerlink\" title=\"Waterline\"></a><a href=\"https://github.com/balderdashy/waterline\">Waterline</a></h2><blockquote>\n<p>An adapter-based ORM for Node.js with support for mysql, mongo, postgres, redis, and more</p>\n</blockquote>\n<p>Waterline是从Sails框架衍生出来的Nodejs平台下的ORM，除了支持常见的mysql、mongodb，还支持PostgreSQL、Redis、Memory、Disk等等 </p>\n<h2 id=\"Bookshelf\"><a href=\"#Bookshelf\" class=\"headerlink\" title=\"Bookshelf\"></a><a href=\"https://github.com/tgriesser/bookshelf\">Bookshelf</a></h2><blockquote>\n<p>A Node.js ORM for PostgreSQL, MySQL and SQLite3 in the style of Backbone.js</p>\n</blockquote>\n<p>与Waterline类似，但作为同类产品且被Ghost选择标配之一的Bookshelf必然有它的特别之处，仍待君细细品来。</p>\n<h2 id=\"Node-Soap\"><a href=\"#Node-Soap\" class=\"headerlink\" title=\"Node-Soap\"></a><a href=\"https://github.com/vpulim/node-soap\">Node-Soap</a></h2><blockquote>\n<p>A SOAP client and server for node.js.</p>\n</blockquote>\n<p>对于REST，大家必然熟悉，就算不熟悉，也是久仰其大名，或者是略有耳闻。REST简单而直观，把HTTP协议利用到了极限，在这种思想指导下，它甚至用HTTP请求的头信息来指明资源的表示形式，用HTTP的错误机制来返回访问资源的错误。但在R.T. Fielding博士在他的论文里提出REST之前，又是谁来承担Web Service这份差使呢？<br>SOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。它基于 XML 格式，在绝大多数情况下，使用HTTP协议传输WSDL请求。<br>而node-soap模块，则允许在node环境中，接入其他程序语言 (诸如 ASP.net、Java 等) 开发的WebService。也能够在node中开发基于SOAP的WebService供其他程序调用。<br>当然，在大多数情况下，过去SOAP能做的事，REST也是能做到的，且REST更加优雅，简单。以我的水平，我也是想不清楚SOAP依然存在的必然性，但是有那么一句话：「存在，就是合理的」。既然，它存在，也有人用到，那么在合作开发中和SOAP相遇也是有可能性的，相信那是我们的缘分。<br>如果你有兴趣，听一下我和SOAP邂逅的故事：<a href=\"http://www.jianshu.com/p/5443f90e36de\">SOAP，Web service的枢纽</a></p>\n<h2 id=\"Passport\"><a href=\"#Passport\" class=\"headerlink\" title=\"Passport\"></a><a href=\"https://github.com/jaredhanson/passport\">Passport</a></h2><blockquote>\n<p>Simple, unobtrusive authentication for Node.js.</p>\n</blockquote>\n<p>如果你的站点想快速建立passport-user结构的用户系统，且能够简单的接入流行的第三方登录，用passport就没错了。它不但提供了本站登录的解决方案，还有一大堆第三方登录的策略，见:<a href=\"https://github.com/jaredhanson/passport/wiki/Strategies#providers\">Strategies</a><br>如果你用Sails的话，这里还有一个承接Sails和passport的模块：<a href=\"https://github.com/kasperisager/sails-generate-auth\">sails-generate-auth</a></p>\n<h2 id=\"Bluebird\"><a href=\"#Bluebird\" class=\"headerlink\" title=\"Bluebird\"></a><a href=\"https://github.com/petkaantonov/bluebird\">Bluebird</a></h2><blockquote>\n<p>Bluebird is a full featured promise library with unmatched performance.</p>\n</blockquote>\n<p>Javascript 的世界有一种痛叫「callback hell」，中文翻译过来叫「回调地狱」，如果能承受得了她带来的痛楚，且继续爱着她，这是「真爱」。Promise的概念，能够让你与javascript好好爱的深沉。<br>实现Promise的库有很多，我知道的有：</p>\n<ul>\n<li>Q</li>\n<li>when</li>\n<li>bluebird</li>\n<li>jQuery的deferred</li>\n<li>javascript自带的Promise（一些高级浏览器内置的Promise对象）</li>\n</ul>\n<p>其中，我用的比较顺手的当属bluebird，它也是时下最优秀博客系统Ghost的标配之一。<br>如果你想深入了解Promise的概念，可以点这里：<a href=\"http://blog.getify.com/promises-part-1/\">Promises: The Sync Problem</a><br>如果你想珍惜时间，珍惜生命，这里有中文版：<a href=\"http://segmentfault.com/blog/kk_470661\">深入理解Promise五部曲</a></p>\n<h2 id=\"Lodash\"><a href=\"#Lodash\" class=\"headerlink\" title=\"Lodash\"></a><a href=\"https://github.com/lodash/lodash\">Lodash</a></h2><blockquote>\n<p>A JavaScript utility library delivering consistency, modularity, performance, &amp; extras.</p>\n</blockquote>\n<p>我想称它为Javascript的瑞士军刀，或者是一个蓝色工具箱。lodash提供了一系列相当不错的跟函数式编程相关的方法。函数式编程就像搭积木一样，像<em>.identity、</em>.partial、_.compose、splat、unsplat等都是职责单一的函数。别看它们简单，把它们当作积木看待，它们释放的是无尽的活力。 越是简单的东西，蕴藏的越是更为无限的可能性。</p>\n<h2 id=\"Node-bcrypt-js\"><a href=\"#Node-bcrypt-js\" class=\"headerlink\" title=\"Node.bcrypt.js\"></a><a href=\"https://github.com/ncb000gt/node.bcrypt.js\">Node.bcrypt.js</a></h2><blockquote>\n<p>bcrypt for NodeJs</p>\n</blockquote>\n<p>bcrypt，是一个跨平台的文件加密工具。由它加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。然而，所提供的所有字符都具有十分重要的意义。密码越强大，您的数据就越安全。而node.bcrypt.js则是披上Nodejs斗篷的bcrypt，它的62.2%是C++代码，而Javascript代码只有30.3%。</p>\n<h2 id=\"Moment\"><a href=\"#Moment\" class=\"headerlink\" title=\"Moment\"></a><a href=\"https://github.com/moment/moment\">Moment</a></h2><blockquote>\n<p>Parse, validate, manipulate, and display dates in javascript.</p>\n</blockquote>\n<p>Moment是一个轻量级用于处理日期的工具，除了对日期进行格式化以外，你还能够对日期进行操作，验证，解析。其在github的star数有1.9W+，比众所周知的Express(github star是1.7w+)还多一点。这么优秀的框架实在是相见恨晚。</p>\n<h2 id=\"Skipper\"><a href=\"#Skipper\" class=\"headerlink\" title=\"Skipper\"></a><a href=\"https://github.com/balderdashy/skipper\">Skipper</a></h2><blockquote>\n<p>Streaming multi-uploads for Sails/Express - supports disk, S3, gridfs, and custom file adapters</p>\n</blockquote>\n<p>Skipper是一款Sails衍生的处理多文件上传的组件，支持上传文件到本地或者远端服务器，如果默认adapter没有你需要的服务，你还能够自定义一套adapter满足你的需求。就像我为了把文件上传到又拍云而定制了的adapter： <a href=\"https://github.com/JerryC8080/skipper-upyun\">skipper-upyun</a></p>\n<h2 id=\"Node-fs-extra\"><a href=\"#Node-fs-extra\" class=\"headerlink\" title=\"Node-fs-extra\"></a><a href=\"https://github.com/jprichardson/node-fs-extra\">Node-fs-extra</a></h2><blockquote>\n<p>Node.js: extra methods for the fs object.</p>\n</blockquote>\n<p>Node-fs-extra提供了一些额外的fs没有的函数，如果Nodejs自带的fs模块，还不能满足你在进行文件操作的使用，或者用着不顺心。不妨来node-fs-extra找一下有没有你想要的解决方案。</p>\n<h2 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a><a href=\"https://github.com/mochajs/mocha\">Mocha</a></h2><blockquote>\n<p>mocha - simple, flexible, fun javascript test framework for node.js &amp; the browser. (BDD, TDD, QUnit styles via interfaces)</p>\n</blockquote>\n<p>Nodejs单元测试哪家强？<br>mocha，mocha，似魔鬼的步伐~~yo!</p>\n<h2 id=\"Should\"><a href=\"#Should\" class=\"headerlink\" title=\"Should\"></a><a href=\"https://github.com/tj/should.js\">Should</a></h2><blockquote>\n<p>BDD style assertions for node.js – test framework agnostic</p>\n</blockquote>\n<p>BDD风格的断言模块，旨在让编程像说白话（至少在测试断言上）。</p>\n<h2 id=\"Supertest\"><a href=\"#Supertest\" class=\"headerlink\" title=\"Supertest\"></a><a href=\"https://github.com/tj/supertest\">Supertest</a></h2><blockquote>\n<p>Super-agent driven library for testing node.js HTTP servers using a fluent API</p>\n</blockquote>\n<p>如果测试的时候，需要HTTP请求呢？找Supertest吧，和Should同一个作者，TJ大神，你值得信赖。</p>\n<h2 id=\"PM2\"><a href=\"#PM2\" class=\"headerlink\" title=\"PM2\"></a><a href=\"https://github.com/Unitech/PM2\">PM2</a></h2><blockquote>\n<p>Production process manager for Node.JS applications. Perfectly designed for microservice architecture.</p>\n</blockquote>\n<p>Nodejs单线程的特性，意味着，如果你的某一行代码阻塞了，你的整个程序都会崩溃。人非圣贤，孰能无过，没有人能保证自己的写的代码永无BUG（难道要在文件头加上无BUG神兽？）。在生产环境下，如果程序挂了怎么办？让它自动重启呗。<br>PM2就是一款解决这种问题的工具，当然，作为一个进程管理器，它的作用不仅仅如此。</p>\n<h2 id=\"Markdown-js\"><a href=\"#Markdown-js\" class=\"headerlink\" title=\"Markdown-js\"></a><a href=\"https://github.com/evilstreak/markdown-js\">Markdown-js</a></h2><blockquote>\n<p>A Markdown parser for javascript</p>\n</blockquote>\n<p>Markdown时下越来越受欢迎了，实质上markdown最终是转换成HTML格式才能显示于网页的。而markdown-js则是把markdown格式的文本转化成HTML格式的工具。但是，如果从HTML格式的文本转化成Markdown格式的文本呢？markdown-js好像不支持，那就用<a href=\"https://github.com/domchristie/to-markdown\">to-markdown</a>吧。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>本文的描述及用语，仅基于本人目前的水平而写，难免有所局限和措辞不当之处。如果有BUG或者不当之处，欢迎指出与吐槽。</p>\n"},{"title":"Kissy WaterFall 静态调用","date":"2013-03-07T04:04:24.000Z","_content":"\n需要用到的JS\n\n```HTML\n<script src=\"kissy.js\"></script>\n<script src=\"base.js\"></script>\n<script src=\"loader.js\"></script>\n<script src=\"waterfall.js\"></script>\n```\n\n需要设置的CSS样式\n\n```HTML\n<style>\n    .ks-waterfall {\n        position: absolute;\n        width: 192px;\n        overflow: hidden;\n        padding: 15px;\n        border: 2px solid #ddd;\n        margin-bottom: 20px;\n        text-align: center;\n        left:-9999px;\n        top:-9999px;\n    }\n</style>\n```\n\nHTML关键代码\n\n```HTML\n<div id='container' style=\"position: relative;\">\n    <!-- 重复的数据块 -->\n    <div class=\"ks-waterfall\"><img src=\"http://farm7.static.flickr.com/6072/6128820646_75d4f4f26d_m.jpg\" width=\"192\" height=\"113\">\n        <div class=\"title\">untitled</div>\n    </div>\n</div>\n```\n\n最后调用WaterFall的内嵌脚本\n\n```javascript\nKISSY.use(\"waterfall\", function (S, Waterfall) {\n    new Waterfall({\n        container: \"#container\",    //节点容器\n        minColCount: 2,             //最小列数\n        colWidth: 235               //每列的宽度\n    });\n});\n```\n","source":"_posts/Kissy-WaterFall-静态调用.md","raw":"---\ntitle: Kissy WaterFall 静态调用\ncategory: 搬砖码农\ndate: 2013-03-07 12:04:24\ntags:\n- 前端\n---\n\n需要用到的JS\n\n```HTML\n<script src=\"kissy.js\"></script>\n<script src=\"base.js\"></script>\n<script src=\"loader.js\"></script>\n<script src=\"waterfall.js\"></script>\n```\n\n需要设置的CSS样式\n\n```HTML\n<style>\n    .ks-waterfall {\n        position: absolute;\n        width: 192px;\n        overflow: hidden;\n        padding: 15px;\n        border: 2px solid #ddd;\n        margin-bottom: 20px;\n        text-align: center;\n        left:-9999px;\n        top:-9999px;\n    }\n</style>\n```\n\nHTML关键代码\n\n```HTML\n<div id='container' style=\"position: relative;\">\n    <!-- 重复的数据块 -->\n    <div class=\"ks-waterfall\"><img src=\"http://farm7.static.flickr.com/6072/6128820646_75d4f4f26d_m.jpg\" width=\"192\" height=\"113\">\n        <div class=\"title\">untitled</div>\n    </div>\n</div>\n```\n\n最后调用WaterFall的内嵌脚本\n\n```javascript\nKISSY.use(\"waterfall\", function (S, Waterfall) {\n    new Waterfall({\n        container: \"#container\",    //节点容器\n        minColCount: 2,             //最小列数\n        colWidth: 235               //每列的宽度\n    });\n});\n```\n","slug":"Kissy-WaterFall-静态调用","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8ty006txwrltnx997n9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>需要用到的JS</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"kissy.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"base.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"loader.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"waterfall.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>需要设置的CSS样式</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .ks-waterfall &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        position: absolute;</span></span><br><span class=\"line\"><span class=\"undefined\">        width: 192px;</span></span><br><span class=\"line\"><span class=\"undefined\">        overflow: hidden;</span></span><br><span class=\"line\"><span class=\"undefined\">        padding: 15px;</span></span><br><span class=\"line\"><span class=\"undefined\">        border: 2px solid #ddd;</span></span><br><span class=\"line\"><span class=\"undefined\">        margin-bottom: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">        text-align: center;</span></span><br><span class=\"line\"><span class=\"undefined\">        left:-9999px;</span></span><br><span class=\"line\"><span class=\"undefined\">        top:-9999px;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>HTML关键代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">'container'</span> <span class=\"attr\">style</span>=<span class=\"string\">\"position: relative;\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 重复的数据块 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ks-waterfall\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://farm7.static.flickr.com/6072/6128820646_75d4f4f26d_m.jpg\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"192\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"113\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"title\"</span>&gt;</span>untitled<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>最后调用WaterFall的内嵌脚本</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KISSY.use(<span class=\"string\">\"waterfall\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">S, Waterfall</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Waterfall(&#123;</span><br><span class=\"line\">        container: <span class=\"string\">\"#container\"</span>,    <span class=\"comment\">//节点容器</span></span><br><span class=\"line\">        minColCount: <span class=\"number\">2</span>,             <span class=\"comment\">//最小列数</span></span><br><span class=\"line\">        colWidth: <span class=\"number\">235</span>               <span class=\"comment\">//每列的宽度</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>需要用到的JS</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"kissy.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"base.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"loader.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"waterfall.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>需要设置的CSS样式</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .ks-waterfall &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        position: absolute;</span></span><br><span class=\"line\"><span class=\"undefined\">        width: 192px;</span></span><br><span class=\"line\"><span class=\"undefined\">        overflow: hidden;</span></span><br><span class=\"line\"><span class=\"undefined\">        padding: 15px;</span></span><br><span class=\"line\"><span class=\"undefined\">        border: 2px solid #ddd;</span></span><br><span class=\"line\"><span class=\"undefined\">        margin-bottom: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">        text-align: center;</span></span><br><span class=\"line\"><span class=\"undefined\">        left:-9999px;</span></span><br><span class=\"line\"><span class=\"undefined\">        top:-9999px;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>HTML关键代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">'container'</span> <span class=\"attr\">style</span>=<span class=\"string\">\"position: relative;\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 重复的数据块 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ks-waterfall\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://farm7.static.flickr.com/6072/6128820646_75d4f4f26d_m.jpg\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"192\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"113\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"title\"</span>&gt;</span>untitled<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>最后调用WaterFall的内嵌脚本</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KISSY.use(<span class=\"string\">\"waterfall\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">S, Waterfall</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Waterfall(&#123;</span><br><span class=\"line\">        container: <span class=\"string\">\"#container\"</span>,    <span class=\"comment\">//节点容器</span></span><br><span class=\"line\">        minColCount: <span class=\"number\">2</span>,             <span class=\"comment\">//最小列数</span></span><br><span class=\"line\">        colWidth: <span class=\"number\">235</span>               <span class=\"comment\">//每列的宽度</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n"},{"title":"Kissy WaterFall 实现手动加载数据","date":"2013-07-21T04:41:06.000Z","_content":"\n## 前言\n由于Kissy WaterFall默认是监听滚动事件来实现数据动态加载的，但是有一些情况要用到手动加载数据。以下是使用Kissy WaterFall实现手动加载数据的方法。\n\n最终实现效果：点击”逛更多的商店“会动态加载数据\n\n\n## 步骤：\n\n1. 当一页数据加载完成后停止监听滚动事件\n\n```javascript\n//加载一页数据完成后触发的事件\nwaterfall.on('addComplete', function () {\n    S.log('after add complete!');\n\twaterfall.pause();\n});\n```\n\n2. 为按钮绑定重启监听滚动事件\n\n```javascript\n//加载更多按钮\n$(\"#button_container_more\").on('click',function(){\t\n\twaterfall.resunme();\n});\n```\n\n3. 附录\n\n> waterfall.pause()与water.resunme()的说明（从官网上转载的）\n> pause()函数和resunme()函数属于插件里的waterfall.loader对象的\n> resunme() ：继续开始监控scroll事件（随时可能会动态加载）\n> pause() ：停止监控scroll事件（停止动态加载）\n\n参考网址：http://docs.kissyui.com/docs/html/api/component/waterfall/loader.html#waterfall.Waterfall.prototype.pause\n\n\n\n\n出现问题：按照以上来完成的话，当点击”加载更多“按钮时，只是启动了滚动监听。意思就是，要加载数据，一要点击按钮，二要再次滚动鼠标。这样的用户体验很差。\n\n解决办法：修改按钮动作：new一个waterfall.loader，重新赋值waterfall对象，再重新绑定addComplete事件。\n代码如下：\n\n```javascript\n\t$(\"#button_container_more\").on('click',function(){\t\n\t\twaterfall = new Waterfall.Loader({\n\t\t\tcontainer:\"#ColumnContainer\",\n\t\t\tload:function (success, end) {\n\t\t\t\t$('#loadingPins').show();\n\t\t\t\t$('.loader').hide();\n\t\t\t\tS.ajax({\n\t\t\t\t\tdata:{\n\t\t\t\t\t\t'method':'flickr.photos.search',\n\t\t\t\t\t\t'api_key':'5d93c2e473e39e9307e86d4a01381266',\n\t\t\t\t\t\t'tags':'rose',\n\t\t\t\t\t\t'page':nextpage,\n\t\t\t\t\t\t'per_page':20,\n\t\t\t\t\t\t'format':'json'\n\t\t\t\t\t},\n\t\t\t\t\turl:'http://api.flickr.com/services/rest/',\n\t\t\t\t\tdataType:\"jsonp\",\n\t\t\t\t\tjsonp:\"jsoncallback\",\n\t\t\t\t\tsuccess:function (d) {\n\t\t\t\t\t\t// 如果数据错误, 则立即结束\n\t\t\t\t\t\tif (d.stat !== 'ok') {\n\t\t\t\t\t\t\talert('load data error!');\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 如果到最后一页了, 也结束加载\n\t\t\t\t\t\tnextpage = d.photos.page + 1;\n\t\t\t\t\t\tif (nextpage > d.photos.pages) {\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 拼装每页数据\n\t\t\t\t\t\tvar items = [];\n\t\t\t\t\t\tS.each(d.photos.photo, function (item) {\n\t\t\t\t\t\t\t/*所用到的字段：\n\t\t\t\t\t\t\t**price\n\t\t\t\t\t\t\t**height\n\t\t\t\t\t\t\t**collection\n\t\t\t\t\t\t\t**title\n\t\t\t\t\t\t\t**src\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\titem.height = Math.round(Math.random() * (300 - 180) + 180); // fake height\t\n\t\t\t\t\t\t\titem.collection = 10;\t//测试用\n\t\t\t\t\t\t\titem.price = 1800;\t\t//测试用\n\t\t\t\t\t\t\titems.push(S.substitute(tpl,item));\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsuccess(items);\n\t\t\t\t\t},\n\t\t\t\t\tcomplete:function () {\n\t\t\t\t\t\t$('#loadingPins').hide();\n\t\t\t\t\t\t$('.loader').show();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tminColCount:2,\n\t\t\tcolWidth:175\n\t\t\t//align:'left' // right, center (default)\n\t\t});\n\t\twaterfall.on('addComplete', function () {\n        \tS.log('after add complete!');\n\t\t\twaterfall.pause();\n    \t});\t\t\n\t});\n```\n\n最终整个脚本文件：\n\n```javascript\nKISSY.use(\"waterfall,ajax,node,button\", function (S, Waterfall, io,  Node, Button) {\n    var $ = Node.all;\n    var tpl = $('#tpl').html(),\n\tnextpage = 1,\n\twaterfall = new Waterfall.Loader({\n\t\tcontainer:\"#ColumnContainer\",\n\t\tload:function (success, end) {\n\t\t\t$('#loadingPins').show();\n\t\t\tS.ajax({\n\t\t\t\tdata:{\n\t\t\t\t\t'method':'flickr.photos.search',\n\t\t\t\t\t'api_key':'5d93c2e473e39e9307e86d4a01381266',\n\t\t\t\t\t'tags':'rose',\n\t\t\t\t\t'page':nextpage,\n\t\t\t\t\t'per_page':20,\n\t\t\t\t\t'format':'json'\n\t\t\t\t},\n\t\t\t\turl:'http://api.flickr.com/services/rest/',\n\t\t\t\tdataType:\"jsonp\",\n\t\t\t\tjsonp:\"jsoncallback\",\n\t\t\t\tsuccess:function (d) {\n\t\t\t\t\t// 如果数据错误, 则立即结束\n\t\t\t\t\tif (d.stat !== 'ok') {\n\t\t\t\t\t\talert('load data error!');\n\t\t\t\t\t\tend();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// 如果到最后一页了, 也结束加载\n\t\t\t\t\tnextpage = d.photos.page + 1;\n\t\t\t\t\tif (nextpage > d.photos.pages) {\n\t\t\t\t\t\tend();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// 拼装每页数据\n\t\t\t\t\tvar items = [];\n\t\t\t\t\tS.each(d.photos.photo, function (item) {\n\t\t\t\t\t\t/*所用到的字段：\n\t\t\t\t\t\t**price\n\t\t\t\t\t\t**height\n\t\t\t\t\t\t**collection\n\t\t\t\t\t\t**title\n\t\t\t\t\t\t**src\n\t\t\t\t\t\t*/\n\t\t\t\t\t\titem.height = Math.round(Math.random() * (300 - 180) + 180); // fake height\t\n\t\t\t\t\t\titem.collection = 10;\t//测试用\n\t\t\t\t\t\titem.price = 1800;\t\t//测试用\n\t\t\t\t\t\titems.push(S.substitute(tpl,item));\n\t\t\t\t\t});\n\t\t\t\t\tsuccess(items);\n\t\t\t\t},\n\t\t\t\tcomplete:function () {\n\t\t\t\t\t$('#loadingPins').hide();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tminColCount:2,\n\t\tcolWidth:175\n\t\t//align:'left' // right, center (default)\n\t});\n    waterfall.on('adjustComplete', function () {\n        S.log('after adjust complete!');\n    });\n\t//加载一页数据完成后触发的事件\n    waterfall.on('addComplete', function () {\n        S.log('after add complete!');\n\t\twaterfall.pause();\n    });\n    // scrollTo\n    $('#BackToTop').on('click', function (e) {\n        e.halt();\n        e.preventDefault();\n        $(window).stop();\n        $(window).animate({\n            scrollTop:0\n        }, 1, \"easeOut\");\n    });\n\t//加载更多按钮\n\t$(\"#button_container_more\").on('click',function(){\t\n\t\twaterfall = new Waterfall.Loader({\n\t\t\tcontainer:\"#ColumnContainer\",\n\t\t\tload:function (success, end) {\n\t\t\t\t$('#loadingPins').show();\n\t\t\t\t$('.loader').hide();\n\t\t\t\tS.ajax({\n\t\t\t\t\tdata:{\n\t\t\t\t\t\t'method':'flickr.photos.search',\n\t\t\t\t\t\t'api_key':'5d93c2e473e39e9307e86d4a01381266',\n\t\t\t\t\t\t'tags':'rose',\n\t\t\t\t\t\t'page':nextpage,\n\t\t\t\t\t\t'per_page':20,\n\t\t\t\t\t\t'format':'json'\n\t\t\t\t\t},\n\t\t\t\t\turl:'http://api.flickr.com/services/rest/',\n\t\t\t\t\tdataType:\"jsonp\",\n\t\t\t\t\tjsonp:\"jsoncallback\",\n\t\t\t\t\tsuccess:function (d) {\n\t\t\t\t\t\t// 如果数据错误, 则立即结束\n\t\t\t\t\t\tif (d.stat !== 'ok') {\n\t\t\t\t\t\t\talert('load data error!');\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 如果到最后一页了, 也结束加载\n\t\t\t\t\t\tnextpage = d.photos.page + 1;\n\t\t\t\t\t\tif (nextpage > d.photos.pages) {\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 拼装每页数据\n\t\t\t\t\t\tvar items = [];\n\t\t\t\t\t\tS.each(d.photos.photo, function (item) {\n\t\t\t\t\t\t\t/*所用到的字段：\n\t\t\t\t\t\t\t**price\n\t\t\t\t\t\t\t**height\n\t\t\t\t\t\t\t**collection\n\t\t\t\t\t\t\t**title\n\t\t\t\t\t\t\t**src\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\titem.height = Math.round(Math.random() * (300 - 180) + 180); // fake height\t\n\t\t\t\t\t\t\titem.collection = 10;\t//测试用\n\t\t\t\t\t\t\titem.price = 1800;\t\t//测试用\n\t\t\t\t\t\t\titems.push(S.substitute(tpl,item));\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsuccess(items);\n\t\t\t\t\t},\n\t\t\t\t\tcomplete:function () {\n\t\t\t\t\t\t$('#loadingPins').hide();\n\t\t\t\t\t\t$('.loader').show();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tminColCount:2,\n\t\t\tcolWidth:175\n\t\t\t//align:'left' // right, center (default)\n\t\t});\n\t\twaterfall.on('addComplete', function () {\n        \tS.log('after add complete!');\n\t\t\twaterfall.pause();\n    \t});\t\t\n\t});\n\t\n\t//收藏按钮功能\n\tvar collect;\n\t$('#ColumnContainer').delegate(\"mouseover\", \".collect\", function (event) {\n\t\tvar w = $(event.currentTarget).children(\"span\");\n\t\tvar text = w.text();\n\t\tif(text >= 0){\n\t\t\tcollect = text;\n\t\t}\n\t\t\n\t\tw.replaceWith(\"<span class='collects'>收藏</span>\");\n\t\t//w.css(\"text-indent\",\"3px\");\n\t});\n\t\n\t$('#ColumnContainer').delegate(\"mouseout\", \".collect\", function (event) {\n\t\tvar w = $(event.currentTarget).children(\"span\");\n\t\tw.replaceWith(\"<span class='collectionAmount'>\"+collect+\"</span>\");\n\t\t//w.css(\"text-indent\",\"13px\");\n\t});\n});\n```","source":"_posts/Kissy-WaterFall-实现手动加载数据.md","raw":"---\ntitle: Kissy WaterFall 实现手动加载数据\ncategory: 搬砖码农\ndate: 2013-07-21 12:41:06\ntags:\n- 前端\n---\n\n## 前言\n由于Kissy WaterFall默认是监听滚动事件来实现数据动态加载的，但是有一些情况要用到手动加载数据。以下是使用Kissy WaterFall实现手动加载数据的方法。\n\n最终实现效果：点击”逛更多的商店“会动态加载数据\n\n\n## 步骤：\n\n1. 当一页数据加载完成后停止监听滚动事件\n\n```javascript\n//加载一页数据完成后触发的事件\nwaterfall.on('addComplete', function () {\n    S.log('after add complete!');\n\twaterfall.pause();\n});\n```\n\n2. 为按钮绑定重启监听滚动事件\n\n```javascript\n//加载更多按钮\n$(\"#button_container_more\").on('click',function(){\t\n\twaterfall.resunme();\n});\n```\n\n3. 附录\n\n> waterfall.pause()与water.resunme()的说明（从官网上转载的）\n> pause()函数和resunme()函数属于插件里的waterfall.loader对象的\n> resunme() ：继续开始监控scroll事件（随时可能会动态加载）\n> pause() ：停止监控scroll事件（停止动态加载）\n\n参考网址：http://docs.kissyui.com/docs/html/api/component/waterfall/loader.html#waterfall.Waterfall.prototype.pause\n\n\n\n\n出现问题：按照以上来完成的话，当点击”加载更多“按钮时，只是启动了滚动监听。意思就是，要加载数据，一要点击按钮，二要再次滚动鼠标。这样的用户体验很差。\n\n解决办法：修改按钮动作：new一个waterfall.loader，重新赋值waterfall对象，再重新绑定addComplete事件。\n代码如下：\n\n```javascript\n\t$(\"#button_container_more\").on('click',function(){\t\n\t\twaterfall = new Waterfall.Loader({\n\t\t\tcontainer:\"#ColumnContainer\",\n\t\t\tload:function (success, end) {\n\t\t\t\t$('#loadingPins').show();\n\t\t\t\t$('.loader').hide();\n\t\t\t\tS.ajax({\n\t\t\t\t\tdata:{\n\t\t\t\t\t\t'method':'flickr.photos.search',\n\t\t\t\t\t\t'api_key':'5d93c2e473e39e9307e86d4a01381266',\n\t\t\t\t\t\t'tags':'rose',\n\t\t\t\t\t\t'page':nextpage,\n\t\t\t\t\t\t'per_page':20,\n\t\t\t\t\t\t'format':'json'\n\t\t\t\t\t},\n\t\t\t\t\turl:'http://api.flickr.com/services/rest/',\n\t\t\t\t\tdataType:\"jsonp\",\n\t\t\t\t\tjsonp:\"jsoncallback\",\n\t\t\t\t\tsuccess:function (d) {\n\t\t\t\t\t\t// 如果数据错误, 则立即结束\n\t\t\t\t\t\tif (d.stat !== 'ok') {\n\t\t\t\t\t\t\talert('load data error!');\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 如果到最后一页了, 也结束加载\n\t\t\t\t\t\tnextpage = d.photos.page + 1;\n\t\t\t\t\t\tif (nextpage > d.photos.pages) {\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 拼装每页数据\n\t\t\t\t\t\tvar items = [];\n\t\t\t\t\t\tS.each(d.photos.photo, function (item) {\n\t\t\t\t\t\t\t/*所用到的字段：\n\t\t\t\t\t\t\t**price\n\t\t\t\t\t\t\t**height\n\t\t\t\t\t\t\t**collection\n\t\t\t\t\t\t\t**title\n\t\t\t\t\t\t\t**src\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\titem.height = Math.round(Math.random() * (300 - 180) + 180); // fake height\t\n\t\t\t\t\t\t\titem.collection = 10;\t//测试用\n\t\t\t\t\t\t\titem.price = 1800;\t\t//测试用\n\t\t\t\t\t\t\titems.push(S.substitute(tpl,item));\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsuccess(items);\n\t\t\t\t\t},\n\t\t\t\t\tcomplete:function () {\n\t\t\t\t\t\t$('#loadingPins').hide();\n\t\t\t\t\t\t$('.loader').show();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tminColCount:2,\n\t\t\tcolWidth:175\n\t\t\t//align:'left' // right, center (default)\n\t\t});\n\t\twaterfall.on('addComplete', function () {\n        \tS.log('after add complete!');\n\t\t\twaterfall.pause();\n    \t});\t\t\n\t});\n```\n\n最终整个脚本文件：\n\n```javascript\nKISSY.use(\"waterfall,ajax,node,button\", function (S, Waterfall, io,  Node, Button) {\n    var $ = Node.all;\n    var tpl = $('#tpl').html(),\n\tnextpage = 1,\n\twaterfall = new Waterfall.Loader({\n\t\tcontainer:\"#ColumnContainer\",\n\t\tload:function (success, end) {\n\t\t\t$('#loadingPins').show();\n\t\t\tS.ajax({\n\t\t\t\tdata:{\n\t\t\t\t\t'method':'flickr.photos.search',\n\t\t\t\t\t'api_key':'5d93c2e473e39e9307e86d4a01381266',\n\t\t\t\t\t'tags':'rose',\n\t\t\t\t\t'page':nextpage,\n\t\t\t\t\t'per_page':20,\n\t\t\t\t\t'format':'json'\n\t\t\t\t},\n\t\t\t\turl:'http://api.flickr.com/services/rest/',\n\t\t\t\tdataType:\"jsonp\",\n\t\t\t\tjsonp:\"jsoncallback\",\n\t\t\t\tsuccess:function (d) {\n\t\t\t\t\t// 如果数据错误, 则立即结束\n\t\t\t\t\tif (d.stat !== 'ok') {\n\t\t\t\t\t\talert('load data error!');\n\t\t\t\t\t\tend();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// 如果到最后一页了, 也结束加载\n\t\t\t\t\tnextpage = d.photos.page + 1;\n\t\t\t\t\tif (nextpage > d.photos.pages) {\n\t\t\t\t\t\tend();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// 拼装每页数据\n\t\t\t\t\tvar items = [];\n\t\t\t\t\tS.each(d.photos.photo, function (item) {\n\t\t\t\t\t\t/*所用到的字段：\n\t\t\t\t\t\t**price\n\t\t\t\t\t\t**height\n\t\t\t\t\t\t**collection\n\t\t\t\t\t\t**title\n\t\t\t\t\t\t**src\n\t\t\t\t\t\t*/\n\t\t\t\t\t\titem.height = Math.round(Math.random() * (300 - 180) + 180); // fake height\t\n\t\t\t\t\t\titem.collection = 10;\t//测试用\n\t\t\t\t\t\titem.price = 1800;\t\t//测试用\n\t\t\t\t\t\titems.push(S.substitute(tpl,item));\n\t\t\t\t\t});\n\t\t\t\t\tsuccess(items);\n\t\t\t\t},\n\t\t\t\tcomplete:function () {\n\t\t\t\t\t$('#loadingPins').hide();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tminColCount:2,\n\t\tcolWidth:175\n\t\t//align:'left' // right, center (default)\n\t});\n    waterfall.on('adjustComplete', function () {\n        S.log('after adjust complete!');\n    });\n\t//加载一页数据完成后触发的事件\n    waterfall.on('addComplete', function () {\n        S.log('after add complete!');\n\t\twaterfall.pause();\n    });\n    // scrollTo\n    $('#BackToTop').on('click', function (e) {\n        e.halt();\n        e.preventDefault();\n        $(window).stop();\n        $(window).animate({\n            scrollTop:0\n        }, 1, \"easeOut\");\n    });\n\t//加载更多按钮\n\t$(\"#button_container_more\").on('click',function(){\t\n\t\twaterfall = new Waterfall.Loader({\n\t\t\tcontainer:\"#ColumnContainer\",\n\t\t\tload:function (success, end) {\n\t\t\t\t$('#loadingPins').show();\n\t\t\t\t$('.loader').hide();\n\t\t\t\tS.ajax({\n\t\t\t\t\tdata:{\n\t\t\t\t\t\t'method':'flickr.photos.search',\n\t\t\t\t\t\t'api_key':'5d93c2e473e39e9307e86d4a01381266',\n\t\t\t\t\t\t'tags':'rose',\n\t\t\t\t\t\t'page':nextpage,\n\t\t\t\t\t\t'per_page':20,\n\t\t\t\t\t\t'format':'json'\n\t\t\t\t\t},\n\t\t\t\t\turl:'http://api.flickr.com/services/rest/',\n\t\t\t\t\tdataType:\"jsonp\",\n\t\t\t\t\tjsonp:\"jsoncallback\",\n\t\t\t\t\tsuccess:function (d) {\n\t\t\t\t\t\t// 如果数据错误, 则立即结束\n\t\t\t\t\t\tif (d.stat !== 'ok') {\n\t\t\t\t\t\t\talert('load data error!');\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 如果到最后一页了, 也结束加载\n\t\t\t\t\t\tnextpage = d.photos.page + 1;\n\t\t\t\t\t\tif (nextpage > d.photos.pages) {\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 拼装每页数据\n\t\t\t\t\t\tvar items = [];\n\t\t\t\t\t\tS.each(d.photos.photo, function (item) {\n\t\t\t\t\t\t\t/*所用到的字段：\n\t\t\t\t\t\t\t**price\n\t\t\t\t\t\t\t**height\n\t\t\t\t\t\t\t**collection\n\t\t\t\t\t\t\t**title\n\t\t\t\t\t\t\t**src\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\titem.height = Math.round(Math.random() * (300 - 180) + 180); // fake height\t\n\t\t\t\t\t\t\titem.collection = 10;\t//测试用\n\t\t\t\t\t\t\titem.price = 1800;\t\t//测试用\n\t\t\t\t\t\t\titems.push(S.substitute(tpl,item));\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsuccess(items);\n\t\t\t\t\t},\n\t\t\t\t\tcomplete:function () {\n\t\t\t\t\t\t$('#loadingPins').hide();\n\t\t\t\t\t\t$('.loader').show();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tminColCount:2,\n\t\t\tcolWidth:175\n\t\t\t//align:'left' // right, center (default)\n\t\t});\n\t\twaterfall.on('addComplete', function () {\n        \tS.log('after add complete!');\n\t\t\twaterfall.pause();\n    \t});\t\t\n\t});\n\t\n\t//收藏按钮功能\n\tvar collect;\n\t$('#ColumnContainer').delegate(\"mouseover\", \".collect\", function (event) {\n\t\tvar w = $(event.currentTarget).children(\"span\");\n\t\tvar text = w.text();\n\t\tif(text >= 0){\n\t\t\tcollect = text;\n\t\t}\n\t\t\n\t\tw.replaceWith(\"<span class='collects'>收藏</span>\");\n\t\t//w.css(\"text-indent\",\"3px\");\n\t});\n\t\n\t$('#ColumnContainer').delegate(\"mouseout\", \".collect\", function (event) {\n\t\tvar w = $(event.currentTarget).children(\"span\");\n\t\tw.replaceWith(\"<span class='collectionAmount'>\"+collect+\"</span>\");\n\t\t//w.css(\"text-indent\",\"13px\");\n\t});\n});\n```","slug":"Kissy-WaterFall-实现手动加载数据","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8u3006wxwrlmnxjgyxc","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于Kissy WaterFall默认是监听滚动事件来实现数据动态加载的，但是有一些情况要用到手动加载数据。以下是使用Kissy WaterFall实现手动加载数据的方法。</p>\n<p>最终实现效果：点击”逛更多的商店“会动态加载数据</p>\n<h2 id=\"步骤：\"><a href=\"#步骤：\" class=\"headerlink\" title=\"步骤：\"></a>步骤：</h2><ol>\n<li>当一页数据加载完成后停止监听滚动事件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加载一页数据完成后触发的事件</span></span><br><span class=\"line\">waterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    S.log(<span class=\"string\">'after add complete!'</span>);</span><br><span class=\"line\">\twaterfall.pause();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>为按钮绑定重启监听滚动事件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加载更多按钮</span></span><br><span class=\"line\">$(<span class=\"string\">\"#button_container_more\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;\t</span><br><span class=\"line\">\twaterfall.resunme();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>附录</li>\n</ol>\n<blockquote>\n<p>waterfall.pause()与water.resunme()的说明（从官网上转载的）<br>pause()函数和resunme()函数属于插件里的waterfall.loader对象的<br>resunme() ：继续开始监控scroll事件（随时可能会动态加载）<br>pause() ：停止监控scroll事件（停止动态加载）</p>\n</blockquote>\n<p>参考网址：<a href=\"http://docs.kissyui.com/docs/html/api/component/waterfall/loader.html#waterfall.Waterfall.prototype.pause\" target=\"_blank\" rel=\"external\">http://docs.kissyui.com/docs/html/api/component/waterfall/loader.html#waterfall.Waterfall.prototype.pause</a></p>\n<p>出现问题：按照以上来完成的话，当点击”加载更多“按钮时，只是启动了滚动监听。意思就是，要加载数据，一要点击按钮，二要再次滚动鼠标。这样的用户体验很差。</p>\n<p>解决办法：修改按钮动作：new一个waterfall.loader，重新赋值waterfall对象，再重新绑定addComplete事件。<br>代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#button_container_more\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;\t</span><br><span class=\"line\">\twaterfall = <span class=\"keyword\">new</span> Waterfall.Loader(&#123;</span><br><span class=\"line\">\t\tcontainer:<span class=\"string\">\"#ColumnContainer\"</span>,</span><br><span class=\"line\">\t\tload:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">success, end</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t$(<span class=\"string\">'#loadingPins'</span>).show();</span><br><span class=\"line\">\t\t\t$(<span class=\"string\">'.loader'</span>).hide();</span><br><span class=\"line\">\t\t\tS.ajax(&#123;</span><br><span class=\"line\">\t\t\t\tdata:&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'method'</span>:<span class=\"string\">'flickr.photos.search'</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'api_key'</span>:<span class=\"string\">'5d93c2e473e39e9307e86d4a01381266'</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'tags'</span>:<span class=\"string\">'rose'</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'page'</span>:nextpage,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'per_page'</span>:<span class=\"number\">20</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'format'</span>:<span class=\"string\">'json'</span></span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\turl:<span class=\"string\">'http://api.flickr.com/services/rest/'</span>,</span><br><span class=\"line\">\t\t\t\tdataType:<span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">\t\t\t\tjsonp:<span class=\"string\">\"jsoncallback\"</span>,</span><br><span class=\"line\">\t\t\t\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">d</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果数据错误, 则立即结束</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (d.stat !== <span class=\"string\">'ok'</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\talert(<span class=\"string\">'load data error!'</span>);</span><br><span class=\"line\">\t\t\t\t\t\tend();</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果到最后一页了, 也结束加载</span></span><br><span class=\"line\">\t\t\t\t\tnextpage = d.photos.page + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (nextpage &gt; d.photos.pages) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tend();</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 拼装每页数据</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">\t\t\t\t\tS.each(d.photos.photo, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">/*所用到的字段：</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**price</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**height</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**collection</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**title</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**src</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t*/</span></span><br><span class=\"line\">\t\t\t\t\t\titem.height = <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Math</span>.random() * (<span class=\"number\">300</span> - <span class=\"number\">180</span>) + <span class=\"number\">180</span>); <span class=\"comment\">// fake height\t</span></span><br><span class=\"line\">\t\t\t\t\t\titem.collection = <span class=\"number\">10</span>;\t<span class=\"comment\">//测试用</span></span><br><span class=\"line\">\t\t\t\t\t\titem.price = <span class=\"number\">1800</span>;\t\t<span class=\"comment\">//测试用</span></span><br><span class=\"line\">\t\t\t\t\t\titems.push(S.substitute(tpl,item));</span><br><span class=\"line\">\t\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t\tsuccess(items);</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tcomplete:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).hide();</span><br><span class=\"line\">\t\t\t\t\t$(<span class=\"string\">'.loader'</span>).show();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tminColCount:<span class=\"number\">2</span>,</span><br><span class=\"line\">\t\tcolWidth:<span class=\"number\">175</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//align:'left' // right, center (default)</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\twaterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       \tS.log(<span class=\"string\">'after add complete!'</span>);</span><br><span class=\"line\">\t\twaterfall.pause();</span><br><span class=\"line\">   \t&#125;);\t\t</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>最终整个脚本文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KISSY.use(<span class=\"string\">\"waterfall,ajax,node,button\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">S, Waterfall, io,  Node, Button</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $ = Node.all;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tpl = $(<span class=\"string\">'#tpl'</span>).html(),</span><br><span class=\"line\">\tnextpage = <span class=\"number\">1</span>,</span><br><span class=\"line\">\twaterfall = <span class=\"keyword\">new</span> Waterfall.Loader(&#123;</span><br><span class=\"line\">\t\tcontainer:<span class=\"string\">\"#ColumnContainer\"</span>,</span><br><span class=\"line\">\t\tload:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">success, end</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t$(<span class=\"string\">'#loadingPins'</span>).show();</span><br><span class=\"line\">\t\t\tS.ajax(&#123;</span><br><span class=\"line\">\t\t\t\tdata:&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'method'</span>:<span class=\"string\">'flickr.photos.search'</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'api_key'</span>:<span class=\"string\">'5d93c2e473e39e9307e86d4a01381266'</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'tags'</span>:<span class=\"string\">'rose'</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'page'</span>:nextpage,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'per_page'</span>:<span class=\"number\">20</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'format'</span>:<span class=\"string\">'json'</span></span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\turl:<span class=\"string\">'http://api.flickr.com/services/rest/'</span>,</span><br><span class=\"line\">\t\t\t\tdataType:<span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">\t\t\t\tjsonp:<span class=\"string\">\"jsoncallback\"</span>,</span><br><span class=\"line\">\t\t\t\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">d</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果数据错误, 则立即结束</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (d.stat !== <span class=\"string\">'ok'</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\talert(<span class=\"string\">'load data error!'</span>);</span><br><span class=\"line\">\t\t\t\t\t\tend();</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果到最后一页了, 也结束加载</span></span><br><span class=\"line\">\t\t\t\t\tnextpage = d.photos.page + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (nextpage &gt; d.photos.pages) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tend();</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 拼装每页数据</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">\t\t\t\t\tS.each(d.photos.photo, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">/*所用到的字段：</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**price</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**height</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**collection</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**title</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**src</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t*/</span></span><br><span class=\"line\">\t\t\t\t\t\titem.height = <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Math</span>.random() * (<span class=\"number\">300</span> - <span class=\"number\">180</span>) + <span class=\"number\">180</span>); <span class=\"comment\">// fake height\t</span></span><br><span class=\"line\">\t\t\t\t\t\titem.collection = <span class=\"number\">10</span>;\t<span class=\"comment\">//测试用</span></span><br><span class=\"line\">\t\t\t\t\t\titem.price = <span class=\"number\">1800</span>;\t\t<span class=\"comment\">//测试用</span></span><br><span class=\"line\">\t\t\t\t\t\titems.push(S.substitute(tpl,item));</span><br><span class=\"line\">\t\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t\tsuccess(items);</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tcomplete:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).hide();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tminColCount:<span class=\"number\">2</span>,</span><br><span class=\"line\">\t\tcolWidth:<span class=\"number\">175</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//align:'left' // right, center (default)</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">    waterfall.on(<span class=\"string\">'adjustComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        S.log(<span class=\"string\">'after adjust complete!'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">\t<span class=\"comment\">//加载一页数据完成后触发的事件</span></span><br><span class=\"line\">    waterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        S.log(<span class=\"string\">'after add complete!'</span>);</span><br><span class=\"line\">\t\twaterfall.pause();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// scrollTo</span></span><br><span class=\"line\">    $(<span class=\"string\">'#BackToTop'</span>).on(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.halt();</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">        $(<span class=\"built_in\">window</span>).stop();</span><br><span class=\"line\">        $(<span class=\"built_in\">window</span>).animate(&#123;</span><br><span class=\"line\">            scrollTop:<span class=\"number\">0</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">1</span>, <span class=\"string\">\"easeOut\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">\t<span class=\"comment\">//加载更多按钮</span></span><br><span class=\"line\">\t$(<span class=\"string\">\"#button_container_more\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;\t</span><br><span class=\"line\">\t\twaterfall = <span class=\"keyword\">new</span> Waterfall.Loader(&#123;</span><br><span class=\"line\">\t\t\tcontainer:<span class=\"string\">\"#ColumnContainer\"</span>,</span><br><span class=\"line\">\t\t\tload:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">success, end</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).show();</span><br><span class=\"line\">\t\t\t\t$(<span class=\"string\">'.loader'</span>).hide();</span><br><span class=\"line\">\t\t\t\tS.ajax(&#123;</span><br><span class=\"line\">\t\t\t\t\tdata:&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">'method'</span>:<span class=\"string\">'flickr.photos.search'</span>,</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">'api_key'</span>:<span class=\"string\">'5d93c2e473e39e9307e86d4a01381266'</span>,</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">'tags'</span>:<span class=\"string\">'rose'</span>,</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">'page'</span>:nextpage,</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">'per_page'</span>:<span class=\"number\">20</span>,</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">'format'</span>:<span class=\"string\">'json'</span></span><br><span class=\"line\">\t\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\t\turl:<span class=\"string\">'http://api.flickr.com/services/rest/'</span>,</span><br><span class=\"line\">\t\t\t\t\tdataType:<span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">\t\t\t\t\tjsonp:<span class=\"string\">\"jsoncallback\"</span>,</span><br><span class=\"line\">\t\t\t\t\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">d</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 如果数据错误, 则立即结束</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (d.stat !== <span class=\"string\">'ok'</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\talert(<span class=\"string\">'load data error!'</span>);</span><br><span class=\"line\">\t\t\t\t\t\t\tend();</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 如果到最后一页了, 也结束加载</span></span><br><span class=\"line\">\t\t\t\t\t\tnextpage = d.photos.page + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (nextpage &gt; d.photos.pages) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tend();</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 拼装每页数据</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">\t\t\t\t\t\tS.each(d.photos.photo, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">/*所用到的字段：</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t**price</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t**height</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t**collection</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t**title</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t**src</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t*/</span></span><br><span class=\"line\">\t\t\t\t\t\t\titem.height = <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Math</span>.random() * (<span class=\"number\">300</span> - <span class=\"number\">180</span>) + <span class=\"number\">180</span>); <span class=\"comment\">// fake height\t</span></span><br><span class=\"line\">\t\t\t\t\t\t\titem.collection = <span class=\"number\">10</span>;\t<span class=\"comment\">//测试用</span></span><br><span class=\"line\">\t\t\t\t\t\t\titem.price = <span class=\"number\">1800</span>;\t\t<span class=\"comment\">//测试用</span></span><br><span class=\"line\">\t\t\t\t\t\t\titems.push(S.substitute(tpl,item));</span><br><span class=\"line\">\t\t\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t\t\tsuccess(items);</span><br><span class=\"line\">\t\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\t\tcomplete:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).hide();</span><br><span class=\"line\">\t\t\t\t\t\t$(<span class=\"string\">'.loader'</span>).show();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tminColCount:<span class=\"number\">2</span>,</span><br><span class=\"line\">\t\t\tcolWidth:<span class=\"number\">175</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//align:'left' // right, center (default)</span></span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\twaterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        \tS.log(<span class=\"string\">'after add complete!'</span>);</span><br><span class=\"line\">\t\t\twaterfall.pause();</span><br><span class=\"line\">    \t&#125;);\t\t</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//收藏按钮功能</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> collect;</span><br><span class=\"line\">\t$(<span class=\"string\">'#ColumnContainer'</span>).delegate(<span class=\"string\">\"mouseover\"</span>, <span class=\"string\">\".collect\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> w = $(event.currentTarget).children(<span class=\"string\">\"span\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> text = w.text();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(text &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcollect = text;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tw.replaceWith(<span class=\"string\">\"&lt;span class='collects'&gt;收藏&lt;/span&gt;\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//w.css(\"text-indent\",\"3px\");</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t$(<span class=\"string\">'#ColumnContainer'</span>).delegate(<span class=\"string\">\"mouseout\"</span>, <span class=\"string\">\".collect\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> w = $(event.currentTarget).children(<span class=\"string\">\"span\"</span>);</span><br><span class=\"line\">\t\tw.replaceWith(<span class=\"string\">\"&lt;span class='collectionAmount'&gt;\"</span>+collect+<span class=\"string\">\"&lt;/span&gt;\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//w.css(\"text-indent\",\"13px\");</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于Kissy WaterFall默认是监听滚动事件来实现数据动态加载的，但是有一些情况要用到手动加载数据。以下是使用Kissy WaterFall实现手动加载数据的方法。</p>\n<p>最终实现效果：点击”逛更多的商店“会动态加载数据</p>\n<h2 id=\"步骤：\"><a href=\"#步骤：\" class=\"headerlink\" title=\"步骤：\"></a>步骤：</h2><ol>\n<li>当一页数据加载完成后停止监听滚动事件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加载一页数据完成后触发的事件</span></span><br><span class=\"line\">waterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    S.log(<span class=\"string\">'after add complete!'</span>);</span><br><span class=\"line\">\twaterfall.pause();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>为按钮绑定重启监听滚动事件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加载更多按钮</span></span><br><span class=\"line\">$(<span class=\"string\">\"#button_container_more\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;\t</span><br><span class=\"line\">\twaterfall.resunme();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>附录</li>\n</ol>\n<blockquote>\n<p>waterfall.pause()与water.resunme()的说明（从官网上转载的）<br>pause()函数和resunme()函数属于插件里的waterfall.loader对象的<br>resunme() ：继续开始监控scroll事件（随时可能会动态加载）<br>pause() ：停止监控scroll事件（停止动态加载）</p>\n</blockquote>\n<p>参考网址：<a href=\"http://docs.kissyui.com/docs/html/api/component/waterfall/loader.html#waterfall.Waterfall.prototype.pause\">http://docs.kissyui.com/docs/html/api/component/waterfall/loader.html#waterfall.Waterfall.prototype.pause</a></p>\n<p>出现问题：按照以上来完成的话，当点击”加载更多“按钮时，只是启动了滚动监听。意思就是，要加载数据，一要点击按钮，二要再次滚动鼠标。这样的用户体验很差。</p>\n<p>解决办法：修改按钮动作：new一个waterfall.loader，重新赋值waterfall对象，再重新绑定addComplete事件。<br>代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#button_container_more\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;\t</span><br><span class=\"line\">\twaterfall = <span class=\"keyword\">new</span> Waterfall.Loader(&#123;</span><br><span class=\"line\">\t\tcontainer:<span class=\"string\">\"#ColumnContainer\"</span>,</span><br><span class=\"line\">\t\tload:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">success, end</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t$(<span class=\"string\">'#loadingPins'</span>).show();</span><br><span class=\"line\">\t\t\t$(<span class=\"string\">'.loader'</span>).hide();</span><br><span class=\"line\">\t\t\tS.ajax(&#123;</span><br><span class=\"line\">\t\t\t\tdata:&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'method'</span>:<span class=\"string\">'flickr.photos.search'</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'api_key'</span>:<span class=\"string\">'5d93c2e473e39e9307e86d4a01381266'</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'tags'</span>:<span class=\"string\">'rose'</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'page'</span>:nextpage,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'per_page'</span>:<span class=\"number\">20</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'format'</span>:<span class=\"string\">'json'</span></span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\turl:<span class=\"string\">'http://api.flickr.com/services/rest/'</span>,</span><br><span class=\"line\">\t\t\t\tdataType:<span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">\t\t\t\tjsonp:<span class=\"string\">\"jsoncallback\"</span>,</span><br><span class=\"line\">\t\t\t\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">d</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果数据错误, 则立即结束</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (d.stat !== <span class=\"string\">'ok'</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\talert(<span class=\"string\">'load data error!'</span>);</span><br><span class=\"line\">\t\t\t\t\t\tend();</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果到最后一页了, 也结束加载</span></span><br><span class=\"line\">\t\t\t\t\tnextpage = d.photos.page + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (nextpage &gt; d.photos.pages) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tend();</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 拼装每页数据</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">\t\t\t\t\tS.each(d.photos.photo, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">/*所用到的字段：</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**price</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**height</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**collection</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**title</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**src</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t*/</span></span><br><span class=\"line\">\t\t\t\t\t\titem.height = <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Math</span>.random() * (<span class=\"number\">300</span> - <span class=\"number\">180</span>) + <span class=\"number\">180</span>); <span class=\"comment\">// fake height\t</span></span><br><span class=\"line\">\t\t\t\t\t\titem.collection = <span class=\"number\">10</span>;\t<span class=\"comment\">//测试用</span></span><br><span class=\"line\">\t\t\t\t\t\titem.price = <span class=\"number\">1800</span>;\t\t<span class=\"comment\">//测试用</span></span><br><span class=\"line\">\t\t\t\t\t\titems.push(S.substitute(tpl,item));</span><br><span class=\"line\">\t\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t\tsuccess(items);</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tcomplete:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).hide();</span><br><span class=\"line\">\t\t\t\t\t$(<span class=\"string\">'.loader'</span>).show();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tminColCount:<span class=\"number\">2</span>,</span><br><span class=\"line\">\t\tcolWidth:<span class=\"number\">175</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//align:'left' // right, center (default)</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\twaterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       \tS.log(<span class=\"string\">'after add complete!'</span>);</span><br><span class=\"line\">\t\twaterfall.pause();</span><br><span class=\"line\">   \t&#125;);\t\t</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>最终整个脚本文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KISSY.use(<span class=\"string\">\"waterfall,ajax,node,button\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">S, Waterfall, io,  Node, Button</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $ = Node.all;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tpl = $(<span class=\"string\">'#tpl'</span>).html(),</span><br><span class=\"line\">\tnextpage = <span class=\"number\">1</span>,</span><br><span class=\"line\">\twaterfall = <span class=\"keyword\">new</span> Waterfall.Loader(&#123;</span><br><span class=\"line\">\t\tcontainer:<span class=\"string\">\"#ColumnContainer\"</span>,</span><br><span class=\"line\">\t\tload:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">success, end</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t$(<span class=\"string\">'#loadingPins'</span>).show();</span><br><span class=\"line\">\t\t\tS.ajax(&#123;</span><br><span class=\"line\">\t\t\t\tdata:&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'method'</span>:<span class=\"string\">'flickr.photos.search'</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'api_key'</span>:<span class=\"string\">'5d93c2e473e39e9307e86d4a01381266'</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'tags'</span>:<span class=\"string\">'rose'</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'page'</span>:nextpage,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'per_page'</span>:<span class=\"number\">20</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">'format'</span>:<span class=\"string\">'json'</span></span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\turl:<span class=\"string\">'http://api.flickr.com/services/rest/'</span>,</span><br><span class=\"line\">\t\t\t\tdataType:<span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">\t\t\t\tjsonp:<span class=\"string\">\"jsoncallback\"</span>,</span><br><span class=\"line\">\t\t\t\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">d</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果数据错误, 则立即结束</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (d.stat !== <span class=\"string\">'ok'</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\talert(<span class=\"string\">'load data error!'</span>);</span><br><span class=\"line\">\t\t\t\t\t\tend();</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果到最后一页了, 也结束加载</span></span><br><span class=\"line\">\t\t\t\t\tnextpage = d.photos.page + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (nextpage &gt; d.photos.pages) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tend();</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 拼装每页数据</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">\t\t\t\t\tS.each(d.photos.photo, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">/*所用到的字段：</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**price</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**height</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**collection</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**title</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t**src</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t*/</span></span><br><span class=\"line\">\t\t\t\t\t\titem.height = <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Math</span>.random() * (<span class=\"number\">300</span> - <span class=\"number\">180</span>) + <span class=\"number\">180</span>); <span class=\"comment\">// fake height\t</span></span><br><span class=\"line\">\t\t\t\t\t\titem.collection = <span class=\"number\">10</span>;\t<span class=\"comment\">//测试用</span></span><br><span class=\"line\">\t\t\t\t\t\titem.price = <span class=\"number\">1800</span>;\t\t<span class=\"comment\">//测试用</span></span><br><span class=\"line\">\t\t\t\t\t\titems.push(S.substitute(tpl,item));</span><br><span class=\"line\">\t\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t\tsuccess(items);</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tcomplete:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).hide();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tminColCount:<span class=\"number\">2</span>,</span><br><span class=\"line\">\t\tcolWidth:<span class=\"number\">175</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//align:'left' // right, center (default)</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">    waterfall.on(<span class=\"string\">'adjustComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        S.log(<span class=\"string\">'after adjust complete!'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">\t<span class=\"comment\">//加载一页数据完成后触发的事件</span></span><br><span class=\"line\">    waterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        S.log(<span class=\"string\">'after add complete!'</span>);</span><br><span class=\"line\">\t\twaterfall.pause();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// scrollTo</span></span><br><span class=\"line\">    $(<span class=\"string\">'#BackToTop'</span>).on(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        e.halt();</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">        $(<span class=\"built_in\">window</span>).stop();</span><br><span class=\"line\">        $(<span class=\"built_in\">window</span>).animate(&#123;</span><br><span class=\"line\">            scrollTop:<span class=\"number\">0</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">1</span>, <span class=\"string\">\"easeOut\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">\t<span class=\"comment\">//加载更多按钮</span></span><br><span class=\"line\">\t$(<span class=\"string\">\"#button_container_more\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;\t</span><br><span class=\"line\">\t\twaterfall = <span class=\"keyword\">new</span> Waterfall.Loader(&#123;</span><br><span class=\"line\">\t\t\tcontainer:<span class=\"string\">\"#ColumnContainer\"</span>,</span><br><span class=\"line\">\t\t\tload:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">success, end</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).show();</span><br><span class=\"line\">\t\t\t\t$(<span class=\"string\">'.loader'</span>).hide();</span><br><span class=\"line\">\t\t\t\tS.ajax(&#123;</span><br><span class=\"line\">\t\t\t\t\tdata:&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">'method'</span>:<span class=\"string\">'flickr.photos.search'</span>,</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">'api_key'</span>:<span class=\"string\">'5d93c2e473e39e9307e86d4a01381266'</span>,</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">'tags'</span>:<span class=\"string\">'rose'</span>,</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">'page'</span>:nextpage,</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">'per_page'</span>:<span class=\"number\">20</span>,</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">'format'</span>:<span class=\"string\">'json'</span></span><br><span class=\"line\">\t\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\t\turl:<span class=\"string\">'http://api.flickr.com/services/rest/'</span>,</span><br><span class=\"line\">\t\t\t\t\tdataType:<span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">\t\t\t\t\tjsonp:<span class=\"string\">\"jsoncallback\"</span>,</span><br><span class=\"line\">\t\t\t\t\tsuccess:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">d</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 如果数据错误, 则立即结束</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (d.stat !== <span class=\"string\">'ok'</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\talert(<span class=\"string\">'load data error!'</span>);</span><br><span class=\"line\">\t\t\t\t\t\t\tend();</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 如果到最后一页了, 也结束加载</span></span><br><span class=\"line\">\t\t\t\t\t\tnextpage = d.photos.page + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (nextpage &gt; d.photos.pages) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tend();</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 拼装每页数据</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">var</span> items = [];</span><br><span class=\"line\">\t\t\t\t\t\tS.each(d.photos.photo, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">/*所用到的字段：</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t**price</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t**height</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t**collection</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t**title</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t**src</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t*/</span></span><br><span class=\"line\">\t\t\t\t\t\t\titem.height = <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Math</span>.random() * (<span class=\"number\">300</span> - <span class=\"number\">180</span>) + <span class=\"number\">180</span>); <span class=\"comment\">// fake height\t</span></span><br><span class=\"line\">\t\t\t\t\t\t\titem.collection = <span class=\"number\">10</span>;\t<span class=\"comment\">//测试用</span></span><br><span class=\"line\">\t\t\t\t\t\t\titem.price = <span class=\"number\">1800</span>;\t\t<span class=\"comment\">//测试用</span></span><br><span class=\"line\">\t\t\t\t\t\t\titems.push(S.substitute(tpl,item));</span><br><span class=\"line\">\t\t\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t\t\tsuccess(items);</span><br><span class=\"line\">\t\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\t\tcomplete:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).hide();</span><br><span class=\"line\">\t\t\t\t\t\t$(<span class=\"string\">'.loader'</span>).show();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tminColCount:<span class=\"number\">2</span>,</span><br><span class=\"line\">\t\t\tcolWidth:<span class=\"number\">175</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//align:'left' // right, center (default)</span></span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\twaterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        \tS.log(<span class=\"string\">'after add complete!'</span>);</span><br><span class=\"line\">\t\t\twaterfall.pause();</span><br><span class=\"line\">    \t&#125;);\t\t</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//收藏按钮功能</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> collect;</span><br><span class=\"line\">\t$(<span class=\"string\">'#ColumnContainer'</span>).delegate(<span class=\"string\">\"mouseover\"</span>, <span class=\"string\">\".collect\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> w = $(event.currentTarget).children(<span class=\"string\">\"span\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> text = w.text();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(text &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcollect = text;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tw.replaceWith(<span class=\"string\">\"&lt;span class='collects'&gt;收藏&lt;/span&gt;\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//w.css(\"text-indent\",\"3px\");</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t$(<span class=\"string\">'#ColumnContainer'</span>).delegate(<span class=\"string\">\"mouseout\"</span>, <span class=\"string\">\".collect\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> w = $(event.currentTarget).children(<span class=\"string\">\"span\"</span>);</span><br><span class=\"line\">\t\tw.replaceWith(<span class=\"string\">\"&lt;span class='collectionAmount'&gt;\"</span>+collect+<span class=\"string\">\"&lt;/span&gt;\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//w.css(\"text-indent\",\"13px\");</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"Javascript那些书籍","date":"2014-07-08T12:50:07.000Z","_content":"\n转眼间已是准大四生了，在身边的小伙伴们纷纷参加各小中大企业的暑期实习的时候，我却因为某原因回家乡宅一两个月咯。\n\n人间有那么一句言论：程序员不持续学习是没出息滴。\n\n人生也何尝不是这样，立志在前端发过发热的我，列了一些关于Javascript的书单，回家好好填补一下那些个知识的漏洞。\n\n![javascript那些书籍](http://img.blog.csdn.net/20140708204644093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmx1ZXN1bjg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)","source":"_posts/Javascript那些书籍.md","raw":"---\ntitle: Javascript那些书籍\ndate: 2014-07-08 20:50:07\ntags:\n- 书籍\n- Javascript\ncategory: 人丑就要多读书\n---\n\n转眼间已是准大四生了，在身边的小伙伴们纷纷参加各小中大企业的暑期实习的时候，我却因为某原因回家乡宅一两个月咯。\n\n人间有那么一句言论：程序员不持续学习是没出息滴。\n\n人生也何尝不是这样，立志在前端发过发热的我，列了一些关于Javascript的书单，回家好好填补一下那些个知识的漏洞。\n\n![javascript那些书籍](http://img.blog.csdn.net/20140708204644093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmx1ZXN1bjg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)","slug":"Javascript那些书籍","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8u5006zxwrl371le7fh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转眼间已是准大四生了，在身边的小伙伴们纷纷参加各小中大企业的暑期实习的时候，我却因为某原因回家乡宅一两个月咯。</p>\n<p>人间有那么一句言论：程序员不持续学习是没出息滴。</p>\n<p>人生也何尝不是这样，立志在前端发过发热的我，列了一些关于Javascript的书单，回家好好填补一下那些个知识的漏洞。</p>\n<p><img src=\"http://img.blog.csdn.net/20140708204644093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmx1ZXN1bjg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"javascript那些书籍\"></p>\n","excerpt":"","more":"<p>转眼间已是准大四生了，在身边的小伙伴们纷纷参加各小中大企业的暑期实习的时候，我却因为某原因回家乡宅一两个月咯。</p>\n<p>人间有那么一句言论：程序员不持续学习是没出息滴。</p>\n<p>人生也何尝不是这样，立志在前端发过发热的我，列了一些关于Javascript的书单，回家好好填补一下那些个知识的漏洞。</p>\n<p><img src=\"http://img.blog.csdn.net/20140708204644093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmx1ZXN1bjg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"javascript那些书籍\"></p>\n"},{"title":"Javascript 原型中的哲学思想","date":"2016-06-28T15:12:00.000Z","_content":"\n\n记得当年初试前端的时候，学习JavaScript过程中，原型问题一直让我疑惑许久，那时候捧着那本著名的红皮书，看到有关原型的讲解时，总是心存疑虑。\n当在JavaScript世界中走过不少旅程之后，再次萌发起研究这部分知识的欲望，翻阅了不少书籍和资料，才搞懂`__proto__`和`prototype`的概念。\n故以作此笔记，日后忘了可以回来看看。\n如果你看的过程中觉得理解有些困难，把例子在代码中跑一跑，亲手试一试也许能解决不少疑惑。\n\n# 一切皆为对象\n\n> 殊不知，JavaScript的世界中的对象，追根溯源来自于一个 null\n\n「一切皆为对象」，这句着实是一手好营销，易记，易上口，印象深刻。\n万物初生时，一个`null`对象，凭空而生，接着`Object`、`Function`学着`null`的模样塑造了自己，并且它们彼此之间喜结连理，提供了`prototype`和`constructor`，一个给子孙提供了基因，一个则制造万千子子孙孙。\n在JavaScript中，`null`也是作为一个对象存在，基于它继承的子子孙孙，当属对象。\n乍一看，`null`像是上帝,而`Object`和`Function`犹如JavaScript世界中的**亚当**与**夏娃**。\n\n\n# 原型指针 `__proto__`\n\n在JavaScript中，每个对象都拥有一个原型对象，而指向该原型对象的内部指针则是`__proto__`,通过它可以从中继承原型对象的属性，原型是JavaScript中的基因链接，有了这个，才能知道这个对象的祖祖辈辈。从对象中的`__proto__`可以访问到他所继承的原型对象。\n\n```javascript\nvar a = new Array();\na.__proto__ === Array.prototype // true\n```\n\n上面代码中，创建了一个Array的实例`a`，该实例的原型指向了`Array.prototype`。\n`Array.prototype`本身也是一个对象，也有继承的原型:\n\n```javascript\na.__proto__.__proto__ === Object.prototype  // true\n// 等同于 Array.prototype.__proto__ === Object.prototype\n```\n\n这就说了明了，Array本身也是继承自Object的，那么Object的原型指向的是谁呢？\n\n```javascript\na.__proto__.__proto__.__proto__ === null  // true\n// 等同于 Object.prototype.__proto__ === null\n```\n\n![prototype.png](/image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png)\n\n所以说，JavaScript中的对象，追根溯源都是来自一个**null**对象。佛曰：**万物皆空**，善哉善哉。\n\n除了使用`.__proto__`方式访问对象的原型，还可以通过`Object.getPrototypeOf`方法来获取对象的原型，以及通过`Object.setPrototypeOf`方法来重写对象的原型\n。\n值得注意的是，按照语言标准，`__proto__`属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用`Object.getPrototypeof`和`Object.setPrototypeOf`，进行原型对象的读写操作。\n这里用`__proto__`属性来描述对象中的原型，是因为这样来得更加形象，且容易理解。\n\n# 原型对象 `prototype`\n函数作为JavaScript中的一等公民，它既是函数又是对象，函数的原型指向的是`Function.prototype`\n\n```javascript\nvar Foo = function() {}\nFoo.__proto__ === Function.prototype // true\n```\n\n函数实例除了拥有`__proto__`属性之外，还拥有`prototype`属性。\n通过该函数构造的新的实例对象，其原型指针`__proto__`会指向该函数的`prototype`属性。\n\n```javascript\nvar a = new Foo();\na.__proto__ === Foo.prototype; // true\n```\n\n而函数的`prototype`属性，本身是一个由`Object`构造的实例对象。\n\n```javascript\nFoo.prototype.__proto__ === Object.prototype; // true\n```\n\n`prototype`属性很特殊，它还有一个隐式的`constructor`，指向了构造函数本身。\n\n\n```javascript\nFoo.prototype.constructor === Foo; // true\na.constructor === Foo; // true\na.constructor === Foo.prototype.constructor; // true\n```\n\n![prototype2.png](/image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png)\n\n# 原型链\n\n## 概念\n原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。\n每个构造函数都有一个原型对象(`prototype`)，原型对象都包含一个指向构造函数的指针(`constructor`)，而实例都包含一个指向原型对象的内部指针(`__proto__`)。\n那么，假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。\n如此层层递进，就构造了实例与原型的链条，这就是**原型链**的基本概念。\n\n## 意义\n“原型链”的作用在于，当读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。以此类推，如果直到最顶层的Object.prototype还是找不到，则返回undefine\n\n# 亲子鉴定\n在JavaScript中，也存在鉴定亲子之间DNA关系的方法：\n1. **instanceof**\n  运算符返回一个布尔值，表示一个对象是否由某个构造函数创建。\n2. **Object.isPrototypeOf()**\n  只要某个对象处在原型链上，isProtypeOf都返回true\n\n```javascript\nvar Bar = function() {}\nvar b = new Bar();\nb instanceof Bar // true\nBar.prototype.isPrototypeOf(b) // true\nObject.prototype.isPrototypeOf(Bar) // true\n```\n要注意，实例`b`的原型是`Bar.prototype`而不是`Bar`\n\n# 一张历史悠久的图\n![jsobj_full.jpg](/image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg)\n\n这是一张描述了`Object`、`Function`以及一个函数实例`Foo`他们之间原型之间联系。如果理解了上面的概念，这张图是不难读懂。\n\n从上图中，能看到一个有趣的地方。\n`Function.prototype.__proto__` 指向了 `Object.prototype`，这说明`Function.prototype` 是一个 `Object`实例，那么应当是先有的`Object`再有`Function`。\n但是`Object.prototype.constructor.__proto__` 又指向了 `Function.prototype`。这样看来，没有`Function`，`Object`也不能创建实例。\n这就产生了一种类「先有鸡还是先有蛋」的经典问题，到底是先有的`Object`还是先有的`Function`呢？\n这么哲学向的问题，留给你思考了。\n我只是感慨：\n**越往JavaScript的深处探索，越发觉得这一门语言很哲学。**\n\n# 先有鸡还是先有蛋？\n> update on 2017/01/05\n\n时隔半年，偶尔翻开这篇文章。    \n对于这个问题，又有了新的思考。    \n愿意跟能看到这里的你来分享一下。\n\n我们可以先把 `Object.prototype` 和 `Function.prototype` 这两个拎出来看，因为他们本身就是一个实例对象。\n为方便理解，我们改一下名字，避免和 Object 和 Function 的强关联，分别叫：`Op` 和 `Fp`\n\n那么就有这样的原型链存在了 \n\n![先有鸡还是先有蛋](/image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png)\n\n我再描述一下上面的原型链，先有 null , 再有了 Op , 然后再有了 Fp ，然后以 Fp 为原型的两个构造函数 (Object, Function) 出现了。    \n而作为构造函数，需要有个 prototype 属性用来作为以该构造函数创造的实例的继承。    \n所以Object.prototype = Op, Function.prototype = Fp。","source":"_posts/JavaScript原型中的哲学思想.md","raw":"---\ntitle: Javascript 原型中的哲学思想\ndate: 2016-06-28 23:12:00\ntags:\n- Javascript\ncategory: 搬砖码农\n---\n\n\n记得当年初试前端的时候，学习JavaScript过程中，原型问题一直让我疑惑许久，那时候捧着那本著名的红皮书，看到有关原型的讲解时，总是心存疑虑。\n当在JavaScript世界中走过不少旅程之后，再次萌发起研究这部分知识的欲望，翻阅了不少书籍和资料，才搞懂`__proto__`和`prototype`的概念。\n故以作此笔记，日后忘了可以回来看看。\n如果你看的过程中觉得理解有些困难，把例子在代码中跑一跑，亲手试一试也许能解决不少疑惑。\n\n# 一切皆为对象\n\n> 殊不知，JavaScript的世界中的对象，追根溯源来自于一个 null\n\n「一切皆为对象」，这句着实是一手好营销，易记，易上口，印象深刻。\n万物初生时，一个`null`对象，凭空而生，接着`Object`、`Function`学着`null`的模样塑造了自己，并且它们彼此之间喜结连理，提供了`prototype`和`constructor`，一个给子孙提供了基因，一个则制造万千子子孙孙。\n在JavaScript中，`null`也是作为一个对象存在，基于它继承的子子孙孙，当属对象。\n乍一看，`null`像是上帝,而`Object`和`Function`犹如JavaScript世界中的**亚当**与**夏娃**。\n\n\n# 原型指针 `__proto__`\n\n在JavaScript中，每个对象都拥有一个原型对象，而指向该原型对象的内部指针则是`__proto__`,通过它可以从中继承原型对象的属性，原型是JavaScript中的基因链接，有了这个，才能知道这个对象的祖祖辈辈。从对象中的`__proto__`可以访问到他所继承的原型对象。\n\n```javascript\nvar a = new Array();\na.__proto__ === Array.prototype // true\n```\n\n上面代码中，创建了一个Array的实例`a`，该实例的原型指向了`Array.prototype`。\n`Array.prototype`本身也是一个对象，也有继承的原型:\n\n```javascript\na.__proto__.__proto__ === Object.prototype  // true\n// 等同于 Array.prototype.__proto__ === Object.prototype\n```\n\n这就说了明了，Array本身也是继承自Object的，那么Object的原型指向的是谁呢？\n\n```javascript\na.__proto__.__proto__.__proto__ === null  // true\n// 等同于 Object.prototype.__proto__ === null\n```\n\n![prototype.png](/image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png)\n\n所以说，JavaScript中的对象，追根溯源都是来自一个**null**对象。佛曰：**万物皆空**，善哉善哉。\n\n除了使用`.__proto__`方式访问对象的原型，还可以通过`Object.getPrototypeOf`方法来获取对象的原型，以及通过`Object.setPrototypeOf`方法来重写对象的原型\n。\n值得注意的是，按照语言标准，`__proto__`属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用`Object.getPrototypeof`和`Object.setPrototypeOf`，进行原型对象的读写操作。\n这里用`__proto__`属性来描述对象中的原型，是因为这样来得更加形象，且容易理解。\n\n# 原型对象 `prototype`\n函数作为JavaScript中的一等公民，它既是函数又是对象，函数的原型指向的是`Function.prototype`\n\n```javascript\nvar Foo = function() {}\nFoo.__proto__ === Function.prototype // true\n```\n\n函数实例除了拥有`__proto__`属性之外，还拥有`prototype`属性。\n通过该函数构造的新的实例对象，其原型指针`__proto__`会指向该函数的`prototype`属性。\n\n```javascript\nvar a = new Foo();\na.__proto__ === Foo.prototype; // true\n```\n\n而函数的`prototype`属性，本身是一个由`Object`构造的实例对象。\n\n```javascript\nFoo.prototype.__proto__ === Object.prototype; // true\n```\n\n`prototype`属性很特殊，它还有一个隐式的`constructor`，指向了构造函数本身。\n\n\n```javascript\nFoo.prototype.constructor === Foo; // true\na.constructor === Foo; // true\na.constructor === Foo.prototype.constructor; // true\n```\n\n![prototype2.png](/image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png)\n\n# 原型链\n\n## 概念\n原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。\n每个构造函数都有一个原型对象(`prototype`)，原型对象都包含一个指向构造函数的指针(`constructor`)，而实例都包含一个指向原型对象的内部指针(`__proto__`)。\n那么，假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。\n如此层层递进，就构造了实例与原型的链条，这就是**原型链**的基本概念。\n\n## 意义\n“原型链”的作用在于，当读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。以此类推，如果直到最顶层的Object.prototype还是找不到，则返回undefine\n\n# 亲子鉴定\n在JavaScript中，也存在鉴定亲子之间DNA关系的方法：\n1. **instanceof**\n  运算符返回一个布尔值，表示一个对象是否由某个构造函数创建。\n2. **Object.isPrototypeOf()**\n  只要某个对象处在原型链上，isProtypeOf都返回true\n\n```javascript\nvar Bar = function() {}\nvar b = new Bar();\nb instanceof Bar // true\nBar.prototype.isPrototypeOf(b) // true\nObject.prototype.isPrototypeOf(Bar) // true\n```\n要注意，实例`b`的原型是`Bar.prototype`而不是`Bar`\n\n# 一张历史悠久的图\n![jsobj_full.jpg](/image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg)\n\n这是一张描述了`Object`、`Function`以及一个函数实例`Foo`他们之间原型之间联系。如果理解了上面的概念，这张图是不难读懂。\n\n从上图中，能看到一个有趣的地方。\n`Function.prototype.__proto__` 指向了 `Object.prototype`，这说明`Function.prototype` 是一个 `Object`实例，那么应当是先有的`Object`再有`Function`。\n但是`Object.prototype.constructor.__proto__` 又指向了 `Function.prototype`。这样看来，没有`Function`，`Object`也不能创建实例。\n这就产生了一种类「先有鸡还是先有蛋」的经典问题，到底是先有的`Object`还是先有的`Function`呢？\n这么哲学向的问题，留给你思考了。\n我只是感慨：\n**越往JavaScript的深处探索，越发觉得这一门语言很哲学。**\n\n# 先有鸡还是先有蛋？\n> update on 2017/01/05\n\n时隔半年，偶尔翻开这篇文章。    \n对于这个问题，又有了新的思考。    \n愿意跟能看到这里的你来分享一下。\n\n我们可以先把 `Object.prototype` 和 `Function.prototype` 这两个拎出来看，因为他们本身就是一个实例对象。\n为方便理解，我们改一下名字，避免和 Object 和 Function 的强关联，分别叫：`Op` 和 `Fp`\n\n那么就有这样的原型链存在了 \n\n![先有鸡还是先有蛋](/image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png)\n\n我再描述一下上面的原型链，先有 null , 再有了 Op , 然后再有了 Fp ，然后以 Fp 为原型的两个构造函数 (Object, Function) 出现了。    \n而作为构造函数，需要有个 prototype 属性用来作为以该构造函数创造的实例的继承。    \n所以Object.prototype = Op, Function.prototype = Fp。","slug":"JavaScript原型中的哲学思想","published":1,"updated":"2017-02-02T14:53:25.000Z","_id":"cl270y8u60074xwrlw5ulzdqb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>记得当年初试前端的时候，学习JavaScript过程中，原型问题一直让我疑惑许久，那时候捧着那本著名的红皮书，看到有关原型的讲解时，总是心存疑虑。<br>当在JavaScript世界中走过不少旅程之后，再次萌发起研究这部分知识的欲望，翻阅了不少书籍和资料，才搞懂<code>__proto__</code>和<code>prototype</code>的概念。<br>故以作此笔记，日后忘了可以回来看看。<br>如果你看的过程中觉得理解有些困难，把例子在代码中跑一跑，亲手试一试也许能解决不少疑惑。</p>\n<h1 id=\"一切皆为对象\"><a href=\"#一切皆为对象\" class=\"headerlink\" title=\"一切皆为对象\"></a>一切皆为对象</h1><blockquote>\n<p>殊不知，JavaScript的世界中的对象，追根溯源来自于一个 null</p>\n</blockquote>\n<p>「一切皆为对象」，这句着实是一手好营销，易记，易上口，印象深刻。<br>万物初生时，一个<code>null</code>对象，凭空而生，接着<code>Object</code>、<code>Function</code>学着<code>null</code>的模样塑造了自己，并且它们彼此之间喜结连理，提供了<code>prototype</code>和<code>constructor</code>，一个给子孙提供了基因，一个则制造万千子子孙孙。<br>在JavaScript中，<code>null</code>也是作为一个对象存在，基于它继承的子子孙孙，当属对象。<br>乍一看，<code>null</code>像是上帝,而<code>Object</code>和<code>Function</code>犹如JavaScript世界中的<strong>亚当</strong>与<strong>夏娃</strong>。</p>\n<h1 id=\"原型指针-proto\"><a href=\"#原型指针-proto\" class=\"headerlink\" title=\"原型指针 __proto__\"></a>原型指针 <code>__proto__</code></h1><p>在JavaScript中，每个对象都拥有一个原型对象，而指向该原型对象的内部指针则是<code>__proto__</code>,通过它可以从中继承原型对象的属性，原型是JavaScript中的基因链接，有了这个，才能知道这个对象的祖祖辈辈。从对象中的<code>__proto__</code>可以访问到他所继承的原型对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">a.__proto__ === <span class=\"built_in\">Array</span>.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，创建了一个Array的实例<code>a</code>，该实例的原型指向了<code>Array.prototype</code>。<br><code>Array.prototype</code>本身也是一个对象，也有继承的原型:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.__proto__.__proto__ === <span class=\"built_in\">Object</span>.prototype  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 等同于 Array.prototype.__proto__ === Object.prototype</span></span><br></pre></td></tr></table></figure>\n<p>这就说了明了，Array本身也是继承自Object的，那么Object的原型指向的是谁呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.__proto__.__proto__.__proto__ === <span class=\"literal\">null</span>  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 等同于 Object.prototype.__proto__ === null</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png\" alt=\"prototype.png\"></p>\n<p>所以说，JavaScript中的对象，追根溯源都是来自一个<strong>null</strong>对象。佛曰：<strong>万物皆空</strong>，善哉善哉。</p>\n<p>除了使用<code>.__proto__</code>方式访问对象的原型，还可以通过<code>Object.getPrototypeOf</code>方法来获取对象的原型，以及通过<code>Object.setPrototypeOf</code>方法来重写对象的原型<br>。<br>值得注意的是，按照语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeof</code>和<code>Object.setPrototypeOf</code>，进行原型对象的读写操作。<br>这里用<code>__proto__</code>属性来描述对象中的原型，是因为这样来得更加形象，且容易理解。</p>\n<h1 id=\"原型对象-prototype\"><a href=\"#原型对象-prototype\" class=\"headerlink\" title=\"原型对象 prototype\"></a>原型对象 <code>prototype</code></h1><p>函数作为JavaScript中的一等公民，它既是函数又是对象，函数的原型指向的是<code>Function.prototype</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Foo.__proto__ === <span class=\"built_in\">Function</span>.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>函数实例除了拥有<code>__proto__</code>属性之外，还拥有<code>prototype</code>属性。<br>通过该函数构造的新的实例对象，其原型指针<code>__proto__</code>会指向该函数的<code>prototype</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">a.__proto__ === Foo.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>而函数的<code>prototype</code>属性，本身是一个由<code>Object</code>构造的实例对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>prototype</code>属性很特殊，它还有一个隐式的<code>constructor</code>，指向了构造函数本身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.prototype.constructor === Foo; <span class=\"comment\">// true</span></span><br><span class=\"line\">a.constructor === Foo; <span class=\"comment\">// true</span></span><br><span class=\"line\">a.constructor === Foo.prototype.constructor; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png\" alt=\"prototype2.png\"></p>\n<h1 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。<br>每个构造函数都有一个原型对象(<code>prototype</code>)，原型对象都包含一个指向构造函数的指针(<code>constructor</code>)，而实例都包含一个指向原型对象的内部指针(<code>__proto__</code>)。<br>那么，假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。<br>如此层层递进，就构造了实例与原型的链条，这就是<strong>原型链</strong>的基本概念。</p>\n<h2 id=\"意义\"><a href=\"#意义\" class=\"headerlink\" title=\"意义\"></a>意义</h2><p>“原型链”的作用在于，当读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。以此类推，如果直到最顶层的Object.prototype还是找不到，则返回undefine</p>\n<h1 id=\"亲子鉴定\"><a href=\"#亲子鉴定\" class=\"headerlink\" title=\"亲子鉴定\"></a>亲子鉴定</h1><p>在JavaScript中，也存在鉴定亲子之间DNA关系的方法：</p>\n<ol>\n<li><strong>instanceof</strong><br>运算符返回一个布尔值，表示一个对象是否由某个构造函数创建。</li>\n<li><strong>Object.isPrototypeOf()</strong><br>只要某个对象处在原型链上，isProtypeOf都返回true</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Bar();</span><br><span class=\"line\">b <span class=\"keyword\">instanceof</span> Bar <span class=\"comment\">// true</span></span><br><span class=\"line\">Bar.prototype.isPrototypeOf(b) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.isPrototypeOf(Bar) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>要注意，实例<code>b</code>的原型是<code>Bar.prototype</code>而不是<code>Bar</code></p>\n<h1 id=\"一张历史悠久的图\"><a href=\"#一张历史悠久的图\" class=\"headerlink\" title=\"一张历史悠久的图\"></a>一张历史悠久的图</h1><p><img src=\"/image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg\" alt=\"jsobj_full.jpg\"></p>\n<p>这是一张描述了<code>Object</code>、<code>Function</code>以及一个函数实例<code>Foo</code>他们之间原型之间联系。如果理解了上面的概念，这张图是不难读懂。</p>\n<p>从上图中，能看到一个有趣的地方。<br><code>Function.prototype.__proto__</code> 指向了 <code>Object.prototype</code>，这说明<code>Function.prototype</code> 是一个 <code>Object</code>实例，那么应当是先有的<code>Object</code>再有<code>Function</code>。<br>但是<code>Object.prototype.constructor.__proto__</code> 又指向了 <code>Function.prototype</code>。这样看来，没有<code>Function</code>，<code>Object</code>也不能创建实例。<br>这就产生了一种类「先有鸡还是先有蛋」的经典问题，到底是先有的<code>Object</code>还是先有的<code>Function</code>呢？<br>这么哲学向的问题，留给你思考了。<br>我只是感慨：<br><strong>越往JavaScript的深处探索，越发觉得这一门语言很哲学。</strong></p>\n<h1 id=\"先有鸡还是先有蛋？\"><a href=\"#先有鸡还是先有蛋？\" class=\"headerlink\" title=\"先有鸡还是先有蛋？\"></a>先有鸡还是先有蛋？</h1><blockquote>\n<p>update on 2017/01/05</p>\n</blockquote>\n<p>时隔半年，偶尔翻开这篇文章。<br>对于这个问题，又有了新的思考。<br>愿意跟能看到这里的你来分享一下。</p>\n<p>我们可以先把 <code>Object.prototype</code> 和 <code>Function.prototype</code> 这两个拎出来看，因为他们本身就是一个实例对象。<br>为方便理解，我们改一下名字，避免和 Object 和 Function 的强关联，分别叫：<code>Op</code> 和 <code>Fp</code></p>\n<p>那么就有这样的原型链存在了 </p>\n<p><img src=\"/image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png\" alt=\"先有鸡还是先有蛋\"></p>\n<p>我再描述一下上面的原型链，先有 null , 再有了 Op , 然后再有了 Fp ，然后以 Fp 为原型的两个构造函数 (Object, Function) 出现了。<br>而作为构造函数，需要有个 prototype 属性用来作为以该构造函数创造的实例的继承。<br>所以Object.prototype = Op, Function.prototype = Fp。</p>\n","excerpt":"","more":"<p>记得当年初试前端的时候，学习JavaScript过程中，原型问题一直让我疑惑许久，那时候捧着那本著名的红皮书，看到有关原型的讲解时，总是心存疑虑。<br>当在JavaScript世界中走过不少旅程之后，再次萌发起研究这部分知识的欲望，翻阅了不少书籍和资料，才搞懂<code>__proto__</code>和<code>prototype</code>的概念。<br>故以作此笔记，日后忘了可以回来看看。<br>如果你看的过程中觉得理解有些困难，把例子在代码中跑一跑，亲手试一试也许能解决不少疑惑。</p>\n<h1 id=\"一切皆为对象\"><a href=\"#一切皆为对象\" class=\"headerlink\" title=\"一切皆为对象\"></a>一切皆为对象</h1><blockquote>\n<p>殊不知，JavaScript的世界中的对象，追根溯源来自于一个 null</p>\n</blockquote>\n<p>「一切皆为对象」，这句着实是一手好营销，易记，易上口，印象深刻。<br>万物初生时，一个<code>null</code>对象，凭空而生，接着<code>Object</code>、<code>Function</code>学着<code>null</code>的模样塑造了自己，并且它们彼此之间喜结连理，提供了<code>prototype</code>和<code>constructor</code>，一个给子孙提供了基因，一个则制造万千子子孙孙。<br>在JavaScript中，<code>null</code>也是作为一个对象存在，基于它继承的子子孙孙，当属对象。<br>乍一看，<code>null</code>像是上帝,而<code>Object</code>和<code>Function</code>犹如JavaScript世界中的<strong>亚当</strong>与<strong>夏娃</strong>。</p>\n<h1 id=\"原型指针-proto\"><a href=\"#原型指针-proto\" class=\"headerlink\" title=\"原型指针 __proto__\"></a>原型指针 <code>__proto__</code></h1><p>在JavaScript中，每个对象都拥有一个原型对象，而指向该原型对象的内部指针则是<code>__proto__</code>,通过它可以从中继承原型对象的属性，原型是JavaScript中的基因链接，有了这个，才能知道这个对象的祖祖辈辈。从对象中的<code>__proto__</code>可以访问到他所继承的原型对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">a.__proto__ === <span class=\"built_in\">Array</span>.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，创建了一个Array的实例<code>a</code>，该实例的原型指向了<code>Array.prototype</code>。<br><code>Array.prototype</code>本身也是一个对象，也有继承的原型:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.__proto__.__proto__ === <span class=\"built_in\">Object</span>.prototype  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 等同于 Array.prototype.__proto__ === Object.prototype</span></span><br></pre></td></tr></table></figure>\n<p>这就说了明了，Array本身也是继承自Object的，那么Object的原型指向的是谁呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.__proto__.__proto__.__proto__ === <span class=\"literal\">null</span>  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 等同于 Object.prototype.__proto__ === null</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png\" alt=\"prototype.png\"></p>\n<p>所以说，JavaScript中的对象，追根溯源都是来自一个<strong>null</strong>对象。佛曰：<strong>万物皆空</strong>，善哉善哉。</p>\n<p>除了使用<code>.__proto__</code>方式访问对象的原型，还可以通过<code>Object.getPrototypeOf</code>方法来获取对象的原型，以及通过<code>Object.setPrototypeOf</code>方法来重写对象的原型<br>。<br>值得注意的是，按照语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeof</code>和<code>Object.setPrototypeOf</code>，进行原型对象的读写操作。<br>这里用<code>__proto__</code>属性来描述对象中的原型，是因为这样来得更加形象，且容易理解。</p>\n<h1 id=\"原型对象-prototype\"><a href=\"#原型对象-prototype\" class=\"headerlink\" title=\"原型对象 prototype\"></a>原型对象 <code>prototype</code></h1><p>函数作为JavaScript中的一等公民，它既是函数又是对象，函数的原型指向的是<code>Function.prototype</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Foo.__proto__ === <span class=\"built_in\">Function</span>.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>函数实例除了拥有<code>__proto__</code>属性之外，还拥有<code>prototype</code>属性。<br>通过该函数构造的新的实例对象，其原型指针<code>__proto__</code>会指向该函数的<code>prototype</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">a.__proto__ === Foo.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>而函数的<code>prototype</code>属性，本身是一个由<code>Object</code>构造的实例对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>prototype</code>属性很特殊，它还有一个隐式的<code>constructor</code>，指向了构造函数本身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.prototype.constructor === Foo; <span class=\"comment\">// true</span></span><br><span class=\"line\">a.constructor === Foo; <span class=\"comment\">// true</span></span><br><span class=\"line\">a.constructor === Foo.prototype.constructor; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png\" alt=\"prototype2.png\"></p>\n<h1 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。<br>每个构造函数都有一个原型对象(<code>prototype</code>)，原型对象都包含一个指向构造函数的指针(<code>constructor</code>)，而实例都包含一个指向原型对象的内部指针(<code>__proto__</code>)。<br>那么，假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。<br>如此层层递进，就构造了实例与原型的链条，这就是<strong>原型链</strong>的基本概念。</p>\n<h2 id=\"意义\"><a href=\"#意义\" class=\"headerlink\" title=\"意义\"></a>意义</h2><p>“原型链”的作用在于，当读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。以此类推，如果直到最顶层的Object.prototype还是找不到，则返回undefine</p>\n<h1 id=\"亲子鉴定\"><a href=\"#亲子鉴定\" class=\"headerlink\" title=\"亲子鉴定\"></a>亲子鉴定</h1><p>在JavaScript中，也存在鉴定亲子之间DNA关系的方法：</p>\n<ol>\n<li><strong>instanceof</strong><br>运算符返回一个布尔值，表示一个对象是否由某个构造函数创建。</li>\n<li><strong>Object.isPrototypeOf()</strong><br>只要某个对象处在原型链上，isProtypeOf都返回true</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Bar();</span><br><span class=\"line\">b <span class=\"keyword\">instanceof</span> Bar <span class=\"comment\">// true</span></span><br><span class=\"line\">Bar.prototype.isPrototypeOf(b) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.isPrototypeOf(Bar) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>要注意，实例<code>b</code>的原型是<code>Bar.prototype</code>而不是<code>Bar</code></p>\n<h1 id=\"一张历史悠久的图\"><a href=\"#一张历史悠久的图\" class=\"headerlink\" title=\"一张历史悠久的图\"></a>一张历史悠久的图</h1><p><img src=\"/image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg\" alt=\"jsobj_full.jpg\"></p>\n<p>这是一张描述了<code>Object</code>、<code>Function</code>以及一个函数实例<code>Foo</code>他们之间原型之间联系。如果理解了上面的概念，这张图是不难读懂。</p>\n<p>从上图中，能看到一个有趣的地方。<br><code>Function.prototype.__proto__</code> 指向了 <code>Object.prototype</code>，这说明<code>Function.prototype</code> 是一个 <code>Object</code>实例，那么应当是先有的<code>Object</code>再有<code>Function</code>。<br>但是<code>Object.prototype.constructor.__proto__</code> 又指向了 <code>Function.prototype</code>。这样看来，没有<code>Function</code>，<code>Object</code>也不能创建实例。<br>这就产生了一种类「先有鸡还是先有蛋」的经典问题，到底是先有的<code>Object</code>还是先有的<code>Function</code>呢？<br>这么哲学向的问题，留给你思考了。<br>我只是感慨：<br><strong>越往JavaScript的深处探索，越发觉得这一门语言很哲学。</strong></p>\n<h1 id=\"先有鸡还是先有蛋？\"><a href=\"#先有鸡还是先有蛋？\" class=\"headerlink\" title=\"先有鸡还是先有蛋？\"></a>先有鸡还是先有蛋？</h1><blockquote>\n<p>update on 2017/01/05</p>\n</blockquote>\n<p>时隔半年，偶尔翻开这篇文章。<br>对于这个问题，又有了新的思考。<br>愿意跟能看到这里的你来分享一下。</p>\n<p>我们可以先把 <code>Object.prototype</code> 和 <code>Function.prototype</code> 这两个拎出来看，因为他们本身就是一个实例对象。<br>为方便理解，我们改一下名字，避免和 Object 和 Function 的强关联，分别叫：<code>Op</code> 和 <code>Fp</code></p>\n<p>那么就有这样的原型链存在了 </p>\n<p><img src=\"/image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png\" alt=\"先有鸡还是先有蛋\"></p>\n<p>我再描述一下上面的原型链，先有 null , 再有了 Op , 然后再有了 Fp ，然后以 Fp 为原型的两个构造函数 (Object, Function) 出现了。<br>而作为构造函数，需要有个 prototype 属性用来作为以该构造函数创造的实例的继承。<br>所以Object.prototype = Op, Function.prototype = Fp。</p>\n"},{"title":"如何构建可控,可靠,可扩展的 PWA 应用","date":"2022-04-20T03:06:27.392Z","_content":"\n# 如何构建可控,可靠,可扩展的 PWA 应用\n\n## 概述\n\nPWA （Progressive Web App）指的是使用指定技术和标准模式来开发的 Web 应用，让 Web 应用具有原生应用的特性和体验。比如我们觉得本地应用使用便捷，响应速度更加快等。\n\nPWA 由 Google 于 2016 年提出，于 2017 年正式技术落地，并在 2018 年迎来重大突破，全球顶级的浏览器厂商，Google、Microsoft、Apple 已经全数宣布支持 PWA 技术。\n\nPWA 的关键技术有两个：\n\n1. Manifest：浏览器允许你提供一个清单文件，从而实现 [A2HS](https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Add_to_home_screen)\n2. ServiceWorker：通过对网络请求的代理，从而实现资源缓存、站点加速、离线应用等场景。\n\n这两个是目前绝大部分开发者构建 PWA 应用所使用的最多的技术。\n\n其次还有诸如：消息推送、WebStream、Web蓝牙、Web分享、硬件访问等API。出于浏览器厂商的支持不一，普及度还不高。\n\n不管怎么样，使用 ServiceWorker 来优化用户体验，已经成为Web前端优化的主流技术。\n\n\n\n## 工具与框架\n\n2018 年之前，主流的工具是：\n\n1. [google/sw-toolbox](https://github.com/GoogleChromeLabs/sw-toolbox): 提供了一套工具，用于方便的构建 ServiceWorker。\n2. [google/sw-precache](https://github.com/GoogleChromeLabs/sw-precache): 提供在构建阶段，注入资源清单到 ServiceWorker 中，从而实现预缓存功能。 \n3. [baidu/Lavas](https://github.com/lavas-project/lavas): 百度开发的基于 Vue 的 PWA 集成解决方案。\n\n后来由于 Google 开发了更加优秀的工具集 [Workbox](https://developers.google.com/web/tools/workbox)，`sw-toolbox` 和 `sw-precache` 得以退出舞台。\n\n而 Lavas 由于团队解散，主要作者离职，已处于停止维护状态。\n\n\n\n## 痛点\n\nWorkbox 提供了一套工具集合，用以帮助我们管理 ServiceWorker ，它对 CacheStorage 的封装，也得以让我们更轻松的去管理资源。\n\n但是在构建实际的 PWA 应用的时候，我们还需要关心很多问题：\n\n1. 如何组织工程和代码？\n2. 如何进行单元测试？\n3. 如何解决 MPA (Multiple Page Application) 应用间的 ServiceWorker 作用域冲突问题？\n4. 如何远程控制我们的 ServiceWorker？\n5. 最优的资源缓存方案？\n6. 如何监控我们的 ServiceWorker，收集数据？\n\n由于 Workbox 的定位是 **「Library」**，而我们需要一个 **「Framework」** 去为这些通用问题提供统一的解决方案。\n\n并且， 我们希望它是渐进式（Progressive）的，就犹如 PWA 所提倡的那样。\n\n\n\n## 代码解耦\n\n**是什么问题？**\n\n当我们的 ServiceWorker 程序代码越来越多的时候，会造成代码臃肿，管理混乱，复用困难。\n同时一些常见的实现，如：远程控制、进程通讯、数据上报等，希望能实现按需插拔式的复用，这样才能达到「渐进式」的目的。\n\n我们都知道，ServiceWorker 在运行时提供了一系列事件，常用的有：\n\n```typescript\nself.addEventListener('install', event => { });\nself.addEventListener('activate', event => { });\nself.addEventListener(\"fetch\", event => { });\nself.addEventListener('message', event => { });\n```\n\n当我们有多个功能实现都要监听相同的事件，就会导致同个文件的代码越来越臃肿：\n\n```typescript\nself.addEventListener('install', event => {\n  // 远程控制模块 - 配置初始化\n  ...\n  // 资源预缓存模块 - 缓存资源\n  ...\n  // 数据上报模块 - 收集事件\n  ...\n});\n  \nself.addEventListener('activate', event => {\n  // 远程控制模块 - 刷新配置\n  ...\n  // 数据上报模块 - 收集事件\n  ...\n});\n  \nself.addEventListener(\"fetch\", event => {\n  // 远程控制模块 - 心跳检查\n  ...\n  // 资源缓存模块 - 缓存匹配\n  ...\n  // 数据上报模块 - 收集事件\n  ...\n});\n\nself.addEventListener('message', event => {\n  // 数据上报模块 - 收集事件\n  ...\n});\n```\n\n你可能会说可以进行「模块化」：\n\n```typescript\nimport remoteController from './remoete-controller.ts';  // 远程控制模块\nimport assetsCache from './assets-cache.ts';  // 资源缓存模块\nimport collector from './collector.ts';  // 数据收集模块\nimport precache from './pre-cache.ts';  // 资源预缓存模块\n\nself.addEventListener('install', event => {\n  // 远程控制模块 - 配置初始化\n  remoteController.init(...);\n  // 资源预缓存模块 - 缓存资源\n  assetsCache.store(...);\n  // 数据上报模块 - 收集事件\n  collector.log(...);\n});\n  \nself.addEventListener('activate', event => {\n  // 远程控制模块 - 刷新配置\n  remoteController.refresh(..);\n  // 数据上报模块 - 收集事件\n  collector.log(...);\n});\n  \nself.addEventListener(\"fetch\", event => {\n  // 远程控制模块 - 心跳检查\n  remoteController.heartbeat(...);\n  // 资源缓存模块 - 缓存匹配\n  assetsCache.match(...);\n  // 数据上报模块 - 收集事件\n  collector.log(...);\n});\n\nself.addEventListener('message', event => {\n  // 数据上报模块 - 收集事件\n  collector.log(...);\n});\n```\n\n模块化能减少主文件的代码量，同时也一定程度上对功能进行了解耦，但是这种方式还存在一些问题：\n\n1. **复用困难**：当要使用一个模块的功能时，要在多个事件中去正确的调用模块的接口。同样，要去掉一个模块事，也要多个事件中去修改。\n2. **使用成本高**：模块暴露各种接口，使用者必须了解透彻模块的运转方式，以及接口的使用，才能很好的使用。\n3. **解耦有限**：如果模块更多，甚至要解决同域名下多个前端应用的命名空间冲突问题，就会显得捉襟见肘。\n\n要达到我们目的：**「渐进式」**，我们需要对代码的组织再优化一下。\n\n\n\n**插件化实现**\n\n我们可以把 ServiceWorker 的一系列事件的控制权交出去，各模块通过插件的方式来使用这些事件。\n\n我们知道 Koa.js 著名的洋葱模型：\n\n![koa洋葱模型](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20200827101330.png)\n\n\n洋葱模型是「插件化」的很好的思想，但是它是 **「一维」** 的，Koa 完成一次网络请求的应答，各个中间件只需要监听一个事件。\n\n而在 ServiceWorker 中，除了上面提及到的常用四个事件，他还有更多事件，如：[`SyncEvent`](https://developer.mozilla.org/en-US/docs/Web/API/SyncEvent), [`NotificationEvent`](https://developer.mozilla.org/en-US/docs/Web/API/NotificationEvent)。\n\n所以，我们还要多弄几个「洋葱」去满足更多的事件。\n\n同时由于 PWA 应用的代码一般会运行在两个线程：主线程、ServiceWorker 线程。\n\n最后，我们去封装原生的事件，去提供插件化支持，从而有了：**「多维洋葱插件系统」**：\n\n\n\n![GlacierJS 多维洋葱插件系统](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204121006999.png)\n\n对原生事件和生命周期进行封装之后，我们为每一个插件提供更优雅的生命周期钩子函数：\n\n![GlacierJS 生命周期图示](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204121158786.png)\n\n我们基于 [GlacierJS](https://jerryc8080.github.io/GlacierJS) 的话，可以很容易做到模块的插件化。\n\n在 ServiceWorker 线程的主文件中注册插件：\n\n```typescript\nimport { GlacierSW } from '@glacierjs/sw';\nimport RemoteController from './remoete-controller.ts';  // 远程控制模块\nimport AssetsCache from './assets-cache.ts';  // 资源缓存模块\nimport Collector from './collector.ts';  // 数据收集模块\nimport Precache from './pre-cache.ts';  // 资源预缓存模块\nimport MyPluginSW from './my-plugin.ts'\n\nconst glacier = new GlacierSW();\n\nglacier.use(new Log(...));\nglacier.use(new RemoteController(...));\nglacier.use(new AssetsCache(...));\nglacier.use(new Collector(...));\nglacier.use(new Precache(...));\n\nglacier.listen();\n```\n\n而在插件中，我们可以通过监听事件去收归一个独立模块的逻辑：\n\n```typescript\nimport { ServiceWorkerPlugin } from '@glacierjs/sw';\nimport type { FetchContext, UseContext  } from '@glacierjs/sw';\n\nexport class MyPluginSW implements ServiceWorkerPlugin {\n    constructor() {...}\n    public async onUse(context: UseContext) {...}\n    public async onInstall(event) {...}\n    public async onActivate() {...}\n    public async onFetch(context: FetchContext) {...}\n    public async onMessage(event) {...}\n    public async onUninstall() {...}\n}\n```\n\n\n\n## 作用域冲突\n\n我们都知道关于 ServiceWorker 的作用域有两个关键特性：\n\n1. **默认的作用域是注册时候的 Path。**\n2. **同个路径下同时间只能有一个 ServiceWorker 得到控制权。**\n\n\n\n**作用域缩小与扩大**\n\n关于第一个特性，例如注册 Service Worker 文件为 `/a/b/sw.js`，则 scope 默认为 `/a/b/`：\n\n```typescript\nif (navigator.serviceWorker) {\n    navigator.serviceWorker.register('/a/b/sw.js').then(function (reg) {\n        console.log(reg.scope);\n        // scope => https://yourhost/a/b/\n    });\n}\n```\n\n当然我们可以在注册的的时候指定 `scope` 去向下缩小作用域，例如：\n\n```typescript\nif (navigator.serviceWorker) {\n    navigator.serviceWorker.register('/a/b/sw.js', {scope: '/a/b/c/'})\n        .then(function (reg) {\n            console.log(reg.scope);\n            // scope => https://yourhost/a/b/c/\n        });\n}\n```\n\n也可以通过服务器对 ServiceWorker 文件的响应设置 `Service-Worker-Allowed` 头部，去扩大作用域。\n\n例如 Google Docs 在作用域 `https://docs.google.com/document/u/0/` 注册了一个来自于 `https://docs.google.com/document/offline/serviceworker.js` 的 ServiceWorker\n\n![img](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204131004508.png)\n\n\n\n**MPA下的 ServiceWorker 治理**\n\n现代 Web App 项目主要有两种架构形式存在： **SPA(Single Page Application)** 和 **MPA(Multiple Page Application)**\n\nMPA 这种架构的模式在现如今的大型 Web App 非常常见，这种 Web App 相比较于 SPA 能够承受更重的业务体量，并且利于大型 Web App 的后期维护和扩展，它往往会有多个团队去维护。\n\n假设我们有一个 MPA 的站点：\n\n```typescript\n.\n|-- app1\n|   |-- app1-service-worker.js\n|   `-- index.html\n|-- app2\n|   `-- index.html\n|-- index.html\n`-- root-service-worker.js\n```\n\n**app1** 和 **app2** 分别由不同的团队维护。\n\n如果我们在根目录 `'/'` 注册了 `root-service-worker.js`，去完成一些通用的功能，例如：「日志收集」、「静态资源缓存」等。\n\n然后 **app1** 团队利用 ServiceWorker 的能力开发了一些特定的功能需要，例如 app1 的「离线化功能」。\n\n他们在 `app1/index.html `目录注册了 `app1-service-worker.js`。\n\n这时候，访问 `app1/*` 下的所有页面，ServiceWorker 控制权会交给 `app1-service-worker.js`，也就是只有app1的「离线化功能」在工作，而原来的「日志收集」、「静态缓存」等功能会失效。\n\n显然这种情况是我们不希望看到的，并且在实际的开发中发生的概率会很大。\n\n\n\n解决这个问题有两种方案：\n\n1. 封装「日志收集」、「静态资源缓存」功能，`app1-service-worker.js`引入并使用这些功能。\n2. 把「离线化功能」整合到 `root-service-worker.js`，只允许注册该 ServiceWorker。\n\n关于方案一，封装通用功能这是正确的，但是主域下的功能可能完全没办法一一拆解，并且后续主域的 ServiceWorker 更新了新功能，子域下的 ServiceWorker 还需要主动去更新和升级。\n\n关于方案二，显然可以解决方案一的问题，但是其他应用，例如 **app2** 可能不需要「离线化功能」。\n\n**基于此，我们引入方案三：功能整合到主域，支持功能的组合按照作用域隔离。**\n\n基于  [GlacierJS](https://jerryc8080.github.io/GlacierJS)  的话代码上可能会是这样的：\n\n```typescript\nconst mainPlugins = [\n  new Collector(); // 日志收集功能\n  new AssetsCache(); // 静态资源缓存功能\n];\n\nglacier.use('/', mainPlugins)；\nglacier.use('/app1', [\n  ...mainPlugins,\n  new Offiline(),  // 离线化功能\n])；\n```\n\n\n\n## 资源缓存\n\nServiceWorker 一个很核心的能力就是能结合 CacheAPI  进行灵活的缓存资源，从而达到优化站点的加载速度、弱网访问、离线应用等。\n\n![image-20220414092525515](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220414092530.png)\n\n对于静态资源有五种常用的缓存策略：\n\n1. **stale-while-revalidate** \n   该模式允许您使用缓存（如果可用）尽快响应请求，如果没有缓存则回退到网络请求，然后使用网络请求来更新缓存，它是一种比较安全的缓存策略。\n2. **cache-first** \n   离线 Web 应用程序将严重依赖缓存，但对于非关键且可以逐渐缓存的资源，**「缓存优先」**是最佳选择。\n   如果缓存中有响应，则将使用缓存的响应来满足请求，并且根本不会使用网络。\n   如果没有缓存响应，则请求将由网络请求完成，然后响应会被缓存，以便下次直接从缓存中提供下一个请求。\n3. **network-first**\n   对于频繁更新的请求，**「网络优先」**策略是理想的解决方案。\n   默认情况下，它会尝试从网络获取最新响应。如果请求成功，它会将响应放入缓存中。如果网络未能返回响应，则将使用缓存的响应。\n4. **network-only**\n   如果您需要从网络满足特定请求，network-only 模式会将资源请求进行透传到网络。\n5. **cache-only**\n   该策略确保从缓存中获取响应。这种场景不太常见，它一般匹配着「预缓存」策略会比较有用。\n\n那这些策略中，我们应该使用哪种呢？答案是根据资源的种类具体选择。\n\n例如一些资源如果只是在 Web 应用发布的时候才会更新，我们就可以使用 cache-first 策略，例如一些 JS、样式、图片等。\n\n而 index.html 作为页面的加载的主入口，更加适宜使用 stale-while-revalidate 策略。\n\n我们以 GlacierJS 的缓存插件（[@glacierjs/plugin-assets-cache](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-assets-cache)）为例：\n\n```typescript\n// in service-worker.js\nimportScripts(\"//cdn.jsdelivr.net/npm/@glacierjs/core/dist/index.min.js\");\nimportScripts('//cdn.jsdelivr.net/npm/@glacierjs/sw/dist/index.min.js');\nimportScripts('//cdn.jsdelivr.net/npm/@glacierjs/plugin-assets-cache/dist/index.min.js');\n\nconst { GlacierSW } = self['@glacierjs/sw'];\nconst { AssetsCacheSW, Strategy } = self['@glacierjs/plugin-assets-cache'];\n\nconst glacierSW = new GlacierSW();\n\nglacierSW.use(new AssetsCacheSW({\n    routes: [{\n        // capture as string: store index.html with stale-while-revalidate strategy.\n        capture: 'https://mysite.com/index.html',\n        strategy: Strategy.STALE_WHILE_REVALIDATE,\n    }, {\n        // capture as RegExp: store all images with cache-first strategy\n        capture: /\\.(png|jpg)$/,\n        strategy: Strategy.CACHE_FIRST\n    }, {\n        // capture as function: store all stylesheet with cache-first strategy\n        capture: ({ request }) => request.destination === 'style',\n        strategy: Strategy.CACHE_FIRST\n    }],\n}));\n```\n\n\n\n## 远程控制\n\n基于 ServiceWorker 的原理，一旦在浏览器安装上了，如果遇到紧急线上问题，唯有发布新的 ServiceWorker 才能解决问题。但是 ServiceWorker 的安装是有时延的，再加上有些团队从修改代码到发布的流程，这个反射弧就很长了。我们有什么办法能缩短对于线上问题的反射弧呢？\n\n**我们可以在远程存储一个配置，针对可预见的场景，进行「远程控制」**：\n\n![remote-controller.drawio](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417015441.png)\n\n**那么我们怎么去获取配置呢？**\n\n**方案一**，如果我们在主线程中获取配置：\n\n1. 需要用户主动刷新页面才会生效。\n2. 做不到轻量的功能关闭，什么意思呢，我们会有开关的场景，主线程只能通过卸载或者清理缓存去实现「关闭」，这个太重了。\n\n**方案二**，如果我们在 ServiceWorker 线程去获取配置：\n\n1. 可以实现轻量功能关闭，透传请求就行了。\n2. 但是如果遇到要干净的清理用户环境的需要，去卸载 ServiceWorker 的时候，就会导致主进程每次注册，到了 ServiceWorker  就卸载，造成频繁安装卸载。\n\n![image-20220417012859191](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417013001.png)\n\n\n\n所以我们的 **最后方案** 是 **「基于双线程的实时配置获取」**。\n\n主线程也要获取配置，然后配置前面要加上防抖保护，防止 **onFetch** 事件短时间并发的问题。\n\n![image-20220417012934418](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417013006.png)\n\n代码上，我们使用 Glacier  的插件 [@glacierjs/plugin-remote-controller](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-remote-controller) 可以轻松实现远程控制：\n\n```typescript\n// in ./remote-controller-sw.ts\nimport { RemoteControllerSW } from '@glacierjs/plugin-remote-controller';\nimport { GlacierSW } from '@glacierjs/sw';\nimport { options } from './options';\n\nconst glacierSW = new GlacierSW();\nglacierSW.use(new RemoteControllerSW({\n  fetchConfig: () => getMyRemoteConfig();\n}));\n\n// 其中 getMyRemoteConfig 用于获取你存在远端的配置，返回的格式规定如下：\nconst getMyRemoteConfig = async () => {\n    const config: RemoteConfig = {\n        // 全局关闭，卸载 ServiceWorker\n        switch: true,\n      \n      \t// 缓存功能开关\n      \tassetsEnable: true,\n\n\t\t\t\t// 精细控制特定缓存\n        assetsCacheRoutes: [{\n            capture: 'https://mysite.com/index.html',\n            strategy: Strategy.STALE_WHILE_REVALIDATE,\n        }],\n    },\n}\n```\n\n\n\n## 数据收集\n\nServiceWorker 发布之后，我们需要保持对线上情况的把控。 对于一些必要的统计指标，我们可能需要进行上统计和上报。\n\n[@glacierjs/plugin-collector](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-collector) 内置了五个常见的数据事件：\n\n1. ServiceWorker 注册：[SW_REGISTER](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_REGISTER)\n2. ServiceWorker 安装成功：[SW_INSTALLED](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_INSTALLED)\n3. ServiceWorker 控制中：[SW_CONTROLLED](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_CONTROLLED)\n4. 命中 onFetch 事件：[SW_FETCH](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_FETCH)\n5. 命中浏览器缓存：[CACHE_HIT](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#CACHE_HIT) of [CacheFrom.Window](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_assets_cache_src.CacheFrom.html#WINDOW)\n6. 命中 CacheAPI 缓存：[CACHE_HIT](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#CACHE_HIT) of [CacheFrom.SW](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_assets_cache_src.CacheFrom.html#SW)\n\n\n\n基于以上数据的收集，我们就可以得到一些常见的通用指标：\n\n1. ServiceWorker 安装率 = SW_REGISTER / SW_INSTALLED\n2. ServiceWorker 控制率 = SW_REGISTER / SW_CONTROLLED\n3. ServiceWorker 缓存命中率 = SW_FETCH / CACHE_HIT (of CacheFrom.SW)\n\n\n\n首先我们在 ServiceWorker 线程中注册 plugin-collector：\n\n```typescript\nimport { AssetsCacheSW } from '@glacierjs/plugin-assets-cache';\nimport { CollectorSW } from '@glacierjs/plugin-collector';\nimport { GlacierSW } from '@glacierjs/sw';\n\nconst glacierSW = new GlacierSW();\n\n// should use plugin-assets-cache first in order to make CollectedDataType.CACHE_HIT work.\nglacierSW.use(new AssetsCacheSW({...}));\nglacierSW.use(new CollectorSW());\n```\n\n然后在主线程中注册 plugin-collector，并且监听数据事件，进行数据上报：\n\n```typescript\nimport {\n  CollectorWindow,\n  CollectedData,\n  CollectedDataType,\n} from '@glacierjs/plugin-collector';\nimport { CacheFrom } from '@glacierjs/plugin-assets-cache';\nimport { GlacierWindow } from '@glacierjs/window';\n\nconst glacierWindow = new GlacierWindow('./service-worker.js');\n\nglacierWindow.use(new CollectorWindow({\n    send(data: CollectedData) {\n      const { type, data } = data;\n\n      switch (type) {\n        case CollectedDataType.SW_REGISTER:\n          myReporter.event('sw-register-count');\n          break;\n\n        case CollectedDataType.SW_INSTALLED:\n          myReporter.event('sw-installed-count');\n          break;\n\n        case CollectedDataType.SW_CONTROLLED:\n          myReporter.event('sw-controlled-count');\n          break;\n\n        case CollectedDataType.SW_FETCH:\n          myReporter.event('sw-fetch-count');\n          break;\n\n        case CollectedDataType.CACHE_HIT:\n          // hit service worker cache\n          if (data?.from === CacheFrom.SW) {\n            myReporter.event(`sw-assets-count:hit-sw-${data?.url}`);\n          }\n\n          // hit browser cache or network\n          if (data?.from === CacheFrom.Window) {\n            myReporter.event(`sw-assets-count:hit-window-${data?.url}`);\n          }\n          break;\n      }\n    },\n}));\n```\n\n其中 `myReporter.event` 是你可能会实现的数据上报库。\n\n\n\n## 单元测试\n\nServiceWorker 测试可以分解为常见的测试组。\n\n![img](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220418092022.png)\n\n\n\n在顶层的是 **「集成测试」**，在这一层，我们检查整体的行为，例如：测试页面可加载，ServiceWorker注册，离线功能等。集成测试是最慢的，但是也是最接近现实情况的。\n\n再往下一层的是 **「浏览器单元测试」**，由于 ServiceWorker 的生命周期，以及一些 API 只有在浏览器环境下才能有，所以我们使用浏览器去进行单元测试，会减少很多环境的问题。\n\n接着是 **「ServiceWorker 单元测试」**，这种测试也是在浏览器环境中注册了测试用的 ServiceWorker 为前提进行的单元测试。\n\n最后一种是 **「模拟 ServiceWorker」**，这种测试粒度会更加精细，精细到某个类某个方法，只检测入参和返回。这意味着没有了浏览器启动成本，并且最终是一种可预测的方式测试代码的方式。\n\n但是模拟 ServiceWorker 是一件困难的事情，如果 mock 的 API 表面不正确，则在集成测试或者浏览器单元测试之前问题不会被发现。我们可以使用 [service-worker-mock](https://www.npmjs.com/package/service-worker-mock) 或者 [MSW](https://github.com/mswjs/msw/issues/170) 在 NodeJS 环境中进行 ServiceWorker 的单元测试。\n\n由于篇幅有限，后续我另开专题来讲讲 ServiceWorker 单元测试的实践。\n\n\n\n## 总结\n\n本文开篇描述了关于 PWA 的基本概念，然后介绍了一些现在社区优秀的工具，以及要去构建一个「可控、可靠、可扩展的 PWA 应用」所面临的的实际的痛点。\n\n于是在三个「可」给出了一些实践性的建议：\n\n1. 通过「数据收集」、「远程控制」保证我们对已发布的 PWA 应用的 **「可控性」**\n2. 通过「单元测试」、「集成测试」去保障我们 PWA 应用的 **「可靠性」**\n3. 通过「多维洋葱插件模型」支持插件化和 MPA 应用，以及整合多个插件，从而达到 PWA 应用的 **「可扩展性」**。\n\n\n\n## 参考\n\n- [《PWA实战：面向下一代的Progressive Web APP》](https://www.amazon.com/PWA%E5%AE%9E%E6%88%98%EF%BC%9A%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84Progressive-Web-Dean-Alan-Hume%EF%BC%88%E8%BF%AA%E6%81%A9%E8%89%BE%E4%BC%A6%E4%BC%91%E5%A7%86%EF%BC%89/dp/B07D4ZSQYP/ref=sr_1_2?keywords=PWA+%E5%AE%9E%E6%88%98&qid=1650419306&sr=8-2)\n- [Service Worker 注册](https://lavas-project.github.io/pwa-book/chapter04/2-service-worker-register.html)\n- [Two HTTP headers related to Service Workers you never may have heard of](https://medium.com/dev-channel/two-http-headers-related-to-service-workers-you-never-may-have-heard-of-c8862f76cc60)\n- [如何优雅的为 PWA 注册 Service Worker](https://zhuanlan.zhihu.com/p/28161855)\n- [Workbox](https://developers.google.com/web/tools/workbox)\n- [GlacierJS - 多维洋葱插件系统](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin)\n- [GlacierJS - 资源缓存](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-assets-cache)\n- [GlacierJS - 远程控制](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-remote-controller)\n- [GlacierJS - 数据收集](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-collector)\n\n","source":"_posts/2022/build-a-extensible-reliable-controllable-PWA-app.md","raw":"---\ntitle: 如何构建可控,可靠,可扩展的 PWA 应用\ncategory: 搬砖码农\ndate: 2022-04-20 09:353:04\ntags: \n- PWA\n---\n\n# 如何构建可控,可靠,可扩展的 PWA 应用\n\n## 概述\n\nPWA （Progressive Web App）指的是使用指定技术和标准模式来开发的 Web 应用，让 Web 应用具有原生应用的特性和体验。比如我们觉得本地应用使用便捷，响应速度更加快等。\n\nPWA 由 Google 于 2016 年提出，于 2017 年正式技术落地，并在 2018 年迎来重大突破，全球顶级的浏览器厂商，Google、Microsoft、Apple 已经全数宣布支持 PWA 技术。\n\nPWA 的关键技术有两个：\n\n1. Manifest：浏览器允许你提供一个清单文件，从而实现 [A2HS](https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Add_to_home_screen)\n2. ServiceWorker：通过对网络请求的代理，从而实现资源缓存、站点加速、离线应用等场景。\n\n这两个是目前绝大部分开发者构建 PWA 应用所使用的最多的技术。\n\n其次还有诸如：消息推送、WebStream、Web蓝牙、Web分享、硬件访问等API。出于浏览器厂商的支持不一，普及度还不高。\n\n不管怎么样，使用 ServiceWorker 来优化用户体验，已经成为Web前端优化的主流技术。\n\n\n\n## 工具与框架\n\n2018 年之前，主流的工具是：\n\n1. [google/sw-toolbox](https://github.com/GoogleChromeLabs/sw-toolbox): 提供了一套工具，用于方便的构建 ServiceWorker。\n2. [google/sw-precache](https://github.com/GoogleChromeLabs/sw-precache): 提供在构建阶段，注入资源清单到 ServiceWorker 中，从而实现预缓存功能。 \n3. [baidu/Lavas](https://github.com/lavas-project/lavas): 百度开发的基于 Vue 的 PWA 集成解决方案。\n\n后来由于 Google 开发了更加优秀的工具集 [Workbox](https://developers.google.com/web/tools/workbox)，`sw-toolbox` 和 `sw-precache` 得以退出舞台。\n\n而 Lavas 由于团队解散，主要作者离职，已处于停止维护状态。\n\n\n\n## 痛点\n\nWorkbox 提供了一套工具集合，用以帮助我们管理 ServiceWorker ，它对 CacheStorage 的封装，也得以让我们更轻松的去管理资源。\n\n但是在构建实际的 PWA 应用的时候，我们还需要关心很多问题：\n\n1. 如何组织工程和代码？\n2. 如何进行单元测试？\n3. 如何解决 MPA (Multiple Page Application) 应用间的 ServiceWorker 作用域冲突问题？\n4. 如何远程控制我们的 ServiceWorker？\n5. 最优的资源缓存方案？\n6. 如何监控我们的 ServiceWorker，收集数据？\n\n由于 Workbox 的定位是 **「Library」**，而我们需要一个 **「Framework」** 去为这些通用问题提供统一的解决方案。\n\n并且， 我们希望它是渐进式（Progressive）的，就犹如 PWA 所提倡的那样。\n\n\n\n## 代码解耦\n\n**是什么问题？**\n\n当我们的 ServiceWorker 程序代码越来越多的时候，会造成代码臃肿，管理混乱，复用困难。\n同时一些常见的实现，如：远程控制、进程通讯、数据上报等，希望能实现按需插拔式的复用，这样才能达到「渐进式」的目的。\n\n我们都知道，ServiceWorker 在运行时提供了一系列事件，常用的有：\n\n```typescript\nself.addEventListener('install', event => { });\nself.addEventListener('activate', event => { });\nself.addEventListener(\"fetch\", event => { });\nself.addEventListener('message', event => { });\n```\n\n当我们有多个功能实现都要监听相同的事件，就会导致同个文件的代码越来越臃肿：\n\n```typescript\nself.addEventListener('install', event => {\n  // 远程控制模块 - 配置初始化\n  ...\n  // 资源预缓存模块 - 缓存资源\n  ...\n  // 数据上报模块 - 收集事件\n  ...\n});\n  \nself.addEventListener('activate', event => {\n  // 远程控制模块 - 刷新配置\n  ...\n  // 数据上报模块 - 收集事件\n  ...\n});\n  \nself.addEventListener(\"fetch\", event => {\n  // 远程控制模块 - 心跳检查\n  ...\n  // 资源缓存模块 - 缓存匹配\n  ...\n  // 数据上报模块 - 收集事件\n  ...\n});\n\nself.addEventListener('message', event => {\n  // 数据上报模块 - 收集事件\n  ...\n});\n```\n\n你可能会说可以进行「模块化」：\n\n```typescript\nimport remoteController from './remoete-controller.ts';  // 远程控制模块\nimport assetsCache from './assets-cache.ts';  // 资源缓存模块\nimport collector from './collector.ts';  // 数据收集模块\nimport precache from './pre-cache.ts';  // 资源预缓存模块\n\nself.addEventListener('install', event => {\n  // 远程控制模块 - 配置初始化\n  remoteController.init(...);\n  // 资源预缓存模块 - 缓存资源\n  assetsCache.store(...);\n  // 数据上报模块 - 收集事件\n  collector.log(...);\n});\n  \nself.addEventListener('activate', event => {\n  // 远程控制模块 - 刷新配置\n  remoteController.refresh(..);\n  // 数据上报模块 - 收集事件\n  collector.log(...);\n});\n  \nself.addEventListener(\"fetch\", event => {\n  // 远程控制模块 - 心跳检查\n  remoteController.heartbeat(...);\n  // 资源缓存模块 - 缓存匹配\n  assetsCache.match(...);\n  // 数据上报模块 - 收集事件\n  collector.log(...);\n});\n\nself.addEventListener('message', event => {\n  // 数据上报模块 - 收集事件\n  collector.log(...);\n});\n```\n\n模块化能减少主文件的代码量，同时也一定程度上对功能进行了解耦，但是这种方式还存在一些问题：\n\n1. **复用困难**：当要使用一个模块的功能时，要在多个事件中去正确的调用模块的接口。同样，要去掉一个模块事，也要多个事件中去修改。\n2. **使用成本高**：模块暴露各种接口，使用者必须了解透彻模块的运转方式，以及接口的使用，才能很好的使用。\n3. **解耦有限**：如果模块更多，甚至要解决同域名下多个前端应用的命名空间冲突问题，就会显得捉襟见肘。\n\n要达到我们目的：**「渐进式」**，我们需要对代码的组织再优化一下。\n\n\n\n**插件化实现**\n\n我们可以把 ServiceWorker 的一系列事件的控制权交出去，各模块通过插件的方式来使用这些事件。\n\n我们知道 Koa.js 著名的洋葱模型：\n\n![koa洋葱模型](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20200827101330.png)\n\n\n洋葱模型是「插件化」的很好的思想，但是它是 **「一维」** 的，Koa 完成一次网络请求的应答，各个中间件只需要监听一个事件。\n\n而在 ServiceWorker 中，除了上面提及到的常用四个事件，他还有更多事件，如：[`SyncEvent`](https://developer.mozilla.org/en-US/docs/Web/API/SyncEvent), [`NotificationEvent`](https://developer.mozilla.org/en-US/docs/Web/API/NotificationEvent)。\n\n所以，我们还要多弄几个「洋葱」去满足更多的事件。\n\n同时由于 PWA 应用的代码一般会运行在两个线程：主线程、ServiceWorker 线程。\n\n最后，我们去封装原生的事件，去提供插件化支持，从而有了：**「多维洋葱插件系统」**：\n\n\n\n![GlacierJS 多维洋葱插件系统](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204121006999.png)\n\n对原生事件和生命周期进行封装之后，我们为每一个插件提供更优雅的生命周期钩子函数：\n\n![GlacierJS 生命周期图示](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204121158786.png)\n\n我们基于 [GlacierJS](https://jerryc8080.github.io/GlacierJS) 的话，可以很容易做到模块的插件化。\n\n在 ServiceWorker 线程的主文件中注册插件：\n\n```typescript\nimport { GlacierSW } from '@glacierjs/sw';\nimport RemoteController from './remoete-controller.ts';  // 远程控制模块\nimport AssetsCache from './assets-cache.ts';  // 资源缓存模块\nimport Collector from './collector.ts';  // 数据收集模块\nimport Precache from './pre-cache.ts';  // 资源预缓存模块\nimport MyPluginSW from './my-plugin.ts'\n\nconst glacier = new GlacierSW();\n\nglacier.use(new Log(...));\nglacier.use(new RemoteController(...));\nglacier.use(new AssetsCache(...));\nglacier.use(new Collector(...));\nglacier.use(new Precache(...));\n\nglacier.listen();\n```\n\n而在插件中，我们可以通过监听事件去收归一个独立模块的逻辑：\n\n```typescript\nimport { ServiceWorkerPlugin } from '@glacierjs/sw';\nimport type { FetchContext, UseContext  } from '@glacierjs/sw';\n\nexport class MyPluginSW implements ServiceWorkerPlugin {\n    constructor() {...}\n    public async onUse(context: UseContext) {...}\n    public async onInstall(event) {...}\n    public async onActivate() {...}\n    public async onFetch(context: FetchContext) {...}\n    public async onMessage(event) {...}\n    public async onUninstall() {...}\n}\n```\n\n\n\n## 作用域冲突\n\n我们都知道关于 ServiceWorker 的作用域有两个关键特性：\n\n1. **默认的作用域是注册时候的 Path。**\n2. **同个路径下同时间只能有一个 ServiceWorker 得到控制权。**\n\n\n\n**作用域缩小与扩大**\n\n关于第一个特性，例如注册 Service Worker 文件为 `/a/b/sw.js`，则 scope 默认为 `/a/b/`：\n\n```typescript\nif (navigator.serviceWorker) {\n    navigator.serviceWorker.register('/a/b/sw.js').then(function (reg) {\n        console.log(reg.scope);\n        // scope => https://yourhost/a/b/\n    });\n}\n```\n\n当然我们可以在注册的的时候指定 `scope` 去向下缩小作用域，例如：\n\n```typescript\nif (navigator.serviceWorker) {\n    navigator.serviceWorker.register('/a/b/sw.js', {scope: '/a/b/c/'})\n        .then(function (reg) {\n            console.log(reg.scope);\n            // scope => https://yourhost/a/b/c/\n        });\n}\n```\n\n也可以通过服务器对 ServiceWorker 文件的响应设置 `Service-Worker-Allowed` 头部，去扩大作用域。\n\n例如 Google Docs 在作用域 `https://docs.google.com/document/u/0/` 注册了一个来自于 `https://docs.google.com/document/offline/serviceworker.js` 的 ServiceWorker\n\n![img](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204131004508.png)\n\n\n\n**MPA下的 ServiceWorker 治理**\n\n现代 Web App 项目主要有两种架构形式存在： **SPA(Single Page Application)** 和 **MPA(Multiple Page Application)**\n\nMPA 这种架构的模式在现如今的大型 Web App 非常常见，这种 Web App 相比较于 SPA 能够承受更重的业务体量，并且利于大型 Web App 的后期维护和扩展，它往往会有多个团队去维护。\n\n假设我们有一个 MPA 的站点：\n\n```typescript\n.\n|-- app1\n|   |-- app1-service-worker.js\n|   `-- index.html\n|-- app2\n|   `-- index.html\n|-- index.html\n`-- root-service-worker.js\n```\n\n**app1** 和 **app2** 分别由不同的团队维护。\n\n如果我们在根目录 `'/'` 注册了 `root-service-worker.js`，去完成一些通用的功能，例如：「日志收集」、「静态资源缓存」等。\n\n然后 **app1** 团队利用 ServiceWorker 的能力开发了一些特定的功能需要，例如 app1 的「离线化功能」。\n\n他们在 `app1/index.html `目录注册了 `app1-service-worker.js`。\n\n这时候，访问 `app1/*` 下的所有页面，ServiceWorker 控制权会交给 `app1-service-worker.js`，也就是只有app1的「离线化功能」在工作，而原来的「日志收集」、「静态缓存」等功能会失效。\n\n显然这种情况是我们不希望看到的，并且在实际的开发中发生的概率会很大。\n\n\n\n解决这个问题有两种方案：\n\n1. 封装「日志收集」、「静态资源缓存」功能，`app1-service-worker.js`引入并使用这些功能。\n2. 把「离线化功能」整合到 `root-service-worker.js`，只允许注册该 ServiceWorker。\n\n关于方案一，封装通用功能这是正确的，但是主域下的功能可能完全没办法一一拆解，并且后续主域的 ServiceWorker 更新了新功能，子域下的 ServiceWorker 还需要主动去更新和升级。\n\n关于方案二，显然可以解决方案一的问题，但是其他应用，例如 **app2** 可能不需要「离线化功能」。\n\n**基于此，我们引入方案三：功能整合到主域，支持功能的组合按照作用域隔离。**\n\n基于  [GlacierJS](https://jerryc8080.github.io/GlacierJS)  的话代码上可能会是这样的：\n\n```typescript\nconst mainPlugins = [\n  new Collector(); // 日志收集功能\n  new AssetsCache(); // 静态资源缓存功能\n];\n\nglacier.use('/', mainPlugins)；\nglacier.use('/app1', [\n  ...mainPlugins,\n  new Offiline(),  // 离线化功能\n])；\n```\n\n\n\n## 资源缓存\n\nServiceWorker 一个很核心的能力就是能结合 CacheAPI  进行灵活的缓存资源，从而达到优化站点的加载速度、弱网访问、离线应用等。\n\n![image-20220414092525515](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220414092530.png)\n\n对于静态资源有五种常用的缓存策略：\n\n1. **stale-while-revalidate** \n   该模式允许您使用缓存（如果可用）尽快响应请求，如果没有缓存则回退到网络请求，然后使用网络请求来更新缓存，它是一种比较安全的缓存策略。\n2. **cache-first** \n   离线 Web 应用程序将严重依赖缓存，但对于非关键且可以逐渐缓存的资源，**「缓存优先」**是最佳选择。\n   如果缓存中有响应，则将使用缓存的响应来满足请求，并且根本不会使用网络。\n   如果没有缓存响应，则请求将由网络请求完成，然后响应会被缓存，以便下次直接从缓存中提供下一个请求。\n3. **network-first**\n   对于频繁更新的请求，**「网络优先」**策略是理想的解决方案。\n   默认情况下，它会尝试从网络获取最新响应。如果请求成功，它会将响应放入缓存中。如果网络未能返回响应，则将使用缓存的响应。\n4. **network-only**\n   如果您需要从网络满足特定请求，network-only 模式会将资源请求进行透传到网络。\n5. **cache-only**\n   该策略确保从缓存中获取响应。这种场景不太常见，它一般匹配着「预缓存」策略会比较有用。\n\n那这些策略中，我们应该使用哪种呢？答案是根据资源的种类具体选择。\n\n例如一些资源如果只是在 Web 应用发布的时候才会更新，我们就可以使用 cache-first 策略，例如一些 JS、样式、图片等。\n\n而 index.html 作为页面的加载的主入口，更加适宜使用 stale-while-revalidate 策略。\n\n我们以 GlacierJS 的缓存插件（[@glacierjs/plugin-assets-cache](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-assets-cache)）为例：\n\n```typescript\n// in service-worker.js\nimportScripts(\"//cdn.jsdelivr.net/npm/@glacierjs/core/dist/index.min.js\");\nimportScripts('//cdn.jsdelivr.net/npm/@glacierjs/sw/dist/index.min.js');\nimportScripts('//cdn.jsdelivr.net/npm/@glacierjs/plugin-assets-cache/dist/index.min.js');\n\nconst { GlacierSW } = self['@glacierjs/sw'];\nconst { AssetsCacheSW, Strategy } = self['@glacierjs/plugin-assets-cache'];\n\nconst glacierSW = new GlacierSW();\n\nglacierSW.use(new AssetsCacheSW({\n    routes: [{\n        // capture as string: store index.html with stale-while-revalidate strategy.\n        capture: 'https://mysite.com/index.html',\n        strategy: Strategy.STALE_WHILE_REVALIDATE,\n    }, {\n        // capture as RegExp: store all images with cache-first strategy\n        capture: /\\.(png|jpg)$/,\n        strategy: Strategy.CACHE_FIRST\n    }, {\n        // capture as function: store all stylesheet with cache-first strategy\n        capture: ({ request }) => request.destination === 'style',\n        strategy: Strategy.CACHE_FIRST\n    }],\n}));\n```\n\n\n\n## 远程控制\n\n基于 ServiceWorker 的原理，一旦在浏览器安装上了，如果遇到紧急线上问题，唯有发布新的 ServiceWorker 才能解决问题。但是 ServiceWorker 的安装是有时延的，再加上有些团队从修改代码到发布的流程，这个反射弧就很长了。我们有什么办法能缩短对于线上问题的反射弧呢？\n\n**我们可以在远程存储一个配置，针对可预见的场景，进行「远程控制」**：\n\n![remote-controller.drawio](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417015441.png)\n\n**那么我们怎么去获取配置呢？**\n\n**方案一**，如果我们在主线程中获取配置：\n\n1. 需要用户主动刷新页面才会生效。\n2. 做不到轻量的功能关闭，什么意思呢，我们会有开关的场景，主线程只能通过卸载或者清理缓存去实现「关闭」，这个太重了。\n\n**方案二**，如果我们在 ServiceWorker 线程去获取配置：\n\n1. 可以实现轻量功能关闭，透传请求就行了。\n2. 但是如果遇到要干净的清理用户环境的需要，去卸载 ServiceWorker 的时候，就会导致主进程每次注册，到了 ServiceWorker  就卸载，造成频繁安装卸载。\n\n![image-20220417012859191](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417013001.png)\n\n\n\n所以我们的 **最后方案** 是 **「基于双线程的实时配置获取」**。\n\n主线程也要获取配置，然后配置前面要加上防抖保护，防止 **onFetch** 事件短时间并发的问题。\n\n![image-20220417012934418](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417013006.png)\n\n代码上，我们使用 Glacier  的插件 [@glacierjs/plugin-remote-controller](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-remote-controller) 可以轻松实现远程控制：\n\n```typescript\n// in ./remote-controller-sw.ts\nimport { RemoteControllerSW } from '@glacierjs/plugin-remote-controller';\nimport { GlacierSW } from '@glacierjs/sw';\nimport { options } from './options';\n\nconst glacierSW = new GlacierSW();\nglacierSW.use(new RemoteControllerSW({\n  fetchConfig: () => getMyRemoteConfig();\n}));\n\n// 其中 getMyRemoteConfig 用于获取你存在远端的配置，返回的格式规定如下：\nconst getMyRemoteConfig = async () => {\n    const config: RemoteConfig = {\n        // 全局关闭，卸载 ServiceWorker\n        switch: true,\n      \n      \t// 缓存功能开关\n      \tassetsEnable: true,\n\n\t\t\t\t// 精细控制特定缓存\n        assetsCacheRoutes: [{\n            capture: 'https://mysite.com/index.html',\n            strategy: Strategy.STALE_WHILE_REVALIDATE,\n        }],\n    },\n}\n```\n\n\n\n## 数据收集\n\nServiceWorker 发布之后，我们需要保持对线上情况的把控。 对于一些必要的统计指标，我们可能需要进行上统计和上报。\n\n[@glacierjs/plugin-collector](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-collector) 内置了五个常见的数据事件：\n\n1. ServiceWorker 注册：[SW_REGISTER](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_REGISTER)\n2. ServiceWorker 安装成功：[SW_INSTALLED](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_INSTALLED)\n3. ServiceWorker 控制中：[SW_CONTROLLED](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_CONTROLLED)\n4. 命中 onFetch 事件：[SW_FETCH](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_FETCH)\n5. 命中浏览器缓存：[CACHE_HIT](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#CACHE_HIT) of [CacheFrom.Window](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_assets_cache_src.CacheFrom.html#WINDOW)\n6. 命中 CacheAPI 缓存：[CACHE_HIT](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#CACHE_HIT) of [CacheFrom.SW](https://jerryc8080.github.io/GlacierJS/api/enums/plugin_assets_cache_src.CacheFrom.html#SW)\n\n\n\n基于以上数据的收集，我们就可以得到一些常见的通用指标：\n\n1. ServiceWorker 安装率 = SW_REGISTER / SW_INSTALLED\n2. ServiceWorker 控制率 = SW_REGISTER / SW_CONTROLLED\n3. ServiceWorker 缓存命中率 = SW_FETCH / CACHE_HIT (of CacheFrom.SW)\n\n\n\n首先我们在 ServiceWorker 线程中注册 plugin-collector：\n\n```typescript\nimport { AssetsCacheSW } from '@glacierjs/plugin-assets-cache';\nimport { CollectorSW } from '@glacierjs/plugin-collector';\nimport { GlacierSW } from '@glacierjs/sw';\n\nconst glacierSW = new GlacierSW();\n\n// should use plugin-assets-cache first in order to make CollectedDataType.CACHE_HIT work.\nglacierSW.use(new AssetsCacheSW({...}));\nglacierSW.use(new CollectorSW());\n```\n\n然后在主线程中注册 plugin-collector，并且监听数据事件，进行数据上报：\n\n```typescript\nimport {\n  CollectorWindow,\n  CollectedData,\n  CollectedDataType,\n} from '@glacierjs/plugin-collector';\nimport { CacheFrom } from '@glacierjs/plugin-assets-cache';\nimport { GlacierWindow } from '@glacierjs/window';\n\nconst glacierWindow = new GlacierWindow('./service-worker.js');\n\nglacierWindow.use(new CollectorWindow({\n    send(data: CollectedData) {\n      const { type, data } = data;\n\n      switch (type) {\n        case CollectedDataType.SW_REGISTER:\n          myReporter.event('sw-register-count');\n          break;\n\n        case CollectedDataType.SW_INSTALLED:\n          myReporter.event('sw-installed-count');\n          break;\n\n        case CollectedDataType.SW_CONTROLLED:\n          myReporter.event('sw-controlled-count');\n          break;\n\n        case CollectedDataType.SW_FETCH:\n          myReporter.event('sw-fetch-count');\n          break;\n\n        case CollectedDataType.CACHE_HIT:\n          // hit service worker cache\n          if (data?.from === CacheFrom.SW) {\n            myReporter.event(`sw-assets-count:hit-sw-${data?.url}`);\n          }\n\n          // hit browser cache or network\n          if (data?.from === CacheFrom.Window) {\n            myReporter.event(`sw-assets-count:hit-window-${data?.url}`);\n          }\n          break;\n      }\n    },\n}));\n```\n\n其中 `myReporter.event` 是你可能会实现的数据上报库。\n\n\n\n## 单元测试\n\nServiceWorker 测试可以分解为常见的测试组。\n\n![img](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220418092022.png)\n\n\n\n在顶层的是 **「集成测试」**，在这一层，我们检查整体的行为，例如：测试页面可加载，ServiceWorker注册，离线功能等。集成测试是最慢的，但是也是最接近现实情况的。\n\n再往下一层的是 **「浏览器单元测试」**，由于 ServiceWorker 的生命周期，以及一些 API 只有在浏览器环境下才能有，所以我们使用浏览器去进行单元测试，会减少很多环境的问题。\n\n接着是 **「ServiceWorker 单元测试」**，这种测试也是在浏览器环境中注册了测试用的 ServiceWorker 为前提进行的单元测试。\n\n最后一种是 **「模拟 ServiceWorker」**，这种测试粒度会更加精细，精细到某个类某个方法，只检测入参和返回。这意味着没有了浏览器启动成本，并且最终是一种可预测的方式测试代码的方式。\n\n但是模拟 ServiceWorker 是一件困难的事情，如果 mock 的 API 表面不正确，则在集成测试或者浏览器单元测试之前问题不会被发现。我们可以使用 [service-worker-mock](https://www.npmjs.com/package/service-worker-mock) 或者 [MSW](https://github.com/mswjs/msw/issues/170) 在 NodeJS 环境中进行 ServiceWorker 的单元测试。\n\n由于篇幅有限，后续我另开专题来讲讲 ServiceWorker 单元测试的实践。\n\n\n\n## 总结\n\n本文开篇描述了关于 PWA 的基本概念，然后介绍了一些现在社区优秀的工具，以及要去构建一个「可控、可靠、可扩展的 PWA 应用」所面临的的实际的痛点。\n\n于是在三个「可」给出了一些实践性的建议：\n\n1. 通过「数据收集」、「远程控制」保证我们对已发布的 PWA 应用的 **「可控性」**\n2. 通过「单元测试」、「集成测试」去保障我们 PWA 应用的 **「可靠性」**\n3. 通过「多维洋葱插件模型」支持插件化和 MPA 应用，以及整合多个插件，从而达到 PWA 应用的 **「可扩展性」**。\n\n\n\n## 参考\n\n- [《PWA实战：面向下一代的Progressive Web APP》](https://www.amazon.com/PWA%E5%AE%9E%E6%88%98%EF%BC%9A%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84Progressive-Web-Dean-Alan-Hume%EF%BC%88%E8%BF%AA%E6%81%A9%E8%89%BE%E4%BC%A6%E4%BC%91%E5%A7%86%EF%BC%89/dp/B07D4ZSQYP/ref=sr_1_2?keywords=PWA+%E5%AE%9E%E6%88%98&qid=1650419306&sr=8-2)\n- [Service Worker 注册](https://lavas-project.github.io/pwa-book/chapter04/2-service-worker-register.html)\n- [Two HTTP headers related to Service Workers you never may have heard of](https://medium.com/dev-channel/two-http-headers-related-to-service-workers-you-never-may-have-heard-of-c8862f76cc60)\n- [如何优雅的为 PWA 注册 Service Worker](https://zhuanlan.zhihu.com/p/28161855)\n- [Workbox](https://developers.google.com/web/tools/workbox)\n- [GlacierJS - 多维洋葱插件系统](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin)\n- [GlacierJS - 资源缓存](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-assets-cache)\n- [GlacierJS - 远程控制](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-remote-controller)\n- [GlacierJS - 数据收集](https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-collector)\n\n","slug":"2022/build-a-extensible-reliable-controllable-PWA-app","published":1,"updated":"2022-04-20T03:46:27.769Z","_id":"cl2717vlr0000x1rl499igfbq","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"如何构建可控-可靠-可扩展的-PWA-应用\"><a href=\"#如何构建可控-可靠-可扩展的-PWA-应用\" class=\"headerlink\" title=\"如何构建可控,可靠,可扩展的 PWA 应用\"></a>如何构建可控,可靠,可扩展的 PWA 应用</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>PWA （Progressive Web App）指的是使用指定技术和标准模式来开发的 Web 应用，让 Web 应用具有原生应用的特性和体验。比如我们觉得本地应用使用便捷，响应速度更加快等。</p>\n<p>PWA 由 Google 于 2016 年提出，于 2017 年正式技术落地，并在 2018 年迎来重大突破，全球顶级的浏览器厂商，Google、Microsoft、Apple 已经全数宣布支持 PWA 技术。</p>\n<p>PWA 的关键技术有两个：</p>\n<ol>\n<li>Manifest：浏览器允许你提供一个清单文件，从而实现 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Add_to_home_screen\">A2HS</a></li>\n<li>ServiceWorker：通过对网络请求的代理，从而实现资源缓存、站点加速、离线应用等场景。</li>\n</ol>\n<p>这两个是目前绝大部分开发者构建 PWA 应用所使用的最多的技术。</p>\n<p>其次还有诸如：消息推送、WebStream、Web蓝牙、Web分享、硬件访问等API。出于浏览器厂商的支持不一，普及度还不高。</p>\n<p>不管怎么样，使用 ServiceWorker 来优化用户体验，已经成为Web前端优化的主流技术。</p>\n<h2 id=\"工具与框架\"><a href=\"#工具与框架\" class=\"headerlink\" title=\"工具与框架\"></a>工具与框架</h2><p>2018 年之前，主流的工具是：</p>\n<ol>\n<li><a href=\"https://github.com/GoogleChromeLabs/sw-toolbox\">google&#x2F;sw-toolbox</a>: 提供了一套工具，用于方便的构建 ServiceWorker。</li>\n<li><a href=\"https://github.com/GoogleChromeLabs/sw-precache\">google&#x2F;sw-precache</a>: 提供在构建阶段，注入资源清单到 ServiceWorker 中，从而实现预缓存功能。 </li>\n<li><a href=\"https://github.com/lavas-project/lavas\">baidu&#x2F;Lavas</a>: 百度开发的基于 Vue 的 PWA 集成解决方案。</li>\n</ol>\n<p>后来由于 Google 开发了更加优秀的工具集 <a href=\"https://developers.google.com/web/tools/workbox\">Workbox</a>，<code>sw-toolbox</code> 和 <code>sw-precache</code> 得以退出舞台。</p>\n<p>而 Lavas 由于团队解散，主要作者离职，已处于停止维护状态。</p>\n<h2 id=\"痛点\"><a href=\"#痛点\" class=\"headerlink\" title=\"痛点\"></a>痛点</h2><p>Workbox 提供了一套工具集合，用以帮助我们管理 ServiceWorker ，它对 CacheStorage 的封装，也得以让我们更轻松的去管理资源。</p>\n<p>但是在构建实际的 PWA 应用的时候，我们还需要关心很多问题：</p>\n<ol>\n<li>如何组织工程和代码？</li>\n<li>如何进行单元测试？</li>\n<li>如何解决 MPA (Multiple Page Application) 应用间的 ServiceWorker 作用域冲突问题？</li>\n<li>如何远程控制我们的 ServiceWorker？</li>\n<li>最优的资源缓存方案？</li>\n<li>如何监控我们的 ServiceWorker，收集数据？</li>\n</ol>\n<p>由于 Workbox 的定位是 <strong>「Library」</strong>，而我们需要一个 <strong>「Framework」</strong> 去为这些通用问题提供统一的解决方案。</p>\n<p>并且， 我们希望它是渐进式（Progressive）的，就犹如 PWA 所提倡的那样。</p>\n<h2 id=\"代码解耦\"><a href=\"#代码解耦\" class=\"headerlink\" title=\"代码解耦\"></a>代码解耦</h2><p><strong>是什么问题？</strong></p>\n<p>当我们的 ServiceWorker 程序代码越来越多的时候，会造成代码臃肿，管理混乱，复用困难。<br>同时一些常见的实现，如：远程控制、进程通讯、数据上报等，希望能实现按需插拔式的复用，这样才能达到「渐进式」的目的。</p>\n<p>我们都知道，ServiceWorker 在运行时提供了一系列事件，常用的有：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123; &#125;);</span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;activate&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123; &#125;);</span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;fetch&quot;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123; &#125;);</span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123; &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>当我们有多个功能实现都要监听相同的事件，就会导致同个文件的代码越来越臃肿：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程控制模块 - 配置初始化</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 资源预缓存模块 - 缓存资源</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;activate&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程控制模块 - 刷新配置</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;fetch&quot;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程控制模块 - 心跳检查</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 资源缓存模块 - 缓存匹配</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>你可能会说可以进行「模块化」：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> remoteController <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./remoete-controller.ts&#x27;</span>;  <span class=\"comment\">// 远程控制模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> assetsCache <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./assets-cache.ts&#x27;</span>;  <span class=\"comment\">// 资源缓存模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> collector <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./collector.ts&#x27;</span>;  <span class=\"comment\">// 数据收集模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> precache <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./pre-cache.ts&#x27;</span>;  <span class=\"comment\">// 资源预缓存模块</span></span><br><span class=\"line\"></span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程控制模块 - 配置初始化</span></span><br><span class=\"line\">  remoteController.<span class=\"title function_\">init</span>(...);</span><br><span class=\"line\">  <span class=\"comment\">// 资源预缓存模块 - 缓存资源</span></span><br><span class=\"line\">  assetsCache.<span class=\"title function_\">store</span>(...);</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  collector.<span class=\"title function_\">log</span>(...);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;activate&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程控制模块 - 刷新配置</span></span><br><span class=\"line\">  remoteController.<span class=\"title function_\">refresh</span>(..);</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  collector.<span class=\"title function_\">log</span>(...);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;fetch&quot;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程控制模块 - 心跳检查</span></span><br><span class=\"line\">  remoteController.<span class=\"title function_\">heartbeat</span>(...);</span><br><span class=\"line\">  <span class=\"comment\">// 资源缓存模块 - 缓存匹配</span></span><br><span class=\"line\">  assetsCache.<span class=\"title function_\">match</span>(...);</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  collector.<span class=\"title function_\">log</span>(...);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  collector.<span class=\"title function_\">log</span>(...);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>模块化能减少主文件的代码量，同时也一定程度上对功能进行了解耦，但是这种方式还存在一些问题：</p>\n<ol>\n<li><strong>复用困难</strong>：当要使用一个模块的功能时，要在多个事件中去正确的调用模块的接口。同样，要去掉一个模块事，也要多个事件中去修改。</li>\n<li><strong>使用成本高</strong>：模块暴露各种接口，使用者必须了解透彻模块的运转方式，以及接口的使用，才能很好的使用。</li>\n<li><strong>解耦有限</strong>：如果模块更多，甚至要解决同域名下多个前端应用的命名空间冲突问题，就会显得捉襟见肘。</li>\n</ol>\n<p>要达到我们目的：<strong>「渐进式」</strong>，我们需要对代码的组织再优化一下。</p>\n<p><strong>插件化实现</strong></p>\n<p>我们可以把 ServiceWorker 的一系列事件的控制权交出去，各模块通过插件的方式来使用这些事件。</p>\n<p>我们知道 Koa.js 著名的洋葱模型：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20200827101330.png\" alt=\"koa洋葱模型\"></p>\n<p>洋葱模型是「插件化」的很好的思想，但是它是 <strong>「一维」</strong> 的，Koa 完成一次网络请求的应答，各个中间件只需要监听一个事件。</p>\n<p>而在 ServiceWorker 中，除了上面提及到的常用四个事件，他还有更多事件，如：<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/SyncEvent\"><code>SyncEvent</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/NotificationEvent\"><code>NotificationEvent</code></a>。</p>\n<p>所以，我们还要多弄几个「洋葱」去满足更多的事件。</p>\n<p>同时由于 PWA 应用的代码一般会运行在两个线程：主线程、ServiceWorker 线程。</p>\n<p>最后，我们去封装原生的事件，去提供插件化支持，从而有了：<strong>「多维洋葱插件系统」</strong>：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204121006999.png\" alt=\"GlacierJS 多维洋葱插件系统\"></p>\n<p>对原生事件和生命周期进行封装之后，我们为每一个插件提供更优雅的生命周期钩子函数：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204121158786.png\" alt=\"GlacierJS 生命周期图示\"></p>\n<p>我们基于 <a href=\"https://jerryc8080.github.io/GlacierJS\">GlacierJS</a> 的话，可以很容易做到模块的插件化。</p>\n<p>在 ServiceWorker 线程的主文件中注册插件：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">GlacierSW</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/sw&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">RemoteController</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./remoete-controller.ts&#x27;</span>;  <span class=\"comment\">// 远程控制模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">AssetsCache</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./assets-cache.ts&#x27;</span>;  <span class=\"comment\">// 资源缓存模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Collector</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./collector.ts&#x27;</span>;  <span class=\"comment\">// 数据收集模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Precache</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./pre-cache.ts&#x27;</span>;  <span class=\"comment\">// 资源预缓存模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">MyPluginSW</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./my-plugin.ts&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> glacier = <span class=\"keyword\">new</span> <span class=\"title class_\">GlacierSW</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Log</span>(...));</span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">RemoteController</span>(...));</span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">AssetsCache</span>(...));</span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Collector</span>(...));</span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Precache</span>(...));</span><br><span class=\"line\"></span><br><span class=\"line\">glacier.<span class=\"title function_\">listen</span>();</span><br></pre></td></tr></table></figure>\n\n<p>而在插件中，我们可以通过监听事件去收归一个独立模块的逻辑：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ServiceWorkerPlugin</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/sw&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">type</span> &#123; <span class=\"title class_\">FetchContext</span>, <span class=\"title class_\">UseContext</span>  &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/sw&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyPluginSW</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ServiceWorkerPlugin</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">async</span> <span class=\"title function_\">onUse</span>(<span class=\"params\">context: UseContext</span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">async</span> <span class=\"title function_\">onInstall</span>(<span class=\"params\">event</span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">async</span> <span class=\"title function_\">onActivate</span>(<span class=\"params\"></span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">async</span> <span class=\"title function_\">onFetch</span>(<span class=\"params\">context: FetchContext</span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">async</span> <span class=\"title function_\">onMessage</span>(<span class=\"params\">event</span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">async</span> <span class=\"title function_\">onUninstall</span>(<span class=\"params\"></span>) &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"作用域冲突\"><a href=\"#作用域冲突\" class=\"headerlink\" title=\"作用域冲突\"></a>作用域冲突</h2><p>我们都知道关于 ServiceWorker 的作用域有两个关键特性：</p>\n<ol>\n<li><strong>默认的作用域是注册时候的 Path。</strong></li>\n<li><strong>同个路径下同时间只能有一个 ServiceWorker 得到控制权。</strong></li>\n</ol>\n<p><strong>作用域缩小与扩大</strong></p>\n<p>关于第一个特性，例如注册 Service Worker 文件为 <code>/a/b/sw.js</code>，则 scope 默认为 <code>/a/b/</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (navigator.<span class=\"property\">serviceWorker</span>) &#123;</span><br><span class=\"line\">    navigator.<span class=\"property\">serviceWorker</span>.<span class=\"title function_\">register</span>(<span class=\"string\">&#x27;/a/b/sw.js&#x27;</span>).<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">reg</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(reg.<span class=\"property\">scope</span>);</span><br><span class=\"line\">        <span class=\"comment\">// scope =&gt; https://yourhost/a/b/</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然我们可以在注册的的时候指定 <code>scope</code> 去向下缩小作用域，例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (navigator.<span class=\"property\">serviceWorker</span>) &#123;</span><br><span class=\"line\">    navigator.<span class=\"property\">serviceWorker</span>.<span class=\"title function_\">register</span>(<span class=\"string\">&#x27;/a/b/sw.js&#x27;</span>, &#123;<span class=\"attr\">scope</span>: <span class=\"string\">&#x27;/a/b/c/&#x27;</span>&#125;)</span><br><span class=\"line\">        .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">reg</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(reg.<span class=\"property\">scope</span>);</span><br><span class=\"line\">            <span class=\"comment\">// scope =&gt; https://yourhost/a/b/c/</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以通过服务器对 ServiceWorker 文件的响应设置 <code>Service-Worker-Allowed</code> 头部，去扩大作用域。</p>\n<p>例如 Google Docs 在作用域 <code>https://docs.google.com/document/u/0/</code> 注册了一个来自于 <code>https://docs.google.com/document/offline/serviceworker.js</code> 的 ServiceWorker</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204131004508.png\" alt=\"img\"></p>\n<p><strong>MPA下的 ServiceWorker 治理</strong></p>\n<p>现代 Web App 项目主要有两种架构形式存在： <strong>SPA(Single Page Application)</strong> 和 <strong>MPA(Multiple Page Application)</strong></p>\n<p>MPA 这种架构的模式在现如今的大型 Web App 非常常见，这种 Web App 相比较于 SPA 能够承受更重的业务体量，并且利于大型 Web App 的后期维护和扩展，它往往会有多个团队去维护。</p>\n<p>假设我们有一个 MPA 的站点：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">|-- app1</span><br><span class=\"line\">|   |-- app1-service-worker.<span class=\"property\">js</span></span><br><span class=\"line\">|   <span class=\"string\">`-- index.html</span></span><br><span class=\"line\"><span class=\"string\">|-- app2</span></span><br><span class=\"line\"><span class=\"string\">|   `</span>-- index.<span class=\"property\">html</span></span><br><span class=\"line\">|-- index.<span class=\"property\">html</span></span><br><span class=\"line\"><span class=\"string\">`-- root-service-worker.js</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>app1</strong> 和 <strong>app2</strong> 分别由不同的团队维护。</p>\n<p>如果我们在根目录 <code>&#39;/&#39;</code> 注册了 <code>root-service-worker.js</code>，去完成一些通用的功能，例如：「日志收集」、「静态资源缓存」等。</p>\n<p>然后 <strong>app1</strong> 团队利用 ServiceWorker 的能力开发了一些特定的功能需要，例如 app1 的「离线化功能」。</p>\n<p>他们在 <code>app1/index.html </code>目录注册了 <code>app1-service-worker.js</code>。</p>\n<p>这时候，访问 <code>app1/*</code> 下的所有页面，ServiceWorker 控制权会交给 <code>app1-service-worker.js</code>，也就是只有app1的「离线化功能」在工作，而原来的「日志收集」、「静态缓存」等功能会失效。</p>\n<p>显然这种情况是我们不希望看到的，并且在实际的开发中发生的概率会很大。</p>\n<p>解决这个问题有两种方案：</p>\n<ol>\n<li>封装「日志收集」、「静态资源缓存」功能，<code>app1-service-worker.js</code>引入并使用这些功能。</li>\n<li>把「离线化功能」整合到 <code>root-service-worker.js</code>，只允许注册该 ServiceWorker。</li>\n</ol>\n<p>关于方案一，封装通用功能这是正确的，但是主域下的功能可能完全没办法一一拆解，并且后续主域的 ServiceWorker 更新了新功能，子域下的 ServiceWorker 还需要主动去更新和升级。</p>\n<p>关于方案二，显然可以解决方案一的问题，但是其他应用，例如 <strong>app2</strong> 可能不需要「离线化功能」。</p>\n<p><strong>基于此，我们引入方案三：功能整合到主域，支持功能的组合按照作用域隔离。</strong></p>\n<p>基于  <a href=\"https://jerryc8080.github.io/GlacierJS\">GlacierJS</a>  的话代码上可能会是这样的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mainPlugins = [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">Collector</span>(); <span class=\"comment\">// 日志收集功能</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">AssetsCache</span>(); <span class=\"comment\">// 静态资源缓存功能</span></span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"string\">&#x27;/&#x27;</span>, mainPlugins)；</span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"string\">&#x27;/app1&#x27;</span>, [</span><br><span class=\"line\">  ...mainPlugins,</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">Offiline</span>(),  <span class=\"comment\">// 离线化功能</span></span><br><span class=\"line\">])；</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"资源缓存\"><a href=\"#资源缓存\" class=\"headerlink\" title=\"资源缓存\"></a>资源缓存</h2><p>ServiceWorker 一个很核心的能力就是能结合 CacheAPI  进行灵活的缓存资源，从而达到优化站点的加载速度、弱网访问、离线应用等。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220414092530.png\" alt=\"image-20220414092525515\"></p>\n<p>对于静态资源有五种常用的缓存策略：</p>\n<ol>\n<li><strong>stale-while-revalidate</strong><br>该模式允许您使用缓存（如果可用）尽快响应请求，如果没有缓存则回退到网络请求，然后使用网络请求来更新缓存，它是一种比较安全的缓存策略。</li>\n<li><strong>cache-first</strong><br>离线 Web 应用程序将严重依赖缓存，但对于非关键且可以逐渐缓存的资源，<strong>「缓存优先」</strong>是最佳选择。<br>如果缓存中有响应，则将使用缓存的响应来满足请求，并且根本不会使用网络。<br>如果没有缓存响应，则请求将由网络请求完成，然后响应会被缓存，以便下次直接从缓存中提供下一个请求。</li>\n<li><strong>network-first</strong><br>对于频繁更新的请求，<strong>「网络优先」</strong>策略是理想的解决方案。<br>默认情况下，它会尝试从网络获取最新响应。如果请求成功，它会将响应放入缓存中。如果网络未能返回响应，则将使用缓存的响应。</li>\n<li><strong>network-only</strong><br>如果您需要从网络满足特定请求，network-only 模式会将资源请求进行透传到网络。</li>\n<li><strong>cache-only</strong><br>该策略确保从缓存中获取响应。这种场景不太常见，它一般匹配着「预缓存」策略会比较有用。</li>\n</ol>\n<p>那这些策略中，我们应该使用哪种呢？答案是根据资源的种类具体选择。</p>\n<p>例如一些资源如果只是在 Web 应用发布的时候才会更新，我们就可以使用 cache-first 策略，例如一些 JS、样式、图片等。</p>\n<p>而 index.html 作为页面的加载的主入口，更加适宜使用 stale-while-revalidate 策略。</p>\n<p>我们以 GlacierJS 的缓存插件（<a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-assets-cache\">@glacierjs&#x2F;plugin-assets-cache</a>）为例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in service-worker.js</span></span><br><span class=\"line\"><span class=\"title function_\">importScripts</span>(<span class=\"string\">&quot;//cdn.jsdelivr.net/npm/@glacierjs/core/dist/index.min.js&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">importScripts</span>(<span class=\"string\">&#x27;//cdn.jsdelivr.net/npm/@glacierjs/sw/dist/index.min.js&#x27;</span>);</span><br><span class=\"line\"><span class=\"title function_\">importScripts</span>(<span class=\"string\">&#x27;//cdn.jsdelivr.net/npm/@glacierjs/plugin-assets-cache/dist/index.min.js&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">GlacierSW</span> &#125; = self[<span class=\"string\">&#x27;@glacierjs/sw&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">AssetsCacheSW</span>, <span class=\"title class_\">Strategy</span> &#125; = self[<span class=\"string\">&#x27;@glacierjs/plugin-assets-cache&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> glacierSW = <span class=\"keyword\">new</span> <span class=\"title class_\">GlacierSW</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">glacierSW.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">AssetsCacheSW</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">routes</span>: [&#123;</span><br><span class=\"line\">        <span class=\"comment\">// capture as string: store index.html with stale-while-revalidate strategy.</span></span><br><span class=\"line\">        <span class=\"attr\">capture</span>: <span class=\"string\">&#x27;https://mysite.com/index.html&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">strategy</span>: <span class=\"title class_\">Strategy</span>.<span class=\"property\">STALE_WHILE_REVALIDATE</span>,</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        <span class=\"comment\">// capture as RegExp: store all images with cache-first strategy</span></span><br><span class=\"line\">        <span class=\"attr\">capture</span>: <span class=\"regexp\">/\\.(png|jpg)$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">strategy</span>: <span class=\"title class_\">Strategy</span>.<span class=\"property\">CACHE_FIRST</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        <span class=\"comment\">// capture as function: store all stylesheet with cache-first strategy</span></span><br><span class=\"line\">        <span class=\"attr\">capture</span>: <span class=\"function\">(<span class=\"params\">&#123; request &#125;</span>) =&gt;</span> request.<span class=\"property\">destination</span> === <span class=\"string\">&#x27;style&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">strategy</span>: <span class=\"title class_\">Strategy</span>.<span class=\"property\">CACHE_FIRST</span></span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"远程控制\"><a href=\"#远程控制\" class=\"headerlink\" title=\"远程控制\"></a>远程控制</h2><p>基于 ServiceWorker 的原理，一旦在浏览器安装上了，如果遇到紧急线上问题，唯有发布新的 ServiceWorker 才能解决问题。但是 ServiceWorker 的安装是有时延的，再加上有些团队从修改代码到发布的流程，这个反射弧就很长了。我们有什么办法能缩短对于线上问题的反射弧呢？</p>\n<p><strong>我们可以在远程存储一个配置，针对可预见的场景，进行「远程控制」</strong>：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417015441.png\" alt=\"remote-controller.drawio\"></p>\n<p><strong>那么我们怎么去获取配置呢？</strong></p>\n<p><strong>方案一</strong>，如果我们在主线程中获取配置：</p>\n<ol>\n<li>需要用户主动刷新页面才会生效。</li>\n<li>做不到轻量的功能关闭，什么意思呢，我们会有开关的场景，主线程只能通过卸载或者清理缓存去实现「关闭」，这个太重了。</li>\n</ol>\n<p><strong>方案二</strong>，如果我们在 ServiceWorker 线程去获取配置：</p>\n<ol>\n<li>可以实现轻量功能关闭，透传请求就行了。</li>\n<li>但是如果遇到要干净的清理用户环境的需要，去卸载 ServiceWorker 的时候，就会导致主进程每次注册，到了 ServiceWorker  就卸载，造成频繁安装卸载。</li>\n</ol>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417013001.png\" alt=\"image-20220417012859191\"></p>\n<p>所以我们的 <strong>最后方案</strong> 是 <strong>「基于双线程的实时配置获取」</strong>。</p>\n<p>主线程也要获取配置，然后配置前面要加上防抖保护，防止 <strong>onFetch</strong> 事件短时间并发的问题。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417013006.png\" alt=\"image-20220417012934418\"></p>\n<p>代码上，我们使用 Glacier  的插件 <a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-remote-controller\">@glacierjs&#x2F;plugin-remote-controller</a> 可以轻松实现远程控制：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in ./remote-controller-sw.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">RemoteControllerSW</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/plugin-remote-controller&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">GlacierSW</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/sw&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; options &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./options&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> glacierSW = <span class=\"keyword\">new</span> <span class=\"title class_\">GlacierSW</span>();</span><br><span class=\"line\">glacierSW.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">RemoteControllerSW</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">fetchConfig</span>: <span class=\"function\">() =&gt;</span> <span class=\"title function_\">getMyRemoteConfig</span>();</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其中 getMyRemoteConfig 用于获取你存在远端的配置，返回的格式规定如下：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getMyRemoteConfig</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">config</span>: <span class=\"title class_\">RemoteConfig</span> = &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 全局关闭，卸载 ServiceWorker</span></span><br><span class=\"line\">        <span class=\"attr\">switch</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      </span><br><span class=\"line\">      \t<span class=\"comment\">// 缓存功能开关</span></span><br><span class=\"line\">      \t<span class=\"attr\">assetsEnable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 精细控制特定缓存</span></span><br><span class=\"line\">        <span class=\"attr\">assetsCacheRoutes</span>: [&#123;</span><br><span class=\"line\">            <span class=\"attr\">capture</span>: <span class=\"string\">&#x27;https://mysite.com/index.html&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">strategy</span>: <span class=\"title class_\">Strategy</span>.<span class=\"property\">STALE_WHILE_REVALIDATE</span>,</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"数据收集\"><a href=\"#数据收集\" class=\"headerlink\" title=\"数据收集\"></a>数据收集</h2><p>ServiceWorker 发布之后，我们需要保持对线上情况的把控。 对于一些必要的统计指标，我们可能需要进行上统计和上报。</p>\n<p><a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-collector\">@glacierjs&#x2F;plugin-collector</a> 内置了五个常见的数据事件：</p>\n<ol>\n<li>ServiceWorker 注册：<a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_REGISTER\">SW_REGISTER</a></li>\n<li>ServiceWorker 安装成功：<a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_INSTALLED\">SW_INSTALLED</a></li>\n<li>ServiceWorker 控制中：<a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_CONTROLLED\">SW_CONTROLLED</a></li>\n<li>命中 onFetch 事件：<a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_FETCH\">SW_FETCH</a></li>\n<li>命中浏览器缓存：<a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#CACHE_HIT\">CACHE_HIT</a> of <a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_assets_cache_src.CacheFrom.html#WINDOW\">CacheFrom.Window</a></li>\n<li>命中 CacheAPI 缓存：<a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#CACHE_HIT\">CACHE_HIT</a> of <a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_assets_cache_src.CacheFrom.html#SW\">CacheFrom.SW</a></li>\n</ol>\n<p>基于以上数据的收集，我们就可以得到一些常见的通用指标：</p>\n<ol>\n<li>ServiceWorker 安装率 &#x3D; SW_REGISTER &#x2F; SW_INSTALLED</li>\n<li>ServiceWorker 控制率 &#x3D; SW_REGISTER &#x2F; SW_CONTROLLED</li>\n<li>ServiceWorker 缓存命中率 &#x3D; SW_FETCH &#x2F; CACHE_HIT (of CacheFrom.SW)</li>\n</ol>\n<p>首先我们在 ServiceWorker 线程中注册 plugin-collector：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AssetsCacheSW</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/plugin-assets-cache&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CollectorSW</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/plugin-collector&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">GlacierSW</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/sw&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> glacierSW = <span class=\"keyword\">new</span> <span class=\"title class_\">GlacierSW</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// should use plugin-assets-cache first in order to make CollectedDataType.CACHE_HIT work.</span></span><br><span class=\"line\">glacierSW.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">AssetsCacheSW</span>(&#123;...&#125;));</span><br><span class=\"line\">glacierSW.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CollectorSW</span>());</span><br></pre></td></tr></table></figure>\n\n<p>然后在主线程中注册 plugin-collector，并且监听数据事件，进行数据上报：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">CollectorWindow</span>,</span><br><span class=\"line\">  <span class=\"title class_\">CollectedData</span>,</span><br><span class=\"line\">  <span class=\"title class_\">CollectedDataType</span>,</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/plugin-collector&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CacheFrom</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/plugin-assets-cache&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">GlacierWindow</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/window&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> glacierWindow = <span class=\"keyword\">new</span> <span class=\"title class_\">GlacierWindow</span>(<span class=\"string\">&#x27;./service-worker.js&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">glacierWindow.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CollectorWindow</span>(&#123;</span><br><span class=\"line\">    <span class=\"title function_\">send</span>(<span class=\"params\">data: CollectedData</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">type</span>, data &#125; = data;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">CollectedDataType</span>.<span class=\"property\">SW_REGISTER</span>:</span><br><span class=\"line\">          myReporter.<span class=\"title function_\">event</span>(<span class=\"string\">&#x27;sw-register-count&#x27;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">CollectedDataType</span>.<span class=\"property\">SW_INSTALLED</span>:</span><br><span class=\"line\">          myReporter.<span class=\"title function_\">event</span>(<span class=\"string\">&#x27;sw-installed-count&#x27;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">CollectedDataType</span>.<span class=\"property\">SW_CONTROLLED</span>:</span><br><span class=\"line\">          myReporter.<span class=\"title function_\">event</span>(<span class=\"string\">&#x27;sw-controlled-count&#x27;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">CollectedDataType</span>.<span class=\"property\">SW_FETCH</span>:</span><br><span class=\"line\">          myReporter.<span class=\"title function_\">event</span>(<span class=\"string\">&#x27;sw-fetch-count&#x27;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">CollectedDataType</span>.<span class=\"property\">CACHE_HIT</span>:</span><br><span class=\"line\">          <span class=\"comment\">// hit service worker cache</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (data?.<span class=\"property\">from</span> === <span class=\"title class_\">CacheFrom</span>.<span class=\"property\">SW</span>) &#123;</span><br><span class=\"line\">            myReporter.<span class=\"title function_\">event</span>(<span class=\"string\">`sw-assets-count:hit-sw-<span class=\"subst\">$&#123;data?.url&#125;</span>`</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// hit browser cache or network</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (data?.<span class=\"property\">from</span> === <span class=\"title class_\">CacheFrom</span>.<span class=\"property\">Window</span>) &#123;</span><br><span class=\"line\">            myReporter.<span class=\"title function_\">event</span>(<span class=\"string\">`sw-assets-count:hit-window-<span class=\"subst\">$&#123;data?.url&#125;</span>`</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>myReporter.event</code> 是你可能会实现的数据上报库。</p>\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><p>ServiceWorker 测试可以分解为常见的测试组。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220418092022.png\" alt=\"img\"></p>\n<p>在顶层的是 <strong>「集成测试」</strong>，在这一层，我们检查整体的行为，例如：测试页面可加载，ServiceWorker注册，离线功能等。集成测试是最慢的，但是也是最接近现实情况的。</p>\n<p>再往下一层的是 <strong>「浏览器单元测试」</strong>，由于 ServiceWorker 的生命周期，以及一些 API 只有在浏览器环境下才能有，所以我们使用浏览器去进行单元测试，会减少很多环境的问题。</p>\n<p>接着是 <strong>「ServiceWorker 单元测试」</strong>，这种测试也是在浏览器环境中注册了测试用的 ServiceWorker 为前提进行的单元测试。</p>\n<p>最后一种是 <strong>「模拟 ServiceWorker」</strong>，这种测试粒度会更加精细，精细到某个类某个方法，只检测入参和返回。这意味着没有了浏览器启动成本，并且最终是一种可预测的方式测试代码的方式。</p>\n<p>但是模拟 ServiceWorker 是一件困难的事情，如果 mock 的 API 表面不正确，则在集成测试或者浏览器单元测试之前问题不会被发现。我们可以使用 <a href=\"https://www.npmjs.com/package/service-worker-mock\">service-worker-mock</a> 或者 <a href=\"https://github.com/mswjs/msw/issues/170\">MSW</a> 在 NodeJS 环境中进行 ServiceWorker 的单元测试。</p>\n<p>由于篇幅有限，后续我另开专题来讲讲 ServiceWorker 单元测试的实践。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文开篇描述了关于 PWA 的基本概念，然后介绍了一些现在社区优秀的工具，以及要去构建一个「可控、可靠、可扩展的 PWA 应用」所面临的的实际的痛点。</p>\n<p>于是在三个「可」给出了一些实践性的建议：</p>\n<ol>\n<li>通过「数据收集」、「远程控制」保证我们对已发布的 PWA 应用的 <strong>「可控性」</strong></li>\n<li>通过「单元测试」、「集成测试」去保障我们 PWA 应用的 <strong>「可靠性」</strong></li>\n<li>通过「多维洋葱插件模型」支持插件化和 MPA 应用，以及整合多个插件，从而达到 PWA 应用的 <strong>「可扩展性」</strong>。</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.amazon.com/PWA%E5%AE%9E%E6%88%98%EF%BC%9A%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84Progressive-Web-Dean-Alan-Hume%EF%BC%88%E8%BF%AA%E6%81%A9%E8%89%BE%E4%BC%A6%E4%BC%91%E5%A7%86%EF%BC%89/dp/B07D4ZSQYP/ref=sr_1_2?keywords=PWA+%E5%AE%9E%E6%88%98&qid=1650419306&sr=8-2\">《PWA实战：面向下一代的Progressive Web APP》</a></li>\n<li><a href=\"https://lavas-project.github.io/pwa-book/chapter04/2-service-worker-register.html\">Service Worker 注册</a></li>\n<li><a href=\"https://medium.com/dev-channel/two-http-headers-related-to-service-workers-you-never-may-have-heard-of-c8862f76cc60\">Two HTTP headers related to Service Workers you never may have heard of</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28161855\">如何优雅的为 PWA 注册 Service Worker</a></li>\n<li><a href=\"https://developers.google.com/web/tools/workbox\">Workbox</a></li>\n<li><a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin\">GlacierJS - 多维洋葱插件系统</a></li>\n<li><a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-assets-cache\">GlacierJS - 资源缓存</a></li>\n<li><a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-remote-controller\">GlacierJS - 远程控制</a></li>\n<li><a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-collector\">GlacierJS - 数据收集</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"如何构建可控-可靠-可扩展的-PWA-应用\"><a href=\"#如何构建可控-可靠-可扩展的-PWA-应用\" class=\"headerlink\" title=\"如何构建可控,可靠,可扩展的 PWA 应用\"></a>如何构建可控,可靠,可扩展的 PWA 应用</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>PWA （Progressive Web App）指的是使用指定技术和标准模式来开发的 Web 应用，让 Web 应用具有原生应用的特性和体验。比如我们觉得本地应用使用便捷，响应速度更加快等。</p>\n<p>PWA 由 Google 于 2016 年提出，于 2017 年正式技术落地，并在 2018 年迎来重大突破，全球顶级的浏览器厂商，Google、Microsoft、Apple 已经全数宣布支持 PWA 技术。</p>\n<p>PWA 的关键技术有两个：</p>\n<ol>\n<li>Manifest：浏览器允许你提供一个清单文件，从而实现 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Add_to_home_screen\">A2HS</a></li>\n<li>ServiceWorker：通过对网络请求的代理，从而实现资源缓存、站点加速、离线应用等场景。</li>\n</ol>\n<p>这两个是目前绝大部分开发者构建 PWA 应用所使用的最多的技术。</p>\n<p>其次还有诸如：消息推送、WebStream、Web蓝牙、Web分享、硬件访问等API。出于浏览器厂商的支持不一，普及度还不高。</p>\n<p>不管怎么样，使用 ServiceWorker 来优化用户体验，已经成为Web前端优化的主流技术。</p>\n<h2 id=\"工具与框架\"><a href=\"#工具与框架\" class=\"headerlink\" title=\"工具与框架\"></a>工具与框架</h2><p>2018 年之前，主流的工具是：</p>\n<ol>\n<li><a href=\"https://github.com/GoogleChromeLabs/sw-toolbox\">google&#x2F;sw-toolbox</a>: 提供了一套工具，用于方便的构建 ServiceWorker。</li>\n<li><a href=\"https://github.com/GoogleChromeLabs/sw-precache\">google&#x2F;sw-precache</a>: 提供在构建阶段，注入资源清单到 ServiceWorker 中，从而实现预缓存功能。 </li>\n<li><a href=\"https://github.com/lavas-project/lavas\">baidu&#x2F;Lavas</a>: 百度开发的基于 Vue 的 PWA 集成解决方案。</li>\n</ol>\n<p>后来由于 Google 开发了更加优秀的工具集 <a href=\"https://developers.google.com/web/tools/workbox\">Workbox</a>，<code>sw-toolbox</code> 和 <code>sw-precache</code> 得以退出舞台。</p>\n<p>而 Lavas 由于团队解散，主要作者离职，已处于停止维护状态。</p>\n<h2 id=\"痛点\"><a href=\"#痛点\" class=\"headerlink\" title=\"痛点\"></a>痛点</h2><p>Workbox 提供了一套工具集合，用以帮助我们管理 ServiceWorker ，它对 CacheStorage 的封装，也得以让我们更轻松的去管理资源。</p>\n<p>但是在构建实际的 PWA 应用的时候，我们还需要关心很多问题：</p>\n<ol>\n<li>如何组织工程和代码？</li>\n<li>如何进行单元测试？</li>\n<li>如何解决 MPA (Multiple Page Application) 应用间的 ServiceWorker 作用域冲突问题？</li>\n<li>如何远程控制我们的 ServiceWorker？</li>\n<li>最优的资源缓存方案？</li>\n<li>如何监控我们的 ServiceWorker，收集数据？</li>\n</ol>\n<p>由于 Workbox 的定位是 <strong>「Library」</strong>，而我们需要一个 <strong>「Framework」</strong> 去为这些通用问题提供统一的解决方案。</p>\n<p>并且， 我们希望它是渐进式（Progressive）的，就犹如 PWA 所提倡的那样。</p>\n<h2 id=\"代码解耦\"><a href=\"#代码解耦\" class=\"headerlink\" title=\"代码解耦\"></a>代码解耦</h2><p><strong>是什么问题？</strong></p>\n<p>当我们的 ServiceWorker 程序代码越来越多的时候，会造成代码臃肿，管理混乱，复用困难。<br>同时一些常见的实现，如：远程控制、进程通讯、数据上报等，希望能实现按需插拔式的复用，这样才能达到「渐进式」的目的。</p>\n<p>我们都知道，ServiceWorker 在运行时提供了一系列事件，常用的有：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123; &#125;);</span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;activate&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123; &#125;);</span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;fetch&quot;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123; &#125;);</span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123; &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>当我们有多个功能实现都要监听相同的事件，就会导致同个文件的代码越来越臃肿：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程控制模块 - 配置初始化</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 资源预缓存模块 - 缓存资源</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;activate&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程控制模块 - 刷新配置</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;fetch&quot;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程控制模块 - 心跳检查</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 资源缓存模块 - 缓存匹配</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>你可能会说可以进行「模块化」：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> remoteController <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./remoete-controller.ts&#x27;</span>;  <span class=\"comment\">// 远程控制模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> assetsCache <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./assets-cache.ts&#x27;</span>;  <span class=\"comment\">// 资源缓存模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> collector <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./collector.ts&#x27;</span>;  <span class=\"comment\">// 数据收集模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> precache <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./pre-cache.ts&#x27;</span>;  <span class=\"comment\">// 资源预缓存模块</span></span><br><span class=\"line\"></span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;install&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程控制模块 - 配置初始化</span></span><br><span class=\"line\">  remoteController.<span class=\"title function_\">init</span>(...);</span><br><span class=\"line\">  <span class=\"comment\">// 资源预缓存模块 - 缓存资源</span></span><br><span class=\"line\">  assetsCache.<span class=\"title function_\">store</span>(...);</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  collector.<span class=\"title function_\">log</span>(...);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;activate&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程控制模块 - 刷新配置</span></span><br><span class=\"line\">  remoteController.<span class=\"title function_\">refresh</span>(..);</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  collector.<span class=\"title function_\">log</span>(...);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;fetch&quot;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 远程控制模块 - 心跳检查</span></span><br><span class=\"line\">  remoteController.<span class=\"title function_\">heartbeat</span>(...);</span><br><span class=\"line\">  <span class=\"comment\">// 资源缓存模块 - 缓存匹配</span></span><br><span class=\"line\">  assetsCache.<span class=\"title function_\">match</span>(...);</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  collector.<span class=\"title function_\">log</span>(...);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 数据上报模块 - 收集事件</span></span><br><span class=\"line\">  collector.<span class=\"title function_\">log</span>(...);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>模块化能减少主文件的代码量，同时也一定程度上对功能进行了解耦，但是这种方式还存在一些问题：</p>\n<ol>\n<li><strong>复用困难</strong>：当要使用一个模块的功能时，要在多个事件中去正确的调用模块的接口。同样，要去掉一个模块事，也要多个事件中去修改。</li>\n<li><strong>使用成本高</strong>：模块暴露各种接口，使用者必须了解透彻模块的运转方式，以及接口的使用，才能很好的使用。</li>\n<li><strong>解耦有限</strong>：如果模块更多，甚至要解决同域名下多个前端应用的命名空间冲突问题，就会显得捉襟见肘。</li>\n</ol>\n<p>要达到我们目的：<strong>「渐进式」</strong>，我们需要对代码的组织再优化一下。</p>\n<p><strong>插件化实现</strong></p>\n<p>我们可以把 ServiceWorker 的一系列事件的控制权交出去，各模块通过插件的方式来使用这些事件。</p>\n<p>我们知道 Koa.js 著名的洋葱模型：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20200827101330.png\" alt=\"koa洋葱模型\"></p>\n<p>洋葱模型是「插件化」的很好的思想，但是它是 <strong>「一维」</strong> 的，Koa 完成一次网络请求的应答，各个中间件只需要监听一个事件。</p>\n<p>而在 ServiceWorker 中，除了上面提及到的常用四个事件，他还有更多事件，如：<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/SyncEvent\"><code>SyncEvent</code></a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/NotificationEvent\"><code>NotificationEvent</code></a>。</p>\n<p>所以，我们还要多弄几个「洋葱」去满足更多的事件。</p>\n<p>同时由于 PWA 应用的代码一般会运行在两个线程：主线程、ServiceWorker 线程。</p>\n<p>最后，我们去封装原生的事件，去提供插件化支持，从而有了：<strong>「多维洋葱插件系统」</strong>：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204121006999.png\" alt=\"GlacierJS 多维洋葱插件系统\"></p>\n<p>对原生事件和生命周期进行封装之后，我们为每一个插件提供更优雅的生命周期钩子函数：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204121158786.png\" alt=\"GlacierJS 生命周期图示\"></p>\n<p>我们基于 <a href=\"https://jerryc8080.github.io/GlacierJS\">GlacierJS</a> 的话，可以很容易做到模块的插件化。</p>\n<p>在 ServiceWorker 线程的主文件中注册插件：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">GlacierSW</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/sw&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">RemoteController</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./remoete-controller.ts&#x27;</span>;  <span class=\"comment\">// 远程控制模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">AssetsCache</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./assets-cache.ts&#x27;</span>;  <span class=\"comment\">// 资源缓存模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Collector</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./collector.ts&#x27;</span>;  <span class=\"comment\">// 数据收集模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Precache</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./pre-cache.ts&#x27;</span>;  <span class=\"comment\">// 资源预缓存模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">MyPluginSW</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./my-plugin.ts&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> glacier = <span class=\"keyword\">new</span> <span class=\"title class_\">GlacierSW</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Log</span>(...));</span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">RemoteController</span>(...));</span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">AssetsCache</span>(...));</span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Collector</span>(...));</span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Precache</span>(...));</span><br><span class=\"line\"></span><br><span class=\"line\">glacier.<span class=\"title function_\">listen</span>();</span><br></pre></td></tr></table></figure>\n\n<p>而在插件中，我们可以通过监听事件去收归一个独立模块的逻辑：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ServiceWorkerPlugin</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/sw&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">type</span> &#123; <span class=\"title class_\">FetchContext</span>, <span class=\"title class_\">UseContext</span>  &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/sw&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyPluginSW</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ServiceWorkerPlugin</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">async</span> <span class=\"title function_\">onUse</span>(<span class=\"params\">context: UseContext</span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">async</span> <span class=\"title function_\">onInstall</span>(<span class=\"params\">event</span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">async</span> <span class=\"title function_\">onActivate</span>(<span class=\"params\"></span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">async</span> <span class=\"title function_\">onFetch</span>(<span class=\"params\">context: FetchContext</span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">async</span> <span class=\"title function_\">onMessage</span>(<span class=\"params\">event</span>) &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">async</span> <span class=\"title function_\">onUninstall</span>(<span class=\"params\"></span>) &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"作用域冲突\"><a href=\"#作用域冲突\" class=\"headerlink\" title=\"作用域冲突\"></a>作用域冲突</h2><p>我们都知道关于 ServiceWorker 的作用域有两个关键特性：</p>\n<ol>\n<li><strong>默认的作用域是注册时候的 Path。</strong></li>\n<li><strong>同个路径下同时间只能有一个 ServiceWorker 得到控制权。</strong></li>\n</ol>\n<p><strong>作用域缩小与扩大</strong></p>\n<p>关于第一个特性，例如注册 Service Worker 文件为 <code>/a/b/sw.js</code>，则 scope 默认为 <code>/a/b/</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (navigator.<span class=\"property\">serviceWorker</span>) &#123;</span><br><span class=\"line\">    navigator.<span class=\"property\">serviceWorker</span>.<span class=\"title function_\">register</span>(<span class=\"string\">&#x27;/a/b/sw.js&#x27;</span>).<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">reg</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(reg.<span class=\"property\">scope</span>);</span><br><span class=\"line\">        <span class=\"comment\">// scope =&gt; https://yourhost/a/b/</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然我们可以在注册的的时候指定 <code>scope</code> 去向下缩小作用域，例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (navigator.<span class=\"property\">serviceWorker</span>) &#123;</span><br><span class=\"line\">    navigator.<span class=\"property\">serviceWorker</span>.<span class=\"title function_\">register</span>(<span class=\"string\">&#x27;/a/b/sw.js&#x27;</span>, &#123;<span class=\"attr\">scope</span>: <span class=\"string\">&#x27;/a/b/c/&#x27;</span>&#125;)</span><br><span class=\"line\">        .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">reg</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(reg.<span class=\"property\">scope</span>);</span><br><span class=\"line\">            <span class=\"comment\">// scope =&gt; https://yourhost/a/b/c/</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以通过服务器对 ServiceWorker 文件的响应设置 <code>Service-Worker-Allowed</code> 头部，去扩大作用域。</p>\n<p>例如 Google Docs 在作用域 <code>https://docs.google.com/document/u/0/</code> 注册了一个来自于 <code>https://docs.google.com/document/offline/serviceworker.js</code> 的 ServiceWorker</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204131004508.png\" alt=\"img\"></p>\n<p><strong>MPA下的 ServiceWorker 治理</strong></p>\n<p>现代 Web App 项目主要有两种架构形式存在： <strong>SPA(Single Page Application)</strong> 和 <strong>MPA(Multiple Page Application)</strong></p>\n<p>MPA 这种架构的模式在现如今的大型 Web App 非常常见，这种 Web App 相比较于 SPA 能够承受更重的业务体量，并且利于大型 Web App 的后期维护和扩展，它往往会有多个团队去维护。</p>\n<p>假设我们有一个 MPA 的站点：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">|-- app1</span><br><span class=\"line\">|   |-- app1-service-worker.<span class=\"property\">js</span></span><br><span class=\"line\">|   <span class=\"string\">`-- index.html</span></span><br><span class=\"line\"><span class=\"string\">|-- app2</span></span><br><span class=\"line\"><span class=\"string\">|   `</span>-- index.<span class=\"property\">html</span></span><br><span class=\"line\">|-- index.<span class=\"property\">html</span></span><br><span class=\"line\"><span class=\"string\">`-- root-service-worker.js</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>app1</strong> 和 <strong>app2</strong> 分别由不同的团队维护。</p>\n<p>如果我们在根目录 <code>&#39;/&#39;</code> 注册了 <code>root-service-worker.js</code>，去完成一些通用的功能，例如：「日志收集」、「静态资源缓存」等。</p>\n<p>然后 <strong>app1</strong> 团队利用 ServiceWorker 的能力开发了一些特定的功能需要，例如 app1 的「离线化功能」。</p>\n<p>他们在 <code>app1/index.html </code>目录注册了 <code>app1-service-worker.js</code>。</p>\n<p>这时候，访问 <code>app1/*</code> 下的所有页面，ServiceWorker 控制权会交给 <code>app1-service-worker.js</code>，也就是只有app1的「离线化功能」在工作，而原来的「日志收集」、「静态缓存」等功能会失效。</p>\n<p>显然这种情况是我们不希望看到的，并且在实际的开发中发生的概率会很大。</p>\n<p>解决这个问题有两种方案：</p>\n<ol>\n<li>封装「日志收集」、「静态资源缓存」功能，<code>app1-service-worker.js</code>引入并使用这些功能。</li>\n<li>把「离线化功能」整合到 <code>root-service-worker.js</code>，只允许注册该 ServiceWorker。</li>\n</ol>\n<p>关于方案一，封装通用功能这是正确的，但是主域下的功能可能完全没办法一一拆解，并且后续主域的 ServiceWorker 更新了新功能，子域下的 ServiceWorker 还需要主动去更新和升级。</p>\n<p>关于方案二，显然可以解决方案一的问题，但是其他应用，例如 <strong>app2</strong> 可能不需要「离线化功能」。</p>\n<p><strong>基于此，我们引入方案三：功能整合到主域，支持功能的组合按照作用域隔离。</strong></p>\n<p>基于  <a href=\"https://jerryc8080.github.io/GlacierJS\">GlacierJS</a>  的话代码上可能会是这样的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mainPlugins = [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">Collector</span>(); <span class=\"comment\">// 日志收集功能</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">AssetsCache</span>(); <span class=\"comment\">// 静态资源缓存功能</span></span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"string\">&#x27;/&#x27;</span>, mainPlugins)；</span><br><span class=\"line\">glacier.<span class=\"title function_\">use</span>(<span class=\"string\">&#x27;/app1&#x27;</span>, [</span><br><span class=\"line\">  ...mainPlugins,</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">Offiline</span>(),  <span class=\"comment\">// 离线化功能</span></span><br><span class=\"line\">])；</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"资源缓存\"><a href=\"#资源缓存\" class=\"headerlink\" title=\"资源缓存\"></a>资源缓存</h2><p>ServiceWorker 一个很核心的能力就是能结合 CacheAPI  进行灵活的缓存资源，从而达到优化站点的加载速度、弱网访问、离线应用等。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220414092530.png\" alt=\"image-20220414092525515\"></p>\n<p>对于静态资源有五种常用的缓存策略：</p>\n<ol>\n<li><strong>stale-while-revalidate</strong><br>该模式允许您使用缓存（如果可用）尽快响应请求，如果没有缓存则回退到网络请求，然后使用网络请求来更新缓存，它是一种比较安全的缓存策略。</li>\n<li><strong>cache-first</strong><br>离线 Web 应用程序将严重依赖缓存，但对于非关键且可以逐渐缓存的资源，<strong>「缓存优先」</strong>是最佳选择。<br>如果缓存中有响应，则将使用缓存的响应来满足请求，并且根本不会使用网络。<br>如果没有缓存响应，则请求将由网络请求完成，然后响应会被缓存，以便下次直接从缓存中提供下一个请求。</li>\n<li><strong>network-first</strong><br>对于频繁更新的请求，<strong>「网络优先」</strong>策略是理想的解决方案。<br>默认情况下，它会尝试从网络获取最新响应。如果请求成功，它会将响应放入缓存中。如果网络未能返回响应，则将使用缓存的响应。</li>\n<li><strong>network-only</strong><br>如果您需要从网络满足特定请求，network-only 模式会将资源请求进行透传到网络。</li>\n<li><strong>cache-only</strong><br>该策略确保从缓存中获取响应。这种场景不太常见，它一般匹配着「预缓存」策略会比较有用。</li>\n</ol>\n<p>那这些策略中，我们应该使用哪种呢？答案是根据资源的种类具体选择。</p>\n<p>例如一些资源如果只是在 Web 应用发布的时候才会更新，我们就可以使用 cache-first 策略，例如一些 JS、样式、图片等。</p>\n<p>而 index.html 作为页面的加载的主入口，更加适宜使用 stale-while-revalidate 策略。</p>\n<p>我们以 GlacierJS 的缓存插件（<a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-assets-cache\">@glacierjs&#x2F;plugin-assets-cache</a>）为例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in service-worker.js</span></span><br><span class=\"line\"><span class=\"title function_\">importScripts</span>(<span class=\"string\">&quot;//cdn.jsdelivr.net/npm/@glacierjs/core/dist/index.min.js&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">importScripts</span>(<span class=\"string\">&#x27;//cdn.jsdelivr.net/npm/@glacierjs/sw/dist/index.min.js&#x27;</span>);</span><br><span class=\"line\"><span class=\"title function_\">importScripts</span>(<span class=\"string\">&#x27;//cdn.jsdelivr.net/npm/@glacierjs/plugin-assets-cache/dist/index.min.js&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">GlacierSW</span> &#125; = self[<span class=\"string\">&#x27;@glacierjs/sw&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">AssetsCacheSW</span>, <span class=\"title class_\">Strategy</span> &#125; = self[<span class=\"string\">&#x27;@glacierjs/plugin-assets-cache&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> glacierSW = <span class=\"keyword\">new</span> <span class=\"title class_\">GlacierSW</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">glacierSW.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">AssetsCacheSW</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">routes</span>: [&#123;</span><br><span class=\"line\">        <span class=\"comment\">// capture as string: store index.html with stale-while-revalidate strategy.</span></span><br><span class=\"line\">        <span class=\"attr\">capture</span>: <span class=\"string\">&#x27;https://mysite.com/index.html&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">strategy</span>: <span class=\"title class_\">Strategy</span>.<span class=\"property\">STALE_WHILE_REVALIDATE</span>,</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        <span class=\"comment\">// capture as RegExp: store all images with cache-first strategy</span></span><br><span class=\"line\">        <span class=\"attr\">capture</span>: <span class=\"regexp\">/\\.(png|jpg)$/</span>,</span><br><span class=\"line\">        <span class=\"attr\">strategy</span>: <span class=\"title class_\">Strategy</span>.<span class=\"property\">CACHE_FIRST</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        <span class=\"comment\">// capture as function: store all stylesheet with cache-first strategy</span></span><br><span class=\"line\">        <span class=\"attr\">capture</span>: <span class=\"function\">(<span class=\"params\">&#123; request &#125;</span>) =&gt;</span> request.<span class=\"property\">destination</span> === <span class=\"string\">&#x27;style&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">strategy</span>: <span class=\"title class_\">Strategy</span>.<span class=\"property\">CACHE_FIRST</span></span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"远程控制\"><a href=\"#远程控制\" class=\"headerlink\" title=\"远程控制\"></a>远程控制</h2><p>基于 ServiceWorker 的原理，一旦在浏览器安装上了，如果遇到紧急线上问题，唯有发布新的 ServiceWorker 才能解决问题。但是 ServiceWorker 的安装是有时延的，再加上有些团队从修改代码到发布的流程，这个反射弧就很长了。我们有什么办法能缩短对于线上问题的反射弧呢？</p>\n<p><strong>我们可以在远程存储一个配置，针对可预见的场景，进行「远程控制」</strong>：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417015441.png\" alt=\"remote-controller.drawio\"></p>\n<p><strong>那么我们怎么去获取配置呢？</strong></p>\n<p><strong>方案一</strong>，如果我们在主线程中获取配置：</p>\n<ol>\n<li>需要用户主动刷新页面才会生效。</li>\n<li>做不到轻量的功能关闭，什么意思呢，我们会有开关的场景，主线程只能通过卸载或者清理缓存去实现「关闭」，这个太重了。</li>\n</ol>\n<p><strong>方案二</strong>，如果我们在 ServiceWorker 线程去获取配置：</p>\n<ol>\n<li>可以实现轻量功能关闭，透传请求就行了。</li>\n<li>但是如果遇到要干净的清理用户环境的需要，去卸载 ServiceWorker 的时候，就会导致主进程每次注册，到了 ServiceWorker  就卸载，造成频繁安装卸载。</li>\n</ol>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417013001.png\" alt=\"image-20220417012859191\"></p>\n<p>所以我们的 <strong>最后方案</strong> 是 <strong>「基于双线程的实时配置获取」</strong>。</p>\n<p>主线程也要获取配置，然后配置前面要加上防抖保护，防止 <strong>onFetch</strong> 事件短时间并发的问题。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417013006.png\" alt=\"image-20220417012934418\"></p>\n<p>代码上，我们使用 Glacier  的插件 <a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-remote-controller\">@glacierjs&#x2F;plugin-remote-controller</a> 可以轻松实现远程控制：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in ./remote-controller-sw.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">RemoteControllerSW</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/plugin-remote-controller&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">GlacierSW</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/sw&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; options &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./options&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> glacierSW = <span class=\"keyword\">new</span> <span class=\"title class_\">GlacierSW</span>();</span><br><span class=\"line\">glacierSW.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">RemoteControllerSW</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">fetchConfig</span>: <span class=\"function\">() =&gt;</span> <span class=\"title function_\">getMyRemoteConfig</span>();</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其中 getMyRemoteConfig 用于获取你存在远端的配置，返回的格式规定如下：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getMyRemoteConfig</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">config</span>: <span class=\"title class_\">RemoteConfig</span> = &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 全局关闭，卸载 ServiceWorker</span></span><br><span class=\"line\">        <span class=\"attr\">switch</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      </span><br><span class=\"line\">      \t<span class=\"comment\">// 缓存功能开关</span></span><br><span class=\"line\">      \t<span class=\"attr\">assetsEnable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 精细控制特定缓存</span></span><br><span class=\"line\">        <span class=\"attr\">assetsCacheRoutes</span>: [&#123;</span><br><span class=\"line\">            <span class=\"attr\">capture</span>: <span class=\"string\">&#x27;https://mysite.com/index.html&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">strategy</span>: <span class=\"title class_\">Strategy</span>.<span class=\"property\">STALE_WHILE_REVALIDATE</span>,</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"数据收集\"><a href=\"#数据收集\" class=\"headerlink\" title=\"数据收集\"></a>数据收集</h2><p>ServiceWorker 发布之后，我们需要保持对线上情况的把控。 对于一些必要的统计指标，我们可能需要进行上统计和上报。</p>\n<p><a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-collector\">@glacierjs&#x2F;plugin-collector</a> 内置了五个常见的数据事件：</p>\n<ol>\n<li>ServiceWorker 注册：<a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_REGISTER\">SW_REGISTER</a></li>\n<li>ServiceWorker 安装成功：<a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_INSTALLED\">SW_INSTALLED</a></li>\n<li>ServiceWorker 控制中：<a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_CONTROLLED\">SW_CONTROLLED</a></li>\n<li>命中 onFetch 事件：<a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_FETCH\">SW_FETCH</a></li>\n<li>命中浏览器缓存：<a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#CACHE_HIT\">CACHE_HIT</a> of <a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_assets_cache_src.CacheFrom.html#WINDOW\">CacheFrom.Window</a></li>\n<li>命中 CacheAPI 缓存：<a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#CACHE_HIT\">CACHE_HIT</a> of <a href=\"https://jerryc8080.github.io/GlacierJS/api/enums/plugin_assets_cache_src.CacheFrom.html#SW\">CacheFrom.SW</a></li>\n</ol>\n<p>基于以上数据的收集，我们就可以得到一些常见的通用指标：</p>\n<ol>\n<li>ServiceWorker 安装率 &#x3D; SW_REGISTER &#x2F; SW_INSTALLED</li>\n<li>ServiceWorker 控制率 &#x3D; SW_REGISTER &#x2F; SW_CONTROLLED</li>\n<li>ServiceWorker 缓存命中率 &#x3D; SW_FETCH &#x2F; CACHE_HIT (of CacheFrom.SW)</li>\n</ol>\n<p>首先我们在 ServiceWorker 线程中注册 plugin-collector：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AssetsCacheSW</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/plugin-assets-cache&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CollectorSW</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/plugin-collector&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">GlacierSW</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/sw&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> glacierSW = <span class=\"keyword\">new</span> <span class=\"title class_\">GlacierSW</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// should use plugin-assets-cache first in order to make CollectedDataType.CACHE_HIT work.</span></span><br><span class=\"line\">glacierSW.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">AssetsCacheSW</span>(&#123;...&#125;));</span><br><span class=\"line\">glacierSW.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CollectorSW</span>());</span><br></pre></td></tr></table></figure>\n\n<p>然后在主线程中注册 plugin-collector，并且监听数据事件，进行数据上报：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">CollectorWindow</span>,</span><br><span class=\"line\">  <span class=\"title class_\">CollectedData</span>,</span><br><span class=\"line\">  <span class=\"title class_\">CollectedDataType</span>,</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/plugin-collector&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CacheFrom</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/plugin-assets-cache&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">GlacierWindow</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@glacierjs/window&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> glacierWindow = <span class=\"keyword\">new</span> <span class=\"title class_\">GlacierWindow</span>(<span class=\"string\">&#x27;./service-worker.js&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">glacierWindow.<span class=\"title function_\">use</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CollectorWindow</span>(&#123;</span><br><span class=\"line\">    <span class=\"title function_\">send</span>(<span class=\"params\">data: CollectedData</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">type</span>, data &#125; = data;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">CollectedDataType</span>.<span class=\"property\">SW_REGISTER</span>:</span><br><span class=\"line\">          myReporter.<span class=\"title function_\">event</span>(<span class=\"string\">&#x27;sw-register-count&#x27;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">CollectedDataType</span>.<span class=\"property\">SW_INSTALLED</span>:</span><br><span class=\"line\">          myReporter.<span class=\"title function_\">event</span>(<span class=\"string\">&#x27;sw-installed-count&#x27;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">CollectedDataType</span>.<span class=\"property\">SW_CONTROLLED</span>:</span><br><span class=\"line\">          myReporter.<span class=\"title function_\">event</span>(<span class=\"string\">&#x27;sw-controlled-count&#x27;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">CollectedDataType</span>.<span class=\"property\">SW_FETCH</span>:</span><br><span class=\"line\">          myReporter.<span class=\"title function_\">event</span>(<span class=\"string\">&#x27;sw-fetch-count&#x27;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">CollectedDataType</span>.<span class=\"property\">CACHE_HIT</span>:</span><br><span class=\"line\">          <span class=\"comment\">// hit service worker cache</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (data?.<span class=\"property\">from</span> === <span class=\"title class_\">CacheFrom</span>.<span class=\"property\">SW</span>) &#123;</span><br><span class=\"line\">            myReporter.<span class=\"title function_\">event</span>(<span class=\"string\">`sw-assets-count:hit-sw-<span class=\"subst\">$&#123;data?.url&#125;</span>`</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// hit browser cache or network</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (data?.<span class=\"property\">from</span> === <span class=\"title class_\">CacheFrom</span>.<span class=\"property\">Window</span>) &#123;</span><br><span class=\"line\">            myReporter.<span class=\"title function_\">event</span>(<span class=\"string\">`sw-assets-count:hit-window-<span class=\"subst\">$&#123;data?.url&#125;</span>`</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>myReporter.event</code> 是你可能会实现的数据上报库。</p>\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><p>ServiceWorker 测试可以分解为常见的测试组。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220418092022.png\" alt=\"img\"></p>\n<p>在顶层的是 <strong>「集成测试」</strong>，在这一层，我们检查整体的行为，例如：测试页面可加载，ServiceWorker注册，离线功能等。集成测试是最慢的，但是也是最接近现实情况的。</p>\n<p>再往下一层的是 <strong>「浏览器单元测试」</strong>，由于 ServiceWorker 的生命周期，以及一些 API 只有在浏览器环境下才能有，所以我们使用浏览器去进行单元测试，会减少很多环境的问题。</p>\n<p>接着是 <strong>「ServiceWorker 单元测试」</strong>，这种测试也是在浏览器环境中注册了测试用的 ServiceWorker 为前提进行的单元测试。</p>\n<p>最后一种是 <strong>「模拟 ServiceWorker」</strong>，这种测试粒度会更加精细，精细到某个类某个方法，只检测入参和返回。这意味着没有了浏览器启动成本，并且最终是一种可预测的方式测试代码的方式。</p>\n<p>但是模拟 ServiceWorker 是一件困难的事情，如果 mock 的 API 表面不正确，则在集成测试或者浏览器单元测试之前问题不会被发现。我们可以使用 <a href=\"https://www.npmjs.com/package/service-worker-mock\">service-worker-mock</a> 或者 <a href=\"https://github.com/mswjs/msw/issues/170\">MSW</a> 在 NodeJS 环境中进行 ServiceWorker 的单元测试。</p>\n<p>由于篇幅有限，后续我另开专题来讲讲 ServiceWorker 单元测试的实践。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文开篇描述了关于 PWA 的基本概念，然后介绍了一些现在社区优秀的工具，以及要去构建一个「可控、可靠、可扩展的 PWA 应用」所面临的的实际的痛点。</p>\n<p>于是在三个「可」给出了一些实践性的建议：</p>\n<ol>\n<li>通过「数据收集」、「远程控制」保证我们对已发布的 PWA 应用的 <strong>「可控性」</strong></li>\n<li>通过「单元测试」、「集成测试」去保障我们 PWA 应用的 <strong>「可靠性」</strong></li>\n<li>通过「多维洋葱插件模型」支持插件化和 MPA 应用，以及整合多个插件，从而达到 PWA 应用的 <strong>「可扩展性」</strong>。</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.amazon.com/PWA%E5%AE%9E%E6%88%98%EF%BC%9A%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84Progressive-Web-Dean-Alan-Hume%EF%BC%88%E8%BF%AA%E6%81%A9%E8%89%BE%E4%BC%A6%E4%BC%91%E5%A7%86%EF%BC%89/dp/B07D4ZSQYP/ref=sr_1_2?keywords=PWA+%E5%AE%9E%E6%88%98&qid=1650419306&sr=8-2\">《PWA实战：面向下一代的Progressive Web APP》</a></li>\n<li><a href=\"https://lavas-project.github.io/pwa-book/chapter04/2-service-worker-register.html\">Service Worker 注册</a></li>\n<li><a href=\"https://medium.com/dev-channel/two-http-headers-related-to-service-workers-you-never-may-have-heard-of-c8862f76cc60\">Two HTTP headers related to Service Workers you never may have heard of</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28161855\">如何优雅的为 PWA 注册 Service Worker</a></li>\n<li><a href=\"https://developers.google.com/web/tools/workbox\">Workbox</a></li>\n<li><a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin\">GlacierJS - 多维洋葱插件系统</a></li>\n<li><a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-assets-cache\">GlacierJS - 资源缓存</a></li>\n<li><a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-remote-controller\">GlacierJS - 远程控制</a></li>\n<li><a href=\"https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-collector\">GlacierJS - 数据收集</a></li>\n</ul>\n"},{"title":"Module Seed: 一套优雅的 Github 工作流","date":"2021-01-28T09:51:00.000Z","_content":"\n## Motivation\n\n平时喜欢写一些 NPM 模块，写得多了，整理出一套工作流，解放一些重复的搭建工作。  \n如果你喜欢，请直接拿去用，也可以参照该项目的一些 Feature ，给你一些提示与帮助。\n\n## Feature\n\n1. 支持 Typescript\n1. 支持单元测试，与测试覆盖率\n1. 快速生成文档站点\n1. 接入 Circle CLI，构建、发包、文档站点一条龙服务\n1. 规范 ESLint + Prettier\n1. 快速生成 Change Log\n1. 生成同时支持 CommonJS 和 ES Module 的 NPM 包\n\n## Download\n\n```shell\ngit clone git@github.com:JerryC8080/module-seed.git\n```\n\n## Usage\n\n### 1. Architecture\n\n```shell\n.\n├── .circleci // CircleCI 脚本\n│   ├── config.yml\n├── coverage // 自动生成的测试覆盖率报告\n├── docs  // 自动生成的文档\n├── build  // 构建代码\n│   ├── main  // 兼容 CommonJS\n│   │   ├── index.d.ts\n│   │   ├── index.js\n│   │   └── lib\n│   └── module  // 兼容 ES Module\n│       ├── index.d.ts\n│       ├── index.js\n│       └── lib\n├── src  // 源码\n│   ├── index.ts\n│   └── lib\n│       ├── hello-world.spec.ts // 单元测试\n│       └── hello-world.ts\n├── CHANGELOG.md\n├── LICENSE\n├── README.md\n├── package.json\n├── tsconfig.json\n└── tsconfig.module.json\n```\n\n### 2. Npm Script\n\n| Script      | Description                                        |\n| ----------- | -------------------------------------------------- |\n| build       | 构建代码，生成 ./build 文件夹                      |\n| fix         | 快速格式化代码                                     |\n| test        | 构建单元测试                                       |\n| watch:build | 动态构建代码，用于开发模式                         |\n| watch:test  | 动态构建单元测试，用于开发模式                     |\n| cov         | 构建单元测试覆盖率，生成 ./coverage 文件夹         |\n| doc         | 构建文档站点，生成 ./docs 文件夹                   |\n| doc:publish | 发布文档站点到 github pages                        |\n| version     | 强制以 patch 模式更新 version，如：v0.0.1 → v0.0.2 |\n\n### 3. Coverage\n\n通过运行 `npm run cov`，命令会构建单元测试，并且输出网页版本的测试报告：\n\n```shell\nopen coverage/index.html\n```\n\n![coverage](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212173414.png)\n\n### 4. Docs\n\n通过运行 `npm run doc`，会构建 TS API 文档，并且输出网页版本：\n\n```shell\nopen docs/index.html\n```\n\n![docs](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212173820.png)\n\n### 5. CircleCI Config\n\n本项目选择 [CircleCI](https://circleci.com/) 来完成项目构建、发布 NPM、发布文档站点等自动化构建工作。\n\n#### 1. Add Repo to CircleCI\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212174309.png)\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212174310.png)\n\n#### 2. Test Coverage to Coveralls\n\n如果想拥有一个这样的 Status: ![Coverage Status](https://coveralls.io/repos/github/JerryC8080/module-seed/badge.svg?branch=master)\n\n需要把你的 repo 添加到 [coveralls.io](https://coveralls.io/)\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175434.png)\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175435.png)\n\n然后，在 CircleCI 添加环境变量 `COVERALLS_REPO_TOKEN`\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175703.png)\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175850.png)\n\n那么，每次 CircleCI 发生构建的时候，就会上报单元测试覆盖率到 coveralls 去。\n\n参考 `.circleci/config.yml` 相关脚本:\n\n```yml\n...\nupload-coveralls:\n  <<: *defaults\n  steps:\n    - attach_workspace:\n        at: ~/repo\n    - run:\n        name: Test Coverage\n        command: npm run cov\n    - run:\n        name: Report for coveralls\n        command: |\n          npm install coveralls --save-dev\n          ./node_modules/.bin/nyc report --reporter=text-lcov | ./node_modules/.bin/coveralls\n    - store_artifacts:\n        path: coverage\n...\n```\n\n#### 3. Doc Site to Github Pages\n\n本地可以通过命令来构建和发布文档站点到 Github Pages\n\n```shell\nnpm run doc\nnpm run doc:publish\n```\n\n如果这个动作交给 CircleCI 来完成，则需要为 Repo 添加一个 `Read/Write` 权限的 `User Key`\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212180750.png)\n\n那么，每次 CircleCI 发生构建的时候，就会构建文档，并发布到 Github Pages 中去。\n\n例如本项目，就可以通过以下地址访问：\n\n[https://jerryc8080.github.io/module-seed](https://jerryc8080.github.io/module-seed)\n\n参考 `.circleci/config.yml` 相关脚本:\n\n```yml\n...\n deploy-docs:\n    <<: *defaults\n    steps:\n      - attach_workspace:\n          at: ~/repo\n      - run:\n          name: Avoid hosts unknown for github\n          command: mkdir ~/.ssh/ && echo -e \"Host github.com\\n\\tStrictHostKeyChecking no\\n\" > ~/.ssh/config\n      - run:\n          name: Set github email and user\n          command: |\n            git config --global user.email \"huangjerryc@gmail.com\"\n            git config --global user.name \"CircleCI-Robot\"\n      - run:\n          name: Show coverage\n          command: ls coverage\n      - run:\n          name: Show docs\n          command: ls docs\n      - run:\n          name: Copy to docs folder\n          command: |\n            mkdir docs/coverage\n            cp -rf coverage/* docs/coverage\n      - run:\n          name: Show docs\n          command: ls docs\n      - run:\n          name: Publish to gh-pages\n          command: npm run doc:publish\n...\n```\n\n#### 4. Coverage site\n\n在 CircleCI 的 `deploy-docs` 任务中，会构建 Coverage Site ，然后一起发布到 Github Pages 的 `/coverage` 目录中。\n\n例如本项目，就可以通过以下地址访问：\n\n[https://jerryc8080.github.io/module-seed/coverage/index.html](https://jerryc8080.github.io/module-seed/coverage/index.html)\n\n#### 5. NPM Deploy\n\n自动化脚本会以 `patch` 的形式升级版本号，例如：`v0.0.1` → `v0.0.2`。  \n然后发布到 [npmjs.com](http://npmjs.com/) 去。\n\n如果需要启用这一功能，需要为 CircleCI Repo 添加 `npm token`。\n\n首先，获取 `npm token`\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182501.png)\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182500.png)\n\n然后，为 CircleCI Repo 添加环境变量：`npm_TOKEN`\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182819.png)\n\n那么，每次 CircleCI 发生构建的时候，就会构建和发布 NPM 包。\n\n参考 `.circleci/config.yml` 相关脚本:\n\n```yml\n...\ndeploy:\n  <<: *defaults\n  steps:\n    - attach_workspace:\n        at: ~/repo\n    - run:\n        name: Set github email and user\n        command: |\n          # You should change email to yours.\n          git config --global user.email \"huangjerryc@gmail.com\"\n          git config --global user.name \"CircleCI-Robot\"\n    - run:\n        name: Authenticate with registry\n        command: echo \"//registry.npmjs.org/:_authToken=$npm_TOKEN\" > ~/repo/.npmrc\n    - run:\n        name: Update version as patch\n        command: npm run version\n    - run:\n        name: Publish package\n        command: npm publish\n...\n```\n","source":"_posts/2021/github-workflow.md","raw":"---\ntitle: \"Module Seed: 一套优雅的 Github 工作流\"\ncategory: 搬砖码农\ndate: 2021-01-28 17:51:00\n---\n\n## Motivation\n\n平时喜欢写一些 NPM 模块，写得多了，整理出一套工作流，解放一些重复的搭建工作。  \n如果你喜欢，请直接拿去用，也可以参照该项目的一些 Feature ，给你一些提示与帮助。\n\n## Feature\n\n1. 支持 Typescript\n1. 支持单元测试，与测试覆盖率\n1. 快速生成文档站点\n1. 接入 Circle CLI，构建、发包、文档站点一条龙服务\n1. 规范 ESLint + Prettier\n1. 快速生成 Change Log\n1. 生成同时支持 CommonJS 和 ES Module 的 NPM 包\n\n## Download\n\n```shell\ngit clone git@github.com:JerryC8080/module-seed.git\n```\n\n## Usage\n\n### 1. Architecture\n\n```shell\n.\n├── .circleci // CircleCI 脚本\n│   ├── config.yml\n├── coverage // 自动生成的测试覆盖率报告\n├── docs  // 自动生成的文档\n├── build  // 构建代码\n│   ├── main  // 兼容 CommonJS\n│   │   ├── index.d.ts\n│   │   ├── index.js\n│   │   └── lib\n│   └── module  // 兼容 ES Module\n│       ├── index.d.ts\n│       ├── index.js\n│       └── lib\n├── src  // 源码\n│   ├── index.ts\n│   └── lib\n│       ├── hello-world.spec.ts // 单元测试\n│       └── hello-world.ts\n├── CHANGELOG.md\n├── LICENSE\n├── README.md\n├── package.json\n├── tsconfig.json\n└── tsconfig.module.json\n```\n\n### 2. Npm Script\n\n| Script      | Description                                        |\n| ----------- | -------------------------------------------------- |\n| build       | 构建代码，生成 ./build 文件夹                      |\n| fix         | 快速格式化代码                                     |\n| test        | 构建单元测试                                       |\n| watch:build | 动态构建代码，用于开发模式                         |\n| watch:test  | 动态构建单元测试，用于开发模式                     |\n| cov         | 构建单元测试覆盖率，生成 ./coverage 文件夹         |\n| doc         | 构建文档站点，生成 ./docs 文件夹                   |\n| doc:publish | 发布文档站点到 github pages                        |\n| version     | 强制以 patch 模式更新 version，如：v0.0.1 → v0.0.2 |\n\n### 3. Coverage\n\n通过运行 `npm run cov`，命令会构建单元测试，并且输出网页版本的测试报告：\n\n```shell\nopen coverage/index.html\n```\n\n![coverage](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212173414.png)\n\n### 4. Docs\n\n通过运行 `npm run doc`，会构建 TS API 文档，并且输出网页版本：\n\n```shell\nopen docs/index.html\n```\n\n![docs](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212173820.png)\n\n### 5. CircleCI Config\n\n本项目选择 [CircleCI](https://circleci.com/) 来完成项目构建、发布 NPM、发布文档站点等自动化构建工作。\n\n#### 1. Add Repo to CircleCI\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212174309.png)\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212174310.png)\n\n#### 2. Test Coverage to Coveralls\n\n如果想拥有一个这样的 Status: ![Coverage Status](https://coveralls.io/repos/github/JerryC8080/module-seed/badge.svg?branch=master)\n\n需要把你的 repo 添加到 [coveralls.io](https://coveralls.io/)\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175434.png)\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175435.png)\n\n然后，在 CircleCI 添加环境变量 `COVERALLS_REPO_TOKEN`\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175703.png)\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175850.png)\n\n那么，每次 CircleCI 发生构建的时候，就会上报单元测试覆盖率到 coveralls 去。\n\n参考 `.circleci/config.yml` 相关脚本:\n\n```yml\n...\nupload-coveralls:\n  <<: *defaults\n  steps:\n    - attach_workspace:\n        at: ~/repo\n    - run:\n        name: Test Coverage\n        command: npm run cov\n    - run:\n        name: Report for coveralls\n        command: |\n          npm install coveralls --save-dev\n          ./node_modules/.bin/nyc report --reporter=text-lcov | ./node_modules/.bin/coveralls\n    - store_artifacts:\n        path: coverage\n...\n```\n\n#### 3. Doc Site to Github Pages\n\n本地可以通过命令来构建和发布文档站点到 Github Pages\n\n```shell\nnpm run doc\nnpm run doc:publish\n```\n\n如果这个动作交给 CircleCI 来完成，则需要为 Repo 添加一个 `Read/Write` 权限的 `User Key`\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212180750.png)\n\n那么，每次 CircleCI 发生构建的时候，就会构建文档，并发布到 Github Pages 中去。\n\n例如本项目，就可以通过以下地址访问：\n\n[https://jerryc8080.github.io/module-seed](https://jerryc8080.github.io/module-seed)\n\n参考 `.circleci/config.yml` 相关脚本:\n\n```yml\n...\n deploy-docs:\n    <<: *defaults\n    steps:\n      - attach_workspace:\n          at: ~/repo\n      - run:\n          name: Avoid hosts unknown for github\n          command: mkdir ~/.ssh/ && echo -e \"Host github.com\\n\\tStrictHostKeyChecking no\\n\" > ~/.ssh/config\n      - run:\n          name: Set github email and user\n          command: |\n            git config --global user.email \"huangjerryc@gmail.com\"\n            git config --global user.name \"CircleCI-Robot\"\n      - run:\n          name: Show coverage\n          command: ls coverage\n      - run:\n          name: Show docs\n          command: ls docs\n      - run:\n          name: Copy to docs folder\n          command: |\n            mkdir docs/coverage\n            cp -rf coverage/* docs/coverage\n      - run:\n          name: Show docs\n          command: ls docs\n      - run:\n          name: Publish to gh-pages\n          command: npm run doc:publish\n...\n```\n\n#### 4. Coverage site\n\n在 CircleCI 的 `deploy-docs` 任务中，会构建 Coverage Site ，然后一起发布到 Github Pages 的 `/coverage` 目录中。\n\n例如本项目，就可以通过以下地址访问：\n\n[https://jerryc8080.github.io/module-seed/coverage/index.html](https://jerryc8080.github.io/module-seed/coverage/index.html)\n\n#### 5. NPM Deploy\n\n自动化脚本会以 `patch` 的形式升级版本号，例如：`v0.0.1` → `v0.0.2`。  \n然后发布到 [npmjs.com](http://npmjs.com/) 去。\n\n如果需要启用这一功能，需要为 CircleCI Repo 添加 `npm token`。\n\n首先，获取 `npm token`\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182501.png)\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182500.png)\n\n然后，为 CircleCI Repo 添加环境变量：`npm_TOKEN`\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182819.png)\n\n那么，每次 CircleCI 发生构建的时候，就会构建和发布 NPM 包。\n\n参考 `.circleci/config.yml` 相关脚本:\n\n```yml\n...\ndeploy:\n  <<: *defaults\n  steps:\n    - attach_workspace:\n        at: ~/repo\n    - run:\n        name: Set github email and user\n        command: |\n          # You should change email to yours.\n          git config --global user.email \"huangjerryc@gmail.com\"\n          git config --global user.name \"CircleCI-Robot\"\n    - run:\n        name: Authenticate with registry\n        command: echo \"//registry.npmjs.org/:_authToken=$npm_TOKEN\" > ~/repo/.npmrc\n    - run:\n        name: Update version as patch\n        command: npm run version\n    - run:\n        name: Publish package\n        command: npm publish\n...\n```\n","slug":"2021/github-workflow","published":1,"updated":"2021-01-28T09:52:36.379Z","_id":"cl271a85q0003hirl4yhb7qxc","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h2><p>平时喜欢写一些 NPM 模块，写得多了，整理出一套工作流，解放一些重复的搭建工作。<br>如果你喜欢，请直接拿去用，也可以参照该项目的一些 Feature ，给你一些提示与帮助。</p>\n<h2 id=\"Feature\"><a href=\"#Feature\" class=\"headerlink\" title=\"Feature\"></a>Feature</h2><ol>\n<li>支持 Typescript</li>\n<li>支持单元测试，与测试覆盖率</li>\n<li>快速生成文档站点</li>\n<li>接入 Circle CLI，构建、发包、文档站点一条龙服务</li>\n<li>规范 ESLint + Prettier</li>\n<li>快速生成 Change Log</li>\n<li>生成同时支持 CommonJS 和 ES Module 的 NPM 包</li>\n</ol>\n<h2 id=\"Download\"><a href=\"#Download\" class=\"headerlink\" title=\"Download\"></a>Download</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:JerryC8080/module-seed.git</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><h3 id=\"1-Architecture\"><a href=\"#1-Architecture\" class=\"headerlink\" title=\"1. Architecture\"></a>1. Architecture</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── .circleci // CircleCI 脚本</span><br><span class=\"line\">│   ├── config.yml</span><br><span class=\"line\">├── coverage // 自动生成的测试覆盖率报告</span><br><span class=\"line\">├── docs  // 自动生成的文档</span><br><span class=\"line\">├── build  // 构建代码</span><br><span class=\"line\">│   ├── main  // 兼容 CommonJS</span><br><span class=\"line\">│   │   ├── index.d.ts</span><br><span class=\"line\">│   │   ├── index.js</span><br><span class=\"line\">│   │   └── lib</span><br><span class=\"line\">│   └── module  // 兼容 ES Module</span><br><span class=\"line\">│       ├── index.d.ts</span><br><span class=\"line\">│       ├── index.js</span><br><span class=\"line\">│       └── lib</span><br><span class=\"line\">├── src  // 源码</span><br><span class=\"line\">│   ├── index.ts</span><br><span class=\"line\">│   └── lib</span><br><span class=\"line\">│       ├── hello-world.spec.ts // 单元测试</span><br><span class=\"line\">│       └── hello-world.ts</span><br><span class=\"line\">├── CHANGELOG.md</span><br><span class=\"line\">├── LICENSE</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── tsconfig.json</span><br><span class=\"line\">└── tsconfig.module.json</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Npm-Script\"><a href=\"#2-Npm-Script\" class=\"headerlink\" title=\"2. Npm Script\"></a>2. Npm Script</h3><table>\n<thead>\n<tr>\n<th>Script</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>build</td>\n<td>构建代码，生成 .&#x2F;build 文件夹</td>\n</tr>\n<tr>\n<td>fix</td>\n<td>快速格式化代码</td>\n</tr>\n<tr>\n<td>test</td>\n<td>构建单元测试</td>\n</tr>\n<tr>\n<td>watch:build</td>\n<td>动态构建代码，用于开发模式</td>\n</tr>\n<tr>\n<td>watch:test</td>\n<td>动态构建单元测试，用于开发模式</td>\n</tr>\n<tr>\n<td>cov</td>\n<td>构建单元测试覆盖率，生成 .&#x2F;coverage 文件夹</td>\n</tr>\n<tr>\n<td>doc</td>\n<td>构建文档站点，生成 .&#x2F;docs 文件夹</td>\n</tr>\n<tr>\n<td>doc:publish</td>\n<td>发布文档站点到 github pages</td>\n</tr>\n<tr>\n<td>version</td>\n<td>强制以 patch 模式更新 version，如：v0.0.1 → v0.0.2</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-Coverage\"><a href=\"#3-Coverage\" class=\"headerlink\" title=\"3. Coverage\"></a>3. Coverage</h3><p>通过运行 <code>npm run cov</code>，命令会构建单元测试，并且输出网页版本的测试报告：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open coverage/index.html</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212173414.png\" alt=\"coverage\"></p>\n<h3 id=\"4-Docs\"><a href=\"#4-Docs\" class=\"headerlink\" title=\"4. Docs\"></a>4. Docs</h3><p>通过运行 <code>npm run doc</code>，会构建 TS API 文档，并且输出网页版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open docs/index.html</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212173820.png\" alt=\"docs\"></p>\n<h3 id=\"5-CircleCI-Config\"><a href=\"#5-CircleCI-Config\" class=\"headerlink\" title=\"5. CircleCI Config\"></a>5. CircleCI Config</h3><p>本项目选择 <a href=\"https://circleci.com/\">CircleCI</a> 来完成项目构建、发布 NPM、发布文档站点等自动化构建工作。</p>\n<h4 id=\"1-Add-Repo-to-CircleCI\"><a href=\"#1-Add-Repo-to-CircleCI\" class=\"headerlink\" title=\"1. Add Repo to CircleCI\"></a>1. Add Repo to CircleCI</h4><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212174309.png\"></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212174310.png\"></p>\n<h4 id=\"2-Test-Coverage-to-Coveralls\"><a href=\"#2-Test-Coverage-to-Coveralls\" class=\"headerlink\" title=\"2. Test Coverage to Coveralls\"></a>2. Test Coverage to Coveralls</h4><p>如果想拥有一个这样的 Status: <img src=\"https://coveralls.io/repos/github/JerryC8080/module-seed/badge.svg?branch=master\" alt=\"Coverage Status\"></p>\n<p>需要把你的 repo 添加到 <a href=\"https://coveralls.io/\">coveralls.io</a></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175434.png\"></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175435.png\"></p>\n<p>然后，在 CircleCI 添加环境变量 <code>COVERALLS_REPO_TOKEN</code></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175703.png\"></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175850.png\"></p>\n<p>那么，每次 CircleCI 发生构建的时候，就会上报单元测试覆盖率到 coveralls 去。</p>\n<p>参考 <code>.circleci/config.yml</code> 相关脚本:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">...</span></span><br><span class=\"line\"><span class=\"attr\">upload-coveralls:</span></span><br><span class=\"line\">  <span class=\"string\">&lt;&lt;:</span> <span class=\"meta\">*defaults</span></span><br><span class=\"line\">  <span class=\"attr\">steps:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">attach_workspace:</span></span><br><span class=\"line\">        <span class=\"attr\">at:</span> <span class=\"string\">~/repo</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">Test</span> <span class=\"string\">Coverage</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">cov</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">Report</span> <span class=\"string\">for</span> <span class=\"string\">coveralls</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          npm install coveralls --save-dev</span></span><br><span class=\"line\"><span class=\"string\">          ./node_modules/.bin/nyc report --reporter=text-lcov | ./node_modules/.bin/coveralls</span></span><br><span class=\"line\"><span class=\"string\"></span>    <span class=\"bullet\">-</span> <span class=\"attr\">store_artifacts:</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">coverage</span></span><br><span class=\"line\"><span class=\"string\">...</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-Doc-Site-to-Github-Pages\"><a href=\"#3-Doc-Site-to-Github-Pages\" class=\"headerlink\" title=\"3. Doc Site to Github Pages\"></a>3. Doc Site to Github Pages</h4><p>本地可以通过命令来构建和发布文档站点到 Github Pages</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run doc</span><br><span class=\"line\">npm run doc:publish</span><br></pre></td></tr></table></figure>\n\n<p>如果这个动作交给 CircleCI 来完成，则需要为 Repo 添加一个 <code>Read/Write</code> 权限的 <code>User Key</code></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212180750.png\"></p>\n<p>那么，每次 CircleCI 发生构建的时候，就会构建文档，并发布到 Github Pages 中去。</p>\n<p>例如本项目，就可以通过以下地址访问：</p>\n<p><a href=\"https://jerryc8080.github.io/module-seed\">https://jerryc8080.github.io/module-seed</a></p>\n<p>参考 <code>.circleci/config.yml</code> 相关脚本:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">...</span></span><br><span class=\"line\"> <span class=\"attr\">deploy-docs:</span></span><br><span class=\"line\">    <span class=\"string\">&lt;&lt;:</span> <span class=\"meta\">*defaults</span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">attach_workspace:</span></span><br><span class=\"line\">          <span class=\"attr\">at:</span> <span class=\"string\">~/repo</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Avoid</span> <span class=\"string\">hosts</span> <span class=\"string\">unknown</span> <span class=\"string\">for</span> <span class=\"string\">github</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">mkdir</span> <span class=\"string\">~/.ssh/</span> <span class=\"string\">&amp;&amp;</span> <span class=\"string\">echo</span> <span class=\"string\">-e</span> <span class=\"string\">&quot;Host github.com\\n\\tStrictHostKeyChecking no\\n&quot;</span> <span class=\"string\">&gt;</span> <span class=\"string\">~/.ssh/config</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Set</span> <span class=\"string\">github</span> <span class=\"string\">email</span> <span class=\"string\">and</span> <span class=\"string\">user</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">            git config --global user.email &quot;huangjerryc@gmail.com&quot;</span></span><br><span class=\"line\"><span class=\"string\">            git config --global user.name &quot;CircleCI-Robot&quot;</span></span><br><span class=\"line\"><span class=\"string\"></span>      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Show</span> <span class=\"string\">coverage</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">ls</span> <span class=\"string\">coverage</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Show</span> <span class=\"string\">docs</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">ls</span> <span class=\"string\">docs</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Copy</span> <span class=\"string\">to</span> <span class=\"string\">docs</span> <span class=\"string\">folder</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">            mkdir docs/coverage</span></span><br><span class=\"line\"><span class=\"string\">            cp -rf coverage/* docs/coverage</span></span><br><span class=\"line\"><span class=\"string\"></span>      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Show</span> <span class=\"string\">docs</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">ls</span> <span class=\"string\">docs</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Publish</span> <span class=\"string\">to</span> <span class=\"string\">gh-pages</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">doc:publish</span></span><br><span class=\"line\"><span class=\"string\">...</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-Coverage-site\"><a href=\"#4-Coverage-site\" class=\"headerlink\" title=\"4. Coverage site\"></a>4. Coverage site</h4><p>在 CircleCI 的 <code>deploy-docs</code> 任务中，会构建 Coverage Site ，然后一起发布到 Github Pages 的 <code>/coverage</code> 目录中。</p>\n<p>例如本项目，就可以通过以下地址访问：</p>\n<p><a href=\"https://jerryc8080.github.io/module-seed/coverage/index.html\">https://jerryc8080.github.io/module-seed/coverage/index.html</a></p>\n<h4 id=\"5-NPM-Deploy\"><a href=\"#5-NPM-Deploy\" class=\"headerlink\" title=\"5. NPM Deploy\"></a>5. NPM Deploy</h4><p>自动化脚本会以 <code>patch</code> 的形式升级版本号，例如：<code>v0.0.1</code> → <code>v0.0.2</code>。<br>然后发布到 <a href=\"http://npmjs.com/\">npmjs.com</a> 去。</p>\n<p>如果需要启用这一功能，需要为 CircleCI Repo 添加 <code>npm token</code>。</p>\n<p>首先，获取 <code>npm token</code></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182501.png\"><br><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182500.png\"></p>\n<p>然后，为 CircleCI Repo 添加环境变量：<code>npm_TOKEN</code></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182819.png\"></p>\n<p>那么，每次 CircleCI 发生构建的时候，就会构建和发布 NPM 包。</p>\n<p>参考 <code>.circleci/config.yml</code> 相关脚本:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">...</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"string\">&lt;&lt;:</span> <span class=\"meta\">*defaults</span></span><br><span class=\"line\">  <span class=\"attr\">steps:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">attach_workspace:</span></span><br><span class=\"line\">        <span class=\"attr\">at:</span> <span class=\"string\">~/repo</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">Set</span> <span class=\"string\">github</span> <span class=\"string\">email</span> <span class=\"string\">and</span> <span class=\"string\">user</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          # You should change email to yours.</span></span><br><span class=\"line\"><span class=\"string\">          git config --global user.email &quot;huangjerryc@gmail.com&quot;</span></span><br><span class=\"line\"><span class=\"string\">          git config --global user.name &quot;CircleCI-Robot&quot;</span></span><br><span class=\"line\"><span class=\"string\"></span>    <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">Authenticate</span> <span class=\"string\">with</span> <span class=\"string\">registry</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;//registry.npmjs.org/:_authToken=$npm_TOKEN&quot;</span> <span class=\"string\">&gt;</span> <span class=\"string\">~/repo/.npmrc</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">Update</span> <span class=\"string\">version</span> <span class=\"string\">as</span> <span class=\"string\">patch</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">version</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">Publish</span> <span class=\"string\">package</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> <span class=\"string\">npm</span> <span class=\"string\">publish</span></span><br><span class=\"line\"><span class=\"string\">...</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h2><p>平时喜欢写一些 NPM 模块，写得多了，整理出一套工作流，解放一些重复的搭建工作。<br>如果你喜欢，请直接拿去用，也可以参照该项目的一些 Feature ，给你一些提示与帮助。</p>\n<h2 id=\"Feature\"><a href=\"#Feature\" class=\"headerlink\" title=\"Feature\"></a>Feature</h2><ol>\n<li>支持 Typescript</li>\n<li>支持单元测试，与测试覆盖率</li>\n<li>快速生成文档站点</li>\n<li>接入 Circle CLI，构建、发包、文档站点一条龙服务</li>\n<li>规范 ESLint + Prettier</li>\n<li>快速生成 Change Log</li>\n<li>生成同时支持 CommonJS 和 ES Module 的 NPM 包</li>\n</ol>\n<h2 id=\"Download\"><a href=\"#Download\" class=\"headerlink\" title=\"Download\"></a>Download</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:JerryC8080/module-seed.git</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><h3 id=\"1-Architecture\"><a href=\"#1-Architecture\" class=\"headerlink\" title=\"1. Architecture\"></a>1. Architecture</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── .circleci // CircleCI 脚本</span><br><span class=\"line\">│   ├── config.yml</span><br><span class=\"line\">├── coverage // 自动生成的测试覆盖率报告</span><br><span class=\"line\">├── docs  // 自动生成的文档</span><br><span class=\"line\">├── build  // 构建代码</span><br><span class=\"line\">│   ├── main  // 兼容 CommonJS</span><br><span class=\"line\">│   │   ├── index.d.ts</span><br><span class=\"line\">│   │   ├── index.js</span><br><span class=\"line\">│   │   └── lib</span><br><span class=\"line\">│   └── module  // 兼容 ES Module</span><br><span class=\"line\">│       ├── index.d.ts</span><br><span class=\"line\">│       ├── index.js</span><br><span class=\"line\">│       └── lib</span><br><span class=\"line\">├── src  // 源码</span><br><span class=\"line\">│   ├── index.ts</span><br><span class=\"line\">│   └── lib</span><br><span class=\"line\">│       ├── hello-world.spec.ts // 单元测试</span><br><span class=\"line\">│       └── hello-world.ts</span><br><span class=\"line\">├── CHANGELOG.md</span><br><span class=\"line\">├── LICENSE</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── tsconfig.json</span><br><span class=\"line\">└── tsconfig.module.json</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Npm-Script\"><a href=\"#2-Npm-Script\" class=\"headerlink\" title=\"2. Npm Script\"></a>2. Npm Script</h3><table>\n<thead>\n<tr>\n<th>Script</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>build</td>\n<td>构建代码，生成 .&#x2F;build 文件夹</td>\n</tr>\n<tr>\n<td>fix</td>\n<td>快速格式化代码</td>\n</tr>\n<tr>\n<td>test</td>\n<td>构建单元测试</td>\n</tr>\n<tr>\n<td>watch:build</td>\n<td>动态构建代码，用于开发模式</td>\n</tr>\n<tr>\n<td>watch:test</td>\n<td>动态构建单元测试，用于开发模式</td>\n</tr>\n<tr>\n<td>cov</td>\n<td>构建单元测试覆盖率，生成 .&#x2F;coverage 文件夹</td>\n</tr>\n<tr>\n<td>doc</td>\n<td>构建文档站点，生成 .&#x2F;docs 文件夹</td>\n</tr>\n<tr>\n<td>doc:publish</td>\n<td>发布文档站点到 github pages</td>\n</tr>\n<tr>\n<td>version</td>\n<td>强制以 patch 模式更新 version，如：v0.0.1 → v0.0.2</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-Coverage\"><a href=\"#3-Coverage\" class=\"headerlink\" title=\"3. Coverage\"></a>3. Coverage</h3><p>通过运行 <code>npm run cov</code>，命令会构建单元测试，并且输出网页版本的测试报告：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open coverage/index.html</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212173414.png\" alt=\"coverage\"></p>\n<h3 id=\"4-Docs\"><a href=\"#4-Docs\" class=\"headerlink\" title=\"4. Docs\"></a>4. Docs</h3><p>通过运行 <code>npm run doc</code>，会构建 TS API 文档，并且输出网页版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open docs/index.html</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212173820.png\" alt=\"docs\"></p>\n<h3 id=\"5-CircleCI-Config\"><a href=\"#5-CircleCI-Config\" class=\"headerlink\" title=\"5. CircleCI Config\"></a>5. CircleCI Config</h3><p>本项目选择 <a href=\"https://circleci.com/\">CircleCI</a> 来完成项目构建、发布 NPM、发布文档站点等自动化构建工作。</p>\n<h4 id=\"1-Add-Repo-to-CircleCI\"><a href=\"#1-Add-Repo-to-CircleCI\" class=\"headerlink\" title=\"1. Add Repo to CircleCI\"></a>1. Add Repo to CircleCI</h4><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212174309.png\"></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212174310.png\"></p>\n<h4 id=\"2-Test-Coverage-to-Coveralls\"><a href=\"#2-Test-Coverage-to-Coveralls\" class=\"headerlink\" title=\"2. Test Coverage to Coveralls\"></a>2. Test Coverage to Coveralls</h4><p>如果想拥有一个这样的 Status: <img src=\"https://coveralls.io/repos/github/JerryC8080/module-seed/badge.svg?branch=master\" alt=\"Coverage Status\"></p>\n<p>需要把你的 repo 添加到 <a href=\"https://coveralls.io/\">coveralls.io</a></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175434.png\"></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175435.png\"></p>\n<p>然后，在 CircleCI 添加环境变量 <code>COVERALLS_REPO_TOKEN</code></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175703.png\"></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175850.png\"></p>\n<p>那么，每次 CircleCI 发生构建的时候，就会上报单元测试覆盖率到 coveralls 去。</p>\n<p>参考 <code>.circleci/config.yml</code> 相关脚本:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">...</span></span><br><span class=\"line\"><span class=\"attr\">upload-coveralls:</span></span><br><span class=\"line\">  <span class=\"string\">&lt;&lt;:</span> <span class=\"meta\">*defaults</span></span><br><span class=\"line\">  <span class=\"attr\">steps:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">attach_workspace:</span></span><br><span class=\"line\">        <span class=\"attr\">at:</span> <span class=\"string\">~/repo</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">Test</span> <span class=\"string\">Coverage</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">cov</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">Report</span> <span class=\"string\">for</span> <span class=\"string\">coveralls</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          npm install coveralls --save-dev</span></span><br><span class=\"line\"><span class=\"string\">          ./node_modules/.bin/nyc report --reporter=text-lcov | ./node_modules/.bin/coveralls</span></span><br><span class=\"line\"><span class=\"string\"></span>    <span class=\"bullet\">-</span> <span class=\"attr\">store_artifacts:</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">coverage</span></span><br><span class=\"line\"><span class=\"string\">...</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-Doc-Site-to-Github-Pages\"><a href=\"#3-Doc-Site-to-Github-Pages\" class=\"headerlink\" title=\"3. Doc Site to Github Pages\"></a>3. Doc Site to Github Pages</h4><p>本地可以通过命令来构建和发布文档站点到 Github Pages</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run doc</span><br><span class=\"line\">npm run doc:publish</span><br></pre></td></tr></table></figure>\n\n<p>如果这个动作交给 CircleCI 来完成，则需要为 Repo 添加一个 <code>Read/Write</code> 权限的 <code>User Key</code></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212180750.png\"></p>\n<p>那么，每次 CircleCI 发生构建的时候，就会构建文档，并发布到 Github Pages 中去。</p>\n<p>例如本项目，就可以通过以下地址访问：</p>\n<p><a href=\"https://jerryc8080.github.io/module-seed\">https://jerryc8080.github.io/module-seed</a></p>\n<p>参考 <code>.circleci/config.yml</code> 相关脚本:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">...</span></span><br><span class=\"line\"> <span class=\"attr\">deploy-docs:</span></span><br><span class=\"line\">    <span class=\"string\">&lt;&lt;:</span> <span class=\"meta\">*defaults</span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">attach_workspace:</span></span><br><span class=\"line\">          <span class=\"attr\">at:</span> <span class=\"string\">~/repo</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Avoid</span> <span class=\"string\">hosts</span> <span class=\"string\">unknown</span> <span class=\"string\">for</span> <span class=\"string\">github</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">mkdir</span> <span class=\"string\">~/.ssh/</span> <span class=\"string\">&amp;&amp;</span> <span class=\"string\">echo</span> <span class=\"string\">-e</span> <span class=\"string\">&quot;Host github.com\\n\\tStrictHostKeyChecking no\\n&quot;</span> <span class=\"string\">&gt;</span> <span class=\"string\">~/.ssh/config</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Set</span> <span class=\"string\">github</span> <span class=\"string\">email</span> <span class=\"string\">and</span> <span class=\"string\">user</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">            git config --global user.email &quot;huangjerryc@gmail.com&quot;</span></span><br><span class=\"line\"><span class=\"string\">            git config --global user.name &quot;CircleCI-Robot&quot;</span></span><br><span class=\"line\"><span class=\"string\"></span>      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Show</span> <span class=\"string\">coverage</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">ls</span> <span class=\"string\">coverage</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Show</span> <span class=\"string\">docs</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">ls</span> <span class=\"string\">docs</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Copy</span> <span class=\"string\">to</span> <span class=\"string\">docs</span> <span class=\"string\">folder</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">            mkdir docs/coverage</span></span><br><span class=\"line\"><span class=\"string\">            cp -rf coverage/* docs/coverage</span></span><br><span class=\"line\"><span class=\"string\"></span>      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Show</span> <span class=\"string\">docs</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">ls</span> <span class=\"string\">docs</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">Publish</span> <span class=\"string\">to</span> <span class=\"string\">gh-pages</span></span><br><span class=\"line\">          <span class=\"attr\">command:</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">doc:publish</span></span><br><span class=\"line\"><span class=\"string\">...</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-Coverage-site\"><a href=\"#4-Coverage-site\" class=\"headerlink\" title=\"4. Coverage site\"></a>4. Coverage site</h4><p>在 CircleCI 的 <code>deploy-docs</code> 任务中，会构建 Coverage Site ，然后一起发布到 Github Pages 的 <code>/coverage</code> 目录中。</p>\n<p>例如本项目，就可以通过以下地址访问：</p>\n<p><a href=\"https://jerryc8080.github.io/module-seed/coverage/index.html\">https://jerryc8080.github.io/module-seed/coverage/index.html</a></p>\n<h4 id=\"5-NPM-Deploy\"><a href=\"#5-NPM-Deploy\" class=\"headerlink\" title=\"5. NPM Deploy\"></a>5. NPM Deploy</h4><p>自动化脚本会以 <code>patch</code> 的形式升级版本号，例如：<code>v0.0.1</code> → <code>v0.0.2</code>。<br>然后发布到 <a href=\"http://npmjs.com/\">npmjs.com</a> 去。</p>\n<p>如果需要启用这一功能，需要为 CircleCI Repo 添加 <code>npm token</code>。</p>\n<p>首先，获取 <code>npm token</code></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182501.png\"><br><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182500.png\"></p>\n<p>然后，为 CircleCI Repo 添加环境变量：<code>npm_TOKEN</code></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182819.png\"></p>\n<p>那么，每次 CircleCI 发生构建的时候，就会构建和发布 NPM 包。</p>\n<p>参考 <code>.circleci/config.yml</code> 相关脚本:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">...</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"string\">&lt;&lt;:</span> <span class=\"meta\">*defaults</span></span><br><span class=\"line\">  <span class=\"attr\">steps:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">attach_workspace:</span></span><br><span class=\"line\">        <span class=\"attr\">at:</span> <span class=\"string\">~/repo</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">Set</span> <span class=\"string\">github</span> <span class=\"string\">email</span> <span class=\"string\">and</span> <span class=\"string\">user</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          # You should change email to yours.</span></span><br><span class=\"line\"><span class=\"string\">          git config --global user.email &quot;huangjerryc@gmail.com&quot;</span></span><br><span class=\"line\"><span class=\"string\">          git config --global user.name &quot;CircleCI-Robot&quot;</span></span><br><span class=\"line\"><span class=\"string\"></span>    <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">Authenticate</span> <span class=\"string\">with</span> <span class=\"string\">registry</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;//registry.npmjs.org/:_authToken=$npm_TOKEN&quot;</span> <span class=\"string\">&gt;</span> <span class=\"string\">~/repo/.npmrc</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">Update</span> <span class=\"string\">version</span> <span class=\"string\">as</span> <span class=\"string\">patch</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">version</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">run:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">Publish</span> <span class=\"string\">package</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> <span class=\"string\">npm</span> <span class=\"string\">publish</span></span><br><span class=\"line\"><span class=\"string\">...</span></span><br></pre></td></tr></table></figure>\n"},{"title":"函数保险丝：避免函数过热调用","date":"2021-01-28T07:34:00.000Z","_content":"\n  <img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20210128154439.png\" width=300 />\n\n## 前言\n\n在日常开发中，我们会遇到很多这样的场景：\n\n1. 在抢购活动中，用户往往会频繁刷新接口，要给接口加上防护，频繁调用停止响应。\n2. 在弱网环境中，往往会实现失败重试功能，如果失败次数多了，频繁的重试需要制止。\n3. 在股票市场中，当价格波动的幅度在交易时间中达到某一个限定的熔断点时，对其暂停交易一段时间的机制。\n4. ......\n\n这类问题，本质是：**「过热的调用」**\n\n在物理电路中，对于「过热的调用」有一种大家生活中都常见的电子元件：**保险丝**\n\n保险丝会在电流异常升高到一定的高度和热度的时候，自身熔断切断电流，保护电路安全运行。\n\n我们可以模仿这样的思路，去解决编程中的「过热的调用」问题：\n\n1. 设定一个阈值，如果函数在短时间内调用次数达到这个阈值，就熔断一段时间。\n2. 在函数有一段时间没有被调用了，让函数的热度降下来。\n\n\n\n## 函数保险丝的功能实现\n\n基于以上的思路，我实现了一个 npm 库：[Method Fuse](https://github.com/JerryC8080/method-fuse)\n\n使用方式如下：\n\n### Step1：安装\n\n`npm install @jerryc/method-fuse`\n\n### Step2：快速使用\n\n```javascript\nimport { MethodFuse } from '@jerryc/method-fuse';\n\n// 一个请求远程资源的异步函数\nconst getAssets = async () => API.requestAssets();\n\n// 创建 MethodFuse 实例\nconst fuse = new MethodFuse({\n  // 命名，用于日志输出\n  name: 'TestFuse',\n\n  // 最大负荷，默认：3\n  maxLoad: 3,\n\n  // 每次熔断时间。每次熔断之后，间隔 N 毫秒之后重铸，默认：5000ms\n  breakingTime: 5000,\n\n  // 自动冷却时间。在最后一次调用间隔 N 毫秒之后自动重铸，默认：1000ms\n  coolDownTime: 1000,\n});\n\n// 代理原函数\nconst getAssetsProxy = fuse.proxy(getAssets);\n\n// 高频并发调用 getAssetsProxy。\ngetAssetsProxy();\ngetAssetsProxy();\ngetAssetsProxy();\ngetAssetsProxy(); // 此次调用会熔断\nsetTimeout(() => getAssetsProxy(), 5000); // 等待熔断重铸后，方可重新调用。\n\n// 以上会打印日志：\n// [method-fuse:info] TestFuse-通过保险丝(1/3)\n// [method-fuse:info] TestFuse-通过保险丝(2/3)\n// [method-fuse:info] TestFuse-通过保险丝(3/3)\n// [method-fuse:error] TestFuse-保险丝熔断，5000ms 之后重铸\n// [method-fuse:info] TestFuse-保险丝重置\n// [method-fuse:info] TestFuse-通过保险丝(1/3)\n```\n\n### Step3：使用装饰器\n\n如果你的项目中支持 `TS` 或者 `ES Decorator`，那么 `MethodFuse` 提供了快捷使用的装饰器。\n\n```javascript\nimport { decorator as methodFuse } from '@jerryc/method-fuse';\n\n@methodFuse({ name: 'TestFuse' })\nasync function getAsset() {\n  return API.requestAssets();\n};\n```\n\n### Step4：修改日志级别\n\n`MethodFuse` 内置了一个迷你 logger（power by [@jerryc/mini-logger](https://github.com/JerryC8080/mini-logger)），方便内部日志打印，外部可以获得 `Logger` 的实例，进行 log level 的控制。\n\n```javascript\nimport { LoggerLevel } from '@jerryc/mini-logger';\nimport { logger, MethodFuse } from '@jerryc/method-fuse';\n\n// 创建 MethodFuse 实例\nconst MethodFuse = new MethodFuse({ name: 'TestFuse' });\n\n// 下调 Log level\nlogger.level = LoggerLevel.ERROR;\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2021/method-fuse.md","raw":"---\ntitle: 函数保险丝：避免函数过热调用\ncategory: 搬砖码农\ndate: 2021-1-28 15:34:00\n---\n\n  <img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20210128154439.png\" width=300 />\n\n## 前言\n\n在日常开发中，我们会遇到很多这样的场景：\n\n1. 在抢购活动中，用户往往会频繁刷新接口，要给接口加上防护，频繁调用停止响应。\n2. 在弱网环境中，往往会实现失败重试功能，如果失败次数多了，频繁的重试需要制止。\n3. 在股票市场中，当价格波动的幅度在交易时间中达到某一个限定的熔断点时，对其暂停交易一段时间的机制。\n4. ......\n\n这类问题，本质是：**「过热的调用」**\n\n在物理电路中，对于「过热的调用」有一种大家生活中都常见的电子元件：**保险丝**\n\n保险丝会在电流异常升高到一定的高度和热度的时候，自身熔断切断电流，保护电路安全运行。\n\n我们可以模仿这样的思路，去解决编程中的「过热的调用」问题：\n\n1. 设定一个阈值，如果函数在短时间内调用次数达到这个阈值，就熔断一段时间。\n2. 在函数有一段时间没有被调用了，让函数的热度降下来。\n\n\n\n## 函数保险丝的功能实现\n\n基于以上的思路，我实现了一个 npm 库：[Method Fuse](https://github.com/JerryC8080/method-fuse)\n\n使用方式如下：\n\n### Step1：安装\n\n`npm install @jerryc/method-fuse`\n\n### Step2：快速使用\n\n```javascript\nimport { MethodFuse } from '@jerryc/method-fuse';\n\n// 一个请求远程资源的异步函数\nconst getAssets = async () => API.requestAssets();\n\n// 创建 MethodFuse 实例\nconst fuse = new MethodFuse({\n  // 命名，用于日志输出\n  name: 'TestFuse',\n\n  // 最大负荷，默认：3\n  maxLoad: 3,\n\n  // 每次熔断时间。每次熔断之后，间隔 N 毫秒之后重铸，默认：5000ms\n  breakingTime: 5000,\n\n  // 自动冷却时间。在最后一次调用间隔 N 毫秒之后自动重铸，默认：1000ms\n  coolDownTime: 1000,\n});\n\n// 代理原函数\nconst getAssetsProxy = fuse.proxy(getAssets);\n\n// 高频并发调用 getAssetsProxy。\ngetAssetsProxy();\ngetAssetsProxy();\ngetAssetsProxy();\ngetAssetsProxy(); // 此次调用会熔断\nsetTimeout(() => getAssetsProxy(), 5000); // 等待熔断重铸后，方可重新调用。\n\n// 以上会打印日志：\n// [method-fuse:info] TestFuse-通过保险丝(1/3)\n// [method-fuse:info] TestFuse-通过保险丝(2/3)\n// [method-fuse:info] TestFuse-通过保险丝(3/3)\n// [method-fuse:error] TestFuse-保险丝熔断，5000ms 之后重铸\n// [method-fuse:info] TestFuse-保险丝重置\n// [method-fuse:info] TestFuse-通过保险丝(1/3)\n```\n\n### Step3：使用装饰器\n\n如果你的项目中支持 `TS` 或者 `ES Decorator`，那么 `MethodFuse` 提供了快捷使用的装饰器。\n\n```javascript\nimport { decorator as methodFuse } from '@jerryc/method-fuse';\n\n@methodFuse({ name: 'TestFuse' })\nasync function getAsset() {\n  return API.requestAssets();\n};\n```\n\n### Step4：修改日志级别\n\n`MethodFuse` 内置了一个迷你 logger（power by [@jerryc/mini-logger](https://github.com/JerryC8080/mini-logger)），方便内部日志打印，外部可以获得 `Logger` 的实例，进行 log level 的控制。\n\n```javascript\nimport { LoggerLevel } from '@jerryc/mini-logger';\nimport { logger, MethodFuse } from '@jerryc/method-fuse';\n\n// 创建 MethodFuse 实例\nconst MethodFuse = new MethodFuse({ name: 'TestFuse' });\n\n// 下调 Log level\nlogger.level = LoggerLevel.ERROR;\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2021/method-fuse","published":1,"updated":"2021-01-28T09:36:07.795Z","_id":"cl271ajup0005hirl2y061b1z","comments":1,"layout":"post","photos":[],"link":"","content":"  <img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20210128154439.png\" width=300 />\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在日常开发中，我们会遇到很多这样的场景：</p>\n<ol>\n<li>在抢购活动中，用户往往会频繁刷新接口，要给接口加上防护，频繁调用停止响应。</li>\n<li>在弱网环境中，往往会实现失败重试功能，如果失败次数多了，频繁的重试需要制止。</li>\n<li>在股票市场中，当价格波动的幅度在交易时间中达到某一个限定的熔断点时，对其暂停交易一段时间的机制。</li>\n<li>……</li>\n</ol>\n<p>这类问题，本质是：<strong>「过热的调用」</strong></p>\n<p>在物理电路中，对于「过热的调用」有一种大家生活中都常见的电子元件：<strong>保险丝</strong></p>\n<p>保险丝会在电流异常升高到一定的高度和热度的时候，自身熔断切断电流，保护电路安全运行。</p>\n<p>我们可以模仿这样的思路，去解决编程中的「过热的调用」问题：</p>\n<ol>\n<li>设定一个阈值，如果函数在短时间内调用次数达到这个阈值，就熔断一段时间。</li>\n<li>在函数有一段时间没有被调用了，让函数的热度降下来。</li>\n</ol>\n<h2 id=\"函数保险丝的功能实现\"><a href=\"#函数保险丝的功能实现\" class=\"headerlink\" title=\"函数保险丝的功能实现\"></a>函数保险丝的功能实现</h2><p>基于以上的思路，我实现了一个 npm 库：<a href=\"https://github.com/JerryC8080/method-fuse\">Method Fuse</a></p>\n<p>使用方式如下：</p>\n<h3 id=\"Step1：安装\"><a href=\"#Step1：安装\" class=\"headerlink\" title=\"Step1：安装\"></a>Step1：安装</h3><p><code>npm install @jerryc/method-fuse</code></p>\n<h3 id=\"Step2：快速使用\"><a href=\"#Step2：快速使用\" class=\"headerlink\" title=\"Step2：快速使用\"></a>Step2：快速使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">MethodFuse</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@jerryc/method-fuse&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个请求远程资源的异步函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getAssets</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; <span class=\"variable constant_\">API</span>.<span class=\"title function_\">requestAssets</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建 MethodFuse 实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fuse = <span class=\"keyword\">new</span> <span class=\"title class_\">MethodFuse</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 命名，用于日志输出</span></span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;TestFuse&#x27;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 最大负荷，默认：3</span></span><br><span class=\"line\">  <span class=\"attr\">maxLoad</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 每次熔断时间。每次熔断之后，间隔 N 毫秒之后重铸，默认：5000ms</span></span><br><span class=\"line\">  <span class=\"attr\">breakingTime</span>: <span class=\"number\">5000</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 自动冷却时间。在最后一次调用间隔 N 毫秒之后自动重铸，默认：1000ms</span></span><br><span class=\"line\">  <span class=\"attr\">coolDownTime</span>: <span class=\"number\">1000</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理原函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> getAssetsProxy = fuse.<span class=\"title function_\">proxy</span>(getAssets);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 高频并发调用 getAssetsProxy。</span></span><br><span class=\"line\"><span class=\"title function_\">getAssetsProxy</span>();</span><br><span class=\"line\"><span class=\"title function_\">getAssetsProxy</span>();</span><br><span class=\"line\"><span class=\"title function_\">getAssetsProxy</span>();</span><br><span class=\"line\"><span class=\"title function_\">getAssetsProxy</span>(); <span class=\"comment\">// 此次调用会熔断</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">getAssetsProxy</span>(), <span class=\"number\">5000</span>); <span class=\"comment\">// 等待熔断重铸后，方可重新调用。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以上会打印日志：</span></span><br><span class=\"line\"><span class=\"comment\">// [method-fuse:info] TestFuse-通过保险丝(1/3)</span></span><br><span class=\"line\"><span class=\"comment\">// [method-fuse:info] TestFuse-通过保险丝(2/3)</span></span><br><span class=\"line\"><span class=\"comment\">// [method-fuse:info] TestFuse-通过保险丝(3/3)</span></span><br><span class=\"line\"><span class=\"comment\">// [method-fuse:error] TestFuse-保险丝熔断，5000ms 之后重铸</span></span><br><span class=\"line\"><span class=\"comment\">// [method-fuse:info] TestFuse-保险丝重置</span></span><br><span class=\"line\"><span class=\"comment\">// [method-fuse:info] TestFuse-通过保险丝(1/3)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Step3：使用装饰器\"><a href=\"#Step3：使用装饰器\" class=\"headerlink\" title=\"Step3：使用装饰器\"></a>Step3：使用装饰器</h3><p>如果你的项目中支持 <code>TS</code> 或者 <code>ES Decorator</code>，那么 <code>MethodFuse</code> 提供了快捷使用的装饰器。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; decorator <span class=\"keyword\">as</span> methodFuse &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@jerryc/method-fuse&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"title function_\">methodFuse</span>(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;TestFuse&#x27;</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getAsset</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable constant_\">API</span>.<span class=\"title function_\">requestAssets</span>();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Step4：修改日志级别\"><a href=\"#Step4：修改日志级别\" class=\"headerlink\" title=\"Step4：修改日志级别\"></a>Step4：修改日志级别</h3><p><code>MethodFuse</code> 内置了一个迷你 logger（power by <a href=\"https://github.com/JerryC8080/mini-logger\">@jerryc&#x2F;mini-logger</a>），方便内部日志打印，外部可以获得 <code>Logger</code> 的实例，进行 log level 的控制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">LoggerLevel</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@jerryc/mini-logger&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; logger, <span class=\"title class_\">MethodFuse</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@jerryc/method-fuse&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建 MethodFuse 实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">MethodFuse</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">MethodFuse</span>(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;TestFuse&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下调 Log level</span></span><br><span class=\"line\">logger.<span class=\"property\">level</span> = <span class=\"title class_\">LoggerLevel</span>.<span class=\"property\">ERROR</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"  <img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20210128154439.png\" width=300 />\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在日常开发中，我们会遇到很多这样的场景：</p>\n<ol>\n<li>在抢购活动中，用户往往会频繁刷新接口，要给接口加上防护，频繁调用停止响应。</li>\n<li>在弱网环境中，往往会实现失败重试功能，如果失败次数多了，频繁的重试需要制止。</li>\n<li>在股票市场中，当价格波动的幅度在交易时间中达到某一个限定的熔断点时，对其暂停交易一段时间的机制。</li>\n<li>……</li>\n</ol>\n<p>这类问题，本质是：<strong>「过热的调用」</strong></p>\n<p>在物理电路中，对于「过热的调用」有一种大家生活中都常见的电子元件：<strong>保险丝</strong></p>\n<p>保险丝会在电流异常升高到一定的高度和热度的时候，自身熔断切断电流，保护电路安全运行。</p>\n<p>我们可以模仿这样的思路，去解决编程中的「过热的调用」问题：</p>\n<ol>\n<li>设定一个阈值，如果函数在短时间内调用次数达到这个阈值，就熔断一段时间。</li>\n<li>在函数有一段时间没有被调用了，让函数的热度降下来。</li>\n</ol>\n<h2 id=\"函数保险丝的功能实现\"><a href=\"#函数保险丝的功能实现\" class=\"headerlink\" title=\"函数保险丝的功能实现\"></a>函数保险丝的功能实现</h2><p>基于以上的思路，我实现了一个 npm 库：<a href=\"https://github.com/JerryC8080/method-fuse\">Method Fuse</a></p>\n<p>使用方式如下：</p>\n<h3 id=\"Step1：安装\"><a href=\"#Step1：安装\" class=\"headerlink\" title=\"Step1：安装\"></a>Step1：安装</h3><p><code>npm install @jerryc/method-fuse</code></p>\n<h3 id=\"Step2：快速使用\"><a href=\"#Step2：快速使用\" class=\"headerlink\" title=\"Step2：快速使用\"></a>Step2：快速使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">MethodFuse</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@jerryc/method-fuse&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个请求远程资源的异步函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getAssets</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; <span class=\"variable constant_\">API</span>.<span class=\"title function_\">requestAssets</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建 MethodFuse 实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fuse = <span class=\"keyword\">new</span> <span class=\"title class_\">MethodFuse</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 命名，用于日志输出</span></span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;TestFuse&#x27;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 最大负荷，默认：3</span></span><br><span class=\"line\">  <span class=\"attr\">maxLoad</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 每次熔断时间。每次熔断之后，间隔 N 毫秒之后重铸，默认：5000ms</span></span><br><span class=\"line\">  <span class=\"attr\">breakingTime</span>: <span class=\"number\">5000</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 自动冷却时间。在最后一次调用间隔 N 毫秒之后自动重铸，默认：1000ms</span></span><br><span class=\"line\">  <span class=\"attr\">coolDownTime</span>: <span class=\"number\">1000</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理原函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> getAssetsProxy = fuse.<span class=\"title function_\">proxy</span>(getAssets);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 高频并发调用 getAssetsProxy。</span></span><br><span class=\"line\"><span class=\"title function_\">getAssetsProxy</span>();</span><br><span class=\"line\"><span class=\"title function_\">getAssetsProxy</span>();</span><br><span class=\"line\"><span class=\"title function_\">getAssetsProxy</span>();</span><br><span class=\"line\"><span class=\"title function_\">getAssetsProxy</span>(); <span class=\"comment\">// 此次调用会熔断</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">getAssetsProxy</span>(), <span class=\"number\">5000</span>); <span class=\"comment\">// 等待熔断重铸后，方可重新调用。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以上会打印日志：</span></span><br><span class=\"line\"><span class=\"comment\">// [method-fuse:info] TestFuse-通过保险丝(1/3)</span></span><br><span class=\"line\"><span class=\"comment\">// [method-fuse:info] TestFuse-通过保险丝(2/3)</span></span><br><span class=\"line\"><span class=\"comment\">// [method-fuse:info] TestFuse-通过保险丝(3/3)</span></span><br><span class=\"line\"><span class=\"comment\">// [method-fuse:error] TestFuse-保险丝熔断，5000ms 之后重铸</span></span><br><span class=\"line\"><span class=\"comment\">// [method-fuse:info] TestFuse-保险丝重置</span></span><br><span class=\"line\"><span class=\"comment\">// [method-fuse:info] TestFuse-通过保险丝(1/3)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Step3：使用装饰器\"><a href=\"#Step3：使用装饰器\" class=\"headerlink\" title=\"Step3：使用装饰器\"></a>Step3：使用装饰器</h3><p>如果你的项目中支持 <code>TS</code> 或者 <code>ES Decorator</code>，那么 <code>MethodFuse</code> 提供了快捷使用的装饰器。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; decorator <span class=\"keyword\">as</span> methodFuse &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@jerryc/method-fuse&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"title function_\">methodFuse</span>(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;TestFuse&#x27;</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getAsset</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable constant_\">API</span>.<span class=\"title function_\">requestAssets</span>();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Step4：修改日志级别\"><a href=\"#Step4：修改日志级别\" class=\"headerlink\" title=\"Step4：修改日志级别\"></a>Step4：修改日志级别</h3><p><code>MethodFuse</code> 内置了一个迷你 logger（power by <a href=\"https://github.com/JerryC8080/mini-logger\">@jerryc&#x2F;mini-logger</a>），方便内部日志打印，外部可以获得 <code>Logger</code> 的实例，进行 log level 的控制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">LoggerLevel</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@jerryc/mini-logger&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; logger, <span class=\"title class_\">MethodFuse</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@jerryc/method-fuse&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建 MethodFuse 实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">MethodFuse</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">MethodFuse</span>(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;TestFuse&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下调 Log level</span></span><br><span class=\"line\">logger.<span class=\"property\">level</span> = <span class=\"title class_\">LoggerLevel</span>.<span class=\"property\">ERROR</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"微信小程序登录的前端设计与实现","date":"2020-10-16T14:22:25.000Z","_content":"\n# 一. 前言\n\n对于登录/注册的设计如此精雕细琢的目的，当然是想让这个作为应用的基础能力，有足够的健壮性，避免出现全站性的阻塞。\n\n同时要充分考虑如何解耦和封装，在开展新的小程序的时候，能更快的去复用能力，避免重复采坑。\n\n登录注册这模块，就像个冰山，我们以为它就是「输入账号密码，就完成登录了」，但实际下面还有各种需要考虑的问题。\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016104626.jpg)\n\n在此，跟在座的各位分享一下，最近做完一个小程序登录/注册模块之后，沉淀下来的一些设计经验和想法。\n\n# 二. 业务场景\n\n在用户浏览小程序的过程中，由业务需要，往往需要获取用户的一些基本信息，常见的有：\n\n1. 微信昵称\n2. 微信手机号\n\n而不同的产品，对于用户的信息要求不尽相同，也会有不一样的授权流程。\n\n第一种，常见于电商系统中，用户购买商品的时候，为了识别用户多平台的账号，往往用手机号去做一个联系，这时候需要用户去授权手机号。\n\n![授权手机号](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111059.jpg)\n\n第二种，为了让用户信息得到基本的初始化，往往需要更进一步获取用户信息：如微信昵称，`unionId` 等，就需要询问用户授权。\n\n![授权用户信息](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111042.jpg)\n\n第三种，囊括第一种，第二种。\n\n![完整授权流程](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111006.jpg)\n\n# 三. 概念\n\n秉着沉淀一套通用的小程序登录方案和服务为目标，我们去分析一下业务，得出变量。\n\n在做技术设计之前，讲点必要的废话，对一些概念进行基本调频。\n\n\n\n## 2.1 关于「登录」\n\n登录在英文中是 「login」，对应的还有 「logout」。而登录之前，你需要拥有一个账号，就要 「register」（or sign up）。\n\n话说一开始的产品是没有登录/注册功能的，用的人多了就慢慢有了。出于产品本身的需求，需要对「用户」进行身份识别。\n\n在现实社会中，我们每个人都有一个身份ID：身份证。当我到了16岁的时候，第一次去公安局领身份证的时候，就完成了一次「注册」行为。然后我去网吧上网，身份证刷一下，完成了一次「登录」行为。\n\n那么对于虚拟世界的互联网来说，这个身份证明就是「账号+密码」。\n\n常见的登录/注册方式有：\n\n1. **账号密码注册**\n\n\t在互联网的早期，个人邮箱和手机覆盖度小。所以，就需要用户自己想一个账号名，我们注册个QQ号，就是这种形式。\n\n\t![from 汽车之家](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105159.png)\t\n\n2. **邮箱地址注册**\n\n\t千禧年之后，PC互联网时代快速普及，我们都创建了属于自己的个人邮箱。加上QQ也自带邮箱账号。由于邮箱具有个人私密性，且能够进行信息的沟通，因此，大部分网站开始采用邮箱账号作为用户名来进行注册，并且会在注册的过程中要求登录到相应邮箱内查收激活邮件，验证我们对该注册邮箱的所有权。\n\n\t![from 支付宝](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105005.png)\n\n3. **手机号码注册**\n\n\t在互联网普及之后，智能手机与移动互联网发展迅猛。手机也成为每个人必不可少的移动设备，同时移动互联网也已经深深融入每个人的现代生活当中。所以，相较于邮箱，目前手机号码与个人的联系更加紧密，而且越来越多的移动应用出现，采用手机号码作为用户名的注册方式也得到了广泛的使用。   \n\n\t![from 知乎](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105120.png)\n\n到了 2020 年，微信用户规模达 12 亿。那么，微信账号，起码在中国，已成为新一代互联网世界的「身份标识」。\n\n而对微信小程序而言，天然就能知道当前用户的微信账号ID。微信允许小程序应用，能在用户无感知的情况下，悄无声息的「登录」到我们的小程序应用中去，这个就是我们经常称之为的「静默登录」。\n\n\n其实微信小程序的登录，跟传统 Web 应用的「单点登录」本质是一样的概念。\n\n1. 单点登录：在 A 站登录了，C 站和 B 站能实现快速的「静默登录」。\n2. 微信小程序登录：在微信中，登录了微信账号，那么在整个小程序生态中，都可以实现「静默登录」。\n\n\n由于 Http 本来是无状态的，业界基本对于登录态的一般做法：\n\n1. cookie-session：常用于浏览器应用中\n2. access token：常用于移动端等非浏览器应用\n\n在微信小程序来说，对于「JS逻辑层」并不是一个浏览器环境，自然没有 `Cookie`，那么通常会使用 `access token` 的方式。\n\n\n\n## 2.2 关于「授权」\n\n对于需要更进一步获取用的用户昵称、用户手机号等信息的产品来说。微信出于用户隐私的考虑，需要用户主动同意授权。小程序应用才能获取到这部分信息，这就有了目前流行的小程序「授权用户信息」、「授权手机号」的交互了。\n\n出于不同的用户信息敏感度不同的考虑，微信小程序对于不同的用户信息提供「授权」的方式不尽相同：\n\n1. 调用具体 API 方式，弹窗授权。\n   1. 例如调用 [`wx.getLocation()`](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getLocation.html) 的时候，如果用户未授权，则会弹出地址授权界面。\n   2. 如果拒绝了，就不会再次弹窗，`wx.getLocation()`直接返回失败。\n2. `<button open-type=\"xxx\" />` 方式。\n   1. 仅支持：用户敏感信息，用户手机号，需要配合后端进行对称加解密，方能拿到数据。\n   2. 用户已拒绝，再次点击按钮，仍然会弹窗。\n3. 通过 [`wx.authorize()`](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/authorize/wx.authorize.html)，提前询问授权，之后需要获取相关信息的时候不用再次弹出授权。\n\n# 四. 详细设计\n\n梳理清楚了概念之后，我们模块的划分上，可以拆分为两大块：\n\n1. **登录**：负责与服务端创建起一个会话，这个会话实现静默登录以及相关的容错处理等，模块命名为：`Session`\n2. **授权**：负责与用户交互，获取与更新信息，以及权限的控制处理等，模块命名为：`Auth`\n\n\n\n## 3.1 登录的实现\n\n### 3.1.1 静默登录\n\n![微信登录](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111135.png)\n\n微信官方提供的登录方案，总结为三步：\n\n1. 前端通过 `wx.login()` 获取一次性加密凭证 code，交给后端。\n2. 后端把这个 code 传输给微信服务器端，换取用户唯一标识 `openId` 和授权凭证 `session_key`。（用于后续服务器端和微信服务器的特殊 API 调用，具体看：[微信官方文档-服务端获取开放数据](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)）。\n3. 后端把从微信服务器获取到的用户凭证与自行生成的登录态凭证（token），传输给前端。前端保存起来，下次请求的时候带给后端，就能识别哪个用户。\n\n如果只是实现这个流程的话，挺简单的。\n\n但要实现一个健壮的登录过程，还需要注意更多的边界情况：\n\n1. **收拢 `wx.login()` 的调用**：\n\n\t由于 `wx.login()` 会产生不可预测的副作用，例如会可能导致`session_key`失效，从而导致后续的授权解密场景中的失败。我们这里可以提供一个像 `session.login()` 的方法，掌握 `wx.login()` 控制权，对其做一系列的封装和容错处理。\n\n2. **调用的时机**：\n\n\t通常我们会在应用启动的时候（ `app.onLaunch()` ），去发起静默登录。但这里会由小程序生命周期设计问题而导致的一个异步问题：加载页面的时候，去调用一个需要登录态的后端 API 的时候，前面异步的静态登录过程有可能还没有完成，从而导致请求失败。\n\n\t当然也可以在第一个需要登录态的接口调用的时候以异步阻塞的方式发起登录调用，这个需要结合良好设计的接口层。\n\n\t以上讲到的两种场景的详细设计思路下文会讲到。\n\n3. **并发调用的问题**：\n\n\t在业务场景中，难免会出现多处代码需要触发登录，如果遇到极端情况，这多处代码同时间发起调用。那就会造成短时间多次发起登录过程，尽管之前的请求还没有完成。针对这种情况，我们可以以第一个调用为阻塞，后续调用等待结果，就像精子和卵子结合的过程。\n\n4. **未过期调用的问题**：\n\n\t如果我们的登录态未过期，完全可以正常使用的，默认情况就不需再去发起登录过程了。这时候我们可以默认情况下先去检查登录态是否可用，不能用，我们再发起请求。然后还可以提供一个类似 `session.login({ force: true })`的参数去强行发起登录。\n\n\n\n### 3.1.2 静默登录异步状态的处理\n\n**1. 应用启动的时候调用**\n\n因为大部分情况都需要依赖登录态，我们会很自然而然的想到把这个调用的时机放到应用启动的时候（ `app.onLaunch()` ）来调用。\n\n但是由于原生的小程序启动流程中， `App`，`Page`，`Component` 的生命周期钩子函数，都不支持异步阻塞。\n\n那么我们很容易会遇到 `app.onLaunch` 发起的「登录过程」在 `page.onLoad` 的时候还没有完成，我们就无法正确去做一些依赖登录态的操作。\n\n针对这种情况，我们设计了一个状态机的工具：[status](http://beautywejs.com/#/remote/plugin-status?id=plugin-statusl)\n\n\n\n![状态机](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016110706.png)\n\n\n\n基于状态机，我们就可以编写这样的代码：\n\n```javascript\nimport { Status } from '@beautywe/plugin-status';\n\n// on app.js\nApp({\n    status: {\n       login: new Status('login');\n    },\n\n    onLaunch() {\n        session\n            // 发起静默登录调用\n            .login()\n\n            // 把状态机设置为 success\n            .then(() => this.status.login.success())\n      \n            // 把状态机设置为 fail\n            .catch(() => this.status.login.fail());\n    },\n});\n\n\n// on page.js\nPage({\n    onLoad() {\n      const loginStatus = getApp().status.login;\n      \n      // must 里面会进行状态的判断，例如登录中就等待，登录成功就直接返回，登录失败抛出等。\n      loginStatus().status.login.must(() => {\n        // 进行一些需要登录态的操作...\n      });\n    },\n});\n```\n\n\n\n**2. 在「第一个需要登录态接口」被调用的时候去发起登录**\n\n更进一步，我们会发现，需要登录态的更深层次的节点是在发起的「需要登录态的后端 API 」的时候。\n\n那么我们可以在调用「需要登录态的后端 API」的时候再去发起「静默登录」，对于并发的场景，让其他请求等待一下就好了。\n\n以 [fly.js](https://wendux.github.io/dist/#/doc/flyio/readme) 作为 `wx.request()` 封装的「网络请求层」，做一个简单的例子：\n\n```javascript\n// 发起请求，并表明该请求是需要登录态的\nfly.post('https://...', params, { needLogin: true });\n\n// 在 fly 拦截器中处理逻辑\nfly.interceptors.request.use(async (req)=>{\n\n  // 在请求需要登录态的时候\n  if (req.needLogin !== false) {\n\n    // ensureLogin 核心逻辑是：判断是否已登录，如否发起登录调用，如果正在登录，则进入队列等待回调。\n    await session.ensureLogin();\n    \n    // 登录成功后，获取 token，通过 headers 传递给后端。\n    const token = await session.getToken();\n    Object.assign(req.headers, { [AUTH_KEY_NAME]: token });\n  }\n  \n  return req;\n});\n\n```\n\n\n\n### 3.1.3 自定义登录态过期的容错处理\n\n当自定义登录态过期的时候，后端需要返回特定的状态码，例如：`AUTH_EXPIRED` 、 `AUTH_INVALID` 等。\n\n前端可以在「网络请求层」去监听所有请求的这个状态码，然后发起刷新登录态，再去重放失败的请求：\n\n```javascript\n// 添加响应拦截器\nfly.interceptors.response.use(\n    (response) => {\n      const code = res.data;\n        \n      // 登录态过期或失效\n      if ( ['AUTH_EXPIRED', 'AUTH_INVALID'].includes(code) ) {\n      \n        // 刷新登录态\n        await session.refreshLogin();\n        \n        // 然后重新发起请求\n        return fly.request(request);\n      }\n    }\n)\n```\n\n那么如果并发的发起多个请求，都返回了登录态失效的状态码，上述代码就会被执行多次。\n\n我们需要对 `session.refreshLogin()` 做一些特殊的容错处理：\n\n1. **请求锁**：同一时间，只允许一个正在过程中的网络请求。\n2. **等待队列**：请求被锁定之后，调用该方法的所有调用，都推入一个队列中，等待网络请求完成之后共用返回结果。\n3. **熔断机制**：如果短时间内多次调用，则停止响应一段时间，类似于 TCP 慢启动。\n\n示例代码：\n\n```javascript\nclass Session {\n  // ....\n  \n  // 刷新登录保险丝，最多重复 3 次，然后熔断，5s 后恢复\n  refreshLoginFuseLine = REFRESH_LOGIN_FUSELINE_DEFAULT;\n  refreshLoginFuseLocked = false;\n  refreshLoginFuseRestoreTime = 5000;\n\n  // 熔断控制\n  refreshLoginFuse(): Promise<void> {\n    if (this.refreshLoginFuseLocked) {\n      return Promise.reject('刷新登录-保险丝已熔断，请稍后');\n    }\n    if (this.refreshLoginFuseLine > 0) {\n      this.refreshLoginFuseLine = this.refreshLoginFuseLine - 1;\n      return Promise.resolve();\n    } else {\n      this.refreshLoginFuseLocked = true;\n      setTimeout(() => {\n        this.refreshLoginFuseLocked = false;\n        this.refreshLoginFuseLine = REFRESH_LOGIN_FUSELINE_DEFAULT;\n        logger.info('刷新登录-保险丝熔断解除');\n      }, this.refreshLoginFuseRestoreTime);\n      return Promise.reject('刷新登录-保险丝熔断!!');\n    }\n  }\n\n  // 并发回调队列\n  refreshLoginQueueMaxLength = 100;\n  refreshLoginQueue: any[] = [];\n  refreshLoginLocked = false;\n\n  // 刷新登录态\n  refreshLogin(): Promise<void> {\n    return Promise.resolve()\n    \n      // 回调队列 + 熔断 控制\n      .then(() => this.refreshLoginFuse())\n      .then(() => {\n        if (this.refreshLoginLocked) {\n          const maxLength = this.refreshLoginQueueMaxLength;\n          if (this.refreshLoginQueue.length >= maxLength) {\n            return Promise.reject(`refreshLoginQueue 超出容量：${maxLength}`);\n          }\n          return new Promise((resolve, reject) => {\n            this.refreshLoginQueue.push([resolve, reject]);\n          });\n        }\n        this.refreshLoginLocked = true;\n      })\n\n      // 通过前置控制之后，发起登录过程\n      .then(() => {\n        this.clearSession();\n        wx.showLoading({ title: '刷新登录态中', mask: true });\n        return this.login()\n          .then(() => {\n            wx.hideLoading();\n            wx.showToast({ icon: 'none', title: '登录成功' });\n            this.refreshLoginQueue.forEach(([resolve]) => resolve());\n            this.refreshLoginLocked = false;\n          })\n          .catch(err => {\n            wx.hideLoading();\n            wx.showToast({ icon: 'none', title: '登录失败' });\n            this.refreshLoginQueue.forEach(([, reject]) => reject());\n            this.refreshLoginLocked = false;\n            throw err;\n          });\n      });\n\n  // ...\n}\n```\n\n### 3.1.4 微信 session_key 过期的容错处理\n\n我们从上面的「静默登录」之后，微信服务器端会下发一个 `session_key` 给后端，而这个会在需要获取[微信开放数据](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)的时候会用到。\n\n![微信开放数据](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016110824.png)\n\n\n\n而 `session_key` 是有时效性的，以下摘自微信官方描述：\n\n> #### 会话密钥 session_key 有效性\n>\n> 开发者如果遇到因为 session_key 不正确而校验签名失败或解密失败，请关注下面几个与 session_key 有关的注意事项。\n>\n> 1. [wx.login](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html) 调用时，用户的 session_key **可能**会被更新而致使旧 session_key 失效（刷新机制存在最短周期，如果同一个用户短时间内多次调用 [wx.login](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html)，并非每次调用都导致 session_key 刷新）。开发者应该在明确需要重新登录时才调用 [wx.login](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html)，及时通过 [auth.code2Session](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html) 接口更新服务器存储的 session_key。\n> 2. 微信不会把 session_key 的有效期告知开发者。我们会根据用户使用小程序的行为对 session_key 进行续期。用户越频繁使用小程序，session_key 有效期越长。\n> 3. 开发者在 session_key 失效时，可以通过重新执行登录流程获取有效的 session_key。使用接口 [wx.checkSession](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.checkSession.html)可以校验 session_key 是否有效，从而避免小程序反复执行登录流程。\n> 4. 当开发者在实现自定义登录态时，可以考虑以 session_key 有效期作为自身登录态有效期，也可以实现自定义的时效性策略。\n\n翻译成简单的两句话：\n\n1. `session_key` 时效性由微信控制，开发者不可预测。\n2. `wx.login` 可能会导致 `session_key` 过期，可以在使用接口之前用` wx.checkSession` 检查一下。\n\n而对于第二点，我们通过实验发现，偶发性的在 `session_key` 已过期的情况下，`wx.checkSession` 会概率性返回 `true`\n\n社区也有相关的反馈未得到解决：\n\n* [小程序解密手机号,隔一小段时间后,checksession:ok,但是解密失败](https://developers.weixin.qq.com/community/develop/doc/000424005b89983f337a622c751000?highLine=wx.checkSession)\n* [wx.checkSession有效，但是解密数据失败](https://developers.weixin.qq.com/community/develop/doc/0008e429bd0c886e10699f59c51000?_at=1602745291452)\n* [checkSession判断session_key未失效，但是解密手机号失败](https://developers.weixin.qq.com/community/develop/doc/000a04ab4546d80d5428ffcee51800?_at=1602745291452)\n\n**所以结论是：`wx.checkSession`可靠性是不达 100% 的。**\n\n\n\n基于以上，我们需要对 `session_key` 的过期做一些容错处理：\n\n1. 发起需要使用 `session_key` 的请求前，做一次 `wx.checkSession` 操作，如果失败了刷新登录态。\n2. 后端使用 `session_key` 解密开放数据失败之后，返回特定错误码（如：`DECRYPT_WX_OPEN_DATA_FAIL`），前端刷新登录态。\n\n示例代码：\n\n```javascript\n// 定义检查 session_key 有效性的操作\nconst ensureSessionKey = async () => {\n  const hasSession = await new Promise(resolve => {\n    wx.checkSession({\n      success: () => resolve(true),\n      fail: () => resolve(false),\n    });\n  });\n  \n  if (!hasSession) {\n    logger.info('sessionKey 已过期，刷新登录态');\n\n    // 接上面提到的刷新登录逻辑\n    return session.refreshLogin();\n  }\n\n  return Promise.resolve();\n}\n\n// 在发起请求的时候，先做一次确保 session_key 最新的操作（以 fly.js 作为网络请求层为例）\nconst updatePhone = async (params) => {\n  await ensureSessionKey();\n  const res = await fly.post('https://xxx', params);\n}\n\n// 添加响应拦截器, 监听网络请求返回\nfly.interceptors.response.use(\n    (response) => {\n      const code = res.data;\n        \n      // 登录态过期或失效\n      if ( ['DECRYPT_WX_OPEN_DATA_FAIL'].includes(code)) {\n\n        // 刷新登录态\n        await session.refreshLogin();\n        \n        // 由于加密场景的加密数据由用户点击产生，session_key 可能已经更改，需要用户重新点击一遍。\n        wx.showToast({ title: '网络出小差了，请稍后重试', icon: 'none' });\n      }\n    }\n)\n```\n\n\n\n## 3.2 授权的实现\n\n### 3.2.1 组件拆分与设计\n\n在用户信息和手机号获取的方式上，微信是以 `<button open-type='xxx' />` 的方式，让用户主动点击授权的。\n\n那么为了让代码更解耦，我们设计这样三个组件：\n\n1. `<user-contaienr getUserInfo=\"onUserInfoAuth\">`: 包装点击交互，通过 `<slot>` 支持点击区域的自定义UI。\n2. `<phone-container getPhonenNmber=\"onPhoneAuth\">` : 与 `<user-container>` 同理。\n3. `<auth-flow>`: 根据业务需要，组合 `<user-container>`、`<phone-container>` 组合来定义不同的授权流程。\n\n\n\n以开头的业务场景的流程为例，它有这样的要求：\n\n1. 有多个步骤。\n2. 如果中途断掉了，可以从中间接上。\n3. 有些场景中，只要求达到「用户信息授权」，而不需要完成「用户手机号」。\n\n![完整授权流程](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111006.jpg)\n\n那么授权的阶段可以分三层：\n\n```javascript\n// 用户登录的阶段\nexport enum AuthStep {\n  // 阶段一：只有登录态，没有用户信息，没有手机号\n  ONE = 1,\n\n  // 阶段二：有用户信息，没有手机号\n  TWO = 2,\n\n  // 阶段三：有用户信息，有手机号\n  THREE = 3,\n}\n```\n\n`AuthStep` 的推进过程是不可逆的，我们可以定义一个 `nextStep` 函数来封装 AuthStep 更新的逻辑。外部使用的话，只要无脑调用 `nextStep` 方法，等待回调结果就行。\n\n示例伪代码：\n\n```javascript\n// auth-flow component\n\nComponent({\n  // ...\n  \n  data: {\n    // 默认情况下，只需要到达阶段二。\n    mustAuthStep: AuthStep.TWO\n  },\n  \n  // 允许临时更改组件的需要达到的阶段。\n  setMustAuthStep(mustAuthStep: AuthStep) {\n    this.setData({ mustAuthStep });\n  },\n  \n  // 根据用户当前的信息，计算用户处在授权的阶段\n  getAuthStep() {\n    let currAuthStep;\n    \n    // 没有用户信息，尚在第一步\n    if (!session.hasUser() || !session.hasUnionId()) {\n      currAuthStep = AuthStepType.ONE;\n    }\n\n    // 没有手机号，尚在第二步\n    if (!session.hasPhone()) {\n      currAuthStep = AuthStepType.TWO;\n    }\n\n    // 都有，尚在第三步\n    currAuthStep = AuthStepType.THREE;\n    return currAuthStep;\n  }\n  \n  // 发起下一步授权，如果都已经完成，就直接返回成功。\n  nextStep(e) {\n    const { mustAuthStep } = this.data;\n    const currAuthStep = this.updateAuthStep();\n  \n    // 已完成授权\n    if (currAuthStep >= mustAuthStep || currAuthStep === AuthStepType.THREE) {\n      // 更新全局的授权状态机，广播消息给订阅者。\n      return getApp().status.auth.success();\n    }\n\n    // 第一步：更新用户信息\n    if (currAuthStep === AuthStepType.ONE) {\n      // 已有密文信息，更新用户信息\n      if (e) session.updateUser(e);\n\n      // 更新到视图层，展示对应UI，等待获取用户信息\n      else this.setData({ currAuthStep });\n      return;\n    }\n\n    // 第二步：更新手机信息\n    if (currAuthStep === AuthStepType.TWO) {\n      // 已有密文信息，更新手机号\n      if (e) this.bindPhone(e);\n\n      // 未有密文信息，弹出获取窗口\n      else this.setData({ currAuthStep });\n      return;\n    }\n\n    console.warn('auth.nextStep 错误', { currAuthStep, mustAuthStep });\n  },\n  \n  // ...\n});\n```\n\n那么我们的 `<auth-flow>` 中就可以根据 `currAuthStep` 和 `mustAuthStep` 来去做不同的 UI 展示。需要注意的是使用 `<user-container>`、`<phone-container>` 的时候连接上 `nextStep(e)` 函数。\n\n示例伪代码：\n\n```html\n<view class=\"auth-flow\">\n\n  <!-- 已完成授权 -->\n  <block wx:if=\"{{currAuthStep === mustAuthStep || currAuthStep === AuthStep.THREE}}\">\n    <view>已完成授权</view>\n  </block>\n\n  <!-- 未完成授权，第一步：授权用户信息 -->\n  <block wx:elif=\"{{currAuthStep === AuthStep.ONE}}\">\n    <user-container bind:getuserinfo=\"nextStep\">\n      <view>授权用户信息</view>\n    </user-container>\n  </block>\n\n  <!-- 未完成授权，第二步：授权手机号 -->\n  <block wx:elif=\"{{currAuthStep === AuthStep.TWO}}\">\n    <phone-container bind:getphonenumber=\"nextStep\">\n      <view>授权手机号</view>\n    </phone-container>\n  </block>\n  \n</view>\n```\n\n\n\n### 3.2.2 权限拦截的处理\n\n到这里，我们制作好了用来承载授权流程的组件 `<auth-flow>` ，那么接下来就是决定要使用它的时机了。\n\n我们梳理需要授权的场景：\n\n1. 点击某个按钮，例如：购买某个商品。\n\n   对于这种场景，常见的是通过弹窗完成授权，用户可以选择关闭。\n\n   \n\n   ![授权模型-弹窗](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016113312.png)\n\n2. 浏览某个页面，例如：访问个人中心。\n\n   对于这种场景，我们可以在点击跳转某个页面的时候，进行拦截，弹窗处理。但这样的缺点是，跳转到目标页面的地方可能会很多，每个都拦截，难免会错漏。而且当目标页面作为「小程序落地页面」的时候，就避免不了。\n\n   这时候，我们可以通过重定向到授权页面来完成授权流程，完成之后，再回来。\n\n   \n   \n   ![授权模型-页面](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016113324.png)\n\n那么我们定义一个枚举变量：\n\n```javascript\n// 授权的展示形式\nexport enum AuthDisplayMode {\n  // 以弹窗形式\n  POPUP = 'button',\n\n  // 以页面形式\n  PAGE = 'page',\n}\n```\n\n我们可以设计一个 `mustAuth` 方法，在点击某个按钮，或者页面加载的时候，进行授权控制。\n\n伪代码示例：\n\n```javascript\nclass Session {\n  // ...\n  \n  mustAuth({\n    mustAuthStep = AuthStepType.TWO, // 需要授权的LEVEL，默认需要获取用户资料\n    popupCompName = 'auth-popup',\t// 授权弹窗组件的 id\n    mode = AuthDisplayMode.POPUP, // 默认以弹窗模式\n  } = {}): Promise<void> {\n    \n    // 如果当前的授权步骤已经达标，则返回成功\n    if (this.currentAuthStep() >= mustAuthStep) return Promise.resolve();\n\n    // 尝试获取当前页面的 <auth-popup id=\"auth-popup\" /> 组件实例\n    const pages = getCurrentPages();\n    const curPage = pages[pages.length - 1];\n    const popupComp = curPage.selectComponent(`#${popupCompName}`);\n\n    // 组件不存在或者显示指定页面，跳转到授权页面\n    if (!popupComp || mode === AuthDisplayMode.PAGE) {\n      const curRoute = curPage.route;\n\n      // 跳转到授权页面，带上当前页面路由，授权完成之后，回到当前页面。\n      wx.redirectTo({ url: `authPage?backTo=${encodeURIComponent(curRoute)}` });\n      return Promise.resolve();\n    }\n    \n    // 设置授权 LEVEL，然后调用 <auth-popup> 的 nextStep 方法，进行进一步的授权。\n    popupComp.setMustAuthStep(mustAuthStep);\n    popupComp.nextStep();\n\n    // 等待成功回调或者失败回调\n    return new Promise((resolve, reject) => {\n      const authStatus = getApp().status.auth;\n      authStatus.onceSuccess(resolve);\n      authStatus.onceFail(reject);\n    });\n  }\n  \n  // ...\n}\n```\n\n那么我们就能在按钮点击，或者页面加载的时候进行授权拦截：\n\n```javascript\nPage({\n  onLoad() {\n    session.mustAuth().then(() => {\n      // 开始初始化页面...\n    })；\n  }\n  \n  onClick(e) {\n    session.mustAuth().then(() => {\n      // 开始处理回调逻辑...\n    })；\n  }\n})\n```\n\n当然，如果项目使用了 TS 的话，或者支持 ES7 Decorator 特性的话，我们可以为 `mustAuth` 提供一个装饰器版本：\n\n```javascript\nexport function mustAuth(option = {}) {\n  return function(\n    _target,\n    _propertyName,\n    descriptor,\n  ) {\n    // 劫持目标方法\n    const method = descriptor.value;\n    \n    // 重写目标方法\n    descriptor.value = function(...args: any[]) {\n      return session.mustAuth(option).then(() => {\n        // 登录完成之后，重放原来方法\n        if (method) return method.apply(this, args);\n      });\n    };\n  };\n}\n```\n\n那么使用方式就简单一些了：\n\n```javascript\nPage({\n  @mustAuth();\n  onLoad() {\n    // 开始初始化页面...\n  }\n  \n  @mustAuth();\n  onClick(e) {\n    // 开始处理回调逻辑...\n  }\n});\n```\n\n\n\n## 3.3. 前后端交互协议整理\n\n作为一套可复用的小程序登录方案，当然需要去定义好前后端的交互协议。\n\n那么整套登录流程下来，需要的接口有这么几个：\n\n![登录注册前后端接口协议](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016162606.png)\n\n1. **静默登录 silentLogin**\n  \n   1. 入参：\n      1. code: 产自 wx.login()\n   2. 出参：\n      1. token: 自定义登录态凭证\n      2. userInfo: 用户信息\n   3. 说明：\n      1. 后端利用 code 跟微信客户端换取用户标识，然后注册并登录用户，返回自定义登录态 `token` 给前端\n      2. `token` 前端会存起来，每个请求都会带上\n      3. userInfo 需要包含`nickname`和`phone`字段，前端用于计算当前用户的授权阶段。当然这个状态的记录可以放在后端，但是我们认为放在前端，会更加灵活。\n2. **更新用户信息 updateUser**\n   1. 入参：\n      1. nickname: 用户昵称\n      2. encrypt: 微信开放数据相关的 `iv`, `encryptedData`\n      3. 以及其他如性别地址等非必要字段\n   2. 出参：\n      1. userInfo：更新后的最新用户信息\n   3. 说明：\n      1. 后端解密微信开放数据，获取隐蔽数据，如：`unionId `等\n      2. 后端支持更新包括 `nickname`等用户基本信息。\n      3. 前端会把 userInfo 信息更新到 `session` 中，用于计算授权阶段。\n3. **更新用户手机号 updatePhone**\n   1. 入参：\n      1. encrypt：微信开放数据相关的 `iv`, `encryptedData`\n   2. 出参：\n      1. userInfo：更新后的最新用户信息\n   3. 说明：\n      1. 后端解密开放式局，获取手机号，并更新到用户信息中。 \n      2. 前端会把 userInfo 信息更新到 `session` 中，用于计算授权阶段。\n4. **解绑手机号 unbindPhone**\n   1. 入参：-\n   2. 出参：-\n   3. 说明：后端解绑用户手机号，成功与否，走业务定义的前后端协议。\n5. **登录 logout**\n   1. 入参：-\n   2. 出参：-\n   3. 说明：后端主动过期登录态，成功与否，走业务定义的前后端协议。\n   \n   \n\n# 五. 架构图\n\n最后我们来梳理一下整体的「登录服务」的架构图：\n\n![微信小程序登录服务架构图](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjqk8sm9dbj30v60fp0uc.jpg)\n\n由「登录服务」和「底层建设」组合提供的通用服务，业务层只需要去根据产品需求，定制授权的流程 `<auth-flow>` ，就能满足大部分场景了。\n\n# 六. 总结\n\n本篇文章通过一些常见的登录授权场景来展开来描述细节点。\n\n整理了「登录」、「授权」的概念。\n\n然后分别针对「登录」介绍了一些关键的技术实现：\n\n1. 静默登录\n2. 静默登录异步状态的处理\n3. 自定义登录态过期的容错处理\n4. 微信 `session_key` 过期的容错处理\n\n而对于「授权」，会有设计UI部分的逻辑，还需要涉及到组件的拆分：\n\n1. 组件拆分与设计\n2. 权限拦截的处理\n\n然后，梳理了这套登录授权方案所依赖的后端接口，和给出最简单的参考协议。\n\n最后，站在「秉着沉淀一套通用的小程序登录方案和服务为目标」的角度，梳理了一下架构层面上的分层。\n\n1. 业务定制层\n2. 登录服务层\n3. 底层建设\n\n# 七. 参考\n\n1. [fly.js 官网](https://wendux.github.io/dist/#/doc/flyio/readme)\n2. [微信官方文档-授权](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html)\n3. [微信官方文档-服务端获取开放数据](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)\n4. 微信官方社区\n   1. [小程序解密手机号,隔一小段时间后,checksession:ok,但是解密失败](https://developers.weixin.qq.com/community/develop/doc/000424005b89983f337a622c751000?highLine=wx.checkSession)\n   2. [wx.checkSession有效，但是解密数据失败](https://developers.weixin.qq.com/community/develop/doc/0008e429bd0c886e10699f59c51000?_at=1602745291452)\n   3. [checkSession判断session_key未失效，但是解密手机号失败](https://developers.weixin.qq.com/community/develop/doc/000a04ab4546d80d5428ffcee51800?_at=1602745291452)\n\n","source":"_posts/2020/wxapp-login-design.md","raw":"---\ntitle: 微信小程序登录的前端设计与实现\ncategory: 搬砖码农\ndate: 2020-10-16 22:22:25\ntags: \n- 登录 微信小程序\n---\n\n# 一. 前言\n\n对于登录/注册的设计如此精雕细琢的目的，当然是想让这个作为应用的基础能力，有足够的健壮性，避免出现全站性的阻塞。\n\n同时要充分考虑如何解耦和封装，在开展新的小程序的时候，能更快的去复用能力，避免重复采坑。\n\n登录注册这模块，就像个冰山，我们以为它就是「输入账号密码，就完成登录了」，但实际下面还有各种需要考虑的问题。\n\n![](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016104626.jpg)\n\n在此，跟在座的各位分享一下，最近做完一个小程序登录/注册模块之后，沉淀下来的一些设计经验和想法。\n\n# 二. 业务场景\n\n在用户浏览小程序的过程中，由业务需要，往往需要获取用户的一些基本信息，常见的有：\n\n1. 微信昵称\n2. 微信手机号\n\n而不同的产品，对于用户的信息要求不尽相同，也会有不一样的授权流程。\n\n第一种，常见于电商系统中，用户购买商品的时候，为了识别用户多平台的账号，往往用手机号去做一个联系，这时候需要用户去授权手机号。\n\n![授权手机号](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111059.jpg)\n\n第二种，为了让用户信息得到基本的初始化，往往需要更进一步获取用户信息：如微信昵称，`unionId` 等，就需要询问用户授权。\n\n![授权用户信息](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111042.jpg)\n\n第三种，囊括第一种，第二种。\n\n![完整授权流程](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111006.jpg)\n\n# 三. 概念\n\n秉着沉淀一套通用的小程序登录方案和服务为目标，我们去分析一下业务，得出变量。\n\n在做技术设计之前，讲点必要的废话，对一些概念进行基本调频。\n\n\n\n## 2.1 关于「登录」\n\n登录在英文中是 「login」，对应的还有 「logout」。而登录之前，你需要拥有一个账号，就要 「register」（or sign up）。\n\n话说一开始的产品是没有登录/注册功能的，用的人多了就慢慢有了。出于产品本身的需求，需要对「用户」进行身份识别。\n\n在现实社会中，我们每个人都有一个身份ID：身份证。当我到了16岁的时候，第一次去公安局领身份证的时候，就完成了一次「注册」行为。然后我去网吧上网，身份证刷一下，完成了一次「登录」行为。\n\n那么对于虚拟世界的互联网来说，这个身份证明就是「账号+密码」。\n\n常见的登录/注册方式有：\n\n1. **账号密码注册**\n\n\t在互联网的早期，个人邮箱和手机覆盖度小。所以，就需要用户自己想一个账号名，我们注册个QQ号，就是这种形式。\n\n\t![from 汽车之家](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105159.png)\t\n\n2. **邮箱地址注册**\n\n\t千禧年之后，PC互联网时代快速普及，我们都创建了属于自己的个人邮箱。加上QQ也自带邮箱账号。由于邮箱具有个人私密性，且能够进行信息的沟通，因此，大部分网站开始采用邮箱账号作为用户名来进行注册，并且会在注册的过程中要求登录到相应邮箱内查收激活邮件，验证我们对该注册邮箱的所有权。\n\n\t![from 支付宝](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105005.png)\n\n3. **手机号码注册**\n\n\t在互联网普及之后，智能手机与移动互联网发展迅猛。手机也成为每个人必不可少的移动设备，同时移动互联网也已经深深融入每个人的现代生活当中。所以，相较于邮箱，目前手机号码与个人的联系更加紧密，而且越来越多的移动应用出现，采用手机号码作为用户名的注册方式也得到了广泛的使用。   \n\n\t![from 知乎](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105120.png)\n\n到了 2020 年，微信用户规模达 12 亿。那么，微信账号，起码在中国，已成为新一代互联网世界的「身份标识」。\n\n而对微信小程序而言，天然就能知道当前用户的微信账号ID。微信允许小程序应用，能在用户无感知的情况下，悄无声息的「登录」到我们的小程序应用中去，这个就是我们经常称之为的「静默登录」。\n\n\n其实微信小程序的登录，跟传统 Web 应用的「单点登录」本质是一样的概念。\n\n1. 单点登录：在 A 站登录了，C 站和 B 站能实现快速的「静默登录」。\n2. 微信小程序登录：在微信中，登录了微信账号，那么在整个小程序生态中，都可以实现「静默登录」。\n\n\n由于 Http 本来是无状态的，业界基本对于登录态的一般做法：\n\n1. cookie-session：常用于浏览器应用中\n2. access token：常用于移动端等非浏览器应用\n\n在微信小程序来说，对于「JS逻辑层」并不是一个浏览器环境，自然没有 `Cookie`，那么通常会使用 `access token` 的方式。\n\n\n\n## 2.2 关于「授权」\n\n对于需要更进一步获取用的用户昵称、用户手机号等信息的产品来说。微信出于用户隐私的考虑，需要用户主动同意授权。小程序应用才能获取到这部分信息，这就有了目前流行的小程序「授权用户信息」、「授权手机号」的交互了。\n\n出于不同的用户信息敏感度不同的考虑，微信小程序对于不同的用户信息提供「授权」的方式不尽相同：\n\n1. 调用具体 API 方式，弹窗授权。\n   1. 例如调用 [`wx.getLocation()`](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getLocation.html) 的时候，如果用户未授权，则会弹出地址授权界面。\n   2. 如果拒绝了，就不会再次弹窗，`wx.getLocation()`直接返回失败。\n2. `<button open-type=\"xxx\" />` 方式。\n   1. 仅支持：用户敏感信息，用户手机号，需要配合后端进行对称加解密，方能拿到数据。\n   2. 用户已拒绝，再次点击按钮，仍然会弹窗。\n3. 通过 [`wx.authorize()`](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/authorize/wx.authorize.html)，提前询问授权，之后需要获取相关信息的时候不用再次弹出授权。\n\n# 四. 详细设计\n\n梳理清楚了概念之后，我们模块的划分上，可以拆分为两大块：\n\n1. **登录**：负责与服务端创建起一个会话，这个会话实现静默登录以及相关的容错处理等，模块命名为：`Session`\n2. **授权**：负责与用户交互，获取与更新信息，以及权限的控制处理等，模块命名为：`Auth`\n\n\n\n## 3.1 登录的实现\n\n### 3.1.1 静默登录\n\n![微信登录](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111135.png)\n\n微信官方提供的登录方案，总结为三步：\n\n1. 前端通过 `wx.login()` 获取一次性加密凭证 code，交给后端。\n2. 后端把这个 code 传输给微信服务器端，换取用户唯一标识 `openId` 和授权凭证 `session_key`。（用于后续服务器端和微信服务器的特殊 API 调用，具体看：[微信官方文档-服务端获取开放数据](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)）。\n3. 后端把从微信服务器获取到的用户凭证与自行生成的登录态凭证（token），传输给前端。前端保存起来，下次请求的时候带给后端，就能识别哪个用户。\n\n如果只是实现这个流程的话，挺简单的。\n\n但要实现一个健壮的登录过程，还需要注意更多的边界情况：\n\n1. **收拢 `wx.login()` 的调用**：\n\n\t由于 `wx.login()` 会产生不可预测的副作用，例如会可能导致`session_key`失效，从而导致后续的授权解密场景中的失败。我们这里可以提供一个像 `session.login()` 的方法，掌握 `wx.login()` 控制权，对其做一系列的封装和容错处理。\n\n2. **调用的时机**：\n\n\t通常我们会在应用启动的时候（ `app.onLaunch()` ），去发起静默登录。但这里会由小程序生命周期设计问题而导致的一个异步问题：加载页面的时候，去调用一个需要登录态的后端 API 的时候，前面异步的静态登录过程有可能还没有完成，从而导致请求失败。\n\n\t当然也可以在第一个需要登录态的接口调用的时候以异步阻塞的方式发起登录调用，这个需要结合良好设计的接口层。\n\n\t以上讲到的两种场景的详细设计思路下文会讲到。\n\n3. **并发调用的问题**：\n\n\t在业务场景中，难免会出现多处代码需要触发登录，如果遇到极端情况，这多处代码同时间发起调用。那就会造成短时间多次发起登录过程，尽管之前的请求还没有完成。针对这种情况，我们可以以第一个调用为阻塞，后续调用等待结果，就像精子和卵子结合的过程。\n\n4. **未过期调用的问题**：\n\n\t如果我们的登录态未过期，完全可以正常使用的，默认情况就不需再去发起登录过程了。这时候我们可以默认情况下先去检查登录态是否可用，不能用，我们再发起请求。然后还可以提供一个类似 `session.login({ force: true })`的参数去强行发起登录。\n\n\n\n### 3.1.2 静默登录异步状态的处理\n\n**1. 应用启动的时候调用**\n\n因为大部分情况都需要依赖登录态，我们会很自然而然的想到把这个调用的时机放到应用启动的时候（ `app.onLaunch()` ）来调用。\n\n但是由于原生的小程序启动流程中， `App`，`Page`，`Component` 的生命周期钩子函数，都不支持异步阻塞。\n\n那么我们很容易会遇到 `app.onLaunch` 发起的「登录过程」在 `page.onLoad` 的时候还没有完成，我们就无法正确去做一些依赖登录态的操作。\n\n针对这种情况，我们设计了一个状态机的工具：[status](http://beautywejs.com/#/remote/plugin-status?id=plugin-statusl)\n\n\n\n![状态机](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016110706.png)\n\n\n\n基于状态机，我们就可以编写这样的代码：\n\n```javascript\nimport { Status } from '@beautywe/plugin-status';\n\n// on app.js\nApp({\n    status: {\n       login: new Status('login');\n    },\n\n    onLaunch() {\n        session\n            // 发起静默登录调用\n            .login()\n\n            // 把状态机设置为 success\n            .then(() => this.status.login.success())\n      \n            // 把状态机设置为 fail\n            .catch(() => this.status.login.fail());\n    },\n});\n\n\n// on page.js\nPage({\n    onLoad() {\n      const loginStatus = getApp().status.login;\n      \n      // must 里面会进行状态的判断，例如登录中就等待，登录成功就直接返回，登录失败抛出等。\n      loginStatus().status.login.must(() => {\n        // 进行一些需要登录态的操作...\n      });\n    },\n});\n```\n\n\n\n**2. 在「第一个需要登录态接口」被调用的时候去发起登录**\n\n更进一步，我们会发现，需要登录态的更深层次的节点是在发起的「需要登录态的后端 API 」的时候。\n\n那么我们可以在调用「需要登录态的后端 API」的时候再去发起「静默登录」，对于并发的场景，让其他请求等待一下就好了。\n\n以 [fly.js](https://wendux.github.io/dist/#/doc/flyio/readme) 作为 `wx.request()` 封装的「网络请求层」，做一个简单的例子：\n\n```javascript\n// 发起请求，并表明该请求是需要登录态的\nfly.post('https://...', params, { needLogin: true });\n\n// 在 fly 拦截器中处理逻辑\nfly.interceptors.request.use(async (req)=>{\n\n  // 在请求需要登录态的时候\n  if (req.needLogin !== false) {\n\n    // ensureLogin 核心逻辑是：判断是否已登录，如否发起登录调用，如果正在登录，则进入队列等待回调。\n    await session.ensureLogin();\n    \n    // 登录成功后，获取 token，通过 headers 传递给后端。\n    const token = await session.getToken();\n    Object.assign(req.headers, { [AUTH_KEY_NAME]: token });\n  }\n  \n  return req;\n});\n\n```\n\n\n\n### 3.1.3 自定义登录态过期的容错处理\n\n当自定义登录态过期的时候，后端需要返回特定的状态码，例如：`AUTH_EXPIRED` 、 `AUTH_INVALID` 等。\n\n前端可以在「网络请求层」去监听所有请求的这个状态码，然后发起刷新登录态，再去重放失败的请求：\n\n```javascript\n// 添加响应拦截器\nfly.interceptors.response.use(\n    (response) => {\n      const code = res.data;\n        \n      // 登录态过期或失效\n      if ( ['AUTH_EXPIRED', 'AUTH_INVALID'].includes(code) ) {\n      \n        // 刷新登录态\n        await session.refreshLogin();\n        \n        // 然后重新发起请求\n        return fly.request(request);\n      }\n    }\n)\n```\n\n那么如果并发的发起多个请求，都返回了登录态失效的状态码，上述代码就会被执行多次。\n\n我们需要对 `session.refreshLogin()` 做一些特殊的容错处理：\n\n1. **请求锁**：同一时间，只允许一个正在过程中的网络请求。\n2. **等待队列**：请求被锁定之后，调用该方法的所有调用，都推入一个队列中，等待网络请求完成之后共用返回结果。\n3. **熔断机制**：如果短时间内多次调用，则停止响应一段时间，类似于 TCP 慢启动。\n\n示例代码：\n\n```javascript\nclass Session {\n  // ....\n  \n  // 刷新登录保险丝，最多重复 3 次，然后熔断，5s 后恢复\n  refreshLoginFuseLine = REFRESH_LOGIN_FUSELINE_DEFAULT;\n  refreshLoginFuseLocked = false;\n  refreshLoginFuseRestoreTime = 5000;\n\n  // 熔断控制\n  refreshLoginFuse(): Promise<void> {\n    if (this.refreshLoginFuseLocked) {\n      return Promise.reject('刷新登录-保险丝已熔断，请稍后');\n    }\n    if (this.refreshLoginFuseLine > 0) {\n      this.refreshLoginFuseLine = this.refreshLoginFuseLine - 1;\n      return Promise.resolve();\n    } else {\n      this.refreshLoginFuseLocked = true;\n      setTimeout(() => {\n        this.refreshLoginFuseLocked = false;\n        this.refreshLoginFuseLine = REFRESH_LOGIN_FUSELINE_DEFAULT;\n        logger.info('刷新登录-保险丝熔断解除');\n      }, this.refreshLoginFuseRestoreTime);\n      return Promise.reject('刷新登录-保险丝熔断!!');\n    }\n  }\n\n  // 并发回调队列\n  refreshLoginQueueMaxLength = 100;\n  refreshLoginQueue: any[] = [];\n  refreshLoginLocked = false;\n\n  // 刷新登录态\n  refreshLogin(): Promise<void> {\n    return Promise.resolve()\n    \n      // 回调队列 + 熔断 控制\n      .then(() => this.refreshLoginFuse())\n      .then(() => {\n        if (this.refreshLoginLocked) {\n          const maxLength = this.refreshLoginQueueMaxLength;\n          if (this.refreshLoginQueue.length >= maxLength) {\n            return Promise.reject(`refreshLoginQueue 超出容量：${maxLength}`);\n          }\n          return new Promise((resolve, reject) => {\n            this.refreshLoginQueue.push([resolve, reject]);\n          });\n        }\n        this.refreshLoginLocked = true;\n      })\n\n      // 通过前置控制之后，发起登录过程\n      .then(() => {\n        this.clearSession();\n        wx.showLoading({ title: '刷新登录态中', mask: true });\n        return this.login()\n          .then(() => {\n            wx.hideLoading();\n            wx.showToast({ icon: 'none', title: '登录成功' });\n            this.refreshLoginQueue.forEach(([resolve]) => resolve());\n            this.refreshLoginLocked = false;\n          })\n          .catch(err => {\n            wx.hideLoading();\n            wx.showToast({ icon: 'none', title: '登录失败' });\n            this.refreshLoginQueue.forEach(([, reject]) => reject());\n            this.refreshLoginLocked = false;\n            throw err;\n          });\n      });\n\n  // ...\n}\n```\n\n### 3.1.4 微信 session_key 过期的容错处理\n\n我们从上面的「静默登录」之后，微信服务器端会下发一个 `session_key` 给后端，而这个会在需要获取[微信开放数据](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)的时候会用到。\n\n![微信开放数据](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016110824.png)\n\n\n\n而 `session_key` 是有时效性的，以下摘自微信官方描述：\n\n> #### 会话密钥 session_key 有效性\n>\n> 开发者如果遇到因为 session_key 不正确而校验签名失败或解密失败，请关注下面几个与 session_key 有关的注意事项。\n>\n> 1. [wx.login](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html) 调用时，用户的 session_key **可能**会被更新而致使旧 session_key 失效（刷新机制存在最短周期，如果同一个用户短时间内多次调用 [wx.login](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html)，并非每次调用都导致 session_key 刷新）。开发者应该在明确需要重新登录时才调用 [wx.login](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html)，及时通过 [auth.code2Session](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html) 接口更新服务器存储的 session_key。\n> 2. 微信不会把 session_key 的有效期告知开发者。我们会根据用户使用小程序的行为对 session_key 进行续期。用户越频繁使用小程序，session_key 有效期越长。\n> 3. 开发者在 session_key 失效时，可以通过重新执行登录流程获取有效的 session_key。使用接口 [wx.checkSession](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.checkSession.html)可以校验 session_key 是否有效，从而避免小程序反复执行登录流程。\n> 4. 当开发者在实现自定义登录态时，可以考虑以 session_key 有效期作为自身登录态有效期，也可以实现自定义的时效性策略。\n\n翻译成简单的两句话：\n\n1. `session_key` 时效性由微信控制，开发者不可预测。\n2. `wx.login` 可能会导致 `session_key` 过期，可以在使用接口之前用` wx.checkSession` 检查一下。\n\n而对于第二点，我们通过实验发现，偶发性的在 `session_key` 已过期的情况下，`wx.checkSession` 会概率性返回 `true`\n\n社区也有相关的反馈未得到解决：\n\n* [小程序解密手机号,隔一小段时间后,checksession:ok,但是解密失败](https://developers.weixin.qq.com/community/develop/doc/000424005b89983f337a622c751000?highLine=wx.checkSession)\n* [wx.checkSession有效，但是解密数据失败](https://developers.weixin.qq.com/community/develop/doc/0008e429bd0c886e10699f59c51000?_at=1602745291452)\n* [checkSession判断session_key未失效，但是解密手机号失败](https://developers.weixin.qq.com/community/develop/doc/000a04ab4546d80d5428ffcee51800?_at=1602745291452)\n\n**所以结论是：`wx.checkSession`可靠性是不达 100% 的。**\n\n\n\n基于以上，我们需要对 `session_key` 的过期做一些容错处理：\n\n1. 发起需要使用 `session_key` 的请求前，做一次 `wx.checkSession` 操作，如果失败了刷新登录态。\n2. 后端使用 `session_key` 解密开放数据失败之后，返回特定错误码（如：`DECRYPT_WX_OPEN_DATA_FAIL`），前端刷新登录态。\n\n示例代码：\n\n```javascript\n// 定义检查 session_key 有效性的操作\nconst ensureSessionKey = async () => {\n  const hasSession = await new Promise(resolve => {\n    wx.checkSession({\n      success: () => resolve(true),\n      fail: () => resolve(false),\n    });\n  });\n  \n  if (!hasSession) {\n    logger.info('sessionKey 已过期，刷新登录态');\n\n    // 接上面提到的刷新登录逻辑\n    return session.refreshLogin();\n  }\n\n  return Promise.resolve();\n}\n\n// 在发起请求的时候，先做一次确保 session_key 最新的操作（以 fly.js 作为网络请求层为例）\nconst updatePhone = async (params) => {\n  await ensureSessionKey();\n  const res = await fly.post('https://xxx', params);\n}\n\n// 添加响应拦截器, 监听网络请求返回\nfly.interceptors.response.use(\n    (response) => {\n      const code = res.data;\n        \n      // 登录态过期或失效\n      if ( ['DECRYPT_WX_OPEN_DATA_FAIL'].includes(code)) {\n\n        // 刷新登录态\n        await session.refreshLogin();\n        \n        // 由于加密场景的加密数据由用户点击产生，session_key 可能已经更改，需要用户重新点击一遍。\n        wx.showToast({ title: '网络出小差了，请稍后重试', icon: 'none' });\n      }\n    }\n)\n```\n\n\n\n## 3.2 授权的实现\n\n### 3.2.1 组件拆分与设计\n\n在用户信息和手机号获取的方式上，微信是以 `<button open-type='xxx' />` 的方式，让用户主动点击授权的。\n\n那么为了让代码更解耦，我们设计这样三个组件：\n\n1. `<user-contaienr getUserInfo=\"onUserInfoAuth\">`: 包装点击交互，通过 `<slot>` 支持点击区域的自定义UI。\n2. `<phone-container getPhonenNmber=\"onPhoneAuth\">` : 与 `<user-container>` 同理。\n3. `<auth-flow>`: 根据业务需要，组合 `<user-container>`、`<phone-container>` 组合来定义不同的授权流程。\n\n\n\n以开头的业务场景的流程为例，它有这样的要求：\n\n1. 有多个步骤。\n2. 如果中途断掉了，可以从中间接上。\n3. 有些场景中，只要求达到「用户信息授权」，而不需要完成「用户手机号」。\n\n![完整授权流程](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111006.jpg)\n\n那么授权的阶段可以分三层：\n\n```javascript\n// 用户登录的阶段\nexport enum AuthStep {\n  // 阶段一：只有登录态，没有用户信息，没有手机号\n  ONE = 1,\n\n  // 阶段二：有用户信息，没有手机号\n  TWO = 2,\n\n  // 阶段三：有用户信息，有手机号\n  THREE = 3,\n}\n```\n\n`AuthStep` 的推进过程是不可逆的，我们可以定义一个 `nextStep` 函数来封装 AuthStep 更新的逻辑。外部使用的话，只要无脑调用 `nextStep` 方法，等待回调结果就行。\n\n示例伪代码：\n\n```javascript\n// auth-flow component\n\nComponent({\n  // ...\n  \n  data: {\n    // 默认情况下，只需要到达阶段二。\n    mustAuthStep: AuthStep.TWO\n  },\n  \n  // 允许临时更改组件的需要达到的阶段。\n  setMustAuthStep(mustAuthStep: AuthStep) {\n    this.setData({ mustAuthStep });\n  },\n  \n  // 根据用户当前的信息，计算用户处在授权的阶段\n  getAuthStep() {\n    let currAuthStep;\n    \n    // 没有用户信息，尚在第一步\n    if (!session.hasUser() || !session.hasUnionId()) {\n      currAuthStep = AuthStepType.ONE;\n    }\n\n    // 没有手机号，尚在第二步\n    if (!session.hasPhone()) {\n      currAuthStep = AuthStepType.TWO;\n    }\n\n    // 都有，尚在第三步\n    currAuthStep = AuthStepType.THREE;\n    return currAuthStep;\n  }\n  \n  // 发起下一步授权，如果都已经完成，就直接返回成功。\n  nextStep(e) {\n    const { mustAuthStep } = this.data;\n    const currAuthStep = this.updateAuthStep();\n  \n    // 已完成授权\n    if (currAuthStep >= mustAuthStep || currAuthStep === AuthStepType.THREE) {\n      // 更新全局的授权状态机，广播消息给订阅者。\n      return getApp().status.auth.success();\n    }\n\n    // 第一步：更新用户信息\n    if (currAuthStep === AuthStepType.ONE) {\n      // 已有密文信息，更新用户信息\n      if (e) session.updateUser(e);\n\n      // 更新到视图层，展示对应UI，等待获取用户信息\n      else this.setData({ currAuthStep });\n      return;\n    }\n\n    // 第二步：更新手机信息\n    if (currAuthStep === AuthStepType.TWO) {\n      // 已有密文信息，更新手机号\n      if (e) this.bindPhone(e);\n\n      // 未有密文信息，弹出获取窗口\n      else this.setData({ currAuthStep });\n      return;\n    }\n\n    console.warn('auth.nextStep 错误', { currAuthStep, mustAuthStep });\n  },\n  \n  // ...\n});\n```\n\n那么我们的 `<auth-flow>` 中就可以根据 `currAuthStep` 和 `mustAuthStep` 来去做不同的 UI 展示。需要注意的是使用 `<user-container>`、`<phone-container>` 的时候连接上 `nextStep(e)` 函数。\n\n示例伪代码：\n\n```html\n<view class=\"auth-flow\">\n\n  <!-- 已完成授权 -->\n  <block wx:if=\"{{currAuthStep === mustAuthStep || currAuthStep === AuthStep.THREE}}\">\n    <view>已完成授权</view>\n  </block>\n\n  <!-- 未完成授权，第一步：授权用户信息 -->\n  <block wx:elif=\"{{currAuthStep === AuthStep.ONE}}\">\n    <user-container bind:getuserinfo=\"nextStep\">\n      <view>授权用户信息</view>\n    </user-container>\n  </block>\n\n  <!-- 未完成授权，第二步：授权手机号 -->\n  <block wx:elif=\"{{currAuthStep === AuthStep.TWO}}\">\n    <phone-container bind:getphonenumber=\"nextStep\">\n      <view>授权手机号</view>\n    </phone-container>\n  </block>\n  \n</view>\n```\n\n\n\n### 3.2.2 权限拦截的处理\n\n到这里，我们制作好了用来承载授权流程的组件 `<auth-flow>` ，那么接下来就是决定要使用它的时机了。\n\n我们梳理需要授权的场景：\n\n1. 点击某个按钮，例如：购买某个商品。\n\n   对于这种场景，常见的是通过弹窗完成授权，用户可以选择关闭。\n\n   \n\n   ![授权模型-弹窗](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016113312.png)\n\n2. 浏览某个页面，例如：访问个人中心。\n\n   对于这种场景，我们可以在点击跳转某个页面的时候，进行拦截，弹窗处理。但这样的缺点是，跳转到目标页面的地方可能会很多，每个都拦截，难免会错漏。而且当目标页面作为「小程序落地页面」的时候，就避免不了。\n\n   这时候，我们可以通过重定向到授权页面来完成授权流程，完成之后，再回来。\n\n   \n   \n   ![授权模型-页面](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016113324.png)\n\n那么我们定义一个枚举变量：\n\n```javascript\n// 授权的展示形式\nexport enum AuthDisplayMode {\n  // 以弹窗形式\n  POPUP = 'button',\n\n  // 以页面形式\n  PAGE = 'page',\n}\n```\n\n我们可以设计一个 `mustAuth` 方法，在点击某个按钮，或者页面加载的时候，进行授权控制。\n\n伪代码示例：\n\n```javascript\nclass Session {\n  // ...\n  \n  mustAuth({\n    mustAuthStep = AuthStepType.TWO, // 需要授权的LEVEL，默认需要获取用户资料\n    popupCompName = 'auth-popup',\t// 授权弹窗组件的 id\n    mode = AuthDisplayMode.POPUP, // 默认以弹窗模式\n  } = {}): Promise<void> {\n    \n    // 如果当前的授权步骤已经达标，则返回成功\n    if (this.currentAuthStep() >= mustAuthStep) return Promise.resolve();\n\n    // 尝试获取当前页面的 <auth-popup id=\"auth-popup\" /> 组件实例\n    const pages = getCurrentPages();\n    const curPage = pages[pages.length - 1];\n    const popupComp = curPage.selectComponent(`#${popupCompName}`);\n\n    // 组件不存在或者显示指定页面，跳转到授权页面\n    if (!popupComp || mode === AuthDisplayMode.PAGE) {\n      const curRoute = curPage.route;\n\n      // 跳转到授权页面，带上当前页面路由，授权完成之后，回到当前页面。\n      wx.redirectTo({ url: `authPage?backTo=${encodeURIComponent(curRoute)}` });\n      return Promise.resolve();\n    }\n    \n    // 设置授权 LEVEL，然后调用 <auth-popup> 的 nextStep 方法，进行进一步的授权。\n    popupComp.setMustAuthStep(mustAuthStep);\n    popupComp.nextStep();\n\n    // 等待成功回调或者失败回调\n    return new Promise((resolve, reject) => {\n      const authStatus = getApp().status.auth;\n      authStatus.onceSuccess(resolve);\n      authStatus.onceFail(reject);\n    });\n  }\n  \n  // ...\n}\n```\n\n那么我们就能在按钮点击，或者页面加载的时候进行授权拦截：\n\n```javascript\nPage({\n  onLoad() {\n    session.mustAuth().then(() => {\n      // 开始初始化页面...\n    })；\n  }\n  \n  onClick(e) {\n    session.mustAuth().then(() => {\n      // 开始处理回调逻辑...\n    })；\n  }\n})\n```\n\n当然，如果项目使用了 TS 的话，或者支持 ES7 Decorator 特性的话，我们可以为 `mustAuth` 提供一个装饰器版本：\n\n```javascript\nexport function mustAuth(option = {}) {\n  return function(\n    _target,\n    _propertyName,\n    descriptor,\n  ) {\n    // 劫持目标方法\n    const method = descriptor.value;\n    \n    // 重写目标方法\n    descriptor.value = function(...args: any[]) {\n      return session.mustAuth(option).then(() => {\n        // 登录完成之后，重放原来方法\n        if (method) return method.apply(this, args);\n      });\n    };\n  };\n}\n```\n\n那么使用方式就简单一些了：\n\n```javascript\nPage({\n  @mustAuth();\n  onLoad() {\n    // 开始初始化页面...\n  }\n  \n  @mustAuth();\n  onClick(e) {\n    // 开始处理回调逻辑...\n  }\n});\n```\n\n\n\n## 3.3. 前后端交互协议整理\n\n作为一套可复用的小程序登录方案，当然需要去定义好前后端的交互协议。\n\n那么整套登录流程下来，需要的接口有这么几个：\n\n![登录注册前后端接口协议](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016162606.png)\n\n1. **静默登录 silentLogin**\n  \n   1. 入参：\n      1. code: 产自 wx.login()\n   2. 出参：\n      1. token: 自定义登录态凭证\n      2. userInfo: 用户信息\n   3. 说明：\n      1. 后端利用 code 跟微信客户端换取用户标识，然后注册并登录用户，返回自定义登录态 `token` 给前端\n      2. `token` 前端会存起来，每个请求都会带上\n      3. userInfo 需要包含`nickname`和`phone`字段，前端用于计算当前用户的授权阶段。当然这个状态的记录可以放在后端，但是我们认为放在前端，会更加灵活。\n2. **更新用户信息 updateUser**\n   1. 入参：\n      1. nickname: 用户昵称\n      2. encrypt: 微信开放数据相关的 `iv`, `encryptedData`\n      3. 以及其他如性别地址等非必要字段\n   2. 出参：\n      1. userInfo：更新后的最新用户信息\n   3. 说明：\n      1. 后端解密微信开放数据，获取隐蔽数据，如：`unionId `等\n      2. 后端支持更新包括 `nickname`等用户基本信息。\n      3. 前端会把 userInfo 信息更新到 `session` 中，用于计算授权阶段。\n3. **更新用户手机号 updatePhone**\n   1. 入参：\n      1. encrypt：微信开放数据相关的 `iv`, `encryptedData`\n   2. 出参：\n      1. userInfo：更新后的最新用户信息\n   3. 说明：\n      1. 后端解密开放式局，获取手机号，并更新到用户信息中。 \n      2. 前端会把 userInfo 信息更新到 `session` 中，用于计算授权阶段。\n4. **解绑手机号 unbindPhone**\n   1. 入参：-\n   2. 出参：-\n   3. 说明：后端解绑用户手机号，成功与否，走业务定义的前后端协议。\n5. **登录 logout**\n   1. 入参：-\n   2. 出参：-\n   3. 说明：后端主动过期登录态，成功与否，走业务定义的前后端协议。\n   \n   \n\n# 五. 架构图\n\n最后我们来梳理一下整体的「登录服务」的架构图：\n\n![微信小程序登录服务架构图](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjqk8sm9dbj30v60fp0uc.jpg)\n\n由「登录服务」和「底层建设」组合提供的通用服务，业务层只需要去根据产品需求，定制授权的流程 `<auth-flow>` ，就能满足大部分场景了。\n\n# 六. 总结\n\n本篇文章通过一些常见的登录授权场景来展开来描述细节点。\n\n整理了「登录」、「授权」的概念。\n\n然后分别针对「登录」介绍了一些关键的技术实现：\n\n1. 静默登录\n2. 静默登录异步状态的处理\n3. 自定义登录态过期的容错处理\n4. 微信 `session_key` 过期的容错处理\n\n而对于「授权」，会有设计UI部分的逻辑，还需要涉及到组件的拆分：\n\n1. 组件拆分与设计\n2. 权限拦截的处理\n\n然后，梳理了这套登录授权方案所依赖的后端接口，和给出最简单的参考协议。\n\n最后，站在「秉着沉淀一套通用的小程序登录方案和服务为目标」的角度，梳理了一下架构层面上的分层。\n\n1. 业务定制层\n2. 登录服务层\n3. 底层建设\n\n# 七. 参考\n\n1. [fly.js 官网](https://wendux.github.io/dist/#/doc/flyio/readme)\n2. [微信官方文档-授权](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html)\n3. [微信官方文档-服务端获取开放数据](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)\n4. 微信官方社区\n   1. [小程序解密手机号,隔一小段时间后,checksession:ok,但是解密失败](https://developers.weixin.qq.com/community/develop/doc/000424005b89983f337a622c751000?highLine=wx.checkSession)\n   2. [wx.checkSession有效，但是解密数据失败](https://developers.weixin.qq.com/community/develop/doc/0008e429bd0c886e10699f59c51000?_at=1602745291452)\n   3. [checkSession判断session_key未失效，但是解密手机号失败](https://developers.weixin.qq.com/community/develop/doc/000a04ab4546d80d5428ffcee51800?_at=1602745291452)\n\n","slug":"2020/wxapp-login-design","published":1,"updated":"2020-10-19T02:24:42.620Z","_id":"cl271blq50000o1rl7h999rim","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"一-前言\"><a href=\"#一-前言\" class=\"headerlink\" title=\"一. 前言\"></a>一. 前言</h1><p>对于登录&#x2F;注册的设计如此精雕细琢的目的，当然是想让这个作为应用的基础能力，有足够的健壮性，避免出现全站性的阻塞。</p>\n<p>同时要充分考虑如何解耦和封装，在开展新的小程序的时候，能更快的去复用能力，避免重复采坑。</p>\n<p>登录注册这模块，就像个冰山，我们以为它就是「输入账号密码，就完成登录了」，但实际下面还有各种需要考虑的问题。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016104626.jpg\"></p>\n<p>在此，跟在座的各位分享一下，最近做完一个小程序登录&#x2F;注册模块之后，沉淀下来的一些设计经验和想法。</p>\n<h1 id=\"二-业务场景\"><a href=\"#二-业务场景\" class=\"headerlink\" title=\"二. 业务场景\"></a>二. 业务场景</h1><p>在用户浏览小程序的过程中，由业务需要，往往需要获取用户的一些基本信息，常见的有：</p>\n<ol>\n<li>微信昵称</li>\n<li>微信手机号</li>\n</ol>\n<p>而不同的产品，对于用户的信息要求不尽相同，也会有不一样的授权流程。</p>\n<p>第一种，常见于电商系统中，用户购买商品的时候，为了识别用户多平台的账号，往往用手机号去做一个联系，这时候需要用户去授权手机号。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111059.jpg\" alt=\"授权手机号\"></p>\n<p>第二种，为了让用户信息得到基本的初始化，往往需要更进一步获取用户信息：如微信昵称，<code>unionId</code> 等，就需要询问用户授权。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111042.jpg\" alt=\"授权用户信息\"></p>\n<p>第三种，囊括第一种，第二种。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111006.jpg\" alt=\"完整授权流程\"></p>\n<h1 id=\"三-概念\"><a href=\"#三-概念\" class=\"headerlink\" title=\"三. 概念\"></a>三. 概念</h1><p>秉着沉淀一套通用的小程序登录方案和服务为目标，我们去分析一下业务，得出变量。</p>\n<p>在做技术设计之前，讲点必要的废话，对一些概念进行基本调频。</p>\n<h2 id=\"2-1-关于「登录」\"><a href=\"#2-1-关于「登录」\" class=\"headerlink\" title=\"2.1 关于「登录」\"></a>2.1 关于「登录」</h2><p>登录在英文中是 「login」，对应的还有 「logout」。而登录之前，你需要拥有一个账号，就要 「register」（or sign up）。</p>\n<p>话说一开始的产品是没有登录&#x2F;注册功能的，用的人多了就慢慢有了。出于产品本身的需求，需要对「用户」进行身份识别。</p>\n<p>在现实社会中，我们每个人都有一个身份ID：身份证。当我到了16岁的时候，第一次去公安局领身份证的时候，就完成了一次「注册」行为。然后我去网吧上网，身份证刷一下，完成了一次「登录」行为。</p>\n<p>那么对于虚拟世界的互联网来说，这个身份证明就是「账号+密码」。</p>\n<p>常见的登录&#x2F;注册方式有：</p>\n<ol>\n<li><p><strong>账号密码注册</strong></p>\n<p> 在互联网的早期，个人邮箱和手机覆盖度小。所以，就需要用户自己想一个账号名，我们注册个QQ号，就是这种形式。</p>\n<p> <img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105159.png\" alt=\"from 汽车之家\">\t</p>\n</li>\n<li><p><strong>邮箱地址注册</strong></p>\n<p> 千禧年之后，PC互联网时代快速普及，我们都创建了属于自己的个人邮箱。加上QQ也自带邮箱账号。由于邮箱具有个人私密性，且能够进行信息的沟通，因此，大部分网站开始采用邮箱账号作为用户名来进行注册，并且会在注册的过程中要求登录到相应邮箱内查收激活邮件，验证我们对该注册邮箱的所有权。</p>\n<p> <img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105005.png\" alt=\"from 支付宝\"></p>\n</li>\n<li><p><strong>手机号码注册</strong></p>\n<p> 在互联网普及之后，智能手机与移动互联网发展迅猛。手机也成为每个人必不可少的移动设备，同时移动互联网也已经深深融入每个人的现代生活当中。所以，相较于邮箱，目前手机号码与个人的联系更加紧密，而且越来越多的移动应用出现，采用手机号码作为用户名的注册方式也得到了广泛的使用。   </p>\n<p> <img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105120.png\" alt=\"from 知乎\"></p>\n</li>\n</ol>\n<p>到了 2020 年，微信用户规模达 12 亿。那么，微信账号，起码在中国，已成为新一代互联网世界的「身份标识」。</p>\n<p>而对微信小程序而言，天然就能知道当前用户的微信账号ID。微信允许小程序应用，能在用户无感知的情况下，悄无声息的「登录」到我们的小程序应用中去，这个就是我们经常称之为的「静默登录」。</p>\n<p>其实微信小程序的登录，跟传统 Web 应用的「单点登录」本质是一样的概念。</p>\n<ol>\n<li>单点登录：在 A 站登录了，C 站和 B 站能实现快速的「静默登录」。</li>\n<li>微信小程序登录：在微信中，登录了微信账号，那么在整个小程序生态中，都可以实现「静默登录」。</li>\n</ol>\n<p>由于 Http 本来是无状态的，业界基本对于登录态的一般做法：</p>\n<ol>\n<li>cookie-session：常用于浏览器应用中</li>\n<li>access token：常用于移动端等非浏览器应用</li>\n</ol>\n<p>在微信小程序来说，对于「JS逻辑层」并不是一个浏览器环境，自然没有 <code>Cookie</code>，那么通常会使用 <code>access token</code> 的方式。</p>\n<h2 id=\"2-2-关于「授权」\"><a href=\"#2-2-关于「授权」\" class=\"headerlink\" title=\"2.2 关于「授权」\"></a>2.2 关于「授权」</h2><p>对于需要更进一步获取用的用户昵称、用户手机号等信息的产品来说。微信出于用户隐私的考虑，需要用户主动同意授权。小程序应用才能获取到这部分信息，这就有了目前流行的小程序「授权用户信息」、「授权手机号」的交互了。</p>\n<p>出于不同的用户信息敏感度不同的考虑，微信小程序对于不同的用户信息提供「授权」的方式不尽相同：</p>\n<ol>\n<li>调用具体 API 方式，弹窗授权。<ol>\n<li>例如调用 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getLocation.html\"><code>wx.getLocation()</code></a> 的时候，如果用户未授权，则会弹出地址授权界面。</li>\n<li>如果拒绝了，就不会再次弹窗，<code>wx.getLocation()</code>直接返回失败。</li>\n</ol>\n</li>\n<li><code>&lt;button open-type=&quot;xxx&quot; /&gt;</code> 方式。<ol>\n<li>仅支持：用户敏感信息，用户手机号，需要配合后端进行对称加解密，方能拿到数据。</li>\n<li>用户已拒绝，再次点击按钮，仍然会弹窗。</li>\n</ol>\n</li>\n<li>通过 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/authorize/wx.authorize.html\"><code>wx.authorize()</code></a>，提前询问授权，之后需要获取相关信息的时候不用再次弹出授权。</li>\n</ol>\n<h1 id=\"四-详细设计\"><a href=\"#四-详细设计\" class=\"headerlink\" title=\"四. 详细设计\"></a>四. 详细设计</h1><p>梳理清楚了概念之后，我们模块的划分上，可以拆分为两大块：</p>\n<ol>\n<li><strong>登录</strong>：负责与服务端创建起一个会话，这个会话实现静默登录以及相关的容错处理等，模块命名为：<code>Session</code></li>\n<li><strong>授权</strong>：负责与用户交互，获取与更新信息，以及权限的控制处理等，模块命名为：<code>Auth</code></li>\n</ol>\n<h2 id=\"3-1-登录的实现\"><a href=\"#3-1-登录的实现\" class=\"headerlink\" title=\"3.1 登录的实现\"></a>3.1 登录的实现</h2><h3 id=\"3-1-1-静默登录\"><a href=\"#3-1-1-静默登录\" class=\"headerlink\" title=\"3.1.1 静默登录\"></a>3.1.1 静默登录</h3><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111135.png\" alt=\"微信登录\"></p>\n<p>微信官方提供的登录方案，总结为三步：</p>\n<ol>\n<li>前端通过 <code>wx.login()</code> 获取一次性加密凭证 code，交给后端。</li>\n<li>后端把这个 code 传输给微信服务器端，换取用户唯一标识 <code>openId</code> 和授权凭证 <code>session_key</code>。（用于后续服务器端和微信服务器的特殊 API 调用，具体看：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html\">微信官方文档-服务端获取开放数据</a>）。</li>\n<li>后端把从微信服务器获取到的用户凭证与自行生成的登录态凭证（token），传输给前端。前端保存起来，下次请求的时候带给后端，就能识别哪个用户。</li>\n</ol>\n<p>如果只是实现这个流程的话，挺简单的。</p>\n<p>但要实现一个健壮的登录过程，还需要注意更多的边界情况：</p>\n<ol>\n<li><p><strong>收拢 <code>wx.login()</code> 的调用</strong>：</p>\n<p> 由于 <code>wx.login()</code> 会产生不可预测的副作用，例如会可能导致<code>session_key</code>失效，从而导致后续的授权解密场景中的失败。我们这里可以提供一个像 <code>session.login()</code> 的方法，掌握 <code>wx.login()</code> 控制权，对其做一系列的封装和容错处理。</p>\n</li>\n<li><p><strong>调用的时机</strong>：</p>\n<p> 通常我们会在应用启动的时候（ <code>app.onLaunch()</code> ），去发起静默登录。但这里会由小程序生命周期设计问题而导致的一个异步问题：加载页面的时候，去调用一个需要登录态的后端 API 的时候，前面异步的静态登录过程有可能还没有完成，从而导致请求失败。</p>\n<p> 当然也可以在第一个需要登录态的接口调用的时候以异步阻塞的方式发起登录调用，这个需要结合良好设计的接口层。</p>\n<p> 以上讲到的两种场景的详细设计思路下文会讲到。</p>\n</li>\n<li><p><strong>并发调用的问题</strong>：</p>\n<p> 在业务场景中，难免会出现多处代码需要触发登录，如果遇到极端情况，这多处代码同时间发起调用。那就会造成短时间多次发起登录过程，尽管之前的请求还没有完成。针对这种情况，我们可以以第一个调用为阻塞，后续调用等待结果，就像精子和卵子结合的过程。</p>\n</li>\n<li><p><strong>未过期调用的问题</strong>：</p>\n<p> 如果我们的登录态未过期，完全可以正常使用的，默认情况就不需再去发起登录过程了。这时候我们可以默认情况下先去检查登录态是否可用，不能用，我们再发起请求。然后还可以提供一个类似 <code>session.login(&#123; force: true &#125;)</code>的参数去强行发起登录。</p>\n</li>\n</ol>\n<h3 id=\"3-1-2-静默登录异步状态的处理\"><a href=\"#3-1-2-静默登录异步状态的处理\" class=\"headerlink\" title=\"3.1.2 静默登录异步状态的处理\"></a>3.1.2 静默登录异步状态的处理</h3><p><strong>1. 应用启动的时候调用</strong></p>\n<p>因为大部分情况都需要依赖登录态，我们会很自然而然的想到把这个调用的时机放到应用启动的时候（ <code>app.onLaunch()</code> ）来调用。</p>\n<p>但是由于原生的小程序启动流程中， <code>App</code>，<code>Page</code>，<code>Component</code> 的生命周期钩子函数，都不支持异步阻塞。</p>\n<p>那么我们很容易会遇到 <code>app.onLaunch</code> 发起的「登录过程」在 <code>page.onLoad</code> 的时候还没有完成，我们就无法正确去做一些依赖登录态的操作。</p>\n<p>针对这种情况，我们设计了一个状态机的工具：<a href=\"http://beautywejs.com/#/remote/plugin-status?id=plugin-statusl\">status</a></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016110706.png\" alt=\"状态机\"></p>\n<p>基于状态机，我们就可以编写这样的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Status</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@beautywe/plugin-status&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// on app.js</span></span><br><span class=\"line\"><span class=\"title class_\">App</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">status</span>: &#123;</span><br><span class=\"line\">       <span class=\"attr\">login</span>: <span class=\"keyword\">new</span> <span class=\"title class_\">Status</span>(<span class=\"string\">&#x27;login&#x27;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">onLaunch</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        session</span><br><span class=\"line\">            <span class=\"comment\">// 发起静默登录调用</span></span><br><span class=\"line\">            .<span class=\"title function_\">login</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 把状态机设置为 success</span></span><br><span class=\"line\">            .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">status</span>.<span class=\"property\">login</span>.<span class=\"title function_\">success</span>())</span><br><span class=\"line\">      </span><br><span class=\"line\">            <span class=\"comment\">// 把状态机设置为 fail</span></span><br><span class=\"line\">            .<span class=\"title function_\">catch</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">status</span>.<span class=\"property\">login</span>.<span class=\"title function_\">fail</span>());</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// on page.js</span></span><br><span class=\"line\"><span class=\"title class_\">Page</span>(&#123;</span><br><span class=\"line\">    <span class=\"title function_\">onLoad</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> loginStatus = <span class=\"title function_\">getApp</span>().<span class=\"property\">status</span>.<span class=\"property\">login</span>;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// must 里面会进行状态的判断，例如登录中就等待，登录成功就直接返回，登录失败抛出等。</span></span><br><span class=\"line\">      <span class=\"title function_\">loginStatus</span>().<span class=\"property\">status</span>.<span class=\"property\">login</span>.<span class=\"title function_\">must</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 进行一些需要登录态的操作...</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>2. 在「第一个需要登录态接口」被调用的时候去发起登录</strong></p>\n<p>更进一步，我们会发现，需要登录态的更深层次的节点是在发起的「需要登录态的后端 API 」的时候。</p>\n<p>那么我们可以在调用「需要登录态的后端 API」的时候再去发起「静默登录」，对于并发的场景，让其他请求等待一下就好了。</p>\n<p>以 <a href=\"https://wendux.github.io/dist/#/doc/flyio/readme\">fly.js</a> 作为 <code>wx.request()</code> 封装的「网络请求层」，做一个简单的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发起请求，并表明该请求是需要登录态的</span></span><br><span class=\"line\">fly.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;https://...&#x27;</span>, params, &#123; <span class=\"attr\">needLogin</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 fly 拦截器中处理逻辑</span></span><br><span class=\"line\">fly.<span class=\"property\">interceptors</span>.<span class=\"property\">request</span>.<span class=\"title function_\">use</span>(<span class=\"keyword\">async</span> (req)=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 在请求需要登录态的时候</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (req.<span class=\"property\">needLogin</span> !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ensureLogin 核心逻辑是：判断是否已登录，如否发起登录调用，如果正在登录，则进入队列等待回调。</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> session.<span class=\"title function_\">ensureLogin</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 登录成功后，获取 token，通过 headers 传递给后端。</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> token = <span class=\"keyword\">await</span> session.<span class=\"title function_\">getToken</span>();</span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>(req.<span class=\"property\">headers</span>, &#123; [<span class=\"variable constant_\">AUTH_KEY_NAME</span>]: token &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> req;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-1-3-自定义登录态过期的容错处理\"><a href=\"#3-1-3-自定义登录态过期的容错处理\" class=\"headerlink\" title=\"3.1.3 自定义登录态过期的容错处理\"></a>3.1.3 自定义登录态过期的容错处理</h3><p>当自定义登录态过期的时候，后端需要返回特定的状态码，例如：<code>AUTH_EXPIRED</code> 、 <code>AUTH_INVALID</code> 等。</p>\n<p>前端可以在「网络请求层」去监听所有请求的这个状态码，然后发起刷新登录态，再去重放失败的请求：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加响应拦截器</span></span><br><span class=\"line\">fly.<span class=\"property\">interceptors</span>.<span class=\"property\">response</span>.<span class=\"title function_\">use</span>(</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> code = res.<span class=\"property\">data</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"comment\">// 登录态过期或失效</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( [<span class=\"string\">&#x27;AUTH_EXPIRED&#x27;</span>, <span class=\"string\">&#x27;AUTH_INVALID&#x27;</span>].<span class=\"title function_\">includes</span>(code) ) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 刷新登录态</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> session.<span class=\"title function_\">refreshLogin</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 然后重新发起请求</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> fly.<span class=\"title function_\">request</span>(request);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>那么如果并发的发起多个请求，都返回了登录态失效的状态码，上述代码就会被执行多次。</p>\n<p>我们需要对 <code>session.refreshLogin()</code> 做一些特殊的容错处理：</p>\n<ol>\n<li><strong>请求锁</strong>：同一时间，只允许一个正在过程中的网络请求。</li>\n<li><strong>等待队列</strong>：请求被锁定之后，调用该方法的所有调用，都推入一个队列中，等待网络请求完成之后共用返回结果。</li>\n<li><strong>熔断机制</strong>：如果短时间内多次调用，则停止响应一段时间，类似于 TCP 慢启动。</li>\n</ol>\n<p>示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Session</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 刷新登录保险丝，最多重复 3 次，然后熔断，5s 后恢复</span></span><br><span class=\"line\">  refreshLoginFuseLine = <span class=\"variable constant_\">REFRESH_LOGIN_FUSELINE_DEFAULT</span>;</span><br><span class=\"line\">  refreshLoginFuseLocked = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  refreshLoginFuseRestoreTime = <span class=\"number\">5000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 熔断控制</span></span><br><span class=\"line\">  <span class=\"title function_\">refreshLoginFuse</span>(): <span class=\"title class_\">Promise</span>&lt;<span class=\"keyword\">void</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLocked</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&#x27;刷新登录-保险丝已熔断，请稍后&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLine</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLine</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLine</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLocked</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLocked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLine</span> = <span class=\"variable constant_\">REFRESH_LOGIN_FUSELINE_DEFAULT</span>;</span><br><span class=\"line\">        logger.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;刷新登录-保险丝熔断解除&#x27;</span>);</span><br><span class=\"line\">      &#125;, <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseRestoreTime</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&#x27;刷新登录-保险丝熔断!!&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 并发回调队列</span></span><br><span class=\"line\">  refreshLoginQueueMaxLength = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"attr\">refreshLoginQueue</span>: any[] = [];</span><br><span class=\"line\">  refreshLoginLocked = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 刷新登录态</span></span><br><span class=\"line\">  <span class=\"title function_\">refreshLogin</span>(): <span class=\"title class_\">Promise</span>&lt;<span class=\"keyword\">void</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">// 回调队列 + 熔断 控制</span></span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">refreshLoginFuse</span>())</span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginLocked</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> maxLength = <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginQueueMaxLength</span>;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginQueue</span>.<span class=\"property\">length</span> &gt;= maxLength) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">`refreshLoginQueue 超出容量：<span class=\"subst\">$&#123;maxLength&#125;</span>`</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginQueue</span>.<span class=\"title function_\">push</span>([resolve, reject]);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginLocked</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 通过前置控制之后，发起登录过程</span></span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">clearSession</span>();</span><br><span class=\"line\">        wx.<span class=\"title function_\">showLoading</span>(&#123; <span class=\"attr\">title</span>: <span class=\"string\">&#x27;刷新登录态中&#x27;</span>, <span class=\"attr\">mask</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">login</span>()</span><br><span class=\"line\">          .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            wx.<span class=\"title function_\">hideLoading</span>();</span><br><span class=\"line\">            wx.<span class=\"title function_\">showToast</span>(&#123; <span class=\"attr\">icon</span>: <span class=\"string\">&#x27;none&#x27;</span>, <span class=\"attr\">title</span>: <span class=\"string\">&#x27;登录成功&#x27;</span> &#125;);</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginQueue</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">[resolve]</span>) =&gt;</span> <span class=\"title function_\">resolve</span>());</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginLocked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">            wx.<span class=\"title function_\">hideLoading</span>();</span><br><span class=\"line\">            wx.<span class=\"title function_\">showToast</span>(&#123; <span class=\"attr\">icon</span>: <span class=\"string\">&#x27;none&#x27;</span>, <span class=\"attr\">title</span>: <span class=\"string\">&#x27;登录失败&#x27;</span> &#125;);</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginQueue</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">[, reject]</span>) =&gt;</span> <span class=\"title function_\">reject</span>());</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginLocked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-4-微信-session-key-过期的容错处理\"><a href=\"#3-1-4-微信-session-key-过期的容错处理\" class=\"headerlink\" title=\"3.1.4 微信 session_key 过期的容错处理\"></a>3.1.4 微信 session_key 过期的容错处理</h3><p>我们从上面的「静默登录」之后，微信服务器端会下发一个 <code>session_key</code> 给后端，而这个会在需要获取<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html\">微信开放数据</a>的时候会用到。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016110824.png\" alt=\"微信开放数据\"></p>\n<p>而 <code>session_key</code> 是有时效性的，以下摘自微信官方描述：</p>\n<blockquote>\n<h4 id=\"会话密钥-session-key-有效性\"><a href=\"#会话密钥-session-key-有效性\" class=\"headerlink\" title=\"会话密钥 session_key 有效性\"></a>会话密钥 session_key 有效性</h4><p>开发者如果遇到因为 session_key 不正确而校验签名失败或解密失败，请关注下面几个与 session_key 有关的注意事项。</p>\n<ol>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html\">wx.login</a> 调用时，用户的 session_key <strong>可能</strong>会被更新而致使旧 session_key 失效（刷新机制存在最短周期，如果同一个用户短时间内多次调用 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html\">wx.login</a>，并非每次调用都导致 session_key 刷新）。开发者应该在明确需要重新登录时才调用 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html\">wx.login</a>，及时通过 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html\">auth.code2Session</a> 接口更新服务器存储的 session_key。</li>\n<li>微信不会把 session_key 的有效期告知开发者。我们会根据用户使用小程序的行为对 session_key 进行续期。用户越频繁使用小程序，session_key 有效期越长。</li>\n<li>开发者在 session_key 失效时，可以通过重新执行登录流程获取有效的 session_key。使用接口 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.checkSession.html\">wx.checkSession</a>可以校验 session_key 是否有效，从而避免小程序反复执行登录流程。</li>\n<li>当开发者在实现自定义登录态时，可以考虑以 session_key 有效期作为自身登录态有效期，也可以实现自定义的时效性策略。</li>\n</ol>\n</blockquote>\n<p>翻译成简单的两句话：</p>\n<ol>\n<li><code>session_key</code> 时效性由微信控制，开发者不可预测。</li>\n<li><code>wx.login</code> 可能会导致 <code>session_key</code> 过期，可以在使用接口之前用<code> wx.checkSession</code> 检查一下。</li>\n</ol>\n<p>而对于第二点，我们通过实验发现，偶发性的在 <code>session_key</code> 已过期的情况下，<code>wx.checkSession</code> 会概率性返回 <code>true</code></p>\n<p>社区也有相关的反馈未得到解决：</p>\n<ul>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/000424005b89983f337a622c751000?highLine=wx.checkSession\">小程序解密手机号,隔一小段时间后,checksession:ok,但是解密失败</a></li>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/0008e429bd0c886e10699f59c51000?_at=1602745291452\">wx.checkSession有效，但是解密数据失败</a></li>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/000a04ab4546d80d5428ffcee51800?_at=1602745291452\">checkSession判断session_key未失效，但是解密手机号失败</a></li>\n</ul>\n<p><strong>所以结论是：<code>wx.checkSession</code>可靠性是不达 100% 的。</strong></p>\n<p>基于以上，我们需要对 <code>session_key</code> 的过期做一些容错处理：</p>\n<ol>\n<li>发起需要使用 <code>session_key</code> 的请求前，做一次 <code>wx.checkSession</code> 操作，如果失败了刷新登录态。</li>\n<li>后端使用 <code>session_key</code> 解密开放数据失败之后，返回特定错误码（如：<code>DECRYPT_WX_OPEN_DATA_FAIL</code>），前端刷新登录态。</li>\n</ol>\n<p>示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义检查 session_key 有效性的操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">ensureSessionKey</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hasSession = <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    wx.<span class=\"title function_\">checkSession</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\">() =&gt;</span> <span class=\"title function_\">resolve</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">      <span class=\"attr\">fail</span>: <span class=\"function\">() =&gt;</span> <span class=\"title function_\">resolve</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!hasSession) &#123;</span><br><span class=\"line\">    logger.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;sessionKey 已过期，刷新登录态&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 接上面提到的刷新登录逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> session.<span class=\"title function_\">refreshLogin</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在发起请求的时候，先做一次确保 session_key 最新的操作（以 fly.js 作为网络请求层为例）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">updatePhone</span> = <span class=\"keyword\">async</span> (<span class=\"params\">params</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">ensureSessionKey</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> fly.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;https://xxx&#x27;</span>, params);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加响应拦截器, 监听网络请求返回</span></span><br><span class=\"line\">fly.<span class=\"property\">interceptors</span>.<span class=\"property\">response</span>.<span class=\"title function_\">use</span>(</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> code = res.<span class=\"property\">data</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"comment\">// 登录态过期或失效</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( [<span class=\"string\">&#x27;DECRYPT_WX_OPEN_DATA_FAIL&#x27;</span>].<span class=\"title function_\">includes</span>(code)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 刷新登录态</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> session.<span class=\"title function_\">refreshLogin</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 由于加密场景的加密数据由用户点击产生，session_key 可能已经更改，需要用户重新点击一遍。</span></span><br><span class=\"line\">        wx.<span class=\"title function_\">showToast</span>(&#123; <span class=\"attr\">title</span>: <span class=\"string\">&#x27;网络出小差了，请稍后重试&#x27;</span>, <span class=\"attr\">icon</span>: <span class=\"string\">&#x27;none&#x27;</span> &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-2-授权的实现\"><a href=\"#3-2-授权的实现\" class=\"headerlink\" title=\"3.2 授权的实现\"></a>3.2 授权的实现</h2><h3 id=\"3-2-1-组件拆分与设计\"><a href=\"#3-2-1-组件拆分与设计\" class=\"headerlink\" title=\"3.2.1 组件拆分与设计\"></a>3.2.1 组件拆分与设计</h3><p>在用户信息和手机号获取的方式上，微信是以 <code>&lt;button open-type=&#39;xxx&#39; /&gt;</code> 的方式，让用户主动点击授权的。</p>\n<p>那么为了让代码更解耦，我们设计这样三个组件：</p>\n<ol>\n<li><code>&lt;user-contaienr getUserInfo=&quot;onUserInfoAuth&quot;&gt;</code>: 包装点击交互，通过 <code>&lt;slot&gt;</code> 支持点击区域的自定义UI。</li>\n<li><code>&lt;phone-container getPhonenNmber=&quot;onPhoneAuth&quot;&gt;</code> : 与 <code>&lt;user-container&gt;</code> 同理。</li>\n<li><code>&lt;auth-flow&gt;</code>: 根据业务需要，组合 <code>&lt;user-container&gt;</code>、<code>&lt;phone-container&gt;</code> 组合来定义不同的授权流程。</li>\n</ol>\n<p>以开头的业务场景的流程为例，它有这样的要求：</p>\n<ol>\n<li>有多个步骤。</li>\n<li>如果中途断掉了，可以从中间接上。</li>\n<li>有些场景中，只要求达到「用户信息授权」，而不需要完成「用户手机号」。</li>\n</ol>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111006.jpg\" alt=\"完整授权流程\"></p>\n<p>那么授权的阶段可以分三层：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用户登录的阶段</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> enum <span class=\"title class_\">AuthStep</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 阶段一：只有登录态，没有用户信息，没有手机号</span></span><br><span class=\"line\">  <span class=\"variable constant_\">ONE</span> = <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 阶段二：有用户信息，没有手机号</span></span><br><span class=\"line\">  <span class=\"variable constant_\">TWO</span> = <span class=\"number\">2</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 阶段三：有用户信息，有手机号</span></span><br><span class=\"line\">  <span class=\"variable constant_\">THREE</span> = <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>AuthStep</code> 的推进过程是不可逆的，我们可以定义一个 <code>nextStep</code> 函数来封装 AuthStep 更新的逻辑。外部使用的话，只要无脑调用 <code>nextStep</code> 方法，等待回调结果就行。</p>\n<p>示例伪代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// auth-flow component</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 默认情况下，只需要到达阶段二。</span></span><br><span class=\"line\">    <span class=\"attr\">mustAuthStep</span>: <span class=\"title class_\">AuthStep</span>.<span class=\"property\">TWO</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 允许临时更改组件的需要达到的阶段。</span></span><br><span class=\"line\">  <span class=\"title function_\">setMustAuthStep</span>(<span class=\"params\">mustAuthStep: AuthStep</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setData</span>(&#123; mustAuthStep &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 根据用户当前的信息，计算用户处在授权的阶段</span></span><br><span class=\"line\">  <span class=\"title function_\">getAuthStep</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> currAuthStep;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 没有用户信息，尚在第一步</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!session.<span class=\"title function_\">hasUser</span>() || !session.<span class=\"title function_\">hasUnionId</span>()) &#123;</span><br><span class=\"line\">      currAuthStep = <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">ONE</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 没有手机号，尚在第二步</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!session.<span class=\"title function_\">hasPhone</span>()) &#123;</span><br><span class=\"line\">      currAuthStep = <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">TWO</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 都有，尚在第三步</span></span><br><span class=\"line\">    currAuthStep = <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">THREE</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currAuthStep;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发起下一步授权，如果都已经完成，就直接返回成功。</span></span><br><span class=\"line\">  <span class=\"title function_\">nextStep</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; mustAuthStep &#125; = <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> currAuthStep = <span class=\"variable language_\">this</span>.<span class=\"title function_\">updateAuthStep</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 已完成授权</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currAuthStep &gt;= mustAuthStep || currAuthStep === <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">THREE</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 更新全局的授权状态机，广播消息给订阅者。</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">getApp</span>().<span class=\"property\">status</span>.<span class=\"property\">auth</span>.<span class=\"title function_\">success</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 第一步：更新用户信息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currAuthStep === <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">ONE</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 已有密文信息，更新用户信息</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (e) session.<span class=\"title function_\">updateUser</span>(e);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 更新到视图层，展示对应UI，等待获取用户信息</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">setData</span>(&#123; currAuthStep &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 第二步：更新手机信息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currAuthStep === <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">TWO</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 已有密文信息，更新手机号</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (e) <span class=\"variable language_\">this</span>.<span class=\"title function_\">bindPhone</span>(e);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 未有密文信息，弹出获取窗口</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">setData</span>(&#123; currAuthStep &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;auth.nextStep 错误&#x27;</span>, &#123; currAuthStep, mustAuthStep &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>那么我们的 <code>&lt;auth-flow&gt;</code> 中就可以根据 <code>currAuthStep</code> 和 <code>mustAuthStep</code> 来去做不同的 UI 展示。需要注意的是使用 <code>&lt;user-container&gt;</code>、<code>&lt;phone-container&gt;</code> 的时候连接上 <code>nextStep(e)</code> 函数。</p>\n<p>示例伪代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;auth-flow&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 已完成授权 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">block</span> <span class=\"attr\">wx:if</span>=<span class=\"string\">&quot;&#123;&#123;currAuthStep === mustAuthStep || currAuthStep === AuthStep.THREE&#125;&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span>已完成授权<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">block</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 未完成授权，第一步：授权用户信息 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">block</span> <span class=\"attr\">wx:elif</span>=<span class=\"string\">&quot;&#123;&#123;currAuthStep === AuthStep.ONE&#125;&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">user-container</span> <span class=\"attr\">bind:getuserinfo</span>=<span class=\"string\">&quot;nextStep&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span>授权用户信息<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">user-container</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">block</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 未完成授权，第二步：授权手机号 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">block</span> <span class=\"attr\">wx:elif</span>=<span class=\"string\">&quot;&#123;&#123;currAuthStep === AuthStep.TWO&#125;&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">phone-container</span> <span class=\"attr\">bind:getphonenumber</span>=<span class=\"string\">&quot;nextStep&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span>授权手机号<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">phone-container</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">block</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-2-2-权限拦截的处理\"><a href=\"#3-2-2-权限拦截的处理\" class=\"headerlink\" title=\"3.2.2 权限拦截的处理\"></a>3.2.2 权限拦截的处理</h3><p>到这里，我们制作好了用来承载授权流程的组件 <code>&lt;auth-flow&gt;</code> ，那么接下来就是决定要使用它的时机了。</p>\n<p>我们梳理需要授权的场景：</p>\n<ol>\n<li><p>点击某个按钮，例如：购买某个商品。</p>\n<p>对于这种场景，常见的是通过弹窗完成授权，用户可以选择关闭。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016113312.png\" alt=\"授权模型-弹窗\"></p>\n</li>\n<li><p>浏览某个页面，例如：访问个人中心。</p>\n<p>对于这种场景，我们可以在点击跳转某个页面的时候，进行拦截，弹窗处理。但这样的缺点是，跳转到目标页面的地方可能会很多，每个都拦截，难免会错漏。而且当目标页面作为「小程序落地页面」的时候，就避免不了。</p>\n<p>这时候，我们可以通过重定向到授权页面来完成授权流程，完成之后，再回来。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016113324.png\" alt=\"授权模型-页面\"></p>\n</li>\n</ol>\n<p>那么我们定义一个枚举变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 授权的展示形式</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> enum <span class=\"title class_\">AuthDisplayMode</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 以弹窗形式</span></span><br><span class=\"line\">  <span class=\"variable constant_\">POPUP</span> = <span class=\"string\">&#x27;button&#x27;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 以页面形式</span></span><br><span class=\"line\">  <span class=\"variable constant_\">PAGE</span> = <span class=\"string\">&#x27;page&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以设计一个 <code>mustAuth</code> 方法，在点击某个按钮，或者页面加载的时候，进行授权控制。</p>\n<p>伪代码示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Session</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"title function_\">mustAuth</span>(&#123;</span><br><span class=\"line\">    mustAuthStep = <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">TWO</span>, <span class=\"comment\">// 需要授权的LEVEL，默认需要获取用户资料</span></span><br><span class=\"line\">    popupCompName = <span class=\"string\">&#x27;auth-popup&#x27;</span>,\t<span class=\"comment\">// 授权弹窗组件的 id</span></span><br><span class=\"line\">    mode = <span class=\"title class_\">AuthDisplayMode</span>.<span class=\"property\">POPUP</span>, <span class=\"comment\">// 默认以弹窗模式</span></span><br><span class=\"line\">  &#125; = &#123;&#125;): <span class=\"title class_\">Promise</span>&lt;<span class=\"keyword\">void</span>&gt; &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果当前的授权步骤已经达标，则返回成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">currentAuthStep</span>() &gt;= mustAuthStep) <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 尝试获取当前页面的 &lt;auth-popup id=&quot;auth-popup&quot; /&gt; 组件实例</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> pages = <span class=\"title function_\">getCurrentPages</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> curPage = pages[pages.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> popupComp = curPage.<span class=\"title function_\">selectComponent</span>(<span class=\"string\">`#<span class=\"subst\">$&#123;popupCompName&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 组件不存在或者显示指定页面，跳转到授权页面</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!popupComp || mode === <span class=\"title class_\">AuthDisplayMode</span>.<span class=\"property\">PAGE</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> curRoute = curPage.<span class=\"property\">route</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 跳转到授权页面，带上当前页面路由，授权完成之后，回到当前页面。</span></span><br><span class=\"line\">      wx.<span class=\"title function_\">redirectTo</span>(&#123; <span class=\"attr\">url</span>: <span class=\"string\">`authPage?backTo=<span class=\"subst\">$&#123;<span class=\"built_in\">encodeURIComponent</span>(curRoute)&#125;</span>`</span> &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置授权 LEVEL，然后调用 &lt;auth-popup&gt; 的 nextStep 方法，进行进一步的授权。</span></span><br><span class=\"line\">    popupComp.<span class=\"title function_\">setMustAuthStep</span>(mustAuthStep);</span><br><span class=\"line\">    popupComp.<span class=\"title function_\">nextStep</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待成功回调或者失败回调</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> authStatus = <span class=\"title function_\">getApp</span>().<span class=\"property\">status</span>.<span class=\"property\">auth</span>;</span><br><span class=\"line\">      authStatus.<span class=\"title function_\">onceSuccess</span>(resolve);</span><br><span class=\"line\">      authStatus.<span class=\"title function_\">onceFail</span>(reject);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们就能在按钮点击，或者页面加载的时候进行授权拦截：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Page</span>(&#123;</span><br><span class=\"line\">  <span class=\"title function_\">onLoad</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    session.<span class=\"title function_\">mustAuth</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 开始初始化页面...</span></span><br><span class=\"line\">    &#125;)；</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"title function_\">onClick</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    session.<span class=\"title function_\">mustAuth</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 开始处理回调逻辑...</span></span><br><span class=\"line\">    &#125;)；</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当然，如果项目使用了 TS 的话，或者支持 ES7 Decorator 特性的话，我们可以为 <code>mustAuth</code> 提供一个装饰器版本：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">mustAuth</span>(<span class=\"params\">option = &#123;&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    _target,</span></span><br><span class=\"line\"><span class=\"params\">    _propertyName,</span></span><br><span class=\"line\"><span class=\"params\">    descriptor,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 劫持目标方法</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> method = descriptor.<span class=\"property\">value</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重写目标方法</span></span><br><span class=\"line\">    descriptor.<span class=\"property\">value</span> = <span class=\"keyword\">function</span>(<span class=\"params\">...args: any[]</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> session.<span class=\"title function_\">mustAuth</span>(option).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 登录完成之后，重放原来方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (method) <span class=\"keyword\">return</span> method.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么使用方式就简单一些了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Page</span>(&#123;</span><br><span class=\"line\">  @<span class=\"title function_\">mustAuth</span>();</span><br><span class=\"line\">  <span class=\"title function_\">onLoad</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开始初始化页面...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  @<span class=\"title function_\">mustAuth</span>();</span><br><span class=\"line\">  <span class=\"title function_\">onClick</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开始处理回调逻辑...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-3-前后端交互协议整理\"><a href=\"#3-3-前后端交互协议整理\" class=\"headerlink\" title=\"3.3. 前后端交互协议整理\"></a>3.3. 前后端交互协议整理</h2><p>作为一套可复用的小程序登录方案，当然需要去定义好前后端的交互协议。</p>\n<p>那么整套登录流程下来，需要的接口有这么几个：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016162606.png\" alt=\"登录注册前后端接口协议\"></p>\n<ol>\n<li><p><strong>静默登录 silentLogin</strong></p>\n<ol>\n<li>入参：<ol>\n<li>code: 产自 wx.login()</li>\n</ol>\n</li>\n<li>出参：<ol>\n<li>token: 自定义登录态凭证</li>\n<li>userInfo: 用户信息</li>\n</ol>\n</li>\n<li>说明：<ol>\n<li>后端利用 code 跟微信客户端换取用户标识，然后注册并登录用户，返回自定义登录态 <code>token</code> 给前端</li>\n<li><code>token</code> 前端会存起来，每个请求都会带上</li>\n<li>userInfo 需要包含<code>nickname</code>和<code>phone</code>字段，前端用于计算当前用户的授权阶段。当然这个状态的记录可以放在后端，但是我们认为放在前端，会更加灵活。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>更新用户信息 updateUser</strong></p>\n<ol>\n<li>入参：<ol>\n<li>nickname: 用户昵称</li>\n<li>encrypt: 微信开放数据相关的 <code>iv</code>, <code>encryptedData</code></li>\n<li>以及其他如性别地址等非必要字段</li>\n</ol>\n</li>\n<li>出参：<ol>\n<li>userInfo：更新后的最新用户信息</li>\n</ol>\n</li>\n<li>说明：<ol>\n<li>后端解密微信开放数据，获取隐蔽数据，如：<code>unionId </code>等</li>\n<li>后端支持更新包括 <code>nickname</code>等用户基本信息。</li>\n<li>前端会把 userInfo 信息更新到 <code>session</code> 中，用于计算授权阶段。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>更新用户手机号 updatePhone</strong></p>\n<ol>\n<li>入参：<ol>\n<li>encrypt：微信开放数据相关的 <code>iv</code>, <code>encryptedData</code></li>\n</ol>\n</li>\n<li>出参：<ol>\n<li>userInfo：更新后的最新用户信息</li>\n</ol>\n</li>\n<li>说明：<ol>\n<li>后端解密开放式局，获取手机号，并更新到用户信息中。 </li>\n<li>前端会把 userInfo 信息更新到 <code>session</code> 中，用于计算授权阶段。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>解绑手机号 unbindPhone</strong></p>\n<ol>\n<li>入参：-</li>\n<li>出参：-</li>\n<li>说明：后端解绑用户手机号，成功与否，走业务定义的前后端协议。</li>\n</ol>\n</li>\n<li><p><strong>登录 logout</strong></p>\n<ol>\n<li>入参：-</li>\n<li>出参：-</li>\n<li>说明：后端主动过期登录态，成功与否，走业务定义的前后端协议。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"五-架构图\"><a href=\"#五-架构图\" class=\"headerlink\" title=\"五. 架构图\"></a>五. 架构图</h1><p>最后我们来梳理一下整体的「登录服务」的架构图：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlgy1gjqk8sm9dbj30v60fp0uc.jpg\" alt=\"微信小程序登录服务架构图\"></p>\n<p>由「登录服务」和「底层建设」组合提供的通用服务，业务层只需要去根据产品需求，定制授权的流程 <code>&lt;auth-flow&gt;</code> ，就能满足大部分场景了。</p>\n<h1 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六. 总结\"></a>六. 总结</h1><p>本篇文章通过一些常见的登录授权场景来展开来描述细节点。</p>\n<p>整理了「登录」、「授权」的概念。</p>\n<p>然后分别针对「登录」介绍了一些关键的技术实现：</p>\n<ol>\n<li>静默登录</li>\n<li>静默登录异步状态的处理</li>\n<li>自定义登录态过期的容错处理</li>\n<li>微信 <code>session_key</code> 过期的容错处理</li>\n</ol>\n<p>而对于「授权」，会有设计UI部分的逻辑，还需要涉及到组件的拆分：</p>\n<ol>\n<li>组件拆分与设计</li>\n<li>权限拦截的处理</li>\n</ol>\n<p>然后，梳理了这套登录授权方案所依赖的后端接口，和给出最简单的参考协议。</p>\n<p>最后，站在「秉着沉淀一套通用的小程序登录方案和服务为目标」的角度，梳理了一下架构层面上的分层。</p>\n<ol>\n<li>业务定制层</li>\n<li>登录服务层</li>\n<li>底层建设</li>\n</ol>\n<h1 id=\"七-参考\"><a href=\"#七-参考\" class=\"headerlink\" title=\"七. 参考\"></a>七. 参考</h1><ol>\n<li><a href=\"https://wendux.github.io/dist/#/doc/flyio/readme\">fly.js 官网</a></li>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html\">微信官方文档-授权</a></li>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html\">微信官方文档-服务端获取开放数据</a></li>\n<li>微信官方社区<ol>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/000424005b89983f337a622c751000?highLine=wx.checkSession\">小程序解密手机号,隔一小段时间后,checksession:ok,但是解密失败</a></li>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/0008e429bd0c886e10699f59c51000?_at=1602745291452\">wx.checkSession有效，但是解密数据失败</a></li>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/000a04ab4546d80d5428ffcee51800?_at=1602745291452\">checkSession判断session_key未失效，但是解密手机号失败</a></li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一-前言\"><a href=\"#一-前言\" class=\"headerlink\" title=\"一. 前言\"></a>一. 前言</h1><p>对于登录&#x2F;注册的设计如此精雕细琢的目的，当然是想让这个作为应用的基础能力，有足够的健壮性，避免出现全站性的阻塞。</p>\n<p>同时要充分考虑如何解耦和封装，在开展新的小程序的时候，能更快的去复用能力，避免重复采坑。</p>\n<p>登录注册这模块，就像个冰山，我们以为它就是「输入账号密码，就完成登录了」，但实际下面还有各种需要考虑的问题。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016104626.jpg\"></p>\n<p>在此，跟在座的各位分享一下，最近做完一个小程序登录&#x2F;注册模块之后，沉淀下来的一些设计经验和想法。</p>\n<h1 id=\"二-业务场景\"><a href=\"#二-业务场景\" class=\"headerlink\" title=\"二. 业务场景\"></a>二. 业务场景</h1><p>在用户浏览小程序的过程中，由业务需要，往往需要获取用户的一些基本信息，常见的有：</p>\n<ol>\n<li>微信昵称</li>\n<li>微信手机号</li>\n</ol>\n<p>而不同的产品，对于用户的信息要求不尽相同，也会有不一样的授权流程。</p>\n<p>第一种，常见于电商系统中，用户购买商品的时候，为了识别用户多平台的账号，往往用手机号去做一个联系，这时候需要用户去授权手机号。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111059.jpg\" alt=\"授权手机号\"></p>\n<p>第二种，为了让用户信息得到基本的初始化，往往需要更进一步获取用户信息：如微信昵称，<code>unionId</code> 等，就需要询问用户授权。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111042.jpg\" alt=\"授权用户信息\"></p>\n<p>第三种，囊括第一种，第二种。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111006.jpg\" alt=\"完整授权流程\"></p>\n<h1 id=\"三-概念\"><a href=\"#三-概念\" class=\"headerlink\" title=\"三. 概念\"></a>三. 概念</h1><p>秉着沉淀一套通用的小程序登录方案和服务为目标，我们去分析一下业务，得出变量。</p>\n<p>在做技术设计之前，讲点必要的废话，对一些概念进行基本调频。</p>\n<h2 id=\"2-1-关于「登录」\"><a href=\"#2-1-关于「登录」\" class=\"headerlink\" title=\"2.1 关于「登录」\"></a>2.1 关于「登录」</h2><p>登录在英文中是 「login」，对应的还有 「logout」。而登录之前，你需要拥有一个账号，就要 「register」（or sign up）。</p>\n<p>话说一开始的产品是没有登录&#x2F;注册功能的，用的人多了就慢慢有了。出于产品本身的需求，需要对「用户」进行身份识别。</p>\n<p>在现实社会中，我们每个人都有一个身份ID：身份证。当我到了16岁的时候，第一次去公安局领身份证的时候，就完成了一次「注册」行为。然后我去网吧上网，身份证刷一下，完成了一次「登录」行为。</p>\n<p>那么对于虚拟世界的互联网来说，这个身份证明就是「账号+密码」。</p>\n<p>常见的登录&#x2F;注册方式有：</p>\n<ol>\n<li><p><strong>账号密码注册</strong></p>\n<p> 在互联网的早期，个人邮箱和手机覆盖度小。所以，就需要用户自己想一个账号名，我们注册个QQ号，就是这种形式。</p>\n<p> <img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105159.png\" alt=\"from 汽车之家\">\t</p>\n</li>\n<li><p><strong>邮箱地址注册</strong></p>\n<p> 千禧年之后，PC互联网时代快速普及，我们都创建了属于自己的个人邮箱。加上QQ也自带邮箱账号。由于邮箱具有个人私密性，且能够进行信息的沟通，因此，大部分网站开始采用邮箱账号作为用户名来进行注册，并且会在注册的过程中要求登录到相应邮箱内查收激活邮件，验证我们对该注册邮箱的所有权。</p>\n<p> <img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105005.png\" alt=\"from 支付宝\"></p>\n</li>\n<li><p><strong>手机号码注册</strong></p>\n<p> 在互联网普及之后，智能手机与移动互联网发展迅猛。手机也成为每个人必不可少的移动设备，同时移动互联网也已经深深融入每个人的现代生活当中。所以，相较于邮箱，目前手机号码与个人的联系更加紧密，而且越来越多的移动应用出现，采用手机号码作为用户名的注册方式也得到了广泛的使用。   </p>\n<p> <img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105120.png\" alt=\"from 知乎\"></p>\n</li>\n</ol>\n<p>到了 2020 年，微信用户规模达 12 亿。那么，微信账号，起码在中国，已成为新一代互联网世界的「身份标识」。</p>\n<p>而对微信小程序而言，天然就能知道当前用户的微信账号ID。微信允许小程序应用，能在用户无感知的情况下，悄无声息的「登录」到我们的小程序应用中去，这个就是我们经常称之为的「静默登录」。</p>\n<p>其实微信小程序的登录，跟传统 Web 应用的「单点登录」本质是一样的概念。</p>\n<ol>\n<li>单点登录：在 A 站登录了，C 站和 B 站能实现快速的「静默登录」。</li>\n<li>微信小程序登录：在微信中，登录了微信账号，那么在整个小程序生态中，都可以实现「静默登录」。</li>\n</ol>\n<p>由于 Http 本来是无状态的，业界基本对于登录态的一般做法：</p>\n<ol>\n<li>cookie-session：常用于浏览器应用中</li>\n<li>access token：常用于移动端等非浏览器应用</li>\n</ol>\n<p>在微信小程序来说，对于「JS逻辑层」并不是一个浏览器环境，自然没有 <code>Cookie</code>，那么通常会使用 <code>access token</code> 的方式。</p>\n<h2 id=\"2-2-关于「授权」\"><a href=\"#2-2-关于「授权」\" class=\"headerlink\" title=\"2.2 关于「授权」\"></a>2.2 关于「授权」</h2><p>对于需要更进一步获取用的用户昵称、用户手机号等信息的产品来说。微信出于用户隐私的考虑，需要用户主动同意授权。小程序应用才能获取到这部分信息，这就有了目前流行的小程序「授权用户信息」、「授权手机号」的交互了。</p>\n<p>出于不同的用户信息敏感度不同的考虑，微信小程序对于不同的用户信息提供「授权」的方式不尽相同：</p>\n<ol>\n<li>调用具体 API 方式，弹窗授权。<ol>\n<li>例如调用 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getLocation.html\"><code>wx.getLocation()</code></a> 的时候，如果用户未授权，则会弹出地址授权界面。</li>\n<li>如果拒绝了，就不会再次弹窗，<code>wx.getLocation()</code>直接返回失败。</li>\n</ol>\n</li>\n<li><code>&lt;button open-type=&quot;xxx&quot; /&gt;</code> 方式。<ol>\n<li>仅支持：用户敏感信息，用户手机号，需要配合后端进行对称加解密，方能拿到数据。</li>\n<li>用户已拒绝，再次点击按钮，仍然会弹窗。</li>\n</ol>\n</li>\n<li>通过 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/authorize/wx.authorize.html\"><code>wx.authorize()</code></a>，提前询问授权，之后需要获取相关信息的时候不用再次弹出授权。</li>\n</ol>\n<h1 id=\"四-详细设计\"><a href=\"#四-详细设计\" class=\"headerlink\" title=\"四. 详细设计\"></a>四. 详细设计</h1><p>梳理清楚了概念之后，我们模块的划分上，可以拆分为两大块：</p>\n<ol>\n<li><strong>登录</strong>：负责与服务端创建起一个会话，这个会话实现静默登录以及相关的容错处理等，模块命名为：<code>Session</code></li>\n<li><strong>授权</strong>：负责与用户交互，获取与更新信息，以及权限的控制处理等，模块命名为：<code>Auth</code></li>\n</ol>\n<h2 id=\"3-1-登录的实现\"><a href=\"#3-1-登录的实现\" class=\"headerlink\" title=\"3.1 登录的实现\"></a>3.1 登录的实现</h2><h3 id=\"3-1-1-静默登录\"><a href=\"#3-1-1-静默登录\" class=\"headerlink\" title=\"3.1.1 静默登录\"></a>3.1.1 静默登录</h3><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111135.png\" alt=\"微信登录\"></p>\n<p>微信官方提供的登录方案，总结为三步：</p>\n<ol>\n<li>前端通过 <code>wx.login()</code> 获取一次性加密凭证 code，交给后端。</li>\n<li>后端把这个 code 传输给微信服务器端，换取用户唯一标识 <code>openId</code> 和授权凭证 <code>session_key</code>。（用于后续服务器端和微信服务器的特殊 API 调用，具体看：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html\">微信官方文档-服务端获取开放数据</a>）。</li>\n<li>后端把从微信服务器获取到的用户凭证与自行生成的登录态凭证（token），传输给前端。前端保存起来，下次请求的时候带给后端，就能识别哪个用户。</li>\n</ol>\n<p>如果只是实现这个流程的话，挺简单的。</p>\n<p>但要实现一个健壮的登录过程，还需要注意更多的边界情况：</p>\n<ol>\n<li><p><strong>收拢 <code>wx.login()</code> 的调用</strong>：</p>\n<p> 由于 <code>wx.login()</code> 会产生不可预测的副作用，例如会可能导致<code>session_key</code>失效，从而导致后续的授权解密场景中的失败。我们这里可以提供一个像 <code>session.login()</code> 的方法，掌握 <code>wx.login()</code> 控制权，对其做一系列的封装和容错处理。</p>\n</li>\n<li><p><strong>调用的时机</strong>：</p>\n<p> 通常我们会在应用启动的时候（ <code>app.onLaunch()</code> ），去发起静默登录。但这里会由小程序生命周期设计问题而导致的一个异步问题：加载页面的时候，去调用一个需要登录态的后端 API 的时候，前面异步的静态登录过程有可能还没有完成，从而导致请求失败。</p>\n<p> 当然也可以在第一个需要登录态的接口调用的时候以异步阻塞的方式发起登录调用，这个需要结合良好设计的接口层。</p>\n<p> 以上讲到的两种场景的详细设计思路下文会讲到。</p>\n</li>\n<li><p><strong>并发调用的问题</strong>：</p>\n<p> 在业务场景中，难免会出现多处代码需要触发登录，如果遇到极端情况，这多处代码同时间发起调用。那就会造成短时间多次发起登录过程，尽管之前的请求还没有完成。针对这种情况，我们可以以第一个调用为阻塞，后续调用等待结果，就像精子和卵子结合的过程。</p>\n</li>\n<li><p><strong>未过期调用的问题</strong>：</p>\n<p> 如果我们的登录态未过期，完全可以正常使用的，默认情况就不需再去发起登录过程了。这时候我们可以默认情况下先去检查登录态是否可用，不能用，我们再发起请求。然后还可以提供一个类似 <code>session.login(&#123; force: true &#125;)</code>的参数去强行发起登录。</p>\n</li>\n</ol>\n<h3 id=\"3-1-2-静默登录异步状态的处理\"><a href=\"#3-1-2-静默登录异步状态的处理\" class=\"headerlink\" title=\"3.1.2 静默登录异步状态的处理\"></a>3.1.2 静默登录异步状态的处理</h3><p><strong>1. 应用启动的时候调用</strong></p>\n<p>因为大部分情况都需要依赖登录态，我们会很自然而然的想到把这个调用的时机放到应用启动的时候（ <code>app.onLaunch()</code> ）来调用。</p>\n<p>但是由于原生的小程序启动流程中， <code>App</code>，<code>Page</code>，<code>Component</code> 的生命周期钩子函数，都不支持异步阻塞。</p>\n<p>那么我们很容易会遇到 <code>app.onLaunch</code> 发起的「登录过程」在 <code>page.onLoad</code> 的时候还没有完成，我们就无法正确去做一些依赖登录态的操作。</p>\n<p>针对这种情况，我们设计了一个状态机的工具：<a href=\"http://beautywejs.com/#/remote/plugin-status?id=plugin-statusl\">status</a></p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016110706.png\" alt=\"状态机\"></p>\n<p>基于状态机，我们就可以编写这样的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Status</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@beautywe/plugin-status&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// on app.js</span></span><br><span class=\"line\"><span class=\"title class_\">App</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">status</span>: &#123;</span><br><span class=\"line\">       <span class=\"attr\">login</span>: <span class=\"keyword\">new</span> <span class=\"title class_\">Status</span>(<span class=\"string\">&#x27;login&#x27;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">onLaunch</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        session</span><br><span class=\"line\">            <span class=\"comment\">// 发起静默登录调用</span></span><br><span class=\"line\">            .<span class=\"title function_\">login</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 把状态机设置为 success</span></span><br><span class=\"line\">            .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">status</span>.<span class=\"property\">login</span>.<span class=\"title function_\">success</span>())</span><br><span class=\"line\">      </span><br><span class=\"line\">            <span class=\"comment\">// 把状态机设置为 fail</span></span><br><span class=\"line\">            .<span class=\"title function_\">catch</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">status</span>.<span class=\"property\">login</span>.<span class=\"title function_\">fail</span>());</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// on page.js</span></span><br><span class=\"line\"><span class=\"title class_\">Page</span>(&#123;</span><br><span class=\"line\">    <span class=\"title function_\">onLoad</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> loginStatus = <span class=\"title function_\">getApp</span>().<span class=\"property\">status</span>.<span class=\"property\">login</span>;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// must 里面会进行状态的判断，例如登录中就等待，登录成功就直接返回，登录失败抛出等。</span></span><br><span class=\"line\">      <span class=\"title function_\">loginStatus</span>().<span class=\"property\">status</span>.<span class=\"property\">login</span>.<span class=\"title function_\">must</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 进行一些需要登录态的操作...</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>2. 在「第一个需要登录态接口」被调用的时候去发起登录</strong></p>\n<p>更进一步，我们会发现，需要登录态的更深层次的节点是在发起的「需要登录态的后端 API 」的时候。</p>\n<p>那么我们可以在调用「需要登录态的后端 API」的时候再去发起「静默登录」，对于并发的场景，让其他请求等待一下就好了。</p>\n<p>以 <a href=\"https://wendux.github.io/dist/#/doc/flyio/readme\">fly.js</a> 作为 <code>wx.request()</code> 封装的「网络请求层」，做一个简单的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发起请求，并表明该请求是需要登录态的</span></span><br><span class=\"line\">fly.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;https://...&#x27;</span>, params, &#123; <span class=\"attr\">needLogin</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 fly 拦截器中处理逻辑</span></span><br><span class=\"line\">fly.<span class=\"property\">interceptors</span>.<span class=\"property\">request</span>.<span class=\"title function_\">use</span>(<span class=\"keyword\">async</span> (req)=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 在请求需要登录态的时候</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (req.<span class=\"property\">needLogin</span> !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ensureLogin 核心逻辑是：判断是否已登录，如否发起登录调用，如果正在登录，则进入队列等待回调。</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> session.<span class=\"title function_\">ensureLogin</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 登录成功后，获取 token，通过 headers 传递给后端。</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> token = <span class=\"keyword\">await</span> session.<span class=\"title function_\">getToken</span>();</span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>(req.<span class=\"property\">headers</span>, &#123; [<span class=\"variable constant_\">AUTH_KEY_NAME</span>]: token &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> req;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-1-3-自定义登录态过期的容错处理\"><a href=\"#3-1-3-自定义登录态过期的容错处理\" class=\"headerlink\" title=\"3.1.3 自定义登录态过期的容错处理\"></a>3.1.3 自定义登录态过期的容错处理</h3><p>当自定义登录态过期的时候，后端需要返回特定的状态码，例如：<code>AUTH_EXPIRED</code> 、 <code>AUTH_INVALID</code> 等。</p>\n<p>前端可以在「网络请求层」去监听所有请求的这个状态码，然后发起刷新登录态，再去重放失败的请求：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加响应拦截器</span></span><br><span class=\"line\">fly.<span class=\"property\">interceptors</span>.<span class=\"property\">response</span>.<span class=\"title function_\">use</span>(</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> code = res.<span class=\"property\">data</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"comment\">// 登录态过期或失效</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( [<span class=\"string\">&#x27;AUTH_EXPIRED&#x27;</span>, <span class=\"string\">&#x27;AUTH_INVALID&#x27;</span>].<span class=\"title function_\">includes</span>(code) ) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 刷新登录态</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> session.<span class=\"title function_\">refreshLogin</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 然后重新发起请求</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> fly.<span class=\"title function_\">request</span>(request);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>那么如果并发的发起多个请求，都返回了登录态失效的状态码，上述代码就会被执行多次。</p>\n<p>我们需要对 <code>session.refreshLogin()</code> 做一些特殊的容错处理：</p>\n<ol>\n<li><strong>请求锁</strong>：同一时间，只允许一个正在过程中的网络请求。</li>\n<li><strong>等待队列</strong>：请求被锁定之后，调用该方法的所有调用，都推入一个队列中，等待网络请求完成之后共用返回结果。</li>\n<li><strong>熔断机制</strong>：如果短时间内多次调用，则停止响应一段时间，类似于 TCP 慢启动。</li>\n</ol>\n<p>示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Session</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 刷新登录保险丝，最多重复 3 次，然后熔断，5s 后恢复</span></span><br><span class=\"line\">  refreshLoginFuseLine = <span class=\"variable constant_\">REFRESH_LOGIN_FUSELINE_DEFAULT</span>;</span><br><span class=\"line\">  refreshLoginFuseLocked = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  refreshLoginFuseRestoreTime = <span class=\"number\">5000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 熔断控制</span></span><br><span class=\"line\">  <span class=\"title function_\">refreshLoginFuse</span>(): <span class=\"title class_\">Promise</span>&lt;<span class=\"keyword\">void</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLocked</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&#x27;刷新登录-保险丝已熔断，请稍后&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLine</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLine</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLine</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLocked</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLocked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseLine</span> = <span class=\"variable constant_\">REFRESH_LOGIN_FUSELINE_DEFAULT</span>;</span><br><span class=\"line\">        logger.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;刷新登录-保险丝熔断解除&#x27;</span>);</span><br><span class=\"line\">      &#125;, <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginFuseRestoreTime</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&#x27;刷新登录-保险丝熔断!!&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 并发回调队列</span></span><br><span class=\"line\">  refreshLoginQueueMaxLength = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"attr\">refreshLoginQueue</span>: any[] = [];</span><br><span class=\"line\">  refreshLoginLocked = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 刷新登录态</span></span><br><span class=\"line\">  <span class=\"title function_\">refreshLogin</span>(): <span class=\"title class_\">Promise</span>&lt;<span class=\"keyword\">void</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">// 回调队列 + 熔断 控制</span></span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">refreshLoginFuse</span>())</span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginLocked</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> maxLength = <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginQueueMaxLength</span>;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginQueue</span>.<span class=\"property\">length</span> &gt;= maxLength) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">`refreshLoginQueue 超出容量：<span class=\"subst\">$&#123;maxLength&#125;</span>`</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginQueue</span>.<span class=\"title function_\">push</span>([resolve, reject]);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginLocked</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 通过前置控制之后，发起登录过程</span></span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">clearSession</span>();</span><br><span class=\"line\">        wx.<span class=\"title function_\">showLoading</span>(&#123; <span class=\"attr\">title</span>: <span class=\"string\">&#x27;刷新登录态中&#x27;</span>, <span class=\"attr\">mask</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">login</span>()</span><br><span class=\"line\">          .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            wx.<span class=\"title function_\">hideLoading</span>();</span><br><span class=\"line\">            wx.<span class=\"title function_\">showToast</span>(&#123; <span class=\"attr\">icon</span>: <span class=\"string\">&#x27;none&#x27;</span>, <span class=\"attr\">title</span>: <span class=\"string\">&#x27;登录成功&#x27;</span> &#125;);</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginQueue</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">[resolve]</span>) =&gt;</span> <span class=\"title function_\">resolve</span>());</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginLocked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">            wx.<span class=\"title function_\">hideLoading</span>();</span><br><span class=\"line\">            wx.<span class=\"title function_\">showToast</span>(&#123; <span class=\"attr\">icon</span>: <span class=\"string\">&#x27;none&#x27;</span>, <span class=\"attr\">title</span>: <span class=\"string\">&#x27;登录失败&#x27;</span> &#125;);</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginQueue</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">[, reject]</span>) =&gt;</span> <span class=\"title function_\">reject</span>());</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">refreshLoginLocked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-4-微信-session-key-过期的容错处理\"><a href=\"#3-1-4-微信-session-key-过期的容错处理\" class=\"headerlink\" title=\"3.1.4 微信 session_key 过期的容错处理\"></a>3.1.4 微信 session_key 过期的容错处理</h3><p>我们从上面的「静默登录」之后，微信服务器端会下发一个 <code>session_key</code> 给后端，而这个会在需要获取<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html\">微信开放数据</a>的时候会用到。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016110824.png\" alt=\"微信开放数据\"></p>\n<p>而 <code>session_key</code> 是有时效性的，以下摘自微信官方描述：</p>\n<blockquote>\n<h4 id=\"会话密钥-session-key-有效性\"><a href=\"#会话密钥-session-key-有效性\" class=\"headerlink\" title=\"会话密钥 session_key 有效性\"></a>会话密钥 session_key 有效性</h4><p>开发者如果遇到因为 session_key 不正确而校验签名失败或解密失败，请关注下面几个与 session_key 有关的注意事项。</p>\n<ol>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html\">wx.login</a> 调用时，用户的 session_key <strong>可能</strong>会被更新而致使旧 session_key 失效（刷新机制存在最短周期，如果同一个用户短时间内多次调用 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html\">wx.login</a>，并非每次调用都导致 session_key 刷新）。开发者应该在明确需要重新登录时才调用 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html\">wx.login</a>，及时通过 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html\">auth.code2Session</a> 接口更新服务器存储的 session_key。</li>\n<li>微信不会把 session_key 的有效期告知开发者。我们会根据用户使用小程序的行为对 session_key 进行续期。用户越频繁使用小程序，session_key 有效期越长。</li>\n<li>开发者在 session_key 失效时，可以通过重新执行登录流程获取有效的 session_key。使用接口 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.checkSession.html\">wx.checkSession</a>可以校验 session_key 是否有效，从而避免小程序反复执行登录流程。</li>\n<li>当开发者在实现自定义登录态时，可以考虑以 session_key 有效期作为自身登录态有效期，也可以实现自定义的时效性策略。</li>\n</ol>\n</blockquote>\n<p>翻译成简单的两句话：</p>\n<ol>\n<li><code>session_key</code> 时效性由微信控制，开发者不可预测。</li>\n<li><code>wx.login</code> 可能会导致 <code>session_key</code> 过期，可以在使用接口之前用<code> wx.checkSession</code> 检查一下。</li>\n</ol>\n<p>而对于第二点，我们通过实验发现，偶发性的在 <code>session_key</code> 已过期的情况下，<code>wx.checkSession</code> 会概率性返回 <code>true</code></p>\n<p>社区也有相关的反馈未得到解决：</p>\n<ul>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/000424005b89983f337a622c751000?highLine=wx.checkSession\">小程序解密手机号,隔一小段时间后,checksession:ok,但是解密失败</a></li>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/0008e429bd0c886e10699f59c51000?_at=1602745291452\">wx.checkSession有效，但是解密数据失败</a></li>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/000a04ab4546d80d5428ffcee51800?_at=1602745291452\">checkSession判断session_key未失效，但是解密手机号失败</a></li>\n</ul>\n<p><strong>所以结论是：<code>wx.checkSession</code>可靠性是不达 100% 的。</strong></p>\n<p>基于以上，我们需要对 <code>session_key</code> 的过期做一些容错处理：</p>\n<ol>\n<li>发起需要使用 <code>session_key</code> 的请求前，做一次 <code>wx.checkSession</code> 操作，如果失败了刷新登录态。</li>\n<li>后端使用 <code>session_key</code> 解密开放数据失败之后，返回特定错误码（如：<code>DECRYPT_WX_OPEN_DATA_FAIL</code>），前端刷新登录态。</li>\n</ol>\n<p>示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义检查 session_key 有效性的操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">ensureSessionKey</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hasSession = <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    wx.<span class=\"title function_\">checkSession</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\">() =&gt;</span> <span class=\"title function_\">resolve</span>(<span class=\"literal\">true</span>),</span><br><span class=\"line\">      <span class=\"attr\">fail</span>: <span class=\"function\">() =&gt;</span> <span class=\"title function_\">resolve</span>(<span class=\"literal\">false</span>),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!hasSession) &#123;</span><br><span class=\"line\">    logger.<span class=\"title function_\">info</span>(<span class=\"string\">&#x27;sessionKey 已过期，刷新登录态&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 接上面提到的刷新登录逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> session.<span class=\"title function_\">refreshLogin</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在发起请求的时候，先做一次确保 session_key 最新的操作（以 fly.js 作为网络请求层为例）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">updatePhone</span> = <span class=\"keyword\">async</span> (<span class=\"params\">params</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">ensureSessionKey</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> fly.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;https://xxx&#x27;</span>, params);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加响应拦截器, 监听网络请求返回</span></span><br><span class=\"line\">fly.<span class=\"property\">interceptors</span>.<span class=\"property\">response</span>.<span class=\"title function_\">use</span>(</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> code = res.<span class=\"property\">data</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"comment\">// 登录态过期或失效</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( [<span class=\"string\">&#x27;DECRYPT_WX_OPEN_DATA_FAIL&#x27;</span>].<span class=\"title function_\">includes</span>(code)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 刷新登录态</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> session.<span class=\"title function_\">refreshLogin</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 由于加密场景的加密数据由用户点击产生，session_key 可能已经更改，需要用户重新点击一遍。</span></span><br><span class=\"line\">        wx.<span class=\"title function_\">showToast</span>(&#123; <span class=\"attr\">title</span>: <span class=\"string\">&#x27;网络出小差了，请稍后重试&#x27;</span>, <span class=\"attr\">icon</span>: <span class=\"string\">&#x27;none&#x27;</span> &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-2-授权的实现\"><a href=\"#3-2-授权的实现\" class=\"headerlink\" title=\"3.2 授权的实现\"></a>3.2 授权的实现</h2><h3 id=\"3-2-1-组件拆分与设计\"><a href=\"#3-2-1-组件拆分与设计\" class=\"headerlink\" title=\"3.2.1 组件拆分与设计\"></a>3.2.1 组件拆分与设计</h3><p>在用户信息和手机号获取的方式上，微信是以 <code>&lt;button open-type=&#39;xxx&#39; /&gt;</code> 的方式，让用户主动点击授权的。</p>\n<p>那么为了让代码更解耦，我们设计这样三个组件：</p>\n<ol>\n<li><code>&lt;user-contaienr getUserInfo=&quot;onUserInfoAuth&quot;&gt;</code>: 包装点击交互，通过 <code>&lt;slot&gt;</code> 支持点击区域的自定义UI。</li>\n<li><code>&lt;phone-container getPhonenNmber=&quot;onPhoneAuth&quot;&gt;</code> : 与 <code>&lt;user-container&gt;</code> 同理。</li>\n<li><code>&lt;auth-flow&gt;</code>: 根据业务需要，组合 <code>&lt;user-container&gt;</code>、<code>&lt;phone-container&gt;</code> 组合来定义不同的授权流程。</li>\n</ol>\n<p>以开头的业务场景的流程为例，它有这样的要求：</p>\n<ol>\n<li>有多个步骤。</li>\n<li>如果中途断掉了，可以从中间接上。</li>\n<li>有些场景中，只要求达到「用户信息授权」，而不需要完成「用户手机号」。</li>\n</ol>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111006.jpg\" alt=\"完整授权流程\"></p>\n<p>那么授权的阶段可以分三层：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用户登录的阶段</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> enum <span class=\"title class_\">AuthStep</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 阶段一：只有登录态，没有用户信息，没有手机号</span></span><br><span class=\"line\">  <span class=\"variable constant_\">ONE</span> = <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 阶段二：有用户信息，没有手机号</span></span><br><span class=\"line\">  <span class=\"variable constant_\">TWO</span> = <span class=\"number\">2</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 阶段三：有用户信息，有手机号</span></span><br><span class=\"line\">  <span class=\"variable constant_\">THREE</span> = <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>AuthStep</code> 的推进过程是不可逆的，我们可以定义一个 <code>nextStep</code> 函数来封装 AuthStep 更新的逻辑。外部使用的话，只要无脑调用 <code>nextStep</code> 方法，等待回调结果就行。</p>\n<p>示例伪代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// auth-flow component</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 默认情况下，只需要到达阶段二。</span></span><br><span class=\"line\">    <span class=\"attr\">mustAuthStep</span>: <span class=\"title class_\">AuthStep</span>.<span class=\"property\">TWO</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 允许临时更改组件的需要达到的阶段。</span></span><br><span class=\"line\">  <span class=\"title function_\">setMustAuthStep</span>(<span class=\"params\">mustAuthStep: AuthStep</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setData</span>(&#123; mustAuthStep &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 根据用户当前的信息，计算用户处在授权的阶段</span></span><br><span class=\"line\">  <span class=\"title function_\">getAuthStep</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> currAuthStep;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 没有用户信息，尚在第一步</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!session.<span class=\"title function_\">hasUser</span>() || !session.<span class=\"title function_\">hasUnionId</span>()) &#123;</span><br><span class=\"line\">      currAuthStep = <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">ONE</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 没有手机号，尚在第二步</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!session.<span class=\"title function_\">hasPhone</span>()) &#123;</span><br><span class=\"line\">      currAuthStep = <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">TWO</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 都有，尚在第三步</span></span><br><span class=\"line\">    currAuthStep = <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">THREE</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currAuthStep;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 发起下一步授权，如果都已经完成，就直接返回成功。</span></span><br><span class=\"line\">  <span class=\"title function_\">nextStep</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; mustAuthStep &#125; = <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> currAuthStep = <span class=\"variable language_\">this</span>.<span class=\"title function_\">updateAuthStep</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 已完成授权</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currAuthStep &gt;= mustAuthStep || currAuthStep === <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">THREE</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 更新全局的授权状态机，广播消息给订阅者。</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">getApp</span>().<span class=\"property\">status</span>.<span class=\"property\">auth</span>.<span class=\"title function_\">success</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 第一步：更新用户信息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currAuthStep === <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">ONE</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 已有密文信息，更新用户信息</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (e) session.<span class=\"title function_\">updateUser</span>(e);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 更新到视图层，展示对应UI，等待获取用户信息</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">setData</span>(&#123; currAuthStep &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 第二步：更新手机信息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currAuthStep === <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">TWO</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 已有密文信息，更新手机号</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (e) <span class=\"variable language_\">this</span>.<span class=\"title function_\">bindPhone</span>(e);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 未有密文信息，弹出获取窗口</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">setData</span>(&#123; currAuthStep &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;auth.nextStep 错误&#x27;</span>, &#123; currAuthStep, mustAuthStep &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>那么我们的 <code>&lt;auth-flow&gt;</code> 中就可以根据 <code>currAuthStep</code> 和 <code>mustAuthStep</code> 来去做不同的 UI 展示。需要注意的是使用 <code>&lt;user-container&gt;</code>、<code>&lt;phone-container&gt;</code> 的时候连接上 <code>nextStep(e)</code> 函数。</p>\n<p>示例伪代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;auth-flow&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 已完成授权 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">block</span> <span class=\"attr\">wx:if</span>=<span class=\"string\">&quot;&#123;&#123;currAuthStep === mustAuthStep || currAuthStep === AuthStep.THREE&#125;&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span>已完成授权<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">block</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 未完成授权，第一步：授权用户信息 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">block</span> <span class=\"attr\">wx:elif</span>=<span class=\"string\">&quot;&#123;&#123;currAuthStep === AuthStep.ONE&#125;&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">user-container</span> <span class=\"attr\">bind:getuserinfo</span>=<span class=\"string\">&quot;nextStep&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span>授权用户信息<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">user-container</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">block</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 未完成授权，第二步：授权手机号 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">block</span> <span class=\"attr\">wx:elif</span>=<span class=\"string\">&quot;&#123;&#123;currAuthStep === AuthStep.TWO&#125;&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">phone-container</span> <span class=\"attr\">bind:getphonenumber</span>=<span class=\"string\">&quot;nextStep&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span>授权手机号<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">phone-container</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">block</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-2-2-权限拦截的处理\"><a href=\"#3-2-2-权限拦截的处理\" class=\"headerlink\" title=\"3.2.2 权限拦截的处理\"></a>3.2.2 权限拦截的处理</h3><p>到这里，我们制作好了用来承载授权流程的组件 <code>&lt;auth-flow&gt;</code> ，那么接下来就是决定要使用它的时机了。</p>\n<p>我们梳理需要授权的场景：</p>\n<ol>\n<li><p>点击某个按钮，例如：购买某个商品。</p>\n<p>对于这种场景，常见的是通过弹窗完成授权，用户可以选择关闭。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016113312.png\" alt=\"授权模型-弹窗\"></p>\n</li>\n<li><p>浏览某个页面，例如：访问个人中心。</p>\n<p>对于这种场景，我们可以在点击跳转某个页面的时候，进行拦截，弹窗处理。但这样的缺点是，跳转到目标页面的地方可能会很多，每个都拦截，难免会错漏。而且当目标页面作为「小程序落地页面」的时候，就避免不了。</p>\n<p>这时候，我们可以通过重定向到授权页面来完成授权流程，完成之后，再回来。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016113324.png\" alt=\"授权模型-页面\"></p>\n</li>\n</ol>\n<p>那么我们定义一个枚举变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 授权的展示形式</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> enum <span class=\"title class_\">AuthDisplayMode</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 以弹窗形式</span></span><br><span class=\"line\">  <span class=\"variable constant_\">POPUP</span> = <span class=\"string\">&#x27;button&#x27;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 以页面形式</span></span><br><span class=\"line\">  <span class=\"variable constant_\">PAGE</span> = <span class=\"string\">&#x27;page&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以设计一个 <code>mustAuth</code> 方法，在点击某个按钮，或者页面加载的时候，进行授权控制。</p>\n<p>伪代码示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Session</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"title function_\">mustAuth</span>(&#123;</span><br><span class=\"line\">    mustAuthStep = <span class=\"title class_\">AuthStepType</span>.<span class=\"property\">TWO</span>, <span class=\"comment\">// 需要授权的LEVEL，默认需要获取用户资料</span></span><br><span class=\"line\">    popupCompName = <span class=\"string\">&#x27;auth-popup&#x27;</span>,\t<span class=\"comment\">// 授权弹窗组件的 id</span></span><br><span class=\"line\">    mode = <span class=\"title class_\">AuthDisplayMode</span>.<span class=\"property\">POPUP</span>, <span class=\"comment\">// 默认以弹窗模式</span></span><br><span class=\"line\">  &#125; = &#123;&#125;): <span class=\"title class_\">Promise</span>&lt;<span class=\"keyword\">void</span>&gt; &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果当前的授权步骤已经达标，则返回成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">currentAuthStep</span>() &gt;= mustAuthStep) <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 尝试获取当前页面的 &lt;auth-popup id=&quot;auth-popup&quot; /&gt; 组件实例</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> pages = <span class=\"title function_\">getCurrentPages</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> curPage = pages[pages.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> popupComp = curPage.<span class=\"title function_\">selectComponent</span>(<span class=\"string\">`#<span class=\"subst\">$&#123;popupCompName&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 组件不存在或者显示指定页面，跳转到授权页面</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!popupComp || mode === <span class=\"title class_\">AuthDisplayMode</span>.<span class=\"property\">PAGE</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> curRoute = curPage.<span class=\"property\">route</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 跳转到授权页面，带上当前页面路由，授权完成之后，回到当前页面。</span></span><br><span class=\"line\">      wx.<span class=\"title function_\">redirectTo</span>(&#123; <span class=\"attr\">url</span>: <span class=\"string\">`authPage?backTo=<span class=\"subst\">$&#123;<span class=\"built_in\">encodeURIComponent</span>(curRoute)&#125;</span>`</span> &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置授权 LEVEL，然后调用 &lt;auth-popup&gt; 的 nextStep 方法，进行进一步的授权。</span></span><br><span class=\"line\">    popupComp.<span class=\"title function_\">setMustAuthStep</span>(mustAuthStep);</span><br><span class=\"line\">    popupComp.<span class=\"title function_\">nextStep</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待成功回调或者失败回调</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> authStatus = <span class=\"title function_\">getApp</span>().<span class=\"property\">status</span>.<span class=\"property\">auth</span>;</span><br><span class=\"line\">      authStatus.<span class=\"title function_\">onceSuccess</span>(resolve);</span><br><span class=\"line\">      authStatus.<span class=\"title function_\">onceFail</span>(reject);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们就能在按钮点击，或者页面加载的时候进行授权拦截：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Page</span>(&#123;</span><br><span class=\"line\">  <span class=\"title function_\">onLoad</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    session.<span class=\"title function_\">mustAuth</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 开始初始化页面...</span></span><br><span class=\"line\">    &#125;)；</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"title function_\">onClick</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    session.<span class=\"title function_\">mustAuth</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 开始处理回调逻辑...</span></span><br><span class=\"line\">    &#125;)；</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当然，如果项目使用了 TS 的话，或者支持 ES7 Decorator 特性的话，我们可以为 <code>mustAuth</code> 提供一个装饰器版本：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">mustAuth</span>(<span class=\"params\">option = &#123;&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    _target,</span></span><br><span class=\"line\"><span class=\"params\">    _propertyName,</span></span><br><span class=\"line\"><span class=\"params\">    descriptor,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 劫持目标方法</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> method = descriptor.<span class=\"property\">value</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重写目标方法</span></span><br><span class=\"line\">    descriptor.<span class=\"property\">value</span> = <span class=\"keyword\">function</span>(<span class=\"params\">...args: any[]</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> session.<span class=\"title function_\">mustAuth</span>(option).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 登录完成之后，重放原来方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (method) <span class=\"keyword\">return</span> method.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么使用方式就简单一些了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Page</span>(&#123;</span><br><span class=\"line\">  @<span class=\"title function_\">mustAuth</span>();</span><br><span class=\"line\">  <span class=\"title function_\">onLoad</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开始初始化页面...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  @<span class=\"title function_\">mustAuth</span>();</span><br><span class=\"line\">  <span class=\"title function_\">onClick</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开始处理回调逻辑...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-3-前后端交互协议整理\"><a href=\"#3-3-前后端交互协议整理\" class=\"headerlink\" title=\"3.3. 前后端交互协议整理\"></a>3.3. 前后端交互协议整理</h2><p>作为一套可复用的小程序登录方案，当然需要去定义好前后端的交互协议。</p>\n<p>那么整套登录流程下来，需要的接口有这么几个：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016162606.png\" alt=\"登录注册前后端接口协议\"></p>\n<ol>\n<li><p><strong>静默登录 silentLogin</strong></p>\n<ol>\n<li>入参：<ol>\n<li>code: 产自 wx.login()</li>\n</ol>\n</li>\n<li>出参：<ol>\n<li>token: 自定义登录态凭证</li>\n<li>userInfo: 用户信息</li>\n</ol>\n</li>\n<li>说明：<ol>\n<li>后端利用 code 跟微信客户端换取用户标识，然后注册并登录用户，返回自定义登录态 <code>token</code> 给前端</li>\n<li><code>token</code> 前端会存起来，每个请求都会带上</li>\n<li>userInfo 需要包含<code>nickname</code>和<code>phone</code>字段，前端用于计算当前用户的授权阶段。当然这个状态的记录可以放在后端，但是我们认为放在前端，会更加灵活。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>更新用户信息 updateUser</strong></p>\n<ol>\n<li>入参：<ol>\n<li>nickname: 用户昵称</li>\n<li>encrypt: 微信开放数据相关的 <code>iv</code>, <code>encryptedData</code></li>\n<li>以及其他如性别地址等非必要字段</li>\n</ol>\n</li>\n<li>出参：<ol>\n<li>userInfo：更新后的最新用户信息</li>\n</ol>\n</li>\n<li>说明：<ol>\n<li>后端解密微信开放数据，获取隐蔽数据，如：<code>unionId </code>等</li>\n<li>后端支持更新包括 <code>nickname</code>等用户基本信息。</li>\n<li>前端会把 userInfo 信息更新到 <code>session</code> 中，用于计算授权阶段。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>更新用户手机号 updatePhone</strong></p>\n<ol>\n<li>入参：<ol>\n<li>encrypt：微信开放数据相关的 <code>iv</code>, <code>encryptedData</code></li>\n</ol>\n</li>\n<li>出参：<ol>\n<li>userInfo：更新后的最新用户信息</li>\n</ol>\n</li>\n<li>说明：<ol>\n<li>后端解密开放式局，获取手机号，并更新到用户信息中。 </li>\n<li>前端会把 userInfo 信息更新到 <code>session</code> 中，用于计算授权阶段。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>解绑手机号 unbindPhone</strong></p>\n<ol>\n<li>入参：-</li>\n<li>出参：-</li>\n<li>说明：后端解绑用户手机号，成功与否，走业务定义的前后端协议。</li>\n</ol>\n</li>\n<li><p><strong>登录 logout</strong></p>\n<ol>\n<li>入参：-</li>\n<li>出参：-</li>\n<li>说明：后端主动过期登录态，成功与否，走业务定义的前后端协议。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"五-架构图\"><a href=\"#五-架构图\" class=\"headerlink\" title=\"五. 架构图\"></a>五. 架构图</h1><p>最后我们来梳理一下整体的「登录服务」的架构图：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlgy1gjqk8sm9dbj30v60fp0uc.jpg\" alt=\"微信小程序登录服务架构图\"></p>\n<p>由「登录服务」和「底层建设」组合提供的通用服务，业务层只需要去根据产品需求，定制授权的流程 <code>&lt;auth-flow&gt;</code> ，就能满足大部分场景了。</p>\n<h1 id=\"六-总结\"><a href=\"#六-总结\" class=\"headerlink\" title=\"六. 总结\"></a>六. 总结</h1><p>本篇文章通过一些常见的登录授权场景来展开来描述细节点。</p>\n<p>整理了「登录」、「授权」的概念。</p>\n<p>然后分别针对「登录」介绍了一些关键的技术实现：</p>\n<ol>\n<li>静默登录</li>\n<li>静默登录异步状态的处理</li>\n<li>自定义登录态过期的容错处理</li>\n<li>微信 <code>session_key</code> 过期的容错处理</li>\n</ol>\n<p>而对于「授权」，会有设计UI部分的逻辑，还需要涉及到组件的拆分：</p>\n<ol>\n<li>组件拆分与设计</li>\n<li>权限拦截的处理</li>\n</ol>\n<p>然后，梳理了这套登录授权方案所依赖的后端接口，和给出最简单的参考协议。</p>\n<p>最后，站在「秉着沉淀一套通用的小程序登录方案和服务为目标」的角度，梳理了一下架构层面上的分层。</p>\n<ol>\n<li>业务定制层</li>\n<li>登录服务层</li>\n<li>底层建设</li>\n</ol>\n<h1 id=\"七-参考\"><a href=\"#七-参考\" class=\"headerlink\" title=\"七. 参考\"></a>七. 参考</h1><ol>\n<li><a href=\"https://wendux.github.io/dist/#/doc/flyio/readme\">fly.js 官网</a></li>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html\">微信官方文档-授权</a></li>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html\">微信官方文档-服务端获取开放数据</a></li>\n<li>微信官方社区<ol>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/000424005b89983f337a622c751000?highLine=wx.checkSession\">小程序解密手机号,隔一小段时间后,checksession:ok,但是解密失败</a></li>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/0008e429bd0c886e10699f59c51000?_at=1602745291452\">wx.checkSession有效，但是解密数据失败</a></li>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/000a04ab4546d80d5428ffcee51800?_at=1602745291452\">checkSession判断session_key未失效，但是解密手机号失败</a></li>\n</ol>\n</li>\n</ol>\n"},{"title":"微信小程序路由实战","date":"2021-03-21T12:28:00.000Z","_content":"\n# 0. 目录\n\n- [1. 前言](#1-前言)\n- [2. 智能路由跳转 — Navigator 模块](#2-智能路由跳转--navigator-模块)\n- [3. 虚拟路由策略 — Router 模块](#3-虚拟路由策略--router-模块)\n- [4. 落地中转策略 — LandTransfer 模块](#4-落地中转策略--landtransfer-模块)\n  - [4.1. 对于要解决的第一个问题：统一的落地页](#41-对于要解决的第一个问题统一的落地页)\n  - [4.2. 对于第二个要解决的问题：短链参数](#42-对于第二个要解决的问题短链参数)\n  - [4.3. LandTransfer 模块设计](#43-landtransfer-模块设计)\n- [5. 更好的开发体验](#5-更好的开发体验)\n  - [5.1. Typescript + Router](#51-typescript--router)\n  - [5.2. 智能生成路由配置](#52-智能生成路由配置)\n  - [5.3. 自定义组件跳转](#53-自定义组件跳转)\n- [6. 整体架构图](#6-整体架构图)\n- [7. 最后的最后](#7-最后的最后)\n\n# 1. 前言\n\n在微信小程序由一个 `App()`实例，和众多`Page()`组成。而在小程序中所有页面的路由全部由框架进行管理，框架以栈的形式维护了所有页面，然后提供了以下 API 来进行路由之间的跳转：\n1. `wx.navigateTo`\n2. `wx.redirectTo`\n3. `wx.navigateBack`\n4. `wx.switchTab`\n5. `wx.reLaunch` \n\n但是，对于一个企业应用，把这些问题留给了开发者：\n\n1. 原生 API 使用了 `Callback` 的函数实现形式，与我们现代普遍的 `Promise` 和 `async/await` 存在 gap。\n2. 基于小程序路由的设计，暴露给外部的是真实路由（如扫码，公众号链接等方式），对后续项目重构留下历史包袱。\n3. 小程序页面栈最多十层， 在超过十层后 `wx.navigateTo` 失效，需要开发者判断使用 `wx.redirectTo` 或其他API\n4. 小程序页面栈存在一种特殊的页面：Tab 页面，需要使用 `wx.switchTab` 才能跳转。需要开发者主动判断，不方便后期改动 Tab 页面属性。\n5. 额外的，对于小程序码，要使用无数量限制 API [wxacode.getUnlimited](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html) ，存在参数长度限制32位以内。需要开发者自行解决。\n\n而本文，期望能对这若干问题，逐个提供解决方案。\n\n\n\n# 2. 智能路由跳转 — Navigator 模块\n\n在这里我们一起解决：\n\n1. 原生 API 非 Promsie\n2. 页面栈突破十层时特殊处理\n3. 特殊页面 Tab 的跳转处理\n\n我们的思路是，希望能设计一种逻辑，根据场景来自动判断使用哪个微信路由 API，然后对外只提供一个函数，例如：\n\n```javascript\ngotoPage('/pages/goods/index')\n```\n\n具体逻辑如下：\n\n1. 当跳转的路由为小程序 tab 页面时，则使用 `wx.switchTab`。\n2. 当页面栈达到 10 层之后，如果要跳转的页面在页面栈中，使用 `wx.navigateBack({ delta: X })` 出栈到目标页面。\n3. 当页面栈达到 10 层之后，目标页面不存在页面栈中，使用 `wx.redirectTo` 替换栈顶页面。\n4. 其他情况使用 `wx.navigateTo`\n\n顺带的，我们把这个函数以 Promise 形式实现，以及支持参数作为 `object`传入，例如：\n\n```javascript\ngotoPage('/pages/goods/index', { name: 'jc' }).then(...).catch(...);\n```\n\n大部分场景下，只要使用`gotoPage`就能满足。\n\n那肯定也会有特定的情况，需要显式的指定使用 `navigateTo/switchTab/redirectTo/navigateBack`的哪一个。\n\n那么我们也按照类似的实现，满足相同模式的 API\n\n```javascript\nnavigateTo('/pages/goods/index', { name: 'jc' }).then(...).catch(...);\nswitchTab('/pages/goods/index', { name: 'jc' }).then(...).catch(...);\nredirectTo('/pages/goods/index', { name: 'jc' }).then(...).catch(...);\nnavigateBack('/pages/goods/index', { name: 'jc' }).then(...).catch(...);\n```\n\n这些函数都可以内聚到同一个模块，我们称其为：**Navigator**\n\n```javascript\nconst navigator = new Navigator();\nnavigator.gotoPage(...);\nnavigator.navigateTo(...);\nnavigator.switchTab(...);\nnavigator.redirectTo(...);\nnavigator.navigateBack(...);\n```\n\n\n\n模块设计：\n\n![navigator-class](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202552.png)\n\n\n\n# 3. 虚拟路由策略 — Router 模块\n\n在这里，我们解决：\n\n1. 对外暴露了真实路由，导致历史包袱沉重的问题。\n\n在许多应用开发中，我们经常需要把某种模式匹配到的所有路由，全都映射到同个页面中去。  \n例如，我们有一个 Goods 页面，对于所有 ID 各不相同的商品，都要使用这个页面来承载。  \n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202632.png)\n\n\n\n那么在代码层面上，期望能实现这样的调用方式：\n\n```javascript\n// 创建路由实例\nconst router = new Router();\n\n// 注册路由\nrouter.register({\n  path: '/goods/:id', // 虚拟路由\n  route: '/pages/goods/index', // 真实路由\n});\n\n// 跳转到 /pages/goods/index，参数: onLoad(options) 的 options = { id: '123' }\nrouter.gotoPage('/goods/123');\n\n// 跳转到 /pages/goods/index，参数: onLoad(options) 的 options = { id: '456' }\nrouter.gotoPage('/goods/456');\n```\n\n**Class Router** 的核心逻辑是完成：\n\n1. 路由的注册，完成「虚拟路径」和「真实路径」关系的存储。\n2. 满足「虚拟路径」到「真实路径」的转换，并且识别「动态路径参数」（dynamic segment）。\n3. 路由跳转。\n\n对于「路由的注册」，我们在其内部存储一个 map 就能完成。\n\n而对于「路径的转换」， `vue-router` 有类似的实现，通过其源码发现，内部是使用  [path-to-regexp](https://github.com/pillarjs/path-to-regexp) 作为路径匹配引擎，我们可以拿来用之。\n\n然后对于「路由的跳转」，我们可以直接复用上面提到的 **Navigator** 模块，通过输入真实路径，来完成路由的跳转。\n\n\n\n模块设计：\n\n![route-class](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202636.png)\n\n\n\n其中：\n\n1. RouteMatcher：提供动态路由参数匹配功能，内部使用  [path-to-regexp](https://github.com/pillarjs/path-to-regexp) 作为路径匹配引擎。\n1. Route: 为每个路径创建路由器，存储每个路由的虚拟路径和真实路由的关系。\n1. Router：整合内部各模块，对外提供统一且优雅的调用方式。\n\n\n\n\n\n\n# 4. 落地中转策略 — LandTransfer 模块\n\n在这里，我们解决：\n\n1. 小程序扫码、公众号链接等场景下的落地页统一。\n2. 小程序码，对于无限量API [wxacode.getUnlimited](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html) ，突破参数32位长度限制。\n\n\n\n## 4.1. 对于要解决的第一个问题：统一的落地页\n\n我们把如：扫小程序码、公众号菜单、公众号文章等方式打开小程序某个页面的路径称为「外部路由」。\n\n根据小程序的设计，暴露给外部的连接是真实的页面路径，如：`/pages/home/index`，该设计在实践中存在的弊端：**各个落地页分散，后期修改真实文件路径难度大。**\n\n在 **「中长生命周期」** 产品中，随着产品的迭代，我们难免会遇到项目的重构。如果分发出去的都是没经过处理的真实路径的话，我们重构时就会束手束脚，要做很多的兼容操作。因为你不知道，分发出去的小程序二维码， 有多少被打印到实体物料中。\n\n那么，**「虚拟路由」+「落地中转」** 的策略就显得基本且重要了。\n\n「虚拟路由」的功能，**Router **模块给我们提供了支持了，我们还需要对外提供一个统一的落地页面，让它来完成对内部路由的中转。\n\n基本逻辑：\n\n1. 分发出去的真实路由，指向到唯一的落地页面，如：`$LAND_PAGE: /pages/land-page/index`\n2. 由这个落地页面，进行内部路由的重定向转发，通过接收 参数，如：`path=/user&name=jc&age=18`\n\n![普通模式](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210309185153.png)\n\n在代码层面上，我们希望能实现这样的使用：\n\n```typescript\n// /pages/land-page/index.ts\n\nconst landTransfer = new LandTransfer(landTransferOptions);\n\nPage({\n  onLoad(options) {\n      landTransfer\n        .run(options)\n        .then(() => {...})\n        .catch(() => {...});\n  }\n});\n```\n\n然后针对 TS，我们还可以使用装饰器版本，更加简便：\n\n```typescript\nimport { landTransferDecorator } from 'wxapp-router';\n\nPage({\n  @landTransferDecorator(landTransferOptions)\n  onLoad(options) {\n    // ...\n  },\n});\n```\n\n\n\n## 4.2. 对于第二个要解决的问题：短链参数\n\n微信小程序主要提供了两个接口去生成小程序码：\n\n1. [wxacode.get](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.get.html): 获取小程序码，适用于需要的码数量较少的业务场景。**通过该接口生成的小程序码，永久有效，数量限制为 100,000** 个\n2. [wxacode.getUnlimited](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html): 获取小程序码，适用于需要的码数量极多的业务场景。**通过该接口生成的小程序码，永久有效，数量暂无限制。**\n\n第一种方式，`wxacode.get` 数量限制为 10w 个，虽然量很大了，绝大多数的小程序可能用不到这个量。\n\n但如果我们运营的是一个中大型电商小程序的话，假如：1w 种商品 x 10 种商品规格，那就会超过这个数量。到时候再进行改造，就困难了。\n\n所以，如果抱着是运营一个 **「中长生命周期」** 的产品的话，我们会使用第二种方式：`wxacode.getUnlimited`\n\n不尽人意的是，虽然它没有数量限制，但是对参数会有 32 个字符的限制，显然是不够用的（一个 uuid 就 32 字符了）。\n\n对于这种情况，我们可以使用「短链参数」的形式解决，由于[wxacode.getUnlimited](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html) 会通过 `scene`字段作为 query 参数传递给小程序的，那么我们可以通过 `scene`参数来实现短链服务，这需要后端配合。\n\n前后端交互如下：\n\n![Scene短链模式](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210312182826.png)\n\n1. 当小程序需要生成小程序码的时候，请求后端提供的接口，例如：`/api/encodeShortParams`\n2. 后端把内容转换为 32 字符内的字符串，存储到数据库中。\n3. 后端通过 [wxacode.getUnlimited](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html) 接口，以短链字符串作为 `scene`的值，以商定好的统一落地页 `$LAND_PAGE`作为 `page`值，生成小程序码。\n4. 当通过小程序码进入小程序，小程序获取到 `scene`参数，请求后端提供的接口，例如：`/api/decodeShrotParams`\n5. 小程序理解内容，跳转到目标页面中去。\n\n\n\n而前端对于统一落地页的逻辑处理，我们只需要在第一个问题的基础上，增加一个**转换短链参数内容**的逻辑就行了：\n\n![短链模式](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210309185154.png)\n\n\n\n代码层面上，我们我们只需要多定义转换短链参数的方式：`convertScenePrams`\n\n```typescript\n// in /pages/land-page/index.js\nimport { landTransferDecorator } from 'wxapp-router';\n\nconst landTransferOptions = {\n  // 此处接收 onLoad(options) 中的 options.scene\n  convertSceneParams: (sceneParams) => {\n    return API.convertScene({ sceneParams }).then((content) => {\n      // 假如后端存的是 JSON 字符串，前端decode\n      // 要求 content = { path: '/home', a: 1, b:2 }\n      return JSON.parse(content);\n    });\n  },\n};\n\nPage({\n  @landTransferDecorator(landTransferOptions)\n  onLoad(options) {\n    // ...\n  },\n});\n```\n\n而其中的 `API.convertScene` 就对接服务端提供 HTTP 接口服务来完成。\n\n\n\n## 4.3. LandTransfer 模块设计\n\n![land-transfer](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202654.png)\n\n\n\n# 5. 更好的开发体验\n\n## 5.1. Typescript + Router\n\n对于小程序内部的路由跳转，我们除了指定一个字符串的路由，我们是否也可以通过链式调用，像调用函数那样去跳转页面呢？类似这样；\n\n```typescript\nroutes.pages.user.go({ name: 'jc' });\n```\n\n这样做的好处是：\n\n1. 更自然的调用方式。\n2. 能结合 TS，来做到类型提示和联想。\n\n由于事先 `wxapp-router` 并不知道开发者需要注册的路由是什么样的，所以路由的 TS 声明文件，需要开发者来定义。\n\n例如，我们在项目中维护一份路由文件：\n\n```typescript\n// config/routes.ts\n\n// 创建路由实例\nconst router = new Router();\n\nconst routesConfig = [{\n  path: '/user',\n  route: '/pages/user/index',\n}, {\n  path: '/goods',\n  route: '/pages/goods/index',\n}]；\n\ntype RoutesType {\n  paegs: {\n    user: Route<{name: string}>,\n    goods: Route,\n  }\n}\n\n// 注册路由\nrouter.batchRegister(routesConfig);\n\n// 获取 routes\nconst routes: RoutesType = router.getRoutes();\n\nexport default routes;\n```\n\n然后在别的地方使用它：\n\n```typescript\nimport routes from './routes.ts';\n\nroutes.pages.user.go({ name: 'jc' });\n```\n\n\n\n## 5.2. 智能生成路由配置\n\n如果路由变多的时候，我们还需要对每个路由手动去编写 `RoutesType` 的话，就有点难受了。\n\n在小程序中，我们把正式路由都配置到 `app.json` ，那么在遵循既定的项目结构情况下，我们可以通过自动构建，完成大部分工作，例如：\n\n1. 智能注册路由\n2. 智能识别页面入参声明\n\n\n\n## 5.3. 自定义组件跳转\n\n以上都是脚本层面的使用，小程序中还有 `wxml`, 我们希望能在有个组件快速使用：\n\n```html\n<Router path=\"/pageA\" query=\"{{pageAQuery}}\"></Router>\n<Router path=\"/pageB\" query=\"{{pageBQuery}}\" type=\"redirectTo\"></Router>\n<Router path=\"/pageC/katy\"></Router>\n```\n\n那么，实现一个自定义组件，然后把 **Router**模块包装一下，问题就不大了。\n\n\n\n示例代码：\n\n```html\n// components/router.wxml\n\n<view class=\"wxapp-router\" bind:tap=\"gotoPage\">\n    <slot />\n</view>\n```\n\n```typescript\n// components/router.ts\n\nComponent({\n    properties: {\n        path: String,\n        type: {\n            type: String,\n            value: 'gotoPage'\n        },\n        route: String,\n        query: Object,\n        delta: Number,\n        setData: Object,\n    },\n\n    methods: {\n        gotoPage(event) {\n            const router = getApp().router;\n            const { path, route, type, query} = this.data;\n            const toPath = route || path;\n\n            if (['gotoPage', 'navigateTo', 'switchTab', 'redirectTo'].includes(type)) {\n                (router as any)[type](toPath, query);\n            }\n\n            if (type === 'navigateBack') {\n                const { delta, setData } = this.data;\n                router.navigateBack({ delta }, { setData })\n            }\n        }\n    }\n})\n```\n\n\n\n\n\n# 6. 整体架构图\n\n最后，我们来整体回顾一下各模块的设计\n\n![架构设计](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202700.png)\n\n1. Navigator：封装微信原生路由 API，提供智能跳转策略。\n1. LandTransfer：提供落地页中转策略。\n1. RouteMatcher：提供动态路由参数匹配功能。\n1. Route: 为每个路径创建路由器。\n1. Router：整合内部各模块，对外提供优雅的调用方式。\n1. Logger：内部日志器。\n1. Path-to-regexp: 开源社区的路由匹配引擎。\n\n\n\n# 7. 最后的最后\n\n鉴于写过很多的实战类的文章，会有不少同学想要到整体的示例代码，这次我就索性写了一个工具，Enjoy it!\n\n[wxapp-router](https://github.com/JerryC8080/wxapp-router)： 🛵 The router for Wechat Miniprogram","source":"_posts/2021/wxapp-router-experience.md","raw":"---\ntitle: 微信小程序路由实战\ncategory: 搬砖码农\ndate: 2021-03-21 20:28:00\ntags: \n- 微信小程序\n---\n\n# 0. 目录\n\n- [1. 前言](#1-前言)\n- [2. 智能路由跳转 — Navigator 模块](#2-智能路由跳转--navigator-模块)\n- [3. 虚拟路由策略 — Router 模块](#3-虚拟路由策略--router-模块)\n- [4. 落地中转策略 — LandTransfer 模块](#4-落地中转策略--landtransfer-模块)\n  - [4.1. 对于要解决的第一个问题：统一的落地页](#41-对于要解决的第一个问题统一的落地页)\n  - [4.2. 对于第二个要解决的问题：短链参数](#42-对于第二个要解决的问题短链参数)\n  - [4.3. LandTransfer 模块设计](#43-landtransfer-模块设计)\n- [5. 更好的开发体验](#5-更好的开发体验)\n  - [5.1. Typescript + Router](#51-typescript--router)\n  - [5.2. 智能生成路由配置](#52-智能生成路由配置)\n  - [5.3. 自定义组件跳转](#53-自定义组件跳转)\n- [6. 整体架构图](#6-整体架构图)\n- [7. 最后的最后](#7-最后的最后)\n\n# 1. 前言\n\n在微信小程序由一个 `App()`实例，和众多`Page()`组成。而在小程序中所有页面的路由全部由框架进行管理，框架以栈的形式维护了所有页面，然后提供了以下 API 来进行路由之间的跳转：\n1. `wx.navigateTo`\n2. `wx.redirectTo`\n3. `wx.navigateBack`\n4. `wx.switchTab`\n5. `wx.reLaunch` \n\n但是，对于一个企业应用，把这些问题留给了开发者：\n\n1. 原生 API 使用了 `Callback` 的函数实现形式，与我们现代普遍的 `Promise` 和 `async/await` 存在 gap。\n2. 基于小程序路由的设计，暴露给外部的是真实路由（如扫码，公众号链接等方式），对后续项目重构留下历史包袱。\n3. 小程序页面栈最多十层， 在超过十层后 `wx.navigateTo` 失效，需要开发者判断使用 `wx.redirectTo` 或其他API\n4. 小程序页面栈存在一种特殊的页面：Tab 页面，需要使用 `wx.switchTab` 才能跳转。需要开发者主动判断，不方便后期改动 Tab 页面属性。\n5. 额外的，对于小程序码，要使用无数量限制 API [wxacode.getUnlimited](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html) ，存在参数长度限制32位以内。需要开发者自行解决。\n\n而本文，期望能对这若干问题，逐个提供解决方案。\n\n\n\n# 2. 智能路由跳转 — Navigator 模块\n\n在这里我们一起解决：\n\n1. 原生 API 非 Promsie\n2. 页面栈突破十层时特殊处理\n3. 特殊页面 Tab 的跳转处理\n\n我们的思路是，希望能设计一种逻辑，根据场景来自动判断使用哪个微信路由 API，然后对外只提供一个函数，例如：\n\n```javascript\ngotoPage('/pages/goods/index')\n```\n\n具体逻辑如下：\n\n1. 当跳转的路由为小程序 tab 页面时，则使用 `wx.switchTab`。\n2. 当页面栈达到 10 层之后，如果要跳转的页面在页面栈中，使用 `wx.navigateBack({ delta: X })` 出栈到目标页面。\n3. 当页面栈达到 10 层之后，目标页面不存在页面栈中，使用 `wx.redirectTo` 替换栈顶页面。\n4. 其他情况使用 `wx.navigateTo`\n\n顺带的，我们把这个函数以 Promise 形式实现，以及支持参数作为 `object`传入，例如：\n\n```javascript\ngotoPage('/pages/goods/index', { name: 'jc' }).then(...).catch(...);\n```\n\n大部分场景下，只要使用`gotoPage`就能满足。\n\n那肯定也会有特定的情况，需要显式的指定使用 `navigateTo/switchTab/redirectTo/navigateBack`的哪一个。\n\n那么我们也按照类似的实现，满足相同模式的 API\n\n```javascript\nnavigateTo('/pages/goods/index', { name: 'jc' }).then(...).catch(...);\nswitchTab('/pages/goods/index', { name: 'jc' }).then(...).catch(...);\nredirectTo('/pages/goods/index', { name: 'jc' }).then(...).catch(...);\nnavigateBack('/pages/goods/index', { name: 'jc' }).then(...).catch(...);\n```\n\n这些函数都可以内聚到同一个模块，我们称其为：**Navigator**\n\n```javascript\nconst navigator = new Navigator();\nnavigator.gotoPage(...);\nnavigator.navigateTo(...);\nnavigator.switchTab(...);\nnavigator.redirectTo(...);\nnavigator.navigateBack(...);\n```\n\n\n\n模块设计：\n\n![navigator-class](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202552.png)\n\n\n\n# 3. 虚拟路由策略 — Router 模块\n\n在这里，我们解决：\n\n1. 对外暴露了真实路由，导致历史包袱沉重的问题。\n\n在许多应用开发中，我们经常需要把某种模式匹配到的所有路由，全都映射到同个页面中去。  \n例如，我们有一个 Goods 页面，对于所有 ID 各不相同的商品，都要使用这个页面来承载。  \n\n![](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202632.png)\n\n\n\n那么在代码层面上，期望能实现这样的调用方式：\n\n```javascript\n// 创建路由实例\nconst router = new Router();\n\n// 注册路由\nrouter.register({\n  path: '/goods/:id', // 虚拟路由\n  route: '/pages/goods/index', // 真实路由\n});\n\n// 跳转到 /pages/goods/index，参数: onLoad(options) 的 options = { id: '123' }\nrouter.gotoPage('/goods/123');\n\n// 跳转到 /pages/goods/index，参数: onLoad(options) 的 options = { id: '456' }\nrouter.gotoPage('/goods/456');\n```\n\n**Class Router** 的核心逻辑是完成：\n\n1. 路由的注册，完成「虚拟路径」和「真实路径」关系的存储。\n2. 满足「虚拟路径」到「真实路径」的转换，并且识别「动态路径参数」（dynamic segment）。\n3. 路由跳转。\n\n对于「路由的注册」，我们在其内部存储一个 map 就能完成。\n\n而对于「路径的转换」， `vue-router` 有类似的实现，通过其源码发现，内部是使用  [path-to-regexp](https://github.com/pillarjs/path-to-regexp) 作为路径匹配引擎，我们可以拿来用之。\n\n然后对于「路由的跳转」，我们可以直接复用上面提到的 **Navigator** 模块，通过输入真实路径，来完成路由的跳转。\n\n\n\n模块设计：\n\n![route-class](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202636.png)\n\n\n\n其中：\n\n1. RouteMatcher：提供动态路由参数匹配功能，内部使用  [path-to-regexp](https://github.com/pillarjs/path-to-regexp) 作为路径匹配引擎。\n1. Route: 为每个路径创建路由器，存储每个路由的虚拟路径和真实路由的关系。\n1. Router：整合内部各模块，对外提供统一且优雅的调用方式。\n\n\n\n\n\n\n# 4. 落地中转策略 — LandTransfer 模块\n\n在这里，我们解决：\n\n1. 小程序扫码、公众号链接等场景下的落地页统一。\n2. 小程序码，对于无限量API [wxacode.getUnlimited](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html) ，突破参数32位长度限制。\n\n\n\n## 4.1. 对于要解决的第一个问题：统一的落地页\n\n我们把如：扫小程序码、公众号菜单、公众号文章等方式打开小程序某个页面的路径称为「外部路由」。\n\n根据小程序的设计，暴露给外部的连接是真实的页面路径，如：`/pages/home/index`，该设计在实践中存在的弊端：**各个落地页分散，后期修改真实文件路径难度大。**\n\n在 **「中长生命周期」** 产品中，随着产品的迭代，我们难免会遇到项目的重构。如果分发出去的都是没经过处理的真实路径的话，我们重构时就会束手束脚，要做很多的兼容操作。因为你不知道，分发出去的小程序二维码， 有多少被打印到实体物料中。\n\n那么，**「虚拟路由」+「落地中转」** 的策略就显得基本且重要了。\n\n「虚拟路由」的功能，**Router **模块给我们提供了支持了，我们还需要对外提供一个统一的落地页面，让它来完成对内部路由的中转。\n\n基本逻辑：\n\n1. 分发出去的真实路由，指向到唯一的落地页面，如：`$LAND_PAGE: /pages/land-page/index`\n2. 由这个落地页面，进行内部路由的重定向转发，通过接收 参数，如：`path=/user&name=jc&age=18`\n\n![普通模式](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210309185153.png)\n\n在代码层面上，我们希望能实现这样的使用：\n\n```typescript\n// /pages/land-page/index.ts\n\nconst landTransfer = new LandTransfer(landTransferOptions);\n\nPage({\n  onLoad(options) {\n      landTransfer\n        .run(options)\n        .then(() => {...})\n        .catch(() => {...});\n  }\n});\n```\n\n然后针对 TS，我们还可以使用装饰器版本，更加简便：\n\n```typescript\nimport { landTransferDecorator } from 'wxapp-router';\n\nPage({\n  @landTransferDecorator(landTransferOptions)\n  onLoad(options) {\n    // ...\n  },\n});\n```\n\n\n\n## 4.2. 对于第二个要解决的问题：短链参数\n\n微信小程序主要提供了两个接口去生成小程序码：\n\n1. [wxacode.get](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.get.html): 获取小程序码，适用于需要的码数量较少的业务场景。**通过该接口生成的小程序码，永久有效，数量限制为 100,000** 个\n2. [wxacode.getUnlimited](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html): 获取小程序码，适用于需要的码数量极多的业务场景。**通过该接口生成的小程序码，永久有效，数量暂无限制。**\n\n第一种方式，`wxacode.get` 数量限制为 10w 个，虽然量很大了，绝大多数的小程序可能用不到这个量。\n\n但如果我们运营的是一个中大型电商小程序的话，假如：1w 种商品 x 10 种商品规格，那就会超过这个数量。到时候再进行改造，就困难了。\n\n所以，如果抱着是运营一个 **「中长生命周期」** 的产品的话，我们会使用第二种方式：`wxacode.getUnlimited`\n\n不尽人意的是，虽然它没有数量限制，但是对参数会有 32 个字符的限制，显然是不够用的（一个 uuid 就 32 字符了）。\n\n对于这种情况，我们可以使用「短链参数」的形式解决，由于[wxacode.getUnlimited](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html) 会通过 `scene`字段作为 query 参数传递给小程序的，那么我们可以通过 `scene`参数来实现短链服务，这需要后端配合。\n\n前后端交互如下：\n\n![Scene短链模式](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210312182826.png)\n\n1. 当小程序需要生成小程序码的时候，请求后端提供的接口，例如：`/api/encodeShortParams`\n2. 后端把内容转换为 32 字符内的字符串，存储到数据库中。\n3. 后端通过 [wxacode.getUnlimited](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html) 接口，以短链字符串作为 `scene`的值，以商定好的统一落地页 `$LAND_PAGE`作为 `page`值，生成小程序码。\n4. 当通过小程序码进入小程序，小程序获取到 `scene`参数，请求后端提供的接口，例如：`/api/decodeShrotParams`\n5. 小程序理解内容，跳转到目标页面中去。\n\n\n\n而前端对于统一落地页的逻辑处理，我们只需要在第一个问题的基础上，增加一个**转换短链参数内容**的逻辑就行了：\n\n![短链模式](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210309185154.png)\n\n\n\n代码层面上，我们我们只需要多定义转换短链参数的方式：`convertScenePrams`\n\n```typescript\n// in /pages/land-page/index.js\nimport { landTransferDecorator } from 'wxapp-router';\n\nconst landTransferOptions = {\n  // 此处接收 onLoad(options) 中的 options.scene\n  convertSceneParams: (sceneParams) => {\n    return API.convertScene({ sceneParams }).then((content) => {\n      // 假如后端存的是 JSON 字符串，前端decode\n      // 要求 content = { path: '/home', a: 1, b:2 }\n      return JSON.parse(content);\n    });\n  },\n};\n\nPage({\n  @landTransferDecorator(landTransferOptions)\n  onLoad(options) {\n    // ...\n  },\n});\n```\n\n而其中的 `API.convertScene` 就对接服务端提供 HTTP 接口服务来完成。\n\n\n\n## 4.3. LandTransfer 模块设计\n\n![land-transfer](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202654.png)\n\n\n\n# 5. 更好的开发体验\n\n## 5.1. Typescript + Router\n\n对于小程序内部的路由跳转，我们除了指定一个字符串的路由，我们是否也可以通过链式调用，像调用函数那样去跳转页面呢？类似这样；\n\n```typescript\nroutes.pages.user.go({ name: 'jc' });\n```\n\n这样做的好处是：\n\n1. 更自然的调用方式。\n2. 能结合 TS，来做到类型提示和联想。\n\n由于事先 `wxapp-router` 并不知道开发者需要注册的路由是什么样的，所以路由的 TS 声明文件，需要开发者来定义。\n\n例如，我们在项目中维护一份路由文件：\n\n```typescript\n// config/routes.ts\n\n// 创建路由实例\nconst router = new Router();\n\nconst routesConfig = [{\n  path: '/user',\n  route: '/pages/user/index',\n}, {\n  path: '/goods',\n  route: '/pages/goods/index',\n}]；\n\ntype RoutesType {\n  paegs: {\n    user: Route<{name: string}>,\n    goods: Route,\n  }\n}\n\n// 注册路由\nrouter.batchRegister(routesConfig);\n\n// 获取 routes\nconst routes: RoutesType = router.getRoutes();\n\nexport default routes;\n```\n\n然后在别的地方使用它：\n\n```typescript\nimport routes from './routes.ts';\n\nroutes.pages.user.go({ name: 'jc' });\n```\n\n\n\n## 5.2. 智能生成路由配置\n\n如果路由变多的时候，我们还需要对每个路由手动去编写 `RoutesType` 的话，就有点难受了。\n\n在小程序中，我们把正式路由都配置到 `app.json` ，那么在遵循既定的项目结构情况下，我们可以通过自动构建，完成大部分工作，例如：\n\n1. 智能注册路由\n2. 智能识别页面入参声明\n\n\n\n## 5.3. 自定义组件跳转\n\n以上都是脚本层面的使用，小程序中还有 `wxml`, 我们希望能在有个组件快速使用：\n\n```html\n<Router path=\"/pageA\" query=\"{{pageAQuery}}\"></Router>\n<Router path=\"/pageB\" query=\"{{pageBQuery}}\" type=\"redirectTo\"></Router>\n<Router path=\"/pageC/katy\"></Router>\n```\n\n那么，实现一个自定义组件，然后把 **Router**模块包装一下，问题就不大了。\n\n\n\n示例代码：\n\n```html\n// components/router.wxml\n\n<view class=\"wxapp-router\" bind:tap=\"gotoPage\">\n    <slot />\n</view>\n```\n\n```typescript\n// components/router.ts\n\nComponent({\n    properties: {\n        path: String,\n        type: {\n            type: String,\n            value: 'gotoPage'\n        },\n        route: String,\n        query: Object,\n        delta: Number,\n        setData: Object,\n    },\n\n    methods: {\n        gotoPage(event) {\n            const router = getApp().router;\n            const { path, route, type, query} = this.data;\n            const toPath = route || path;\n\n            if (['gotoPage', 'navigateTo', 'switchTab', 'redirectTo'].includes(type)) {\n                (router as any)[type](toPath, query);\n            }\n\n            if (type === 'navigateBack') {\n                const { delta, setData } = this.data;\n                router.navigateBack({ delta }, { setData })\n            }\n        }\n    }\n})\n```\n\n\n\n\n\n# 6. 整体架构图\n\n最后，我们来整体回顾一下各模块的设计\n\n![架构设计](https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202700.png)\n\n1. Navigator：封装微信原生路由 API，提供智能跳转策略。\n1. LandTransfer：提供落地页中转策略。\n1. RouteMatcher：提供动态路由参数匹配功能。\n1. Route: 为每个路径创建路由器。\n1. Router：整合内部各模块，对外提供优雅的调用方式。\n1. Logger：内部日志器。\n1. Path-to-regexp: 开源社区的路由匹配引擎。\n\n\n\n# 7. 最后的最后\n\n鉴于写过很多的实战类的文章，会有不少同学想要到整体的示例代码，这次我就索性写了一个工具，Enjoy it!\n\n[wxapp-router](https://github.com/JerryC8080/wxapp-router)： 🛵 The router for Wechat Miniprogram","slug":"2021/wxapp-router-experience","published":1,"updated":"2021-11-16T01:59:22.376Z","_id":"cl271bse70003o1rl2wabgnsr","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"0-目录\"><a href=\"#0-目录\" class=\"headerlink\" title=\"0. 目录\"></a>0. 目录</h1><ul>\n<li><a href=\"#1-%E5%89%8D%E8%A8%80\">1. 前言</a></li>\n<li><a href=\"#2-%E6%99%BA%E8%83%BD%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC--navigator-%E6%A8%A1%E5%9D%97\">2. 智能路由跳转 — Navigator 模块</a></li>\n<li><a href=\"#3-%E8%99%9A%E6%8B%9F%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5--router-%E6%A8%A1%E5%9D%97\">3. 虚拟路由策略 — Router 模块</a></li>\n<li><a href=\"#4-%E8%90%BD%E5%9C%B0%E4%B8%AD%E8%BD%AC%E7%AD%96%E7%95%A5--landtransfer-%E6%A8%A1%E5%9D%97\">4. 落地中转策略 — LandTransfer 模块</a><ul>\n<li><a href=\"#41-%E5%AF%B9%E4%BA%8E%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E7%BB%9F%E4%B8%80%E7%9A%84%E8%90%BD%E5%9C%B0%E9%A1%B5\">4.1. 对于要解决的第一个问题：统一的落地页</a></li>\n<li><a href=\"#42-%E5%AF%B9%E4%BA%8E%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E7%9F%AD%E9%93%BE%E5%8F%82%E6%95%B0\">4.2. 对于第二个要解决的问题：短链参数</a></li>\n<li><a href=\"#43-landtransfer-%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1\">4.3. LandTransfer 模块设计</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C\">5. 更好的开发体验</a><ul>\n<li><a href=\"#51-typescript--router\">5.1. Typescript + Router</a></li>\n<li><a href=\"#52-%E6%99%BA%E8%83%BD%E7%94%9F%E6%88%90%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE\">5.2. 智能生成路由配置</a></li>\n<li><a href=\"#53-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E8%B7%B3%E8%BD%AC\">5.3. 自定义组件跳转</a></li>\n</ul>\n</li>\n<li><a href=\"#6-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE\">6. 整体架构图</a></li>\n<li><a href=\"#7-%E6%9C%80%E5%90%8E%E7%9A%84%E6%9C%80%E5%90%8E\">7. 最后的最后</a></li>\n</ul>\n<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>在微信小程序由一个 <code>App()</code>实例，和众多<code>Page()</code>组成。而在小程序中所有页面的路由全部由框架进行管理，框架以栈的形式维护了所有页面，然后提供了以下 API 来进行路由之间的跳转：</p>\n<ol>\n<li><code>wx.navigateTo</code></li>\n<li><code>wx.redirectTo</code></li>\n<li><code>wx.navigateBack</code></li>\n<li><code>wx.switchTab</code></li>\n<li><code>wx.reLaunch</code></li>\n</ol>\n<p>但是，对于一个企业应用，把这些问题留给了开发者：</p>\n<ol>\n<li>原生 API 使用了 <code>Callback</code> 的函数实现形式，与我们现代普遍的 <code>Promise</code> 和 <code>async/await</code> 存在 gap。</li>\n<li>基于小程序路由的设计，暴露给外部的是真实路由（如扫码，公众号链接等方式），对后续项目重构留下历史包袱。</li>\n<li>小程序页面栈最多十层， 在超过十层后 <code>wx.navigateTo</code> 失效，需要开发者判断使用 <code>wx.redirectTo</code> 或其他API</li>\n<li>小程序页面栈存在一种特殊的页面：Tab 页面，需要使用 <code>wx.switchTab</code> 才能跳转。需要开发者主动判断，不方便后期改动 Tab 页面属性。</li>\n<li>额外的，对于小程序码，要使用无数量限制 API <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html\">wxacode.getUnlimited</a> ，存在参数长度限制32位以内。需要开发者自行解决。</li>\n</ol>\n<p>而本文，期望能对这若干问题，逐个提供解决方案。</p>\n<h1 id=\"2-智能路由跳转-—-Navigator-模块\"><a href=\"#2-智能路由跳转-—-Navigator-模块\" class=\"headerlink\" title=\"2. 智能路由跳转 — Navigator 模块\"></a>2. 智能路由跳转 — Navigator 模块</h1><p>在这里我们一起解决：</p>\n<ol>\n<li>原生 API 非 Promsie</li>\n<li>页面栈突破十层时特殊处理</li>\n<li>特殊页面 Tab 的跳转处理</li>\n</ol>\n<p>我们的思路是，希望能设计一种逻辑，根据场景来自动判断使用哪个微信路由 API，然后对外只提供一个函数，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">gotoPage</span>(<span class=\"string\">&#x27;/pages/goods/index&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>具体逻辑如下：</p>\n<ol>\n<li>当跳转的路由为小程序 tab 页面时，则使用 <code>wx.switchTab</code>。</li>\n<li>当页面栈达到 10 层之后，如果要跳转的页面在页面栈中，使用 <code>wx.navigateBack(&#123; delta: X &#125;)</code> 出栈到目标页面。</li>\n<li>当页面栈达到 10 层之后，目标页面不存在页面栈中，使用 <code>wx.redirectTo</code> 替换栈顶页面。</li>\n<li>其他情况使用 <code>wx.navigateTo</code></li>\n</ol>\n<p>顺带的，我们把这个函数以 Promise 形式实现，以及支持参数作为 <code>object</code>传入，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">gotoPage</span>(<span class=\"string\">&#x27;/pages/goods/index&#x27;</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;).<span class=\"title function_\">then</span>(...).<span class=\"title function_\">catch</span>(...);</span><br></pre></td></tr></table></figure>\n\n<p>大部分场景下，只要使用<code>gotoPage</code>就能满足。</p>\n<p>那肯定也会有特定的情况，需要显式的指定使用 <code>navigateTo/switchTab/redirectTo/navigateBack</code>的哪一个。</p>\n<p>那么我们也按照类似的实现，满足相同模式的 API</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">navigateTo</span>(<span class=\"string\">&#x27;/pages/goods/index&#x27;</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;).<span class=\"title function_\">then</span>(...).<span class=\"title function_\">catch</span>(...);</span><br><span class=\"line\"><span class=\"title function_\">switchTab</span>(<span class=\"string\">&#x27;/pages/goods/index&#x27;</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;).<span class=\"title function_\">then</span>(...).<span class=\"title function_\">catch</span>(...);</span><br><span class=\"line\"><span class=\"title function_\">redirectTo</span>(<span class=\"string\">&#x27;/pages/goods/index&#x27;</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;).<span class=\"title function_\">then</span>(...).<span class=\"title function_\">catch</span>(...);</span><br><span class=\"line\"><span class=\"title function_\">navigateBack</span>(<span class=\"string\">&#x27;/pages/goods/index&#x27;</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;).<span class=\"title function_\">then</span>(...).<span class=\"title function_\">catch</span>(...);</span><br></pre></td></tr></table></figure>\n\n<p>这些函数都可以内聚到同一个模块，我们称其为：<strong>Navigator</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> navigator = <span class=\"keyword\">new</span> <span class=\"title class_\">Navigator</span>();</span><br><span class=\"line\">navigator.<span class=\"title function_\">gotoPage</span>(...);</span><br><span class=\"line\">navigator.<span class=\"title function_\">navigateTo</span>(...);</span><br><span class=\"line\">navigator.<span class=\"title function_\">switchTab</span>(...);</span><br><span class=\"line\">navigator.<span class=\"title function_\">redirectTo</span>(...);</span><br><span class=\"line\">navigator.<span class=\"title function_\">navigateBack</span>(...);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>模块设计：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202552.png\" alt=\"navigator-class\"></p>\n<h1 id=\"3-虚拟路由策略-—-Router-模块\"><a href=\"#3-虚拟路由策略-—-Router-模块\" class=\"headerlink\" title=\"3. 虚拟路由策略 — Router 模块\"></a>3. 虚拟路由策略 — Router 模块</h1><p>在这里，我们解决：</p>\n<ol>\n<li>对外暴露了真实路由，导致历史包袱沉重的问题。</li>\n</ol>\n<p>在许多应用开发中，我们经常需要把某种模式匹配到的所有路由，全都映射到同个页面中去。<br>例如，我们有一个 Goods 页面，对于所有 ID 各不相同的商品，都要使用这个页面来承载。  </p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202632.png\"></p>\n<p>那么在代码层面上，期望能实现这样的调用方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建路由实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册路由</span></span><br><span class=\"line\">router.<span class=\"title function_\">register</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/goods/:id&#x27;</span>, <span class=\"comment\">// 虚拟路由</span></span><br><span class=\"line\">  <span class=\"attr\">route</span>: <span class=\"string\">&#x27;/pages/goods/index&#x27;</span>, <span class=\"comment\">// 真实路由</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 跳转到 /pages/goods/index，参数: onLoad(options) 的 options = &#123; id: &#x27;123&#x27; &#125;</span></span><br><span class=\"line\">router.<span class=\"title function_\">gotoPage</span>(<span class=\"string\">&#x27;/goods/123&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 跳转到 /pages/goods/index，参数: onLoad(options) 的 options = &#123; id: &#x27;456&#x27; &#125;</span></span><br><span class=\"line\">router.<span class=\"title function_\">gotoPage</span>(<span class=\"string\">&#x27;/goods/456&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>Class Router</strong> 的核心逻辑是完成：</p>\n<ol>\n<li>路由的注册，完成「虚拟路径」和「真实路径」关系的存储。</li>\n<li>满足「虚拟路径」到「真实路径」的转换，并且识别「动态路径参数」（dynamic segment）。</li>\n<li>路由跳转。</li>\n</ol>\n<p>对于「路由的注册」，我们在其内部存储一个 map 就能完成。</p>\n<p>而对于「路径的转换」， <code>vue-router</code> 有类似的实现，通过其源码发现，内部是使用  <a href=\"https://github.com/pillarjs/path-to-regexp\">path-to-regexp</a> 作为路径匹配引擎，我们可以拿来用之。</p>\n<p>然后对于「路由的跳转」，我们可以直接复用上面提到的 <strong>Navigator</strong> 模块，通过输入真实路径，来完成路由的跳转。</p>\n<p>模块设计：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202636.png\" alt=\"route-class\"></p>\n<p>其中：</p>\n<ol>\n<li>RouteMatcher：提供动态路由参数匹配功能，内部使用  <a href=\"https://github.com/pillarjs/path-to-regexp\">path-to-regexp</a> 作为路径匹配引擎。</li>\n<li>Route: 为每个路径创建路由器，存储每个路由的虚拟路径和真实路由的关系。</li>\n<li>Router：整合内部各模块，对外提供统一且优雅的调用方式。</li>\n</ol>\n<h1 id=\"4-落地中转策略-—-LandTransfer-模块\"><a href=\"#4-落地中转策略-—-LandTransfer-模块\" class=\"headerlink\" title=\"4. 落地中转策略 — LandTransfer 模块\"></a>4. 落地中转策略 — LandTransfer 模块</h1><p>在这里，我们解决：</p>\n<ol>\n<li>小程序扫码、公众号链接等场景下的落地页统一。</li>\n<li>小程序码，对于无限量API <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html\">wxacode.getUnlimited</a> ，突破参数32位长度限制。</li>\n</ol>\n<h2 id=\"4-1-对于要解决的第一个问题：统一的落地页\"><a href=\"#4-1-对于要解决的第一个问题：统一的落地页\" class=\"headerlink\" title=\"4.1. 对于要解决的第一个问题：统一的落地页\"></a>4.1. 对于要解决的第一个问题：统一的落地页</h2><p>我们把如：扫小程序码、公众号菜单、公众号文章等方式打开小程序某个页面的路径称为「外部路由」。</p>\n<p>根据小程序的设计，暴露给外部的连接是真实的页面路径，如：<code>/pages/home/index</code>，该设计在实践中存在的弊端：<strong>各个落地页分散，后期修改真实文件路径难度大。</strong></p>\n<p>在 <strong>「中长生命周期」</strong> 产品中，随着产品的迭代，我们难免会遇到项目的重构。如果分发出去的都是没经过处理的真实路径的话，我们重构时就会束手束脚，要做很多的兼容操作。因为你不知道，分发出去的小程序二维码， 有多少被打印到实体物料中。</p>\n<p>那么，<strong>「虚拟路由」+「落地中转」</strong> 的策略就显得基本且重要了。</p>\n<p>「虚拟路由」的功能，**Router **模块给我们提供了支持了，我们还需要对外提供一个统一的落地页面，让它来完成对内部路由的中转。</p>\n<p>基本逻辑：</p>\n<ol>\n<li>分发出去的真实路由，指向到唯一的落地页面，如：<code>$LAND_PAGE: /pages/land-page/index</code></li>\n<li>由这个落地页面，进行内部路由的重定向转发，通过接收 参数，如：<code>path=/user&amp;name=jc&amp;age=18</code></li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210309185153.png\" alt=\"普通模式\"></p>\n<p>在代码层面上，我们希望能实现这样的使用：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /pages/land-page/index.ts</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> landTransfer = <span class=\"keyword\">new</span> <span class=\"title class_\">LandTransfer</span>(landTransferOptions);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Page</span>(&#123;</span><br><span class=\"line\">  <span class=\"title function_\">onLoad</span>(<span class=\"params\">options</span>) &#123;</span><br><span class=\"line\">      landTransfer</span><br><span class=\"line\">        .<span class=\"title function_\">run</span>(options)</span><br><span class=\"line\">        .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;...&#125;)</span><br><span class=\"line\">        .<span class=\"title function_\">catch</span>(<span class=\"function\">() =&gt;</span> &#123;...&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>然后针对 TS，我们还可以使用装饰器版本，更加简便：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; landTransferDecorator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;wxapp-router&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Page</span>(&#123;</span><br><span class=\"line\">  <span class=\"meta\">@landTransferDecorator</span>(landTransferOptions)</span><br><span class=\"line\">  <span class=\"title function_\">onLoad</span>(<span class=\"params\">options</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4-2-对于第二个要解决的问题：短链参数\"><a href=\"#4-2-对于第二个要解决的问题：短链参数\" class=\"headerlink\" title=\"4.2. 对于第二个要解决的问题：短链参数\"></a>4.2. 对于第二个要解决的问题：短链参数</h2><p>微信小程序主要提供了两个接口去生成小程序码：</p>\n<ol>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.get.html\">wxacode.get</a>: 获取小程序码，适用于需要的码数量较少的业务场景。<strong>通过该接口生成的小程序码，永久有效，数量限制为 100,000</strong> 个</li>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html\">wxacode.getUnlimited</a>: 获取小程序码，适用于需要的码数量极多的业务场景。<strong>通过该接口生成的小程序码，永久有效，数量暂无限制。</strong></li>\n</ol>\n<p>第一种方式，<code>wxacode.get</code> 数量限制为 10w 个，虽然量很大了，绝大多数的小程序可能用不到这个量。</p>\n<p>但如果我们运营的是一个中大型电商小程序的话，假如：1w 种商品 x 10 种商品规格，那就会超过这个数量。到时候再进行改造，就困难了。</p>\n<p>所以，如果抱着是运营一个 <strong>「中长生命周期」</strong> 的产品的话，我们会使用第二种方式：<code>wxacode.getUnlimited</code></p>\n<p>不尽人意的是，虽然它没有数量限制，但是对参数会有 32 个字符的限制，显然是不够用的（一个 uuid 就 32 字符了）。</p>\n<p>对于这种情况，我们可以使用「短链参数」的形式解决，由于<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html\">wxacode.getUnlimited</a> 会通过 <code>scene</code>字段作为 query 参数传递给小程序的，那么我们可以通过 <code>scene</code>参数来实现短链服务，这需要后端配合。</p>\n<p>前后端交互如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210312182826.png\" alt=\"Scene短链模式\"></p>\n<ol>\n<li>当小程序需要生成小程序码的时候，请求后端提供的接口，例如：<code>/api/encodeShortParams</code></li>\n<li>后端把内容转换为 32 字符内的字符串，存储到数据库中。</li>\n<li>后端通过 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html\">wxacode.getUnlimited</a> 接口，以短链字符串作为 <code>scene</code>的值，以商定好的统一落地页 <code>$LAND_PAGE</code>作为 <code>page</code>值，生成小程序码。</li>\n<li>当通过小程序码进入小程序，小程序获取到 <code>scene</code>参数，请求后端提供的接口，例如：<code>/api/decodeShrotParams</code></li>\n<li>小程序理解内容，跳转到目标页面中去。</li>\n</ol>\n<p>而前端对于统一落地页的逻辑处理，我们只需要在第一个问题的基础上，增加一个<strong>转换短链参数内容</strong>的逻辑就行了：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210309185154.png\" alt=\"短链模式\"></p>\n<p>代码层面上，我们我们只需要多定义转换短链参数的方式：<code>convertScenePrams</code></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in /pages/land-page/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; landTransferDecorator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;wxapp-router&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> landTransferOptions = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 此处接收 onLoad(options) 中的 options.scene</span></span><br><span class=\"line\">  <span class=\"attr\">convertSceneParams</span>: <span class=\"function\">(<span class=\"params\">sceneParams</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable constant_\">API</span>.<span class=\"title function_\">convertScene</span>(&#123; sceneParams &#125;).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">content</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 假如后端存的是 JSON 字符串，前端decode</span></span><br><span class=\"line\">      <span class=\"comment\">// 要求 content = &#123; path: &#x27;/home&#x27;, a: 1, b:2 &#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(content);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Page</span>(&#123;</span><br><span class=\"line\">  <span class=\"meta\">@landTransferDecorator</span>(landTransferOptions)</span><br><span class=\"line\">  <span class=\"title function_\">onLoad</span>(<span class=\"params\">options</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>而其中的 <code>API.convertScene</code> 就对接服务端提供 HTTP 接口服务来完成。</p>\n<h2 id=\"4-3-LandTransfer-模块设计\"><a href=\"#4-3-LandTransfer-模块设计\" class=\"headerlink\" title=\"4.3. LandTransfer 模块设计\"></a>4.3. LandTransfer 模块设计</h2><p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202654.png\" alt=\"land-transfer\"></p>\n<h1 id=\"5-更好的开发体验\"><a href=\"#5-更好的开发体验\" class=\"headerlink\" title=\"5. 更好的开发体验\"></a>5. 更好的开发体验</h1><h2 id=\"5-1-Typescript-Router\"><a href=\"#5-1-Typescript-Router\" class=\"headerlink\" title=\"5.1. Typescript + Router\"></a>5.1. Typescript + Router</h2><p>对于小程序内部的路由跳转，我们除了指定一个字符串的路由，我们是否也可以通过链式调用，像调用函数那样去跳转页面呢？类似这样；</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">routes.<span class=\"property\">pages</span>.<span class=\"property\">user</span>.<span class=\"title function_\">go</span>(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这样做的好处是：</p>\n<ol>\n<li>更自然的调用方式。</li>\n<li>能结合 TS，来做到类型提示和联想。</li>\n</ol>\n<p>由于事先 <code>wxapp-router</code> 并不知道开发者需要注册的路由是什么样的，所以路由的 TS 声明文件，需要开发者来定义。</p>\n<p>例如，我们在项目中维护一份路由文件：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config/routes.ts</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建路由实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> routesConfig = [&#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/user&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">route</span>: <span class=\"string\">&#x27;/pages/user/index&#x27;</span>,</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/goods&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">route</span>: <span class=\"string\">&#x27;/pages/goods/index&#x27;</span>,</span><br><span class=\"line\">&#125;]；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">RoutesType</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">paegs</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">user</span>: <span class=\"title class_\">Route</span>&lt;&#123;<span class=\"attr\">name</span>: <span class=\"built_in\">string</span>&#125;&gt;,</span><br><span class=\"line\">    <span class=\"attr\">goods</span>: <span class=\"title class_\">Route</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册路由</span></span><br><span class=\"line\">router.<span class=\"title function_\">batchRegister</span>(routesConfig);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取 routes</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">routes</span>: <span class=\"title class_\">RoutesType</span> = router.<span class=\"title function_\">getRoutes</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> routes;</span><br></pre></td></tr></table></figure>\n\n<p>然后在别的地方使用它：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> routes <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./routes.ts&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">routes.<span class=\"property\">pages</span>.<span class=\"property\">user</span>.<span class=\"title function_\">go</span>(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"5-2-智能生成路由配置\"><a href=\"#5-2-智能生成路由配置\" class=\"headerlink\" title=\"5.2. 智能生成路由配置\"></a>5.2. 智能生成路由配置</h2><p>如果路由变多的时候，我们还需要对每个路由手动去编写 <code>RoutesType</code> 的话，就有点难受了。</p>\n<p>在小程序中，我们把正式路由都配置到 <code>app.json</code> ，那么在遵循既定的项目结构情况下，我们可以通过自动构建，完成大部分工作，例如：</p>\n<ol>\n<li>智能注册路由</li>\n<li>智能识别页面入参声明</li>\n</ol>\n<h2 id=\"5-3-自定义组件跳转\"><a href=\"#5-3-自定义组件跳转\" class=\"headerlink\" title=\"5.3. 自定义组件跳转\"></a>5.3. 自定义组件跳转</h2><p>以上都是脚本层面的使用，小程序中还有 <code>wxml</code>, 我们希望能在有个组件快速使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/pageA&quot;</span> <span class=\"attr\">query</span>=<span class=\"string\">&quot;&#123;&#123;pageAQuery&#125;&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/pageB&quot;</span> <span class=\"attr\">query</span>=<span class=\"string\">&quot;&#123;&#123;pageBQuery&#125;&#125;&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;redirectTo&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/pageC/katy&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>那么，实现一个自定义组件，然后把 <strong>Router</strong>模块包装一下，问题就不大了。</p>\n<p>示例代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// components/router.wxml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wxapp-router&quot;</span> <span class=\"attr\">bind:tap</span>=<span class=\"string\">&quot;gotoPage&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// components/router.ts</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Component</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">properties</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">path</span>: <span class=\"title class_\">String</span>,</span><br><span class=\"line\">        <span class=\"attr\">type</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"title class_\">String</span>,</span><br><span class=\"line\">            <span class=\"attr\">value</span>: <span class=\"string\">&#x27;gotoPage&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">route</span>: <span class=\"title class_\">String</span>,</span><br><span class=\"line\">        <span class=\"attr\">query</span>: <span class=\"title class_\">Object</span>,</span><br><span class=\"line\">        <span class=\"attr\">delta</span>: <span class=\"title class_\">Number</span>,</span><br><span class=\"line\">        <span class=\"attr\">setData</span>: <span class=\"title class_\">Object</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"title function_\">gotoPage</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> router = <span class=\"title function_\">getApp</span>().<span class=\"property\">router</span>;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123; path, route, <span class=\"keyword\">type</span>, query&#125; = <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> toPath = route || path;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ([<span class=\"string\">&#x27;gotoPage&#x27;</span>, <span class=\"string\">&#x27;navigateTo&#x27;</span>, <span class=\"string\">&#x27;switchTab&#x27;</span>, <span class=\"string\">&#x27;redirectTo&#x27;</span>].<span class=\"title function_\">includes</span>(<span class=\"keyword\">type</span>)) &#123;</span><br><span class=\"line\">                (router <span class=\"keyword\">as</span> <span class=\"built_in\">any</span>)[<span class=\"keyword\">type</span>](toPath, query);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">type</span> === <span class=\"string\">&#x27;navigateBack&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> &#123; delta, setData &#125; = <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>;</span><br><span class=\"line\">                router.<span class=\"title function_\">navigateBack</span>(&#123; delta &#125;, &#123; setData &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"6-整体架构图\"><a href=\"#6-整体架构图\" class=\"headerlink\" title=\"6. 整体架构图\"></a>6. 整体架构图</h1><p>最后，我们来整体回顾一下各模块的设计</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202700.png\" alt=\"架构设计\"></p>\n<ol>\n<li>Navigator：封装微信原生路由 API，提供智能跳转策略。</li>\n<li>LandTransfer：提供落地页中转策略。</li>\n<li>RouteMatcher：提供动态路由参数匹配功能。</li>\n<li>Route: 为每个路径创建路由器。</li>\n<li>Router：整合内部各模块，对外提供优雅的调用方式。</li>\n<li>Logger：内部日志器。</li>\n<li>Path-to-regexp: 开源社区的路由匹配引擎。</li>\n</ol>\n<h1 id=\"7-最后的最后\"><a href=\"#7-最后的最后\" class=\"headerlink\" title=\"7. 最后的最后\"></a>7. 最后的最后</h1><p>鉴于写过很多的实战类的文章，会有不少同学想要到整体的示例代码，这次我就索性写了一个工具，Enjoy it!</p>\n<p><a href=\"https://github.com/JerryC8080/wxapp-router\">wxapp-router</a>： 🛵 The router for Wechat Miniprogram</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0-目录\"><a href=\"#0-目录\" class=\"headerlink\" title=\"0. 目录\"></a>0. 目录</h1><ul>\n<li><a href=\"#1-%E5%89%8D%E8%A8%80\">1. 前言</a></li>\n<li><a href=\"#2-%E6%99%BA%E8%83%BD%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC--navigator-%E6%A8%A1%E5%9D%97\">2. 智能路由跳转 — Navigator 模块</a></li>\n<li><a href=\"#3-%E8%99%9A%E6%8B%9F%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5--router-%E6%A8%A1%E5%9D%97\">3. 虚拟路由策略 — Router 模块</a></li>\n<li><a href=\"#4-%E8%90%BD%E5%9C%B0%E4%B8%AD%E8%BD%AC%E7%AD%96%E7%95%A5--landtransfer-%E6%A8%A1%E5%9D%97\">4. 落地中转策略 — LandTransfer 模块</a><ul>\n<li><a href=\"#41-%E5%AF%B9%E4%BA%8E%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E7%BB%9F%E4%B8%80%E7%9A%84%E8%90%BD%E5%9C%B0%E9%A1%B5\">4.1. 对于要解决的第一个问题：统一的落地页</a></li>\n<li><a href=\"#42-%E5%AF%B9%E4%BA%8E%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E7%9F%AD%E9%93%BE%E5%8F%82%E6%95%B0\">4.2. 对于第二个要解决的问题：短链参数</a></li>\n<li><a href=\"#43-landtransfer-%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1\">4.3. LandTransfer 模块设计</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C\">5. 更好的开发体验</a><ul>\n<li><a href=\"#51-typescript--router\">5.1. Typescript + Router</a></li>\n<li><a href=\"#52-%E6%99%BA%E8%83%BD%E7%94%9F%E6%88%90%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE\">5.2. 智能生成路由配置</a></li>\n<li><a href=\"#53-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E8%B7%B3%E8%BD%AC\">5.3. 自定义组件跳转</a></li>\n</ul>\n</li>\n<li><a href=\"#6-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE\">6. 整体架构图</a></li>\n<li><a href=\"#7-%E6%9C%80%E5%90%8E%E7%9A%84%E6%9C%80%E5%90%8E\">7. 最后的最后</a></li>\n</ul>\n<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>在微信小程序由一个 <code>App()</code>实例，和众多<code>Page()</code>组成。而在小程序中所有页面的路由全部由框架进行管理，框架以栈的形式维护了所有页面，然后提供了以下 API 来进行路由之间的跳转：</p>\n<ol>\n<li><code>wx.navigateTo</code></li>\n<li><code>wx.redirectTo</code></li>\n<li><code>wx.navigateBack</code></li>\n<li><code>wx.switchTab</code></li>\n<li><code>wx.reLaunch</code></li>\n</ol>\n<p>但是，对于一个企业应用，把这些问题留给了开发者：</p>\n<ol>\n<li>原生 API 使用了 <code>Callback</code> 的函数实现形式，与我们现代普遍的 <code>Promise</code> 和 <code>async/await</code> 存在 gap。</li>\n<li>基于小程序路由的设计，暴露给外部的是真实路由（如扫码，公众号链接等方式），对后续项目重构留下历史包袱。</li>\n<li>小程序页面栈最多十层， 在超过十层后 <code>wx.navigateTo</code> 失效，需要开发者判断使用 <code>wx.redirectTo</code> 或其他API</li>\n<li>小程序页面栈存在一种特殊的页面：Tab 页面，需要使用 <code>wx.switchTab</code> 才能跳转。需要开发者主动判断，不方便后期改动 Tab 页面属性。</li>\n<li>额外的，对于小程序码，要使用无数量限制 API <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html\">wxacode.getUnlimited</a> ，存在参数长度限制32位以内。需要开发者自行解决。</li>\n</ol>\n<p>而本文，期望能对这若干问题，逐个提供解决方案。</p>\n<h1 id=\"2-智能路由跳转-—-Navigator-模块\"><a href=\"#2-智能路由跳转-—-Navigator-模块\" class=\"headerlink\" title=\"2. 智能路由跳转 — Navigator 模块\"></a>2. 智能路由跳转 — Navigator 模块</h1><p>在这里我们一起解决：</p>\n<ol>\n<li>原生 API 非 Promsie</li>\n<li>页面栈突破十层时特殊处理</li>\n<li>特殊页面 Tab 的跳转处理</li>\n</ol>\n<p>我们的思路是，希望能设计一种逻辑，根据场景来自动判断使用哪个微信路由 API，然后对外只提供一个函数，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">gotoPage</span>(<span class=\"string\">&#x27;/pages/goods/index&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>具体逻辑如下：</p>\n<ol>\n<li>当跳转的路由为小程序 tab 页面时，则使用 <code>wx.switchTab</code>。</li>\n<li>当页面栈达到 10 层之后，如果要跳转的页面在页面栈中，使用 <code>wx.navigateBack(&#123; delta: X &#125;)</code> 出栈到目标页面。</li>\n<li>当页面栈达到 10 层之后，目标页面不存在页面栈中，使用 <code>wx.redirectTo</code> 替换栈顶页面。</li>\n<li>其他情况使用 <code>wx.navigateTo</code></li>\n</ol>\n<p>顺带的，我们把这个函数以 Promise 形式实现，以及支持参数作为 <code>object</code>传入，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">gotoPage</span>(<span class=\"string\">&#x27;/pages/goods/index&#x27;</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;).<span class=\"title function_\">then</span>(...).<span class=\"title function_\">catch</span>(...);</span><br></pre></td></tr></table></figure>\n\n<p>大部分场景下，只要使用<code>gotoPage</code>就能满足。</p>\n<p>那肯定也会有特定的情况，需要显式的指定使用 <code>navigateTo/switchTab/redirectTo/navigateBack</code>的哪一个。</p>\n<p>那么我们也按照类似的实现，满足相同模式的 API</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">navigateTo</span>(<span class=\"string\">&#x27;/pages/goods/index&#x27;</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;).<span class=\"title function_\">then</span>(...).<span class=\"title function_\">catch</span>(...);</span><br><span class=\"line\"><span class=\"title function_\">switchTab</span>(<span class=\"string\">&#x27;/pages/goods/index&#x27;</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;).<span class=\"title function_\">then</span>(...).<span class=\"title function_\">catch</span>(...);</span><br><span class=\"line\"><span class=\"title function_\">redirectTo</span>(<span class=\"string\">&#x27;/pages/goods/index&#x27;</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;).<span class=\"title function_\">then</span>(...).<span class=\"title function_\">catch</span>(...);</span><br><span class=\"line\"><span class=\"title function_\">navigateBack</span>(<span class=\"string\">&#x27;/pages/goods/index&#x27;</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;).<span class=\"title function_\">then</span>(...).<span class=\"title function_\">catch</span>(...);</span><br></pre></td></tr></table></figure>\n\n<p>这些函数都可以内聚到同一个模块，我们称其为：<strong>Navigator</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> navigator = <span class=\"keyword\">new</span> <span class=\"title class_\">Navigator</span>();</span><br><span class=\"line\">navigator.<span class=\"title function_\">gotoPage</span>(...);</span><br><span class=\"line\">navigator.<span class=\"title function_\">navigateTo</span>(...);</span><br><span class=\"line\">navigator.<span class=\"title function_\">switchTab</span>(...);</span><br><span class=\"line\">navigator.<span class=\"title function_\">redirectTo</span>(...);</span><br><span class=\"line\">navigator.<span class=\"title function_\">navigateBack</span>(...);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>模块设计：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202552.png\" alt=\"navigator-class\"></p>\n<h1 id=\"3-虚拟路由策略-—-Router-模块\"><a href=\"#3-虚拟路由策略-—-Router-模块\" class=\"headerlink\" title=\"3. 虚拟路由策略 — Router 模块\"></a>3. 虚拟路由策略 — Router 模块</h1><p>在这里，我们解决：</p>\n<ol>\n<li>对外暴露了真实路由，导致历史包袱沉重的问题。</li>\n</ol>\n<p>在许多应用开发中，我们经常需要把某种模式匹配到的所有路由，全都映射到同个页面中去。<br>例如，我们有一个 Goods 页面，对于所有 ID 各不相同的商品，都要使用这个页面来承载。  </p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202632.png\"></p>\n<p>那么在代码层面上，期望能实现这样的调用方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建路由实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册路由</span></span><br><span class=\"line\">router.<span class=\"title function_\">register</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/goods/:id&#x27;</span>, <span class=\"comment\">// 虚拟路由</span></span><br><span class=\"line\">  <span class=\"attr\">route</span>: <span class=\"string\">&#x27;/pages/goods/index&#x27;</span>, <span class=\"comment\">// 真实路由</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 跳转到 /pages/goods/index，参数: onLoad(options) 的 options = &#123; id: &#x27;123&#x27; &#125;</span></span><br><span class=\"line\">router.<span class=\"title function_\">gotoPage</span>(<span class=\"string\">&#x27;/goods/123&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 跳转到 /pages/goods/index，参数: onLoad(options) 的 options = &#123; id: &#x27;456&#x27; &#125;</span></span><br><span class=\"line\">router.<span class=\"title function_\">gotoPage</span>(<span class=\"string\">&#x27;/goods/456&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>Class Router</strong> 的核心逻辑是完成：</p>\n<ol>\n<li>路由的注册，完成「虚拟路径」和「真实路径」关系的存储。</li>\n<li>满足「虚拟路径」到「真实路径」的转换，并且识别「动态路径参数」（dynamic segment）。</li>\n<li>路由跳转。</li>\n</ol>\n<p>对于「路由的注册」，我们在其内部存储一个 map 就能完成。</p>\n<p>而对于「路径的转换」， <code>vue-router</code> 有类似的实现，通过其源码发现，内部是使用  <a href=\"https://github.com/pillarjs/path-to-regexp\">path-to-regexp</a> 作为路径匹配引擎，我们可以拿来用之。</p>\n<p>然后对于「路由的跳转」，我们可以直接复用上面提到的 <strong>Navigator</strong> 模块，通过输入真实路径，来完成路由的跳转。</p>\n<p>模块设计：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202636.png\" alt=\"route-class\"></p>\n<p>其中：</p>\n<ol>\n<li>RouteMatcher：提供动态路由参数匹配功能，内部使用  <a href=\"https://github.com/pillarjs/path-to-regexp\">path-to-regexp</a> 作为路径匹配引擎。</li>\n<li>Route: 为每个路径创建路由器，存储每个路由的虚拟路径和真实路由的关系。</li>\n<li>Router：整合内部各模块，对外提供统一且优雅的调用方式。</li>\n</ol>\n<h1 id=\"4-落地中转策略-—-LandTransfer-模块\"><a href=\"#4-落地中转策略-—-LandTransfer-模块\" class=\"headerlink\" title=\"4. 落地中转策略 — LandTransfer 模块\"></a>4. 落地中转策略 — LandTransfer 模块</h1><p>在这里，我们解决：</p>\n<ol>\n<li>小程序扫码、公众号链接等场景下的落地页统一。</li>\n<li>小程序码，对于无限量API <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html\">wxacode.getUnlimited</a> ，突破参数32位长度限制。</li>\n</ol>\n<h2 id=\"4-1-对于要解决的第一个问题：统一的落地页\"><a href=\"#4-1-对于要解决的第一个问题：统一的落地页\" class=\"headerlink\" title=\"4.1. 对于要解决的第一个问题：统一的落地页\"></a>4.1. 对于要解决的第一个问题：统一的落地页</h2><p>我们把如：扫小程序码、公众号菜单、公众号文章等方式打开小程序某个页面的路径称为「外部路由」。</p>\n<p>根据小程序的设计，暴露给外部的连接是真实的页面路径，如：<code>/pages/home/index</code>，该设计在实践中存在的弊端：<strong>各个落地页分散，后期修改真实文件路径难度大。</strong></p>\n<p>在 <strong>「中长生命周期」</strong> 产品中，随着产品的迭代，我们难免会遇到项目的重构。如果分发出去的都是没经过处理的真实路径的话，我们重构时就会束手束脚，要做很多的兼容操作。因为你不知道，分发出去的小程序二维码， 有多少被打印到实体物料中。</p>\n<p>那么，<strong>「虚拟路由」+「落地中转」</strong> 的策略就显得基本且重要了。</p>\n<p>「虚拟路由」的功能，**Router **模块给我们提供了支持了，我们还需要对外提供一个统一的落地页面，让它来完成对内部路由的中转。</p>\n<p>基本逻辑：</p>\n<ol>\n<li>分发出去的真实路由，指向到唯一的落地页面，如：<code>$LAND_PAGE: /pages/land-page/index</code></li>\n<li>由这个落地页面，进行内部路由的重定向转发，通过接收 参数，如：<code>path=/user&amp;name=jc&amp;age=18</code></li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210309185153.png\" alt=\"普通模式\"></p>\n<p>在代码层面上，我们希望能实现这样的使用：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /pages/land-page/index.ts</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> landTransfer = <span class=\"keyword\">new</span> <span class=\"title class_\">LandTransfer</span>(landTransferOptions);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Page</span>(&#123;</span><br><span class=\"line\">  <span class=\"title function_\">onLoad</span>(<span class=\"params\">options</span>) &#123;</span><br><span class=\"line\">      landTransfer</span><br><span class=\"line\">        .<span class=\"title function_\">run</span>(options)</span><br><span class=\"line\">        .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;...&#125;)</span><br><span class=\"line\">        .<span class=\"title function_\">catch</span>(<span class=\"function\">() =&gt;</span> &#123;...&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>然后针对 TS，我们还可以使用装饰器版本，更加简便：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; landTransferDecorator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;wxapp-router&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Page</span>(&#123;</span><br><span class=\"line\">  <span class=\"meta\">@landTransferDecorator</span>(landTransferOptions)</span><br><span class=\"line\">  <span class=\"title function_\">onLoad</span>(<span class=\"params\">options</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4-2-对于第二个要解决的问题：短链参数\"><a href=\"#4-2-对于第二个要解决的问题：短链参数\" class=\"headerlink\" title=\"4.2. 对于第二个要解决的问题：短链参数\"></a>4.2. 对于第二个要解决的问题：短链参数</h2><p>微信小程序主要提供了两个接口去生成小程序码：</p>\n<ol>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.get.html\">wxacode.get</a>: 获取小程序码，适用于需要的码数量较少的业务场景。<strong>通过该接口生成的小程序码，永久有效，数量限制为 100,000</strong> 个</li>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html\">wxacode.getUnlimited</a>: 获取小程序码，适用于需要的码数量极多的业务场景。<strong>通过该接口生成的小程序码，永久有效，数量暂无限制。</strong></li>\n</ol>\n<p>第一种方式，<code>wxacode.get</code> 数量限制为 10w 个，虽然量很大了，绝大多数的小程序可能用不到这个量。</p>\n<p>但如果我们运营的是一个中大型电商小程序的话，假如：1w 种商品 x 10 种商品规格，那就会超过这个数量。到时候再进行改造，就困难了。</p>\n<p>所以，如果抱着是运营一个 <strong>「中长生命周期」</strong> 的产品的话，我们会使用第二种方式：<code>wxacode.getUnlimited</code></p>\n<p>不尽人意的是，虽然它没有数量限制，但是对参数会有 32 个字符的限制，显然是不够用的（一个 uuid 就 32 字符了）。</p>\n<p>对于这种情况，我们可以使用「短链参数」的形式解决，由于<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html\">wxacode.getUnlimited</a> 会通过 <code>scene</code>字段作为 query 参数传递给小程序的，那么我们可以通过 <code>scene</code>参数来实现短链服务，这需要后端配合。</p>\n<p>前后端交互如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210312182826.png\" alt=\"Scene短链模式\"></p>\n<ol>\n<li>当小程序需要生成小程序码的时候，请求后端提供的接口，例如：<code>/api/encodeShortParams</code></li>\n<li>后端把内容转换为 32 字符内的字符串，存储到数据库中。</li>\n<li>后端通过 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html\">wxacode.getUnlimited</a> 接口，以短链字符串作为 <code>scene</code>的值，以商定好的统一落地页 <code>$LAND_PAGE</code>作为 <code>page</code>值，生成小程序码。</li>\n<li>当通过小程序码进入小程序，小程序获取到 <code>scene</code>参数，请求后端提供的接口，例如：<code>/api/decodeShrotParams</code></li>\n<li>小程序理解内容，跳转到目标页面中去。</li>\n</ol>\n<p>而前端对于统一落地页的逻辑处理，我们只需要在第一个问题的基础上，增加一个<strong>转换短链参数内容</strong>的逻辑就行了：</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210309185154.png\" alt=\"短链模式\"></p>\n<p>代码层面上，我们我们只需要多定义转换短链参数的方式：<code>convertScenePrams</code></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in /pages/land-page/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; landTransferDecorator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;wxapp-router&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> landTransferOptions = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 此处接收 onLoad(options) 中的 options.scene</span></span><br><span class=\"line\">  <span class=\"attr\">convertSceneParams</span>: <span class=\"function\">(<span class=\"params\">sceneParams</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable constant_\">API</span>.<span class=\"title function_\">convertScene</span>(&#123; sceneParams &#125;).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">content</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 假如后端存的是 JSON 字符串，前端decode</span></span><br><span class=\"line\">      <span class=\"comment\">// 要求 content = &#123; path: &#x27;/home&#x27;, a: 1, b:2 &#125;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(content);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Page</span>(&#123;</span><br><span class=\"line\">  <span class=\"meta\">@landTransferDecorator</span>(landTransferOptions)</span><br><span class=\"line\">  <span class=\"title function_\">onLoad</span>(<span class=\"params\">options</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>而其中的 <code>API.convertScene</code> 就对接服务端提供 HTTP 接口服务来完成。</p>\n<h2 id=\"4-3-LandTransfer-模块设计\"><a href=\"#4-3-LandTransfer-模块设计\" class=\"headerlink\" title=\"4.3. LandTransfer 模块设计\"></a>4.3. LandTransfer 模块设计</h2><p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202654.png\" alt=\"land-transfer\"></p>\n<h1 id=\"5-更好的开发体验\"><a href=\"#5-更好的开发体验\" class=\"headerlink\" title=\"5. 更好的开发体验\"></a>5. 更好的开发体验</h1><h2 id=\"5-1-Typescript-Router\"><a href=\"#5-1-Typescript-Router\" class=\"headerlink\" title=\"5.1. Typescript + Router\"></a>5.1. Typescript + Router</h2><p>对于小程序内部的路由跳转，我们除了指定一个字符串的路由，我们是否也可以通过链式调用，像调用函数那样去跳转页面呢？类似这样；</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">routes.<span class=\"property\">pages</span>.<span class=\"property\">user</span>.<span class=\"title function_\">go</span>(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这样做的好处是：</p>\n<ol>\n<li>更自然的调用方式。</li>\n<li>能结合 TS，来做到类型提示和联想。</li>\n</ol>\n<p>由于事先 <code>wxapp-router</code> 并不知道开发者需要注册的路由是什么样的，所以路由的 TS 声明文件，需要开发者来定义。</p>\n<p>例如，我们在项目中维护一份路由文件：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config/routes.ts</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建路由实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> routesConfig = [&#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/user&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">route</span>: <span class=\"string\">&#x27;/pages/user/index&#x27;</span>,</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/goods&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">route</span>: <span class=\"string\">&#x27;/pages/goods/index&#x27;</span>,</span><br><span class=\"line\">&#125;]；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">RoutesType</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">paegs</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">user</span>: <span class=\"title class_\">Route</span>&lt;&#123;<span class=\"attr\">name</span>: <span class=\"built_in\">string</span>&#125;&gt;,</span><br><span class=\"line\">    <span class=\"attr\">goods</span>: <span class=\"title class_\">Route</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册路由</span></span><br><span class=\"line\">router.<span class=\"title function_\">batchRegister</span>(routesConfig);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取 routes</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">routes</span>: <span class=\"title class_\">RoutesType</span> = router.<span class=\"title function_\">getRoutes</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> routes;</span><br></pre></td></tr></table></figure>\n\n<p>然后在别的地方使用它：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> routes <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./routes.ts&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">routes.<span class=\"property\">pages</span>.<span class=\"property\">user</span>.<span class=\"title function_\">go</span>(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jc&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"5-2-智能生成路由配置\"><a href=\"#5-2-智能生成路由配置\" class=\"headerlink\" title=\"5.2. 智能生成路由配置\"></a>5.2. 智能生成路由配置</h2><p>如果路由变多的时候，我们还需要对每个路由手动去编写 <code>RoutesType</code> 的话，就有点难受了。</p>\n<p>在小程序中，我们把正式路由都配置到 <code>app.json</code> ，那么在遵循既定的项目结构情况下，我们可以通过自动构建，完成大部分工作，例如：</p>\n<ol>\n<li>智能注册路由</li>\n<li>智能识别页面入参声明</li>\n</ol>\n<h2 id=\"5-3-自定义组件跳转\"><a href=\"#5-3-自定义组件跳转\" class=\"headerlink\" title=\"5.3. 自定义组件跳转\"></a>5.3. 自定义组件跳转</h2><p>以上都是脚本层面的使用，小程序中还有 <code>wxml</code>, 我们希望能在有个组件快速使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/pageA&quot;</span> <span class=\"attr\">query</span>=<span class=\"string\">&quot;&#123;&#123;pageAQuery&#125;&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/pageB&quot;</span> <span class=\"attr\">query</span>=<span class=\"string\">&quot;&#123;&#123;pageBQuery&#125;&#125;&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;redirectTo&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/pageC/katy&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>那么，实现一个自定义组件，然后把 <strong>Router</strong>模块包装一下，问题就不大了。</p>\n<p>示例代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// components/router.wxml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wxapp-router&quot;</span> <span class=\"attr\">bind:tap</span>=<span class=\"string\">&quot;gotoPage&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// components/router.ts</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Component</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">properties</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">path</span>: <span class=\"title class_\">String</span>,</span><br><span class=\"line\">        <span class=\"attr\">type</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"title class_\">String</span>,</span><br><span class=\"line\">            <span class=\"attr\">value</span>: <span class=\"string\">&#x27;gotoPage&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">route</span>: <span class=\"title class_\">String</span>,</span><br><span class=\"line\">        <span class=\"attr\">query</span>: <span class=\"title class_\">Object</span>,</span><br><span class=\"line\">        <span class=\"attr\">delta</span>: <span class=\"title class_\">Number</span>,</span><br><span class=\"line\">        <span class=\"attr\">setData</span>: <span class=\"title class_\">Object</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"title function_\">gotoPage</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> router = <span class=\"title function_\">getApp</span>().<span class=\"property\">router</span>;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123; path, route, <span class=\"keyword\">type</span>, query&#125; = <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> toPath = route || path;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ([<span class=\"string\">&#x27;gotoPage&#x27;</span>, <span class=\"string\">&#x27;navigateTo&#x27;</span>, <span class=\"string\">&#x27;switchTab&#x27;</span>, <span class=\"string\">&#x27;redirectTo&#x27;</span>].<span class=\"title function_\">includes</span>(<span class=\"keyword\">type</span>)) &#123;</span><br><span class=\"line\">                (router <span class=\"keyword\">as</span> <span class=\"built_in\">any</span>)[<span class=\"keyword\">type</span>](toPath, query);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">type</span> === <span class=\"string\">&#x27;navigateBack&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> &#123; delta, setData &#125; = <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>;</span><br><span class=\"line\">                router.<span class=\"title function_\">navigateBack</span>(&#123; delta &#125;, &#123; setData &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"6-整体架构图\"><a href=\"#6-整体架构图\" class=\"headerlink\" title=\"6. 整体架构图\"></a>6. 整体架构图</h1><p>最后，我们来整体回顾一下各模块的设计</p>\n<p><img src=\"https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202700.png\" alt=\"架构设计\"></p>\n<ol>\n<li>Navigator：封装微信原生路由 API，提供智能跳转策略。</li>\n<li>LandTransfer：提供落地页中转策略。</li>\n<li>RouteMatcher：提供动态路由参数匹配功能。</li>\n<li>Route: 为每个路径创建路由器。</li>\n<li>Router：整合内部各模块，对外提供优雅的调用方式。</li>\n<li>Logger：内部日志器。</li>\n<li>Path-to-regexp: 开源社区的路由匹配引擎。</li>\n</ol>\n<h1 id=\"7-最后的最后\"><a href=\"#7-最后的最后\" class=\"headerlink\" title=\"7. 最后的最后\"></a>7. 最后的最后</h1><p>鉴于写过很多的实战类的文章，会有不少同学想要到整体的示例代码，这次我就索性写了一个工具，Enjoy it!</p>\n<p><a href=\"https://github.com/JerryC8080/wxapp-router\">wxapp-router</a>： 🛵 The router for Wechat Miniprogram</p>\n"},{"title":"ServiceWorker 缓存与 HTTP 缓存","date":"2022-04-20T17:43:04.000Z","_content":"\n虽然 ServiceWorker 和 PWA 正在成为现代 Web 应用程序的标准，但浏览器资源缓存变得比以往任何时候都复杂。    \n本文涵盖了浏览器缓存的重点内容，具体包括：\n1. ServiceWorker 缓存与 HTTP 缓存的优先级？\n2. 主流浏览器实现的 MemoryCache 和 DiskCache 在哪一层？\n3. MemoryCache、DiskCache、ServiceWorker 缓存哪个速度更快？\n\n## 缓存流程概述\n\n我们先来看标准定义的资源请求遵循的顺序：\n\n![缓存流](https://web-dev.imgix.net/image/admin/vtKWC9Bg9dAMzoFKTeAM.png?auto=format)\n\n1. **ServiceWorker 缓存**：ServiceWorker 检查资源是否存在其缓存中，并根据其编程的缓存策略决定是否返回资源。这个操作不会自动发生，需要在注册的 ServiceWorker 中定义 `fetch` 事件去拦截并处理网络请求，这样才能命中 ServiceWorker 缓存而不是网络或者 HTTP 缓存。\n2. **HTTP 缓存**：这里就是我们常常说的「强缓存」和「协商缓存」，如果 HTTP 缓存未过期的话，浏览器就会使用 HTTP 缓存的资源。\n3. **服务器端**：如果 ServiceWorker 缓存或者 HTTP 缓存中未找到任何资源，则浏览器会向网络请求资源。这里就会涉及到 CDN 服务或者源服务的工作了。\n\n这是标准定义的资源请求流程，但是有追求的浏览器还会在 ServiceWorker 上面加一层 **「内存缓存层」** ，以 Chrome 为例，我们请求一个资源，除去网络，会有三种浏览器缓存返回：\n\n![image-20220420193610795](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204201936867.png)\n\n**那么 MemoryCache 和 DiskCache 与 ServiceWorker Cache 的优先级是怎么样的呢？**    \n下面我们讲讲三者的区别。\n\n## MemoryCache、DiskCache 在缓存流程的哪一层？\n\n我们以 Chrome 为例，MemoryCache 作为第一公民，位于 ServiceWorker 之上。    \n也就是命中了 MemoryCache，就不会触发 ServiceWorker 的 fetch 事件。    \n而 DiskCache 则位于原来的 HTTP 缓存层：\n\n![http-cache-priority.drawio](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421014504.png)\n\nMemoryCache 的存在会导致一个问题： **ServiceWorker 并不总是对资源有着控制权。**\n这会另我们本来期望的情况会变得复杂且不可预知。可惜的是 MemoryCache 并不在 W3C 的标准中，W3C 从 2016 年到现在仍然在讨论着这个事情，看来短时间这个问题是得不到解决了。\n\n> 一些正在讨论的话题：\n>\n> 1. [safari fetches from memory cache instead of Service worker ](https://github.com/w3c/ServiceWorker/issues/1510)\n> 2. [Difference between disk and memory cache](https://github.com/w3c/ServiceWorker/issues/1174)\n> 3. [Advanced Questions About Service Worker](https://github.com/jakearchibald/idb/issues/171)\n> 4. [allow service worker produced resources to be marked as \"cachable\"](https://github.com/w3c/ServiceWorker/issues/962)\n\n**我们真的没有办法么？**\n\n要是我们遇到业务场景，确实对 ServiceWorker 资源控制权有很强的的要求，我们还是可以做点事情的。    \nMemoryCache 是受控于 **「强缓存」** 的，这意味着我们可以在 ServiceWorker 拦截资源的响应，并设置资源响应头来使资源从 MemoryCache 失效：\n\n```\ncache-control: max-age=0\n```\n\n```typescript\nself.addEventListener(\"fetch\", (event) => {\n  event.respondWith(\n    (async function () {\n      // 从 HTTP 缓存或者网络获取资源\n      const res =  fetch(event.request);\n      \n      // 因为 Response 是一个流，只能用一次，所以这里要 clone 一下。\n      const newRes = res.clone();\n      \n      // 改写资源响应头\n\t\t\treturn new Response(res.body, { ...newRes, headers: {\n        'cache-control': 'max-age=0'\n      }});\n    })();\n  );\n});\n```\n\n需要注意的是，这种方法是以牺牲少量加载性能为前提的。这取决于我们实际场景中是性能优先，还是离线优先，或者其他什么情况优先。\n\n## MemoryCache、DiskCache、ServiceWorker 缓存哪个速度更快？\n\n![image-20220420203359745](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204202034325.png)\n\n我们再看一下同一个资源三种缓存的加载速度和优先级：\n1. 加载速度：MemoryCache > **DiskCache > ServiceWorker**\n2. 优先级：MemoryCache > **ServiceWorker> DiskCache**\n\nMemoryCache 优先级在 ServiceWorker 前面，这个没问题。    \n**但是速度更慢的 ServiceWorker 优先级比速度更快的 DiskCache 更高？**    \n**那盘下来，ServiceWorker 岂不是减慢了站点的加载速度？**\n\n## 对照实验\n\n为了研究这个问题，我做了一组对照实验。    \n实验只在 Chrome 进行，chrome devtool 为每个资源提供时间。所有加载资源的信息都可以作为 HAR 文件下载下来，然后编写本地脚本进行信息提取和分析。\n\n![image-20220421001201494](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421001210.png)\n\n**实验条件**\n\n1. 同一个环境：Chrome97 / MacOS 10.14 / Wifi\n2. 同一张图片的多次并发加载：\n   1. 3 张 133KB 图片 10 次实验\n   2. 10 张 133KB 图片 10 次实验\n   3. 100 张 133KB 图片 10 次实验\n3. 观察两个性能：\n   1. DiskCache 缓存性能表现\n   2. ServiceWorker 缓存速度表现\n\n### 实验一：3 张 133KB 图片并发\n\n![image-20220421013805667](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421013900.png)\n\n首先是并发请求 3 张图片进行 10 次实验，取平均数据，然后分别观察 DiskCache、ServiceWorker Cache 的性能表现。\n\n观察：\n1. DiskCache：我们发现下载操作并没有花太多时间，但是资源在等待排队。\n2. ServiceWorker Cache：更多耗时在下载。\n\n结论：但尽管如此，这种情况下， **DiskCache 依然是比 ServiceWorker Cache 更快。**\n\n\n\n### 实验二：3 张 133KB 图片 10 次实验\n\n![image-20220421013924399](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421013928.png)\n\n当我把并发图片增加到 10 张，这种情况可能会更加接近于实际情况，站点中可能会拥有更多的不同的资源（JS文件、字体、样式、图像等），因为某些网站可能会在一个页面存在超过 10 个资源。\n\n观察：\n1. DiskCache：从第二个资源开始排队时间依然很长，但是下载时间是基本不变的。\n2. ServiceWorker Cache： 排队并不是问题，但等待是。\n\n结论：这种情况下， **DiskCache 会略逊于 ServiceWorker Cache。**\n\n\n\n### 实验三：3 张 133KB 图片 100 次实验\n\n![image-20220421014006376](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421014007.png)\n\n当我把并发图片增加到 100 张，这种情况几乎是不真实的情况，但是我好奇为什么 DiskCache 为什么在第一次试验中比 ServiceWorker Cache 更快。\n\n观察：\n1. DiskCache：排队依然是问题，且随着并发数成线性上升。我们甚至能看到浏览器是如何加载图片的，一次并发大概 6 张图片。\n2. ServiceWorker Cache：虽然等待时间随着并发数上升，但是是平缓的。\n\n结论： **大并发下 ServiceWorker Cache 比 DiskCache 更快。**\n\n\n那 DiskCache 和 ServiceWorker 怎么选择？\n**小孩子才做选择，大人都要**\n\n由于 ServiceWorker 的优先级在 DiskCache 之上，我们可以在 ServiceWorker 进行 **「资源竞速」**，同一时间请求 ServiceWorker Cache 和 DiskCache，哪个先返回就把资源返回上一层。代码可能是这样的：\n\n```typescript\nself.addEventListener(\"fetch\", (event) => {\n  event.respondWith(\n    (async function () {\n      const res = Promise.race([\n        // 请求 ServiceWorker Cache\n        cache.open(CACHE_NAME).then(cache => cache.match(event.request)),\n        // 请求 DiskCache 或者网络资源\n        fetch(event.request)\n      ])\n    })();\n  );\n});\n```\n\n\n\n### 实验四：资源竞速之后，并发请求 3 张图片、10 张图片 和 100 张图片\n\n当我们进行资源竞速之后，这种情况下，无论是并发少量资源还是大量资源，都能达到最快的级别。\n\n![image-20220421014045092](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421014505.png)\n![image-20220421005715401](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421005723.png)\n\n# 总结\n\n本篇我们搞懂了 ServiceCache、MemoryCache、DiskCache 的优先级。    \n然后深入对比了 ServiceWorker Cache 和 DiskCache 的性能表现。    \n在少量资源并发的时候，DiskCache 更快，在大量资源并发的时候，ServiceWorker 更快。    \n最后通过「资源竞速」的方式来兼顾两种情况。    \n但是，在某些时候，我们比较 ServiceWorker 和 HTTP 缓存有点不公平。    \nServiceWorker 的用途会更加广泛，它提供了更细力度的缓存控制、使离线化应用得以实现、并且对比主线程，他能够使用更多的 CacheAPI 容量。\n\n\n","source":"_posts/2022/http-cache-vs-service-worker-cache.md","raw":"---\ntitle: ServiceWorker 缓存与 HTTP 缓存\ncategory: 搬砖码农\ndate: 2022-04-21 01:43:04\ntags: \n- PWA\n---\n\n虽然 ServiceWorker 和 PWA 正在成为现代 Web 应用程序的标准，但浏览器资源缓存变得比以往任何时候都复杂。    \n本文涵盖了浏览器缓存的重点内容，具体包括：\n1. ServiceWorker 缓存与 HTTP 缓存的优先级？\n2. 主流浏览器实现的 MemoryCache 和 DiskCache 在哪一层？\n3. MemoryCache、DiskCache、ServiceWorker 缓存哪个速度更快？\n\n## 缓存流程概述\n\n我们先来看标准定义的资源请求遵循的顺序：\n\n![缓存流](https://web-dev.imgix.net/image/admin/vtKWC9Bg9dAMzoFKTeAM.png?auto=format)\n\n1. **ServiceWorker 缓存**：ServiceWorker 检查资源是否存在其缓存中，并根据其编程的缓存策略决定是否返回资源。这个操作不会自动发生，需要在注册的 ServiceWorker 中定义 `fetch` 事件去拦截并处理网络请求，这样才能命中 ServiceWorker 缓存而不是网络或者 HTTP 缓存。\n2. **HTTP 缓存**：这里就是我们常常说的「强缓存」和「协商缓存」，如果 HTTP 缓存未过期的话，浏览器就会使用 HTTP 缓存的资源。\n3. **服务器端**：如果 ServiceWorker 缓存或者 HTTP 缓存中未找到任何资源，则浏览器会向网络请求资源。这里就会涉及到 CDN 服务或者源服务的工作了。\n\n这是标准定义的资源请求流程，但是有追求的浏览器还会在 ServiceWorker 上面加一层 **「内存缓存层」** ，以 Chrome 为例，我们请求一个资源，除去网络，会有三种浏览器缓存返回：\n\n![image-20220420193610795](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204201936867.png)\n\n**那么 MemoryCache 和 DiskCache 与 ServiceWorker Cache 的优先级是怎么样的呢？**    \n下面我们讲讲三者的区别。\n\n## MemoryCache、DiskCache 在缓存流程的哪一层？\n\n我们以 Chrome 为例，MemoryCache 作为第一公民，位于 ServiceWorker 之上。    \n也就是命中了 MemoryCache，就不会触发 ServiceWorker 的 fetch 事件。    \n而 DiskCache 则位于原来的 HTTP 缓存层：\n\n![http-cache-priority.drawio](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421014504.png)\n\nMemoryCache 的存在会导致一个问题： **ServiceWorker 并不总是对资源有着控制权。**\n这会另我们本来期望的情况会变得复杂且不可预知。可惜的是 MemoryCache 并不在 W3C 的标准中，W3C 从 2016 年到现在仍然在讨论着这个事情，看来短时间这个问题是得不到解决了。\n\n> 一些正在讨论的话题：\n>\n> 1. [safari fetches from memory cache instead of Service worker ](https://github.com/w3c/ServiceWorker/issues/1510)\n> 2. [Difference between disk and memory cache](https://github.com/w3c/ServiceWorker/issues/1174)\n> 3. [Advanced Questions About Service Worker](https://github.com/jakearchibald/idb/issues/171)\n> 4. [allow service worker produced resources to be marked as \"cachable\"](https://github.com/w3c/ServiceWorker/issues/962)\n\n**我们真的没有办法么？**\n\n要是我们遇到业务场景，确实对 ServiceWorker 资源控制权有很强的的要求，我们还是可以做点事情的。    \nMemoryCache 是受控于 **「强缓存」** 的，这意味着我们可以在 ServiceWorker 拦截资源的响应，并设置资源响应头来使资源从 MemoryCache 失效：\n\n```\ncache-control: max-age=0\n```\n\n```typescript\nself.addEventListener(\"fetch\", (event) => {\n  event.respondWith(\n    (async function () {\n      // 从 HTTP 缓存或者网络获取资源\n      const res =  fetch(event.request);\n      \n      // 因为 Response 是一个流，只能用一次，所以这里要 clone 一下。\n      const newRes = res.clone();\n      \n      // 改写资源响应头\n\t\t\treturn new Response(res.body, { ...newRes, headers: {\n        'cache-control': 'max-age=0'\n      }});\n    })();\n  );\n});\n```\n\n需要注意的是，这种方法是以牺牲少量加载性能为前提的。这取决于我们实际场景中是性能优先，还是离线优先，或者其他什么情况优先。\n\n## MemoryCache、DiskCache、ServiceWorker 缓存哪个速度更快？\n\n![image-20220420203359745](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204202034325.png)\n\n我们再看一下同一个资源三种缓存的加载速度和优先级：\n1. 加载速度：MemoryCache > **DiskCache > ServiceWorker**\n2. 优先级：MemoryCache > **ServiceWorker> DiskCache**\n\nMemoryCache 优先级在 ServiceWorker 前面，这个没问题。    \n**但是速度更慢的 ServiceWorker 优先级比速度更快的 DiskCache 更高？**    \n**那盘下来，ServiceWorker 岂不是减慢了站点的加载速度？**\n\n## 对照实验\n\n为了研究这个问题，我做了一组对照实验。    \n实验只在 Chrome 进行，chrome devtool 为每个资源提供时间。所有加载资源的信息都可以作为 HAR 文件下载下来，然后编写本地脚本进行信息提取和分析。\n\n![image-20220421001201494](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421001210.png)\n\n**实验条件**\n\n1. 同一个环境：Chrome97 / MacOS 10.14 / Wifi\n2. 同一张图片的多次并发加载：\n   1. 3 张 133KB 图片 10 次实验\n   2. 10 张 133KB 图片 10 次实验\n   3. 100 张 133KB 图片 10 次实验\n3. 观察两个性能：\n   1. DiskCache 缓存性能表现\n   2. ServiceWorker 缓存速度表现\n\n### 实验一：3 张 133KB 图片并发\n\n![image-20220421013805667](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421013900.png)\n\n首先是并发请求 3 张图片进行 10 次实验，取平均数据，然后分别观察 DiskCache、ServiceWorker Cache 的性能表现。\n\n观察：\n1. DiskCache：我们发现下载操作并没有花太多时间，但是资源在等待排队。\n2. ServiceWorker Cache：更多耗时在下载。\n\n结论：但尽管如此，这种情况下， **DiskCache 依然是比 ServiceWorker Cache 更快。**\n\n\n\n### 实验二：3 张 133KB 图片 10 次实验\n\n![image-20220421013924399](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421013928.png)\n\n当我把并发图片增加到 10 张，这种情况可能会更加接近于实际情况，站点中可能会拥有更多的不同的资源（JS文件、字体、样式、图像等），因为某些网站可能会在一个页面存在超过 10 个资源。\n\n观察：\n1. DiskCache：从第二个资源开始排队时间依然很长，但是下载时间是基本不变的。\n2. ServiceWorker Cache： 排队并不是问题，但等待是。\n\n结论：这种情况下， **DiskCache 会略逊于 ServiceWorker Cache。**\n\n\n\n### 实验三：3 张 133KB 图片 100 次实验\n\n![image-20220421014006376](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421014007.png)\n\n当我把并发图片增加到 100 张，这种情况几乎是不真实的情况，但是我好奇为什么 DiskCache 为什么在第一次试验中比 ServiceWorker Cache 更快。\n\n观察：\n1. DiskCache：排队依然是问题，且随着并发数成线性上升。我们甚至能看到浏览器是如何加载图片的，一次并发大概 6 张图片。\n2. ServiceWorker Cache：虽然等待时间随着并发数上升，但是是平缓的。\n\n结论： **大并发下 ServiceWorker Cache 比 DiskCache 更快。**\n\n\n那 DiskCache 和 ServiceWorker 怎么选择？\n**小孩子才做选择，大人都要**\n\n由于 ServiceWorker 的优先级在 DiskCache 之上，我们可以在 ServiceWorker 进行 **「资源竞速」**，同一时间请求 ServiceWorker Cache 和 DiskCache，哪个先返回就把资源返回上一层。代码可能是这样的：\n\n```typescript\nself.addEventListener(\"fetch\", (event) => {\n  event.respondWith(\n    (async function () {\n      const res = Promise.race([\n        // 请求 ServiceWorker Cache\n        cache.open(CACHE_NAME).then(cache => cache.match(event.request)),\n        // 请求 DiskCache 或者网络资源\n        fetch(event.request)\n      ])\n    })();\n  );\n});\n```\n\n\n\n### 实验四：资源竞速之后，并发请求 3 张图片、10 张图片 和 100 张图片\n\n当我们进行资源竞速之后，这种情况下，无论是并发少量资源还是大量资源，都能达到最快的级别。\n\n![image-20220421014045092](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421014505.png)\n![image-20220421005715401](https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421005723.png)\n\n# 总结\n\n本篇我们搞懂了 ServiceCache、MemoryCache、DiskCache 的优先级。    \n然后深入对比了 ServiceWorker Cache 和 DiskCache 的性能表现。    \n在少量资源并发的时候，DiskCache 更快，在大量资源并发的时候，ServiceWorker 更快。    \n最后通过「资源竞速」的方式来兼顾两种情况。    \n但是，在某些时候，我们比较 ServiceWorker 和 HTTP 缓存有点不公平。    \nServiceWorker 的用途会更加广泛，它提供了更细力度的缓存控制、使离线化应用得以实现、并且对比主线程，他能够使用更多的 CacheAPI 容量。\n\n\n","slug":"2022/http-cache-vs-service-worker-cache","published":1,"updated":"2022-04-20T17:52:03.960Z","_id":"cl27v6app0000ewv5m8zl986r","comments":1,"layout":"post","photos":[],"link":"","content":"<p>虽然 ServiceWorker 和 PWA 正在成为现代 Web 应用程序的标准，但浏览器资源缓存变得比以往任何时候都复杂。<br>本文涵盖了浏览器缓存的重点内容，具体包括：</p>\n<ol>\n<li>ServiceWorker 缓存与 HTTP 缓存的优先级？</li>\n<li>主流浏览器实现的 MemoryCache 和 DiskCache 在哪一层？</li>\n<li>MemoryCache、DiskCache、ServiceWorker 缓存哪个速度更快？</li>\n</ol>\n<h2 id=\"缓存流程概述\"><a href=\"#缓存流程概述\" class=\"headerlink\" title=\"缓存流程概述\"></a>缓存流程概述</h2><p>我们先来看标准定义的资源请求遵循的顺序：</p>\n<p><img src=\"https://web-dev.imgix.net/image/admin/vtKWC9Bg9dAMzoFKTeAM.png?auto=format\" alt=\"缓存流\"></p>\n<ol>\n<li><strong>ServiceWorker 缓存</strong>：ServiceWorker 检查资源是否存在其缓存中，并根据其编程的缓存策略决定是否返回资源。这个操作不会自动发生，需要在注册的 ServiceWorker 中定义 <code>fetch</code> 事件去拦截并处理网络请求，这样才能命中 ServiceWorker 缓存而不是网络或者 HTTP 缓存。</li>\n<li><strong>HTTP 缓存</strong>：这里就是我们常常说的「强缓存」和「协商缓存」，如果 HTTP 缓存未过期的话，浏览器就会使用 HTTP 缓存的资源。</li>\n<li><strong>服务器端</strong>：如果 ServiceWorker 缓存或者 HTTP 缓存中未找到任何资源，则浏览器会向网络请求资源。这里就会涉及到 CDN 服务或者源服务的工作了。</li>\n</ol>\n<p>这是标准定义的资源请求流程，但是有追求的浏览器还会在 ServiceWorker 上面加一层 <strong>「内存缓存层」</strong> ，以 Chrome 为例，我们请求一个资源，除去网络，会有三种浏览器缓存返回：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204201936867.png\" alt=\"image-20220420193610795\"></p>\n<p><strong>那么 MemoryCache 和 DiskCache 与 ServiceWorker Cache 的优先级是怎么样的呢？</strong><br>下面我们讲讲三者的区别。</p>\n<h2 id=\"MemoryCache、DiskCache-在缓存流程的哪一层？\"><a href=\"#MemoryCache、DiskCache-在缓存流程的哪一层？\" class=\"headerlink\" title=\"MemoryCache、DiskCache 在缓存流程的哪一层？\"></a>MemoryCache、DiskCache 在缓存流程的哪一层？</h2><p>我们以 Chrome 为例，MemoryCache 作为第一公民，位于 ServiceWorker 之上。<br>也就是命中了 MemoryCache，就不会触发 ServiceWorker 的 fetch 事件。<br>而 DiskCache 则位于原来的 HTTP 缓存层：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421014504.png\" alt=\"http-cache-priority.drawio\"></p>\n<p>MemoryCache 的存在会导致一个问题： <strong>ServiceWorker 并不总是对资源有着控制权。</strong><br>这会另我们本来期望的情况会变得复杂且不可预知。可惜的是 MemoryCache 并不在 W3C 的标准中，W3C 从 2016 年到现在仍然在讨论着这个事情，看来短时间这个问题是得不到解决了。</p>\n<blockquote>\n<p>一些正在讨论的话题：</p>\n<ol>\n<li><a href=\"https://github.com/w3c/ServiceWorker/issues/1510\" target=\"_blank\" rel=\"external\">safari fetches from memory cache instead of Service worker </a></li>\n<li><a href=\"https://github.com/w3c/ServiceWorker/issues/1174\" target=\"_blank\" rel=\"external\">Difference between disk and memory cache</a></li>\n<li><a href=\"https://github.com/jakearchibald/idb/issues/171\" target=\"_blank\" rel=\"external\">Advanced Questions About Service Worker</a></li>\n<li><a href=\"https://github.com/w3c/ServiceWorker/issues/962\" target=\"_blank\" rel=\"external\">allow service worker produced resources to be marked as “cachable”</a></li>\n</ol>\n</blockquote>\n<p><strong>我们真的没有办法么？</strong></p>\n<p>要是我们遇到业务场景，确实对 ServiceWorker 资源控制权有很强的的要求，我们还是可以做点事情的。<br>MemoryCache 是受控于 <strong>「强缓存」</strong> 的，这意味着我们可以在 ServiceWorker 拦截资源的响应，并设置资源响应头来使资源从 MemoryCache 失效：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cache-control: max-age=0</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">\"fetch\"</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  event.respondWith(</span><br><span class=\"line\">    (<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 从 HTTP 缓存或者网络获取资源</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> res =  fetch(event.request);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 因为 Response 是一个流，只能用一次，所以这里要 clone 一下。</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> newRes = res.clone();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 改写资源响应头</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response(res.body, &#123; ...newRes, headers: &#123;</span><br><span class=\"line\">        <span class=\"string\">'cache-control'</span>: <span class=\"string\">'max-age=0'</span></span><br><span class=\"line\">      &#125;&#125;);</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，这种方法是以牺牲少量加载性能为前提的。这取决于我们实际场景中是性能优先，还是离线优先，或者其他什么情况优先。</p>\n<h2 id=\"MemoryCache、DiskCache、ServiceWorker-缓存哪个速度更快？\"><a href=\"#MemoryCache、DiskCache、ServiceWorker-缓存哪个速度更快？\" class=\"headerlink\" title=\"MemoryCache、DiskCache、ServiceWorker 缓存哪个速度更快？\"></a>MemoryCache、DiskCache、ServiceWorker 缓存哪个速度更快？</h2><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204202034325.png\" alt=\"image-20220420203359745\"></p>\n<p>我们再看一下同一个资源三种缓存的加载速度和优先级：</p>\n<ol>\n<li>加载速度：MemoryCache &gt; <strong>DiskCache &gt; ServiceWorker</strong></li>\n<li>优先级：MemoryCache &gt; <strong>ServiceWorker&gt; DiskCache</strong></li>\n</ol>\n<p>MemoryCache 优先级在 ServiceWorker 前面，这个没问题。<br><strong>但是速度更慢的 ServiceWorker 优先级比速度更快的 DiskCache 更高？</strong><br><strong>那盘下来，ServiceWorker 岂不是减慢了站点的加载速度？</strong></p>\n<h2 id=\"对照实验\"><a href=\"#对照实验\" class=\"headerlink\" title=\"对照实验\"></a>对照实验</h2><p>为了研究这个问题，我做了一组对照实验。<br>实验只在 Chrome 进行，chrome devtool 为每个资源提供时间。所有加载资源的信息都可以作为 HAR 文件下载下来，然后编写本地脚本进行信息提取和分析。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421001210.png\" alt=\"image-20220421001201494\"></p>\n<p><strong>实验条件</strong></p>\n<ol>\n<li>同一个环境：Chrome97 / MacOS 10.14 / Wifi</li>\n<li>同一张图片的多次并发加载：<ol>\n<li>3 张 133KB 图片 10 次实验</li>\n<li>10 张 133KB 图片 10 次实验</li>\n<li>100 张 133KB 图片 10 次实验</li>\n</ol>\n</li>\n<li>观察两个性能：<ol>\n<li>DiskCache 缓存性能表现</li>\n<li>ServiceWorker 缓存速度表现</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"实验一：3-张-133KB-图片并发\"><a href=\"#实验一：3-张-133KB-图片并发\" class=\"headerlink\" title=\"实验一：3 张 133KB 图片并发\"></a>实验一：3 张 133KB 图片并发</h3><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421013900.png\" alt=\"image-20220421013805667\"></p>\n<p>首先是并发请求 3 张图片进行 10 次实验，取平均数据，然后分别观察 DiskCache、ServiceWorker Cache 的性能表现。</p>\n<p>观察：</p>\n<ol>\n<li>DiskCache：我们发现下载操作并没有花太多时间，但是资源在等待排队。</li>\n<li>ServiceWorker Cache：更多耗时在下载。</li>\n</ol>\n<p>结论：但尽管如此，这种情况下， <strong>DiskCache 依然是比 ServiceWorker Cache 更快。</strong></p>\n<h3 id=\"实验二：3-张-133KB-图片-10-次实验\"><a href=\"#实验二：3-张-133KB-图片-10-次实验\" class=\"headerlink\" title=\"实验二：3 张 133KB 图片 10 次实验\"></a>实验二：3 张 133KB 图片 10 次实验</h3><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421013928.png\" alt=\"image-20220421013924399\"></p>\n<p>当我把并发图片增加到 10 张，这种情况可能会更加接近于实际情况，站点中可能会拥有更多的不同的资源（JS文件、字体、样式、图像等），因为某些网站可能会在一个页面存在超过 10 个资源。</p>\n<p>观察：</p>\n<ol>\n<li>DiskCache：从第二个资源开始排队时间依然很长，但是下载时间是基本不变的。</li>\n<li>ServiceWorker Cache： 排队并不是问题，但等待是。</li>\n</ol>\n<p>结论：这种情况下， <strong>DiskCache 会略逊于 ServiceWorker Cache。</strong></p>\n<h3 id=\"实验三：3-张-133KB-图片-100-次实验\"><a href=\"#实验三：3-张-133KB-图片-100-次实验\" class=\"headerlink\" title=\"实验三：3 张 133KB 图片 100 次实验\"></a>实验三：3 张 133KB 图片 100 次实验</h3><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421014007.png\" alt=\"image-20220421014006376\"></p>\n<p>当我把并发图片增加到 100 张，这种情况几乎是不真实的情况，但是我好奇为什么 DiskCache 为什么在第一次试验中比 ServiceWorker Cache 更快。</p>\n<p>观察：</p>\n<ol>\n<li>DiskCache：排队依然是问题，且随着并发数成线性上升。我们甚至能看到浏览器是如何加载图片的，一次并发大概 6 张图片。</li>\n<li>ServiceWorker Cache：虽然等待时间随着并发数上升，但是是平缓的。</li>\n</ol>\n<p>结论： <strong>大并发下 ServiceWorker Cache 比 DiskCache 更快。</strong></p>\n<p>那 DiskCache 和 ServiceWorker 怎么选择？<br><strong>小孩子才做选择，大人都要</strong></p>\n<p>由于 ServiceWorker 的优先级在 DiskCache 之上，我们可以在 ServiceWorker 进行 <strong>「资源竞速」</strong>，同一时间请求 ServiceWorker Cache 和 DiskCache，哪个先返回就把资源返回上一层。代码可能是这样的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">\"fetch\"</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  event.respondWith(</span><br><span class=\"line\">    (<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> res = <span class=\"built_in\">Promise</span>.race([</span><br><span class=\"line\">        <span class=\"comment\">// 请求 ServiceWorker Cache</span></span><br><span class=\"line\">        cache.open(CACHE_NAME).then(<span class=\"function\"><span class=\"params\">cache</span> =&gt;</span> cache.match(event.request)),</span><br><span class=\"line\">        <span class=\"comment\">// 请求 DiskCache 或者网络资源</span></span><br><span class=\"line\">        fetch(event.request)</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"实验四：资源竞速之后，并发请求-3-张图片、10-张图片-和-100-张图片\"><a href=\"#实验四：资源竞速之后，并发请求-3-张图片、10-张图片-和-100-张图片\" class=\"headerlink\" title=\"实验四：资源竞速之后，并发请求 3 张图片、10 张图片 和 100 张图片\"></a>实验四：资源竞速之后，并发请求 3 张图片、10 张图片 和 100 张图片</h3><p>当我们进行资源竞速之后，这种情况下，无论是并发少量资源还是大量资源，都能达到最快的级别。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421014505.png\" alt=\"image-20220421014045092\"><br><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421005723.png\" alt=\"image-20220421005715401\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本篇我们搞懂了 ServiceCache、MemoryCache、DiskCache 的优先级。<br>然后深入对比了 ServiceWorker Cache 和 DiskCache 的性能表现。<br>在少量资源并发的时候，DiskCache 更快，在大量资源并发的时候，ServiceWorker 更快。<br>最后通过「资源竞速」的方式来兼顾两种情况。<br>但是，在某些时候，我们比较 ServiceWorker 和 HTTP 缓存有点不公平。<br>ServiceWorker 的用途会更加广泛，它提供了更细力度的缓存控制、使离线化应用得以实现、并且对比主线程，他能够使用更多的 CacheAPI 容量。</p>\n","excerpt":"","more":"<p>虽然 ServiceWorker 和 PWA 正在成为现代 Web 应用程序的标准，但浏览器资源缓存变得比以往任何时候都复杂。<br>本文涵盖了浏览器缓存的重点内容，具体包括：</p>\n<ol>\n<li>ServiceWorker 缓存与 HTTP 缓存的优先级？</li>\n<li>主流浏览器实现的 MemoryCache 和 DiskCache 在哪一层？</li>\n<li>MemoryCache、DiskCache、ServiceWorker 缓存哪个速度更快？</li>\n</ol>\n<h2 id=\"缓存流程概述\"><a href=\"#缓存流程概述\" class=\"headerlink\" title=\"缓存流程概述\"></a>缓存流程概述</h2><p>我们先来看标准定义的资源请求遵循的顺序：</p>\n<p><img src=\"https://web-dev.imgix.net/image/admin/vtKWC9Bg9dAMzoFKTeAM.png?auto=format\" alt=\"缓存流\"></p>\n<ol>\n<li><strong>ServiceWorker 缓存</strong>：ServiceWorker 检查资源是否存在其缓存中，并根据其编程的缓存策略决定是否返回资源。这个操作不会自动发生，需要在注册的 ServiceWorker 中定义 <code>fetch</code> 事件去拦截并处理网络请求，这样才能命中 ServiceWorker 缓存而不是网络或者 HTTP 缓存。</li>\n<li><strong>HTTP 缓存</strong>：这里就是我们常常说的「强缓存」和「协商缓存」，如果 HTTP 缓存未过期的话，浏览器就会使用 HTTP 缓存的资源。</li>\n<li><strong>服务器端</strong>：如果 ServiceWorker 缓存或者 HTTP 缓存中未找到任何资源，则浏览器会向网络请求资源。这里就会涉及到 CDN 服务或者源服务的工作了。</li>\n</ol>\n<p>这是标准定义的资源请求流程，但是有追求的浏览器还会在 ServiceWorker 上面加一层 <strong>「内存缓存层」</strong> ，以 Chrome 为例，我们请求一个资源，除去网络，会有三种浏览器缓存返回：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204201936867.png\" alt=\"image-20220420193610795\"></p>\n<p><strong>那么 MemoryCache 和 DiskCache 与 ServiceWorker Cache 的优先级是怎么样的呢？</strong><br>下面我们讲讲三者的区别。</p>\n<h2 id=\"MemoryCache、DiskCache-在缓存流程的哪一层？\"><a href=\"#MemoryCache、DiskCache-在缓存流程的哪一层？\" class=\"headerlink\" title=\"MemoryCache、DiskCache 在缓存流程的哪一层？\"></a>MemoryCache、DiskCache 在缓存流程的哪一层？</h2><p>我们以 Chrome 为例，MemoryCache 作为第一公民，位于 ServiceWorker 之上。<br>也就是命中了 MemoryCache，就不会触发 ServiceWorker 的 fetch 事件。<br>而 DiskCache 则位于原来的 HTTP 缓存层：</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421014504.png\" alt=\"http-cache-priority.drawio\"></p>\n<p>MemoryCache 的存在会导致一个问题： <strong>ServiceWorker 并不总是对资源有着控制权。</strong><br>这会另我们本来期望的情况会变得复杂且不可预知。可惜的是 MemoryCache 并不在 W3C 的标准中，W3C 从 2016 年到现在仍然在讨论着这个事情，看来短时间这个问题是得不到解决了。</p>\n<blockquote>\n<p>一些正在讨论的话题：</p>\n<ol>\n<li><a href=\"https://github.com/w3c/ServiceWorker/issues/1510\">safari fetches from memory cache instead of Service worker </a></li>\n<li><a href=\"https://github.com/w3c/ServiceWorker/issues/1174\">Difference between disk and memory cache</a></li>\n<li><a href=\"https://github.com/jakearchibald/idb/issues/171\">Advanced Questions About Service Worker</a></li>\n<li><a href=\"https://github.com/w3c/ServiceWorker/issues/962\">allow service worker produced resources to be marked as “cachable”</a></li>\n</ol>\n</blockquote>\n<p><strong>我们真的没有办法么？</strong></p>\n<p>要是我们遇到业务场景，确实对 ServiceWorker 资源控制权有很强的的要求，我们还是可以做点事情的。<br>MemoryCache 是受控于 <strong>「强缓存」</strong> 的，这意味着我们可以在 ServiceWorker 拦截资源的响应，并设置资源响应头来使资源从 MemoryCache 失效：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cache-control: max-age=0</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">\"fetch\"</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  event.respondWith(</span><br><span class=\"line\">    (<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 从 HTTP 缓存或者网络获取资源</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> res =  fetch(event.request);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 因为 Response 是一个流，只能用一次，所以这里要 clone 一下。</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> newRes = res.clone();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 改写资源响应头</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response(res.body, &#123; ...newRes, headers: &#123;</span><br><span class=\"line\">        <span class=\"string\">'cache-control'</span>: <span class=\"string\">'max-age=0'</span></span><br><span class=\"line\">      &#125;&#125;);</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，这种方法是以牺牲少量加载性能为前提的。这取决于我们实际场景中是性能优先，还是离线优先，或者其他什么情况优先。</p>\n<h2 id=\"MemoryCache、DiskCache、ServiceWorker-缓存哪个速度更快？\"><a href=\"#MemoryCache、DiskCache、ServiceWorker-缓存哪个速度更快？\" class=\"headerlink\" title=\"MemoryCache、DiskCache、ServiceWorker 缓存哪个速度更快？\"></a>MemoryCache、DiskCache、ServiceWorker 缓存哪个速度更快？</h2><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204202034325.png\" alt=\"image-20220420203359745\"></p>\n<p>我们再看一下同一个资源三种缓存的加载速度和优先级：</p>\n<ol>\n<li>加载速度：MemoryCache &gt; <strong>DiskCache &gt; ServiceWorker</strong></li>\n<li>优先级：MemoryCache &gt; <strong>ServiceWorker&gt; DiskCache</strong></li>\n</ol>\n<p>MemoryCache 优先级在 ServiceWorker 前面，这个没问题。<br><strong>但是速度更慢的 ServiceWorker 优先级比速度更快的 DiskCache 更高？</strong><br><strong>那盘下来，ServiceWorker 岂不是减慢了站点的加载速度？</strong></p>\n<h2 id=\"对照实验\"><a href=\"#对照实验\" class=\"headerlink\" title=\"对照实验\"></a>对照实验</h2><p>为了研究这个问题，我做了一组对照实验。<br>实验只在 Chrome 进行，chrome devtool 为每个资源提供时间。所有加载资源的信息都可以作为 HAR 文件下载下来，然后编写本地脚本进行信息提取和分析。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421001210.png\" alt=\"image-20220421001201494\"></p>\n<p><strong>实验条件</strong></p>\n<ol>\n<li>同一个环境：Chrome97 / MacOS 10.14 / Wifi</li>\n<li>同一张图片的多次并发加载：<ol>\n<li>3 张 133KB 图片 10 次实验</li>\n<li>10 张 133KB 图片 10 次实验</li>\n<li>100 张 133KB 图片 10 次实验</li>\n</ol>\n</li>\n<li>观察两个性能：<ol>\n<li>DiskCache 缓存性能表现</li>\n<li>ServiceWorker 缓存速度表现</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"实验一：3-张-133KB-图片并发\"><a href=\"#实验一：3-张-133KB-图片并发\" class=\"headerlink\" title=\"实验一：3 张 133KB 图片并发\"></a>实验一：3 张 133KB 图片并发</h3><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421013900.png\" alt=\"image-20220421013805667\"></p>\n<p>首先是并发请求 3 张图片进行 10 次实验，取平均数据，然后分别观察 DiskCache、ServiceWorker Cache 的性能表现。</p>\n<p>观察：</p>\n<ol>\n<li>DiskCache：我们发现下载操作并没有花太多时间，但是资源在等待排队。</li>\n<li>ServiceWorker Cache：更多耗时在下载。</li>\n</ol>\n<p>结论：但尽管如此，这种情况下， <strong>DiskCache 依然是比 ServiceWorker Cache 更快。</strong></p>\n<h3 id=\"实验二：3-张-133KB-图片-10-次实验\"><a href=\"#实验二：3-张-133KB-图片-10-次实验\" class=\"headerlink\" title=\"实验二：3 张 133KB 图片 10 次实验\"></a>实验二：3 张 133KB 图片 10 次实验</h3><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421013928.png\" alt=\"image-20220421013924399\"></p>\n<p>当我把并发图片增加到 10 张，这种情况可能会更加接近于实际情况，站点中可能会拥有更多的不同的资源（JS文件、字体、样式、图像等），因为某些网站可能会在一个页面存在超过 10 个资源。</p>\n<p>观察：</p>\n<ol>\n<li>DiskCache：从第二个资源开始排队时间依然很长，但是下载时间是基本不变的。</li>\n<li>ServiceWorker Cache： 排队并不是问题，但等待是。</li>\n</ol>\n<p>结论：这种情况下， <strong>DiskCache 会略逊于 ServiceWorker Cache。</strong></p>\n<h3 id=\"实验三：3-张-133KB-图片-100-次实验\"><a href=\"#实验三：3-张-133KB-图片-100-次实验\" class=\"headerlink\" title=\"实验三：3 张 133KB 图片 100 次实验\"></a>实验三：3 张 133KB 图片 100 次实验</h3><p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421014007.png\" alt=\"image-20220421014006376\"></p>\n<p>当我把并发图片增加到 100 张，这种情况几乎是不真实的情况，但是我好奇为什么 DiskCache 为什么在第一次试验中比 ServiceWorker Cache 更快。</p>\n<p>观察：</p>\n<ol>\n<li>DiskCache：排队依然是问题，且随着并发数成线性上升。我们甚至能看到浏览器是如何加载图片的，一次并发大概 6 张图片。</li>\n<li>ServiceWorker Cache：虽然等待时间随着并发数上升，但是是平缓的。</li>\n</ol>\n<p>结论： <strong>大并发下 ServiceWorker Cache 比 DiskCache 更快。</strong></p>\n<p>那 DiskCache 和 ServiceWorker 怎么选择？<br><strong>小孩子才做选择，大人都要</strong></p>\n<p>由于 ServiceWorker 的优先级在 DiskCache 之上，我们可以在 ServiceWorker 进行 <strong>「资源竞速」</strong>，同一时间请求 ServiceWorker Cache 和 DiskCache，哪个先返回就把资源返回上一层。代码可能是这样的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">\"fetch\"</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  event.respondWith(</span><br><span class=\"line\">    (<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> res = <span class=\"built_in\">Promise</span>.race([</span><br><span class=\"line\">        <span class=\"comment\">// 请求 ServiceWorker Cache</span></span><br><span class=\"line\">        cache.open(CACHE_NAME).then(<span class=\"function\"><span class=\"params\">cache</span> =&gt;</span> cache.match(event.request)),</span><br><span class=\"line\">        <span class=\"comment\">// 请求 DiskCache 或者网络资源</span></span><br><span class=\"line\">        fetch(event.request)</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"实验四：资源竞速之后，并发请求-3-张图片、10-张图片-和-100-张图片\"><a href=\"#实验四：资源竞速之后，并发请求-3-张图片、10-张图片-和-100-张图片\" class=\"headerlink\" title=\"实验四：资源竞速之后，并发请求 3 张图片、10 张图片 和 100 张图片\"></a>实验四：资源竞速之后，并发请求 3 张图片、10 张图片 和 100 张图片</h3><p>当我们进行资源竞速之后，这种情况下，无论是并发少量资源还是大量资源，都能达到最快的级别。</p>\n<p><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421014505.png\" alt=\"image-20220421014045092\"><br><img src=\"https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220421005723.png\" alt=\"image-20220421005715401\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本篇我们搞懂了 ServiceCache、MemoryCache、DiskCache 的优先级。<br>然后深入对比了 ServiceWorker Cache 和 DiskCache 的性能表现。<br>在少量资源并发的时候，DiskCache 更快，在大量资源并发的时候，ServiceWorker 更快。<br>最后通过「资源竞速」的方式来兼顾两种情况。<br>但是，在某些时候，我们比较 ServiceWorker 和 HTTP 缓存有点不公平。<br>ServiceWorker 的用途会更加广泛，它提供了更细力度的缓存控制、使离线化应用得以实现、并且对比主线程，他能够使用更多的 CacheAPI 容量。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl270y8qf0000xwrlo43rom6u","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8qj0004xwrl3exdtit4"},{"post_id":"cl270y8qy000gxwrl2g3c87v1","category_id":"cl270y8qz000hxwrlv4qejupf","_id":"cl270y8qz000ixwrljchwb85q"},{"post_id":"cl270y8r0000jxwrlk8wefpgk","category_id":"cl270y8r1000kxwrlj33vodet","_id":"cl270y8r1000nxwrln5fn8c72"},{"post_id":"cl270y8r2000oxwrle29760t8","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8r2000pxwrl8j0dlis6"},{"post_id":"cl270y8r3000sxwrlp7rv1guf","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8r4000txwrljqo0k6ns"},{"post_id":"cl270y8r50012xwrloeq9o78f","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8r60013xwrluultkzpj"},{"post_id":"cl270y8r80018xwrlajsnpdzf","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8r80019xwrl79ed3u3l"},{"post_id":"cl270y8ra001exwrllkqpzppz","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8ra001fxwrldhxyfc35"},{"post_id":"cl270y8rc001ixwrlmrvk2dp4","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8rd001jxwrloy6izn1x"},{"post_id":"cl270y8re001mxwrlfpimjjs6","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8re001nxwrlnhxwh5t1"},{"post_id":"cl270y8rg001pxwrlv9bg8klb","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8rg001qxwrlf46fy5un"},{"post_id":"cl270y8rh001txwrlp6u31v4g","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8ri001uxwrlox3tfkz6"},{"post_id":"cl270y8rj001vxwrl0yrr10li","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8rk001wxwrl4s1mmigp"},{"post_id":"cl270y8rm0022xwrl8rld7ubf","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8rn0023xwrl2pnrzegs"},{"post_id":"cl270y8rp0029xwrlzcd3kw3a","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8rq002axwrljkxl4a1m"},{"post_id":"cl270y8rs002cxwrluqpmhz7u","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8rs002dxwrl6fcrwat1"},{"post_id":"cl270y8rv002ixwrlzgdwwine","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8rv002jxwrlqpntaqqz"},{"post_id":"cl270y8rx002mxwrls7tr3cr8","category_id":"cl270y8qz000hxwrlv4qejupf","_id":"cl270y8rx002nxwrl0b5nhnwq"},{"post_id":"cl270y8ry002oxwrlesug2ttl","category_id":"cl270y8qz000hxwrlv4qejupf","_id":"cl270y8rz002pxwrlye51rx1y"},{"post_id":"cl270y8s4002qxwrl6dvx3g43","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8s5002rxwrlagq4ysnp"},{"post_id":"cl270y8s6002uxwrll10yi4hg","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8s6002vxwrl5qyohk4t"},{"post_id":"cl270y8s7002zxwrl2sat7uf8","category_id":"cl270y8qz000hxwrlv4qejupf","_id":"cl270y8s70030xwrlsz31d9kh"},{"post_id":"cl270y8s80031xwrlfameaw29","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8s80032xwrluyslcy91"},{"post_id":"cl270y8s80034xwrl1yke7u26","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8s90035xwrlslo3ny0j"},{"post_id":"cl270y8s9003axwrl18jx28tb","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8sa003bxwrloueg9892"},{"post_id":"cl270y8sd003mxwrlq03a8kw2","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8sd003nxwrlx06zuusn"},{"post_id":"cl270y8se003pxwrlhu79a1av","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8se003qxwrlsp36wmgj"},{"post_id":"cl270y8sf003txwrlfdjza64t","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8sf003uxwrlkfqqfb3w"},{"post_id":"cl270y8sf003xxwrl0puab48e","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8sg003yxwrl1p2vj8i2"},{"post_id":"cl270y8sg0041xwrldeq4ahhe","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8sh0042xwrl2hy2lyzo"},{"post_id":"cl270y8si0044xwrlr3nkzin6","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8si0045xwrlpfxbxtwr"},{"post_id":"cl270y8sj0047xwrluqhsjfzj","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8sj0048xwrlemirkqvm"},{"post_id":"cl270y8sk004axwrlbyiywa0f","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8sk004bxwrltwbuh42n"},{"post_id":"cl270y8sk004dxwrlhgl6e6vx","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8sl004exwrlfl9154dx"},{"post_id":"cl270y8sm004gxwrlmkekmpvy","category_id":"cl270y8qz000hxwrlv4qejupf","_id":"cl270y8sm004hxwrlacinqw7w"},{"post_id":"cl270y8sn004ixwrlmkhha2my","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8sn004jxwrl9naopcqi"},{"post_id":"cl270y8sp004pxwrldcaz4fs0","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8sp004qxwrlr6ujf5pk"},{"post_id":"cl270y8sq004vxwrlw0lod2ec","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8sq004wxwrlzx3f9rif"},{"post_id":"cl270y8sr004zxwrlsqhvjasm","category_id":"cl270y8qz000hxwrlv4qejupf","_id":"cl270y8sr0050xwrlsqd5g2cx"},{"post_id":"cl270y8t80053xwrlv7zhv57u","category_id":"cl270y8qz000hxwrlv4qejupf","_id":"cl270y8t80054xwrlfwxqoqjj"},{"post_id":"cl270y8t90055xwrlkb32rqoo","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8t90056xwrl05y6sd7o"},{"post_id":"cl270y8ta005bxwrlargb4gz6","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8ta005cxwrlrgz570uy"},{"post_id":"cl270y8tb005exwrlab88p5md","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8tb005fxwrlteel7190"},{"post_id":"cl270y8te005hxwrlt5kewg59","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8te005ixwrl0103qj4j"},{"post_id":"cl270y8tg005nxwrlofcm1kzv","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8tg005oxwrlw5dl28zi"},{"post_id":"cl270y8th005txwrl428ccd7u","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8th005uxwrli6as1tuy"},{"post_id":"cl270y8tm0060xwrlpvnd9cdk","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8tm0061xwrlfxkyo7iv"},{"post_id":"cl270y8tn0063xwrlflkldp80","category_id":"cl270y8qz000hxwrlv4qejupf","_id":"cl270y8tn0064xwrl917m7raq"},{"post_id":"cl270y8tn0065xwrljz7ulpt4","category_id":"cl270y8qz000hxwrlv4qejupf","_id":"cl270y8to0066xwrl7xe3gvk5"},{"post_id":"cl270y8to0067xwrl79za6edf","category_id":"cl270y8qz000hxwrlv4qejupf","_id":"cl270y8tp0068xwrlvmch88yd"},{"post_id":"cl270y8tu0069xwrlqqi43tdu","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8tu006axwrlstgmevzt"},{"post_id":"cl270y8tv006dxwrlun9le3ci","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8tv006exwrl6tsi7wtm"},{"post_id":"cl270y8tw006ixwrlpih485fu","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8tw006jxwrle1ies3pm"},{"post_id":"cl270y8tx006oxwrlbblj1alm","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8ty006pxwrl7r1cguxk"},{"post_id":"cl270y8ty006txwrltnx997n9","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8tz006uxwrl3joxahxv"},{"post_id":"cl270y8u3006wxwrlmnxjgyxc","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8u3006xxwrla41duft4"},{"post_id":"cl270y8u5006zxwrl371le7fh","category_id":"cl270y8r1000kxwrlj33vodet","_id":"cl270y8u60070xwrlbu5px1s2"},{"post_id":"cl270y8u60074xwrlw5ulzdqb","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl270y8u70075xwrl8hg1o6fr"},{"post_id":"cl2717vlr0000x1rl499igfbq","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl2717vlt0002x1rlfave61oi"},{"post_id":"cl271a85q0003hirl4yhb7qxc","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl271a85q0004hirl68135zas"},{"post_id":"cl271ajup0005hirl2y061b1z","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl271ajuq0006hirlam7yedz9"},{"post_id":"cl271blq50000o1rl7h999rim","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl271blq60002o1rla7bs3ww4"},{"post_id":"cl271bse70003o1rl2wabgnsr","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl271bse70005o1rl9h3609dj"},{"post_id":"cl27v6app0000ewv5m8zl986r","category_id":"cl270y8qi0001xwrlbh4miv5j","_id":"cl27v6apq0002ewv5n1vw18gx"}],"PostTag":[{"post_id":"cl270y8qf0000xwrlo43rom6u","tag_id":"cl270y8qi0002xwrlqkdoccsk","_id":"cl270y8qj0007xwrlmwuj2hyi"},{"post_id":"cl270y8qf0000xwrlo43rom6u","tag_id":"cl270y8qj0003xwrlagqccbec","_id":"cl270y8qk0008xwrldseoxsr5"},{"post_id":"cl270y8qf0000xwrlo43rom6u","tag_id":"cl270y8qj0005xwrl9utxeg63","_id":"cl270y8qk0009xwrl8g65r20h"},{"post_id":"cl270y8qf0000xwrlo43rom6u","tag_id":"cl270y8qj0006xwrl2epf9ras","_id":"cl270y8qk000axwrlxlomll7j"},{"post_id":"cl270y8r0000jxwrlk8wefpgk","tag_id":"cl270y8r1000lxwrlcxgg8aqr","_id":"cl270y8r1000mxwrlg6iayi2h"},{"post_id":"cl270y8r2000oxwrle29760t8","tag_id":"cl270y8r2000qxwrl4497fc75","_id":"cl270y8r2000rxwrlrxuws458"},{"post_id":"cl270y8r3000sxwrlp7rv1guf","tag_id":"cl270y8r4000uxwrlkwjz109q","_id":"cl270y8r4000yxwrlvy3q0icb"},{"post_id":"cl270y8r3000sxwrlp7rv1guf","tag_id":"cl270y8r4000vxwrl0yfo0jwc","_id":"cl270y8r5000zxwrl81ahxgu8"},{"post_id":"cl270y8r3000sxwrlp7rv1guf","tag_id":"cl270y8r4000wxwrlb7pbwr7c","_id":"cl270y8r50010xwrlk9zzunbc"},{"post_id":"cl270y8r3000sxwrlp7rv1guf","tag_id":"cl270y8r4000xxwrl0ah8uwqu","_id":"cl270y8r50011xwrl7ibh4rlp"},{"post_id":"cl270y8r50012xwrloeq9o78f","tag_id":"cl270y8r60014xwrlmgjqpop0","_id":"cl270y8r60016xwrl1s1xbhl6"},{"post_id":"cl270y8r50012xwrloeq9o78f","tag_id":"cl270y8r60015xwrldugwf02i","_id":"cl270y8r60017xwrles3rnx1t"},{"post_id":"cl270y8r80018xwrlajsnpdzf","tag_id":"cl270y8r8001axwrlejo532g0","_id":"cl270y8r8001cxwrl57l9gguf"},{"post_id":"cl270y8r80018xwrlajsnpdzf","tag_id":"cl270y8r8001bxwrl8ncq7vhn","_id":"cl270y8r9001dxwrl7kfjm970"},{"post_id":"cl270y8ra001exwrllkqpzppz","tag_id":"cl270y8r8001axwrlejo532g0","_id":"cl270y8ra001gxwrl4aje9oxp"},{"post_id":"cl270y8ra001exwrllkqpzppz","tag_id":"cl270y8r8001bxwrl8ncq7vhn","_id":"cl270y8ra001hxwrl1q82uawz"},{"post_id":"cl270y8rc001ixwrlmrvk2dp4","tag_id":"cl270y8rd001kxwrl3feu0tj7","_id":"cl270y8rd001lxwrlcveo78e1"},{"post_id":"cl270y8re001mxwrlfpimjjs6","tag_id":"cl270y8rd001kxwrl3feu0tj7","_id":"cl270y8re001oxwrle4iqmyoa"},{"post_id":"cl270y8rg001pxwrlv9bg8klb","tag_id":"cl270y8r4000xxwrl0ah8uwqu","_id":"cl270y8rg001rxwrld3fqmxxb"},{"post_id":"cl270y8rg001pxwrlv9bg8klb","tag_id":"cl270y8rd001kxwrl3feu0tj7","_id":"cl270y8rg001sxwrlnxqd0mfu"},{"post_id":"cl270y8rj001vxwrl0yrr10li","tag_id":"cl270y8rl001xxwrlgdvh50ve","_id":"cl270y8rl001zxwrl5n1kdx8u"},{"post_id":"cl270y8rj001vxwrl0yrr10li","tag_id":"cl270y8rl001yxwrl2s5rpiq3","_id":"cl270y8rl0020xwrlvsdo6l1t"},{"post_id":"cl270y8rj001vxwrl0yrr10li","tag_id":"cl270y8r8001axwrlejo532g0","_id":"cl270y8rl0021xwrl5m048egv"},{"post_id":"cl270y8rm0022xwrl8rld7ubf","tag_id":"cl270y8rn0024xwrlv1gl583o","_id":"cl270y8ro0026xwrl8xsd6ijz"},{"post_id":"cl270y8rm0022xwrl8rld7ubf","tag_id":"cl270y8ro0025xwrlhk6i4e88","_id":"cl270y8ro0027xwrlgt50jak8"},{"post_id":"cl270y8rm0022xwrl8rld7ubf","tag_id":"cl270y8r4000xxwrl0ah8uwqu","_id":"cl270y8ro0028xwrlaklb2dd7"},{"post_id":"cl270y8rp0029xwrlzcd3kw3a","tag_id":"cl270y8qj0005xwrl9utxeg63","_id":"cl270y8rq002bxwrl2zgbha91"},{"post_id":"cl270y8rs002cxwrluqpmhz7u","tag_id":"cl270y8r4000uxwrlkwjz109q","_id":"cl270y8rs002exwrl5980rvh2"},{"post_id":"cl270y8rs002cxwrluqpmhz7u","tag_id":"cl270y8r4000vxwrl0yfo0jwc","_id":"cl270y8rs002fxwrlmjem4cbr"},{"post_id":"cl270y8rs002cxwrluqpmhz7u","tag_id":"cl270y8r4000wxwrlb7pbwr7c","_id":"cl270y8rs002gxwrl9b8qa2x4"},{"post_id":"cl270y8rs002cxwrluqpmhz7u","tag_id":"cl270y8r8001axwrlejo532g0","_id":"cl270y8ru002hxwrlmryop0ds"},{"post_id":"cl270y8rv002ixwrlzgdwwine","tag_id":"cl270y8rv002kxwrlhpqcv9yw","_id":"cl270y8rw002lxwrl1vkyh75i"},{"post_id":"cl270y8s4002qxwrl6dvx3g43","tag_id":"cl270y8s5002sxwrl55ig6f2w","_id":"cl270y8s5002txwrlz5fyva3g"},{"post_id":"cl270y8s6002uxwrll10yi4hg","tag_id":"cl270y8s6002wxwrl8r77ekrk","_id":"cl270y8s6002xxwrlinquz1hq"},{"post_id":"cl270y8s6002uxwrll10yi4hg","tag_id":"cl270y8r4000xxwrl0ah8uwqu","_id":"cl270y8s6002yxwrl40tluy3n"},{"post_id":"cl270y8s80031xwrlfameaw29","tag_id":"cl270y8r60014xwrlmgjqpop0","_id":"cl270y8s80033xwrl42em31bd"},{"post_id":"cl270y8s80034xwrl1yke7u26","tag_id":"cl270y8s90036xwrl9bnaonq4","_id":"cl270y8s90038xwrl0cd67lbw"},{"post_id":"cl270y8s80034xwrl1yke7u26","tag_id":"cl270y8s90037xwrljnv9h9rc","_id":"cl270y8s90039xwrlrqgixlcx"},{"post_id":"cl270y8s9003axwrl18jx28tb","tag_id":"cl270y8sa003cxwrlzd2k25a2","_id":"cl270y8sa003dxwrl4o00nkuw"},{"post_id":"cl270y8sd003mxwrlq03a8kw2","tag_id":"cl270y8sb003gxwrland59lmd","_id":"cl270y8sd003oxwrlzzm8acp6"},{"post_id":"cl270y8se003pxwrlhu79a1av","tag_id":"cl270y8se003rxwrl11qezz37","_id":"cl270y8se003sxwrlruv7wyqn"},{"post_id":"cl270y8sf003txwrlfdjza64t","tag_id":"cl270y8sf003vxwrli42l6nw7","_id":"cl270y8sf003wxwrlsbe2bylm"},{"post_id":"cl270y8sf003xxwrl0puab48e","tag_id":"cl270y8sg003zxwrlc7u0eu81","_id":"cl270y8sg0040xwrl3l1cd9h3"},{"post_id":"cl270y8sg0041xwrldeq4ahhe","tag_id":"cl270y8sg003zxwrlc7u0eu81","_id":"cl270y8sh0043xwrlqq81nsqe"},{"post_id":"cl270y8si0044xwrlr3nkzin6","tag_id":"cl270y8sg003zxwrlc7u0eu81","_id":"cl270y8si0046xwrlsdwvwu02"},{"post_id":"cl270y8sj0047xwrluqhsjfzj","tag_id":"cl270y8sg003zxwrlc7u0eu81","_id":"cl270y8sj0049xwrlg4co1a33"},{"post_id":"cl270y8sk004axwrlbyiywa0f","tag_id":"cl270y8sg003zxwrlc7u0eu81","_id":"cl270y8sk004cxwrljyng8x17"},{"post_id":"cl270y8sk004dxwrlhgl6e6vx","tag_id":"cl270y8sg003zxwrlc7u0eu81","_id":"cl270y8sl004fxwrl0gyb8a5t"},{"post_id":"cl270y8sn004ixwrlmkhha2my","tag_id":"cl270y8qj0005xwrl9utxeg63","_id":"cl270y8so004mxwrlf06ey4sq"},{"post_id":"cl270y8sn004ixwrlmkhha2my","tag_id":"cl270y8sn004kxwrltryks5ea","_id":"cl270y8so004nxwrl85quguzu"},{"post_id":"cl270y8sn004ixwrlmkhha2my","tag_id":"cl270y8sn004lxwrldxrs9gik","_id":"cl270y8so004oxwrl70743amo"},{"post_id":"cl270y8sp004pxwrldcaz4fs0","tag_id":"cl270y8r4000xxwrl0ah8uwqu","_id":"cl270y8sp004sxwrlafjbjhxx"},{"post_id":"cl270y8sp004pxwrldcaz4fs0","tag_id":"cl270y8qj0005xwrl9utxeg63","_id":"cl270y8sq004txwrl8w6zqm7v"},{"post_id":"cl270y8sp004pxwrldcaz4fs0","tag_id":"cl270y8sp004rxwrllvcuthg2","_id":"cl270y8sq004uxwrlz73iyzwe"},{"post_id":"cl270y8sq004vxwrlw0lod2ec","tag_id":"cl270y8sq004xxwrlgs8l1exc","_id":"cl270y8sr004yxwrlwgaobqtj"},{"post_id":"cl270y8t90055xwrlkb32rqoo","tag_id":"cl270y8t90057xwrl42z9ij1i","_id":"cl270y8t90059xwrlzq1kd082"},{"post_id":"cl270y8t90055xwrlkb32rqoo","tag_id":"cl270y8t90058xwrlf7u3g9t9","_id":"cl270y8t9005axwrl8pu7nh16"},{"post_id":"cl270y8ta005bxwrlargb4gz6","tag_id":"cl270y8sq004xxwrlgs8l1exc","_id":"cl270y8ta005dxwrlyaj1bst3"},{"post_id":"cl270y8tb005exwrlab88p5md","tag_id":"cl270y8sq004xxwrlgs8l1exc","_id":"cl270y8tb005gxwrlnizrzhy0"},{"post_id":"cl270y8te005hxwrlt5kewg59","tag_id":"cl270y8te005jxwrl09hfx2kb","_id":"cl270y8tf005kxwrlqi7yovbf"},{"post_id":"cl270y8tg005nxwrlofcm1kzv","tag_id":"cl270y8tg005pxwrl7wqon6n4","_id":"cl270y8tg005rxwrl87s0jz0v"},{"post_id":"cl270y8tg005nxwrlofcm1kzv","tag_id":"cl270y8tg005qxwrlmu0ayid1","_id":"cl270y8tg005sxwrlw52qwrt9"},{"post_id":"cl270y8th005txwrl428ccd7u","tag_id":"cl270y8sf003vxwrli42l6nw7","_id":"cl270y8th005vxwrlkvhfoi8v"},{"post_id":"cl270y8tm0060xwrlpvnd9cdk","tag_id":"cl270y8sa003cxwrlzd2k25a2","_id":"cl270y8tm0062xwrl2kty8hni"},{"post_id":"cl270y8tu0069xwrlqqi43tdu","tag_id":"cl270y8r4000wxwrlb7pbwr7c","_id":"cl270y8tu006bxwrl56hnxagm"},{"post_id":"cl270y8tu0069xwrlqqi43tdu","tag_id":"cl270y8r4000vxwrl0yfo0jwc","_id":"cl270y8tv006cxwrlv9x3xy1d"},{"post_id":"cl270y8tv006dxwrlun9le3ci","tag_id":"cl270y8r4000xxwrl0ah8uwqu","_id":"cl270y8tw006fxwrl1xkd623l"},{"post_id":"cl270y8tv006dxwrlun9le3ci","tag_id":"cl270y8qj0005xwrl9utxeg63","_id":"cl270y8tw006gxwrlner8n0t9"},{"post_id":"cl270y8tv006dxwrlun9le3ci","tag_id":"cl270y8sp004rxwrllvcuthg2","_id":"cl270y8tw006hxwrlb12uo37n"},{"post_id":"cl270y8tw006ixwrlpih485fu","tag_id":"cl270y8sq004xxwrlgs8l1exc","_id":"cl270y8tx006lxwrly2qxdb1t"},{"post_id":"cl270y8tw006ixwrlpih485fu","tag_id":"cl270y8r4000xxwrl0ah8uwqu","_id":"cl270y8tx006mxwrlyb1n5ddq"},{"post_id":"cl270y8tw006ixwrlpih485fu","tag_id":"cl270y8tx006kxwrl18p9oudo","_id":"cl270y8tx006nxwrlmwc7vc6p"},{"post_id":"cl270y8tx006oxwrlbblj1alm","tag_id":"cl270y8r4000xxwrl0ah8uwqu","_id":"cl270y8ty006qxwrlojkj2zsq"},{"post_id":"cl270y8tx006oxwrlbblj1alm","tag_id":"cl270y8qj0005xwrl9utxeg63","_id":"cl270y8ty006rxwrlic91k6if"},{"post_id":"cl270y8tx006oxwrlbblj1alm","tag_id":"cl270y8rd001kxwrl3feu0tj7","_id":"cl270y8ty006sxwrl47i48m5t"},{"post_id":"cl270y8ty006txwrltnx997n9","tag_id":"cl270y8sq004xxwrlgs8l1exc","_id":"cl270y8tz006vxwrlgeu8n308"},{"post_id":"cl270y8u3006wxwrlmnxjgyxc","tag_id":"cl270y8sq004xxwrlgs8l1exc","_id":"cl270y8u3006yxwrlbfmm0cyb"},{"post_id":"cl270y8u5006zxwrl371le7fh","tag_id":"cl270y8u60071xwrlpjxc6z3n","_id":"cl270y8u60072xwrlfwoeb4yf"},{"post_id":"cl270y8u5006zxwrl371le7fh","tag_id":"cl270y8qj0005xwrl9utxeg63","_id":"cl270y8u60073xwrlv3crqcbc"},{"post_id":"cl270y8u60074xwrlw5ulzdqb","tag_id":"cl270y8qj0005xwrl9utxeg63","_id":"cl270y8u70076xwrll0bpmxbq"},{"post_id":"cl2717vlr0000x1rl499igfbq","tag_id":"cl270y8tl005yxwrl3g4wzoi7","_id":"cl2717vlt0001x1rl5os4333u"},{"post_id":"cl271blq50000o1rl7h999rim","tag_id":"cl270y8sc003kxwrlemvlc7le","_id":"cl271blq60001o1rlfdxg89qe"},{"post_id":"cl271bse70003o1rl2wabgnsr","tag_id":"cl270y8sb003gxwrland59lmd","_id":"cl271bse70004o1rl7ni32iyc"},{"post_id":"cl27v6app0000ewv5m8zl986r","tag_id":"cl270y8tl005yxwrl3g4wzoi7","_id":"cl27v6apq0001ewv5td2k6sab"}],"Tag":[{"name":"HTML","_id":"cl270y8qi0002xwrlqkdoccsk"},{"name":"CSS","_id":"cl270y8qj0003xwrlagqccbec"},{"name":"Javascript","_id":"cl270y8qj0005xwrl9utxeg63"},{"name":"node webkit","_id":"cl270y8qj0006xwrl2epf9ras"},{"name":"读书笔记","_id":"cl270y8r1000lxwrlcxgg8aqr"},{"name":"ROM","_id":"cl270y8r2000qxwrl4497fc75"},{"name":"单点登录","_id":"cl270y8r4000uxwrlkwjz109q"},{"name":"cookie","_id":"cl270y8r4000vxwrl0yfo0jwc"},{"name":"session","_id":"cl270y8r4000wxwrlb7pbwr7c"},{"name":"Nodejs","_id":"cl270y8r4000xxwrl0ah8uwqu"},{"name":"http","_id":"cl270y8r60014xwrlmgjqpop0"},{"name":"cors","_id":"cl270y8r60015xwrldugwf02i"},{"name":"架构","_id":"cl270y8r8001axwrlejo532g0"},{"name":"消息系统","_id":"cl270y8r8001bxwrl8ncq7vhn"},{"name":"Tool Kit","_id":"cl270y8rd001kxwrl3feu0tj7"},{"name":"RESTful","_id":"cl270y8rl001xxwrlgdvh50ve"},{"name":"权限系统","_id":"cl270y8rl001yxwrl2s5rpiq3"},{"name":"mocha","_id":"cl270y8rn0024xwrlv1gl583o"},{"name":"unit test","_id":"cl270y8ro0025xwrlhk6i4e88"},{"name":"语法树","_id":"cl270y8rv002kxwrlhpqcv9yw"},{"name":"Nginx","_id":"cl270y8s5002sxwrl55ig6f2w"},{"name":"SailsJS","_id":"cl270y8s6002wxwrl8r77ekrk"},{"name":"babel","_id":"cl270y8s90036xwrl9bnaonq4"},{"name":"ES6","_id":"cl270y8s90037xwrljnv9h9rc"},{"name":"小程序","_id":"cl270y8sa003cxwrlzd2k25a2"},{"name":"微信小程序","_id":"cl270y8sb003gxwrland59lmd"},{"name":"登录 微信小程序","_id":"cl270y8sc003kxwrlemvlc7le"},{"name":"udp","_id":"cl270y8se003rxwrl11qezz37"},{"name":"javascript","_id":"cl270y8sf003vxwrli42l6nw7"},{"name":"tcp","_id":"cl270y8sg003zxwrlc7u0eu81"},{"name":"v8","_id":"cl270y8sn004kxwrltryks5ea"},{"name":"NodeJS","_id":"cl270y8sn004lxwrldxrs9gik"},{"name":"SOAP","_id":"cl270y8sp004rxwrllvcuthg2"},{"name":"前端","_id":"cl270y8sq004xxwrlgs8l1exc"},{"name":"效率","_id":"cl270y8t90057xwrl42z9ij1i"},{"name":"专注","_id":"cl270y8t90058xwrlf7u3g9t9"},{"name":"前端构建","_id":"cl270y8te005jxwrl09hfx2kb"},{"name":"编译","_id":"cl270y8tg005pxwrl7wqon6n4"},{"name":"解释","_id":"cl270y8tg005qxwrlmu0ayid1"},{"name":"PWA","_id":"cl270y8tl005yxwrl3g4wzoi7"},{"name":"内存","_id":"cl270y8tx006kxwrl18p9oudo"},{"name":"书籍","_id":"cl270y8u60071xwrlpjxc6z3n"}]}}