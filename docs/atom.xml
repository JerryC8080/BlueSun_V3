<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BlueSun</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huang-jerryc.com/"/>
  <updated>2019-08-16T19:26:22.736Z</updated>
  <id>http://huang-jerryc.com/</id>
  
  <author>
    <name>JerryC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个失眠夜的胡思乱想</title>
    <link href="http://huang-jerryc.com/2019/08/17/a-thinking-on-insomnia-night/"/>
    <id>http://huang-jerryc.com/2019/08/17/a-thinking-on-insomnia-night/</id>
    <published>2019-08-16T19:25:13.977Z</published>
    <updated>2019-08-16T19:26:22.736Z</updated>
    
    <content type="html"><![CDATA[<p>现在是凌晨 2:06，今晚喝了两瓶科罗娜。<br>以为喝了酒能好好睡，结果，还是失眠了。</p>
<p>是兴奋也罢，是焦虑也罢。既然明天不用上班，那么就让这个失眠夜来的更放纵些。</p>
<p>刚才躺在床上，竟然在构想起自己的退休生活。<br>希望自己的退休生活，会更有趣些，在衣食上没有基本的担忧，身体虽然有些毛病，但还是能健康的活着，然后和老伴持续的二人世界。有一个独立的孩子，有空可以来看看我们。以及有一两个能持续以恒的爱好。然后，还顺利的养成了终身学习的习惯，作为一个 fasion 的老头。</p>
<p>培养个啥兴趣好呢？回顾过去的众多爱好，找一个能持续发展的。就拿音乐来说，假如我能把音乐这件事学深了，学广了，把玩几门乐器，就算是个糟老头，也能搞搞创作吧。然后有些积蓄，结合着年轻时的阅历和朋友，也能做些小生意吧？又或者也能做做教育吧？</p>
<p>顺着思考如何去过上喜欢的退休生活，似乎有了个更长远的目标，时间跨度更大的目标。</p>
<p>于是乎，才意识到这几年来，只凭借着年少轻狂的那股劲在奔跑，却没有一个可以长远追逐的愿景。</p>
<p>以至于，在碰到人生大事上，如结婚、买房、小孩这些问题上，却有了一种却步感。在碰到职业发展瓶颈上，会满满的焦虑感。还常常回忆过去，留恋过去。</p>
<p>看过一个说法：20 岁年轻人和 50 岁老人做计划，年轻人最多只能做 2 年计划，老人却可以做 5 年甚至 10 年计划。因为 5 年，对年轻人来说是他生命的 1/4，而对老人来说只是他生命的 1/10。 唯一忧桑的是，老人所剩的生命时间不敌年轻的。</p>
<p>从这个例子来看，我认为人类对时间的感受，是相对的，并且是可变化的。<br>那么假如年轻人能够去模拟感受老人对时间维度的感受，是不是也能做出更长远些的计划？然后更加淡定？</p>
<p>倘若把时间维度拉长，如果 30 年后来看今天，却稍稍有一种豁达的感觉。虽然离想清楚，想明白，还有些距离。</p>
<p>这样回去看，所谓的中年危机，互联网 35 岁命劫，在一个更长远的时间跨度中，也只能是件小事情，那么一跨，就过去了。</p>
<p>那么如何回来看当下？<br>毕竟我还是 27 岁的年龄，那就应该在这个时期，去好好感受属于这个时期的生活。<br>好好去感受职场，持续提高个体价值，给这个社会输出贡献，以换取个体生活条件。<br>好好去感受生活，结婚、买房、生子、赡养老人，去感受人生这个阶段必须经历的生活。<br>还有，好好爱惜身体，毕竟生命只有一次。</p>
<p>在历史长流的维度来看，一个人就几十年光景的寿命，诞生、成长、衰老，然后回归自然。<br>那么，这短短的生命，该怎么演绎？<br>第一，感谢父母亲把我们带到这个世界上。<br>第二，去好好感受生命的整个周期。</p>
<p>现在是凌晨 3:16，祝晚安。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在是凌晨 2:06，今晚喝了两瓶科罗娜。&lt;br&gt;以为喝了酒能好好睡，结果，还是失眠了。&lt;/p&gt;
&lt;p&gt;是兴奋也罢，是焦虑也罢。既然明天不用上班，那么就让这个失眠夜来的更放纵些。&lt;/p&gt;
&lt;p&gt;刚才躺在床上，竟然在构想起自己的退休生活。&lt;br&gt;希望自己的退休生活，会更有趣些
    
    </summary>
    
      <category term="三省吾身" scheme="http://huang-jerryc.com/categories/%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>关于 OKR 的一些方法论</title>
    <link href="http://huang-jerryc.com/2019/07/06/about-okr/"/>
    <id>http://huang-jerryc.com/2019/07/06/about-okr/</id>
    <published>2019-07-06T14:53:00.000Z</published>
    <updated>2019-07-06T15:10:30.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>OKR 是由前 Intel CEO，<a href="https://www.wikiwand.com/zh-hk/%E5%AE%89%E8%BF%AA%C2%B7%E8%91%9B%E6%B4%9B%E5%A4%AB" target="_blank" rel="external">安迪·葛洛夫</a> 构建的基本框架。</p>
<p>全称是：「Objective - Key Result」，既强调「目标」与衡量目标的「关键结果」</p>
<p>它是一套管理目标，让目标能落地的工具。<br>它在硅谷科技公司中广为人知，并被世界各地的许多组织采用。<br>它可以应用在组织中，也可以应用在个人的生活中，就像一种思考的模式。</p>
<p>过去两年多的 OKR 实践，有一些体会。<br>作为一个程序员，会自然的去寻找一个工具的最佳实践。</p>
<p>于是，有了这篇文章。</p>
<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>OKR 原理很简单。</p>
<p>要用好 OKR，我的理解，需要把握三个核心：</p>
<ul>
<li>目标</li>
<li>关键结果</li>
<li>过程管理</li>
</ul>
<p>它们分别回答了三个问题：</p>
<ul>
<li>应该做什么？</li>
<li>如何衡量做到了？</li>
<li>怎么落地？</li>
</ul>
<p>然后，思考 OKR，我认为还需要 cover 到两点：</p>
<ul>
<li>看得到的结果</li>
<li>说得出的价值</li>
</ul>
<p><strong>先抛一个不好的例子</strong></p>
<p>来自于我曾经定过的一个 OKR：</p>
<blockquote>
<p>O: 持续学习，提高自身战斗力</p>
<ul>
<li>KR1: CSS3 学习，阅读《CSS揭秘》产出阅读笔记。</li>
<li>KR2: 提高英文阅读能力，阅读《Security Your NodeJS Application》，产出一篇译文。</li>
<li>KR3: 对 Eggjs 或 Vue2 框架的源码进行解读，产出一篇源码解析。</li>
</ul>
</blockquote>
<p>我想先按顺序来讲讲「目标」、「关键结果」、「过程管理」。<br>然后，再回过头来，看看这个例子为啥糟糕，可以怎样修改。</p>
<h3 id="目标-Objective"><a href="#目标-Objective" class="headerlink" title="目标 Objective"></a>目标 Objective</h3><blockquote>
<p>欲望让我们起航，但只有专注、规划和学习才能到达成功的彼岸</p>
</blockquote>
<h5 id="组织的诞生"><a href="#组织的诞生" class="headerlink" title="组织的诞生"></a>组织的诞生</h5><p>回到最初的时候，一个组织的诞生，绝大多数情况是由于一两个人的想法，然后以此为中心，开始聚拢更多有共同目标的人加入进来。</p>
<p>1976年，乔布斯成功说服沃茲尼克組裝机器之后再拿去推销，他们的另一位朋友韦恩随后加入，三人在1976年4月1日成立苹果电脑公司。最初，Apple 仅仅是在卖组装电脑。</p>
<p>1996年，佩奇和布林在学校开始一项关于搜索的研究项目，开发出了搜索引擎 PageRank，后续改名 Google。最初，Google 仅仅是一个搜索引擎。</p>
<h5 id="组织的使命"><a href="#组织的使命" class="headerlink" title="组织的使命"></a>组织的使命</h5><p>随着组织发展，人员壮大，这个能聚拢人的目标，必须要看得远。然后这个目标提升到用另一个词来形容 —「使命」。</p>
<p>Apple 的使命：「藉推广公平的资料使用惯例，建立用户对互联网之信任和信心」<br>Google 的使命：「整合全球信息，使人人皆可访问和收益」<br>阿里巴巴的使命：「让天下没有难做的生意」<br>有赞的使命：「帮助每一位重视产品和服务的商家成功」<br>以及最近我们团队的前端技术委员的使命：「以极致的技术高效支撑业务」</p>
<p>使命描述一般都很简洁，并且容易记忆，像一句广告词，能深深的刻在脑海里。<br>在工作中遇到问题的时候，这个使命就会一下子从脑海里蹦出来指引你找到答案。</p>
<p>其实在某个市场闲逛都有可能让你意识到这个市场有某个问题需要解决，而帮市场解决这个问题，就是一个使命。</p>
<h5 id="阶段性的目标"><a href="#阶段性的目标" class="headerlink" title="阶段性的目标"></a>阶段性的目标</h5><p>为了一步步的达成「使命」，我们需要有目标。相对于使命，它粒度更小，且有时间限制。</p>
<p>所以，目标（Objective）应该：</p>
<ul>
<li>是阶段性的</li>
<li>是有优先级的</li>
<li>它需要能明确方向且鼓舞人心</li>
</ul>
<p>目标，是 OKR 中最重要，最需要想清楚，最首要确定的。<br>在这里，需要回答：你有什么？你要什么？你能放弃什么？</p>
<h5 id="重要与紧急"><a href="#重要与紧急" class="headerlink" title="重要与紧急"></a>重要与紧急</h5><p>「鱼与熊掌不可得兼」，所以我们要有所取舍，事情排个优先级。<br>「重要-紧急象限」是一个不错的指导工具，第一次看到它是在柯维《高效能人士的7个习惯》中的第三个习惯「要事第一」。</p>
<p><img src="https://img.yzcdn.cn/public_files/2019/07/06/e5ce3614f98f98d538944350bd505993.png" alt="重要-紧急"></p>
<p>但在实施的过程中中很有可能会遇到这样一个问题，紧急不重要的事情很紧急，总需要花时间和精力去处理它。然后重要不紧急的事情，会常常分配不到时间和精力。</p>
<p><strong>那么就让重要不紧急的事情也变得紧急起来。</strong></p>
<h5 id="目标需要自上而下的关联"><a href="#目标需要自上而下的关联" class="headerlink" title="目标需要自上而下的关联"></a>目标需要自上而下的关联</h5><p>如果基础的商业问题没有解决，不论实现多少产品功能，团队整体的绩效一定会大打折扣。</p>
<p>在一个组织中，如果没有充分的理解上一层的目标，就很容易跑偏，没有真正在刀刃上使力，造成效率上的浪费。</p>
<p>达到充分的理解目标，是有难度的，对人的眼界、目标理解能力有很高的要求。这不仅仅是执行者责任，更是管理者的责任。</p>
<h3 id="关键结果-Key-Result"><a href="#关键结果-Key-Result" class="headerlink" title="关键结果 Key Result"></a>关键结果 Key Result</h3><h5 id="衡量目标是否达成"><a href="#衡量目标是否达成" class="headerlink" title="衡量目标是否达成"></a>衡量目标是否达成</h5><p>目标定下来了，如果不去执行和落地，那么它永远就只是一个目标。如何去衡量目标是否达到了，就是「关键结果」的任务。</p>
<p>在互联网产品中，通常可以量化的条件有：用户增长、用户激活、收入增长、产品性能、产品质量。</p>
<p>作为技术团队，会更加集中注意力在产品性能和产品质量上面，那么如何去找到这些方向的衡量指标，就要从实际出发了。</p>
<p>比如我们团队会用「质量系数 = BUG数/估时」，来感受一个项目的质量情况。虽然它会有些漏洞，但如果建立在互相信任的基础上，可以提供一定的参考价值。</p>
<h5 id="有些挑战性"><a href="#有些挑战性" class="headerlink" title="有些挑战性"></a>有些挑战性</h5><blockquote>
<p>当达到成结果的时候，我们应该是欢呼雀跃般的兴奋，而不是理所应当的淡定。</p>
</blockquote>
<p>定下一个关键结果之后，问一下自己，有多少信心可以完成。如果信心爆棚，就把目标定高些。如果信心不足，就把目标调低些。因为 OKR 的意义不在于完成目标，更重要的是它能挖掘团队以及个人的潜力。</p>
<p>如果觉得有必要的话，我们可以建立一个「信心指数」，用来帮助确定结果有足够的挑战性而不会让人失去信心。这个指数的开始值最好是 50%，然后通过过程管理来动态变更和追踪。</p>
<p>比如去年我负责的一个「优化微信小程序加载性能」项目中的关键结果：</p>
<ul>
<li>首屏加载时间 3s 内</li>
</ul>
<p>未优化的加载时间是 6s+，回顾当时对目标的信心指数的话，大概是 20%。虽然最后因为部分不可控因素没有达到这个目标，只能维持在 3s-4s 之间。但是这个过程中能让人费尽脑汁的找到各种方法，大幅的提升了除首屏加载以外其他方面的加载体验，这也是额外的收获。</p>
<p>作为管理者，你要清楚的知道哪些人推一推会有更高的产出，哪些人实际执行情况会出现问题，要能看得到看得懂目前组织的目标和进度，并与成员进行同步。</p>
<h3 id="过程管理"><a href="#过程管理" class="headerlink" title="过程管理"></a>过程管理</h3><p>OKR 定下来了，在期限内，就要奔着目标努力奋进。尽管中途发现问题，也尽量不要在中途更改 OKR，让我们尽力跑完计划的阶段再回来总结。我们也可以把时间维度切小，比如把年度切分为半年度，把半年度切分为季度。</p>
<p>并且，目标定下来之后，要经常定期共同回顾，共同看见。而不是定下来了，就放在那里，否则过程中团队发生了问题，成员遇到了困难，很大可能会不被看到。</p>
<p>比较好的形式是每周都一起坐下来看看，每个人分享一下成果，或者说说遇到的困难，看能不能得到其他人的帮助。这个过程，能及时的看到问题，也能让成员对目标有更强的参与感。</p>
<p>那么，OKR应该以什么方式来呈现？《OKR工作法》一书中提供了一种参考：「四象限呈现形式」</p>
<p><img src="https://img.yzcdn.cn/public_files/2019/07/06/989bdd617bc44bab7dcfdd18120ac8a8.jpeg" alt="四象限呈现"></p>
<ul>
<li>第一象限：本周3-4件最重要的事情，并且进行优先级的排序</li>
<li>第二象限：把OKR内容罗列出来，关注和更新每一项KR的信心指数</li>
<li>第三象限：未来中长段时间中的计划，能让我们稍微看远一些。</li>
<li>第四象限：关注那些影响目标的关键因素会不会掉链子，例如团队状态，系统状态等。也可以用红蓝黄颜色表示出来。</li>
</ul>
<h1 id="回过头看看那个糟糕的例子"><a href="#回过头看看那个糟糕的例子" class="headerlink" title="回过头看看那个糟糕的例子"></a>回过头看看那个糟糕的例子</h1><p>糟糕的例子：</p>
<blockquote>
<p>O: 持续学习，提高自身战斗力</p>
<ul>
<li>KR1:CSS3 学习，阅读《CSS揭秘》 产出阅读笔记。</li>
<li>KR2:提高英文阅读能力，阅读《Security Your NodeJS Application》，产出一篇译文。</li>
<li>KR3: Vue2 框架的源码进行解读，产出一篇源码解析。</li>
</ul>
</blockquote>
<p>这个例子的背景是我 2017 年 4 月份加入到有赞，当时定的试用期内的其中一个目标。那时是我第一次认识和使用 OKR，只是单纯的把自身的技能提升计划给罗列了出来，看起来更像是一个 Todo List</p>
<p>现在回过头来看这一份 OKR，有不少问题：</p>
<ol>
<li>目标没有描述出来价值，提升了自身战斗力，然后呢？并没有自上而下的关联团队和组织的目标。所以从目标上，就已经走偏了。</li>
<li>假设目标正确，KR 也没有起到能衡量目标是否达成的作用。例如 KR1 完成了，对目标的推进，并没有说服力。</li>
<li>最后把 OKR 用成了 Todo List。</li>
</ol>
<p>那么我们从目标开始分析，当时作为一个新人加入到一个新的团队，对团队的技术栈和项目都很陌生，需要填补部分空白，快速上手。所以提升自身实力的底层诉求是：快速上手，胜任开发工作。</p>
<p>然后怎么衡量目的达到了呢？我们可以通过项目质量直接衡量，通过项目的熟悉程度来间接衡量。</p>
<p>修正后：</p>
<blockquote>
<p>O: 快速上手，以专业的姿态胜任开发工作。</p>
<ul>
<li>KR1: 质量系数平均在 0.3 以内。（质量系数 = BUG数/估时）</li>
<li>KR2: 代码评审评分平均 3.5 以上。（我们有 Code Review 机制，并且有评分环节）</li>
<li>KR3: 所参与项目评分在 4 以上。（项目也有评分环节）</li>
<li>KR4: 进行两次的项目分享。</li>
</ul>
</blockquote>
<p>那么如果达到这些关键结果，要通过学习框架，还是研究项目，还是熟悉业务，那就是根据实际迎刃而解的事情了。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>凡事预则立，不预则废 ——《礼记·中庸》</p>
</blockquote>
<p>最后要注意的是，OKR 只是一个工具，当你有一个目标，它会给你一种落实目标的方法论。而如果一开始目标没有想清楚，想明白，那就很容易在错的路上越走越远。</p>
<p>每个团队都会有不同的风格，和不同的实际情况。理解方法和工具的原理，明白这么做是为了解决什么问题，然后再调整定制真正适合此时此刻的团队，才是最好的方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;OKR 是由前 Intel CEO，&lt;a href=&quot;https://www.wikiwand.com/zh-hk/%E5%AE%89%E8
    
    </summary>
    
      <category term="三省吾身" scheme="http://huang-jerryc.com/categories/%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>BeautyWe.js 一套专注于微信小程序的开发范式</title>
    <link href="http://huang-jerryc.com/2019/06/11/beautywe-intro/"/>
    <id>http://huang-jerryc.com/2019/06/11/beautywe-intro/</id>
    <published>2019-06-11T06:22:25.000Z</published>
    <updated>2019-07-09T07:38:18.010Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/beautywe/docs/master/docs/assets/images/logo-V4.png" alt></p>
<blockquote>
<p>官网：<a href="http://beautywejs.com" target="_blank" rel="external">beautywejs.com</a><br>Repo: <a href="https://github.com/beautywe/beautywe" target="_blank" rel="external">beautywe</a></p>
</blockquote>
<h1 id="一个简单的介绍"><a href="#一个简单的介绍" class="headerlink" title="一个简单的介绍"></a>一个简单的介绍</h1><p><strong>BeautyWe.js 是什么？</strong></p>
<p>它是一套专注于微信小程序的企业级开发范式，它的愿景是：</p>
<blockquote>
<p>让企业级的微信小程序项目中的代码，更加简单、漂亮。</p>
</blockquote>
<p><strong>为什么要这样命名呢？</strong></p>
<blockquote>
<p>Write <strong>beautiful</strong> code for <strong>we</strong>chat mini program by the <strong>beautiful</strong> <strong>we</strong>!</p>
</blockquote>
<p>「We」 既是我们的 <strong>We</strong>，也是微信的 <strong>We</strong>，Both beautiful！</p>
<p><strong>那么它有什么卖点呢？</strong></p>
<ol>
<li>专注于微信小程序环境，写原汁原味的微信小程序代码。</li>
<li>由于只专注于微信小程序，它的源码也很简单。</li>
<li>插件化的编程方式，让复杂逻辑更容易封装。</li>
<li>再加上一些配套设施：<ol>
<li>一些官方插件。</li>
<li>一套开箱即用，包含了工程化、项目规范以及微信小程序环境独特问题解决方案的框架。</li>
<li>一个CLI工具，帮你快速创建应用，页面，组件等。</li>
</ol>
</li>
</ol>
<p><strong>它由以下几部分组成：</strong></p>
<ul>
<li><p><strong>一个插件化的核心</strong> - <a href="https://github.com/beautywe/beautywe" target="_blank" rel="external">BeautyWe Core</a><br>  对 App、Page 进行抽象和包装，保持传统微信小程序开发姿势，同时开放部分原生能力，让其具有「可插件化」的能力。</p>
</li>
<li><p><strong>一些官方插件</strong> — <a href="https://www.npmjs.com/search?q=keywords%3Abeautywe-plugin" target="_blank" rel="external">BeautyWe Plugins</a><br>  得益于 Core 的「可插件化」特性，封装复杂逻辑，实现可插拔。官方对于常见的需求提供了一些插件：如增强存储、发布/订阅、状态机、Logger、缓存策略等。</p>
</li>
<li><p><strong>一套开箱即用的项目框架</strong> - <a href="https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/contents/framework/introduce" target="_blank" rel="external">BeautyWe Framework</a><br>  描述了一种项目的组织形式，开箱即用，集成了 <code>BeautyWe Core</code> ，并且提供了如：全局窗口、开发规范、多环境开发、全局配置、NPM 等解决方案。</p>
</li>
<li><p><strong>一个CLI工具</strong> - <a href="https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/remote/cli" target="_blank" rel="external">BeautyWe Cli</a><br>  提供快速创建应用、页面、插件，以及项目构建功能的命令行工具。并且还支持自定义的创建模板。</p>
</li>
</ul>
<h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><p>下载</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181427" alt></p>
<p>用 BeautyWe 包装你的应用</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181445" alt></p>
<p>之后，你就能使用 BeautyWe Plugin 提供的能力了。</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181337" alt></p>
<h1 id="开放原生App-Page，支持插件化"><a href="#开放原生App-Page，支持插件化" class="headerlink" title="开放原生App/Page，支持插件化"></a>开放原生App/Page，支持插件化</h1><p><code>new BtApp({...})</code> 的执行结果是对原生的应用进行包装，其中包含了「插件化」的处理，然后返回一个新的实例，这个实例适配原生的 <code>App()</code> 方法。</p>
<p>下面来讲讲「插件化」到底做了什么事情。</p>
<p>首先，插件化开放了原生 App 的四种能力：</p>
<ol>
<li><p><strong>Data 域</strong><br> 把插件的 Data 域合并到原生 App 的 Data 域中，这一块很容易理解。</p>
</li>
<li><p><strong>原生钩子函数</strong><br> 使原生钩子函数（如 <code>onShow</code>, <code>onLoad</code>）可插件化。让原生App与多个插件可以同时监听同一个钩子函数。如何工作的，下面会细说。</p>
</li>
<li><p><strong>事件钩子函数</strong><br> 使事件钩子函数（与 view 层交互的钩子函数），尽管在实现上有一些差异，但是实现原理跟「原生钩子函数」一样的。</p>
</li>
<li><p><strong>自定义方法</strong><br> 让插件能够给使用者提供 API。为了保证插件提供的 API 足够的优雅，支持当调用插件 API 的时候（如 event 插件 <code>this.event.on(...)</code>)，API 方法内部仍然能通过 <code>this</code> 获取到原生实例。</p>
</li>
</ol>
<h4 id="钩子函数的插件化"><a href="#钩子函数的插件化" class="headerlink" title="钩子函数的插件化"></a>钩子函数的插件化</h4><p>原生钩子函数，事件钩子函数我们统一称为「钩子函数」。</p>
<p>对于每一个钩子函数，内部是维护一个以 Series Promise 方式执行的执行队列。</p>
<p>以 <code>onShow</code> 为例，将会以这样的形式执行：</p>
<blockquote>
<p>native.onShow → pluginA.onShow → pluginB.onShow → …</p>
</blockquote>
<p><strong>下面深入一下插件化的原理</strong>：</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181648" alt="beautywe pluggable"></p>
<p>工作原理是这样的：    </p>
<ol>
<li>经过 <code>new BtApp(...)</code> 包装，所有的钩子函数，都会有一个独立的执行队列，    </li>
<li>首先会把原生的各个钩子函数 <code>push</code> 到对应的队列中。然后每 <code>use</code> 插件的时候，都会分解插件的钩子函数，往对应的队列 <code>push</code>。    </li>
<li>当 <code>Native App</code>（原生）触发某个钩子的时候，<code>BtApp</code> 会以 Promise Series 的形式按循序执行对应队列里面的函数。    </li>
<li>特殊的，<code>onLaunch</code> 和 <code>onLoad</code> 的执行队列中，会在队列顶部插入一个初始化的任务（<code>initialize</code>），它会以同步的方式按循序执行 <code>Initialize Queue</code> 里面的函数。这正是插件生命周期函数中的 <code>plugin.initialize</code>。</li>
</ol>
<p>这种设计能提供以下功能：</p>
<ol>
<li><p>可插件化。<br> 只需要往对应钩子函数的事件队列中插入任务。</p>
</li>
<li><p>支持异步。<br> 由于是以 Promise Series 方式运行的，其中一个任务返回一个 Promise，下一个任务会等待这个任务完成再开始。如果发生错误，会流转到原生的 <code>onError()</code> 中。</p>
</li>
<li><p>解决了微信小程序 <code>app.js</code> 中 <code>getApp() === undefinded</code>问题。<br> 造成这个问题，本质是因为 <code>App()</code> 的时候，原生实例未创建。但是由于 Promise 在 event loop 中是一个微任务，被注册在下一次循环。所以 Promise 执行的时候 <code>App()</code> 早已经完成了。</p>
</li>
</ol>
<h1 id="一些官方插件"><a href="#一些官方插件" class="headerlink" title="一些官方插件"></a>一些官方插件</h1><p>BeautyWe 官方提供了一系列的插件：</p>
<ol>
<li>增强存储: Storage</li>
<li>数据列表：List Page</li>
<li>缓存策略：Cache</li>
<li>日志：Logger</li>
<li>事件发布/订阅：Event</li>
<li>状态机：Status</li>
</ol>
<p>它们的使用很简单，哪里需要插哪里。<br>由于篇幅的原因，下面挑几个比较有趣的来讲讲，更多的可以看看官方文档：<a href="http://beautywejs.com" target="_blank" rel="external">BeautyWe</a></p>
<h2 id="增强存储-Storage"><a href="#增强存储-Storage" class="headerlink" title="增强存储 Storage"></a>增强存储 Storage</h2><p>该功能由 <a href="https://github.com/beautywe/plugin-storage" target="_blank" rel="external">@beautywe/plugin-storage</a> 提供。</p>
<p>由于微信小程序原生的数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。</p>
<p>所以该插件在 <code>wx.getStorage/setStorage</code> 的基础上，提供了两种扩展能力：</p>
<ol>
<li>过期控制</li>
<li>版本隔离</li>
</ol>
<p><strong>一些简单的例子</strong></p>
<p>安装<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BtApp &#125; <span class="keyword">from</span> <span class="string">'@beautywe/core'</span>;</span><br><span class="line"><span class="keyword">import</span> storage <span class="keyword">from</span> <span class="string">'@beautywe/plugin-storage'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> BtApp();</span><br><span class="line">app.use(storage());</span><br></pre></td></tr></table></figure></p>
<p>过期控制<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7天后过期</span></span><br><span class="line">app.storage.set(<span class="string">'name'</span>, <span class="string">'jc'</span>, &#123; <span class="attr">expire</span>: <span class="number">7</span> &#125;)；</span><br></pre></td></tr></table></figure></p>
<p>版本隔离<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.use(&#123; <span class="attr">appVersion</span>: <span class="string">'0.0.1'</span> &#125;);</span><br><span class="line">app.set(<span class="string">'name'</span>, <span class="string">'jc'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 jc</span></span><br><span class="line">app.get(<span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当版本更新后</span></span><br><span class="line">app.use(&#123; <span class="attr">appVersion</span>: <span class="string">'0.0.2'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 undefined;</span></span><br><span class="line">app.get(<span class="string">'name'</span>);</span><br></pre></td></tr></table></figure></p>
<p>更多的查看 <a href="https://github.com/beautywe/plugin-storage" target="_blank" rel="external">@beautywe/plugin-storage 官方文档</a></p>
<h2 id="数据列表-List-Page"><a href="#数据列表-List-Page" class="headerlink" title="数据列表 List Page"></a>数据列表 List Page</h2><p>对于十分常见的数据列表分页的业务场景，<code>@beautywe/plugin-listpage</code> 提供了一套打包方案：</p>
<ol>
<li>满足常用「数据列表分页」的业务场景</li>
<li>支持分页</li>
<li>支持多个数据列表</li>
<li>自动捕捉下拉重载：<code>onPullDownRefresh</code></li>
<li>自动捕捉上拉加载：<code>onReachBottom</code></li>
<li>自带请求锁，防止帕金森氏手抖用户</li>
<li>简单优雅的 API</li>
</ol>
<p>一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BeautyWe <span class="keyword">from</span> <span class="string">'@beautywe/core'</span>;</span><br><span class="line"><span class="keyword">import</span> listpage <span class="keyword">from</span> <span class="string">'@beautywe/plugin-listpage'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> page = <span class="keyword">new</span> BeautyWe.BtPage();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 listpage 插件</span></span><br><span class="line">page.use(listpage(&#123;</span><br><span class="line">    lists: [&#123;</span><br><span class="line">        name: <span class="string">'goods'</span>,  <span class="comment">// 数据名</span></span><br><span class="line">        pageSize: <span class="number">20</span>,   <span class="comment">// 每页多少条数据，默认 10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一页的数据源，没次加载页面时，会调用函数，然后取返回的数据。</span></span><br><span class="line">        fetchPageData(&#123; pageNo, pageSize &#125;) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 获取数据</span></span><br><span class="line">            <span class="keyword">return</span> API.getGoodsList(&#123; pageNo, pageSize &#125;)</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 有时候，需要对服务器的数据进行处理，dataCooker 是你定义的函数。</span></span><br><span class="line">                .then(<span class="function">(<span class="params">rawData</span>) =&gt;</span> dataCooker(rawData));</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;],</span><br><span class="line">    enabledPullDownRefresh: <span class="literal">true</span>,    <span class="comment">// 开启下拉重载， 默认 false</span></span><br><span class="line">    enabledReachBottom: <span class="literal">true</span>,    <span class="comment">// 开启上拉加载， 默认 false</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// goods 数据会被加载到，goods 为上面定义的 name</span></span><br><span class="line"><span class="comment">// this.data.listPage.goods = &#123;</span></span><br><span class="line"><span class="comment">//     data: [...],     // 视图层，通过该字段来获取具体的数据</span></span><br><span class="line"><span class="comment">//     hasMore: true,   // 视图层，通过该字段来识别是否有下一页</span></span><br><span class="line"><span class="comment">//     currentPage: 1,  // 视图层，通过该字段来识别当前第几页</span></span><br><span class="line"><span class="comment">//     totalPage: undefined,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>只需要告诉 <code>listpage</code> 如何获取数据，它会自动处理「下拉重载」、「上拉翻页」的操作，然后把数据更新到 <code>this.data.listPage.goods</code> 下。</p>
<p>View 层只需要描述数据怎么展示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"good"</span> <span class="attr">wx:for</span>=<span class="string">"listPage.goods.data"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"no-more"</span> <span class="attr">wx:if</span>=<span class="string">"listPage.goods.hasMore === false"</span>&gt;</span></span><br><span class="line">    没有更多了</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>listpage</code> 还支持多数据列表等其他更多配置，详情看：<a href="https://github.com/beautywe/plugin-listpage" target="_blank" rel="external">@beautywe/plugin-listpage</a></p>
<h2 id="缓存策略-Cache"><a href="#缓存策略-Cache" class="headerlink" title="缓存策略 Cache"></a>缓存策略 Cache</h2><p><code>@beautywe/plugin-cache</code> 提供了一个微信小程序端缓存策略，其底层由 <a href="https://github.com/JerryC8080/super-cache" target="_blank" rel="external">super-cache</a> 提供支持。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>提供一套「服务端接口耗时慢，但加载性能要求高」场景的解决方案</li>
<li>满足最基本的缓存需求，读取（get）和保存（set）</li>
<li>支持针对缓存进行逻辑代理</li>
<li>灵活可配置的数据存储方式</li>
</ol>
<h4 id="How-it-work"><a href="#How-it-work" class="headerlink" title="How it work"></a>How it work</h4><p>一般的请求数据的形式是，页面加载的时候，从服务端获取数据，然后等待数据返回之后，进行页面渲染：</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181755" alt></p>
<p>但这种模式，会受到服务端接口耗时，网络环境等因素影响到加载性能。   </p>
<p>对于加载性能要求高的页面（如首页），一般的 Web 开发我们有很多解决方案（如服务端渲染，服务端缓存，SSR 等）。<br>但是也有一些环境不能使用这种技术（如微信小程序）。</p>
<p>Super Cache 提供了一个中间数据缓存的解决方案：</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181847" alt></p>
<p>思路：    </p>
<ol>
<li>当你需要获取一个数据的时候，如果有缓存，先把旧的数据给你。</li>
<li>然后再从服务端获取新的数据，刷新缓存。</li>
<li>如果一开始没有缓存，则请求服务端数据，再把数据返回。</li>
<li>下一次请求缓存，从第一步开始。</li>
</ol>
<p>这种解决方案，舍弃了一点数据的实时性（非第一次请求，只能获取上一次最新数据），大大提高了前端的加载性能。<br>适合的场景：    </p>
<ol>
<li>数据实时性要求不高。</li>
<li>服务端接口耗时长。</li>
</ol>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BtApp &#125; <span class="keyword">from</span> <span class="string">'@beautywe/core'</span>;</span><br><span class="line"><span class="keyword">import</span> cache <span class="keyword">from</span> <span class="string">'@beautywe/plugin-cache'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> BtApp();</span><br><span class="line">app.use(cache(&#123;</span><br><span class="line">    adapters: [&#123;</span><br><span class="line">        key: <span class="string">'name'</span>,</span><br><span class="line">        data() &#123;</span><br><span class="line">            <span class="keyword">return</span> API.fetch(<span class="string">'xxx/name'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>假设 <code>API.fetch(&#39;xxx/name&#39;)</code> 是请求服务器接口，返回数据：<code>data_from_server</code></p>
<p>那么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.cache.get(<span class="string">'name'</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// value: 'data_from_server'  </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>更多的配置，详情看：<a href="https://github.com/beautywe/plugin-cache" target="_blank" rel="external">@beautywe/plugin-cache</a></p>
<h2 id="日志-Logger"><a href="#日志-Logger" class="headerlink" title="日志 Logger"></a>日志 Logger</h2><p>由 <code>@beautywe/logger-plugin</code> 提供的一个轻量的日志处理方案，它支持：</p>
<ol>
<li>可控的 log level</li>
<li>自定义前缀</li>
<li>日志统一处理</li>
</ol>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BtApp &#125; <span class="keyword">from</span> <span class="string">'@beautywe/core'</span>;</span><br><span class="line"><span class="keyword">import</span> logger <span class="keyword">from</span> <span class="string">'@beautywe/plugin-logger'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> page = <span class="keyword">new</span> BtApp();</span><br><span class="line"></span><br><span class="line">page.use(logger(&#123;</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p><strong>API</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">page.logger.info(<span class="string">'this is info'</span>);</span><br><span class="line">page.logger.warn(<span class="string">'this is warn'</span>);</span><br><span class="line">page.logger.error(<span class="string">'this is error'</span>);</span><br><span class="line">page.logger.debug(<span class="string">'this is debug'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// [info] this is info</span></span><br><span class="line"><span class="comment">// [warn] this is warn</span></span><br><span class="line"><span class="comment">// [error] this is error</span></span><br><span class="line"><span class="comment">// [debug] this is debug</span></span><br></pre></td></tr></table></figure>
<p><strong>Level control</strong></p>
<p>可通过配置来控制哪些 level 该打印：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page.use(logger(&#123;</span><br><span class="line">    level: <span class="string">'warn'</span>,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>那么 <code>warn</code> 以上的 log （<code>info</code>, <code>debug</code>）就不会被打印，这种满足于开发和生成环境对 log 的不同需求。</p>
<p>level 等级如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Logger.LEVEL = &#123;</span><br><span class="line">    error: <span class="number">1</span>,</span><br><span class="line">    warn: <span class="number">2</span>,</span><br><span class="line">    info: <span class="number">3</span>,</span><br><span class="line">    debug: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更多的配置，详情看：<a href="https://github.com/beautywe/plugin-logger" target="_blank" rel="external">@beautywe/plugin-logger</a></p>
<h1 id="BeautyWe-Framework"><a href="#BeautyWe-Framework" class="headerlink" title="BeautyWe Framework"></a>BeautyWe Framework</h1><p><code>@beautywe/core</code> 和 <code>@beautywe/plugin-...</code> 给小程序提供了：</p>
<ol>
<li>开放原生，支持插件化 —— by core</li>
<li>各种插件 —— by plugins</li>
</ol>
<p>但是，还有很多的开发中实际还会遇到的痛点，是上面两个解决不到的。<br>如项目的组织、规范、工程化、配置、多环境等等</p>
<p>这些就是，「BeautyWe Framework」要解决的范畴。</p>
<p>它作为一套开箱即用的项目框架，提供了这些功能：</p>
<ul>
<li>集成 BeautyWe Core</li>
<li>NPM 支持</li>
<li>全局窗口</li>
<li>全局 Page，Component</li>
<li>全局配置文件</li>
<li>多环境开发</li>
<li>Example Pages</li>
<li>正常项目需要的标配：ES2015+,sass,uglify,watch 等</li>
<li>以及我们认为良好的项目规范（eslint，commit log，目录结构等）</li>
</ul>
<p>也是由于篇幅原因，挑几个有趣的来讲讲，更多的可以看看官方文档：<a href="http://beautywejs.com" target="_blank" rel="external">BeautyWe</a></p>
<h2 id="快速创建"><a href="#快速创建" class="headerlink" title="快速创建"></a>快速创建</h2><p>首先安装 <code>@beautywe/cli</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm i @beautywe/cli -g</span><br></pre></td></tr></table></figure>
<h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> beautywe new app</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span> appName: my-app</span><br><span class="line"><span class="meta">&gt;</span> version: 0.0.1</span><br><span class="line"><span class="meta">&gt;</span> appid: 123456</span><br><span class="line"><span class="meta">&gt;</span> 这样可以么:</span><br><span class="line"><span class="meta">&gt;</span> &#123;</span><br><span class="line"><span class="meta">&gt;</span>    "appName": "my-app",</span><br><span class="line"><span class="meta">&gt;</span>    "version": "0.0.1",</span><br><span class="line"><span class="meta">&gt;</span>    "appid": "123456"</span><br><span class="line"><span class="meta">&gt;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>回答几个问题之后，项目就生成了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">my-app</span><br><span class="line">├── gulpfile.js</span><br><span class="line">├── package.json</span><br><span class="line">└── src</span><br><span class="line">    ├── app.js</span><br><span class="line">    ├── app.json</span><br><span class="line">    ├── app.scss</span><br><span class="line">    ├── assets</span><br><span class="line">    ├── components</span><br><span class="line">    ├── config</span><br><span class="line">    ├── examples</span><br><span class="line">    ├── libs</span><br><span class="line">    ├── npm</span><br><span class="line">    ├── pages</span><br><span class="line">    └── project.config.json</span><br></pre></td></tr></table></figure>
<h4 id="创建页面、组件、插件"><a href="#创建页面、组件、插件" class="headerlink" title="创建页面、组件、插件"></a>创建页面、组件、插件</h4><p><strong>页面</strong></p>
<ol>
<li>主包页面：<code>beautywe new page &lt;path|name&gt;</code></li>
<li>分包页面：<code>beautywe new page --subpkg &lt;subPackageName&gt; &lt;path|name&gt;</code></li>
</ol>
<p><strong>组件</strong></p>
<ol>
<li><code>beautywe new component &lt;name&gt;</code></li>
</ol>
<p><strong>插件</strong></p>
<ol>
<li><code>beautywe new plugin &lt;name&gt;</code></li>
</ol>
<h4 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h4><p>在 <code>./.templates</code> 目录中，存放着快速创建命令的创建模板：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tree .templates</span><br><span class="line"></span><br><span class="line">.templates</span><br><span class="line">├── component</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── index.json</span><br><span class="line">│   ├── index.scss</span><br><span class="line">│   └── index.wxml</span><br><span class="line">├── page</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── index.json</span><br><span class="line">│   ├── index.scss</span><br><span class="line">│   └── index.wxml</span><br><span class="line">└── plugin</span><br><span class="line">    └── index.js</span><br></pre></td></tr></table></figure>
<p>可以修改里面的模板，来满足项目级别的自定义模板创建。</p>
<h2 id="全局窗口"><a href="#全局窗口" class="headerlink" title="全局窗口"></a>全局窗口</h2><p>我们都知道微信小程序是「单窗口」的交互平台，一个页面对应一个窗口。<br>而在业务开发中，往往会有诸如这种述求：</p>
<ol>
<li>自定义的 toast 样式</li>
<li>页面底部 copyright</li>
<li>全局的 loading 样式</li>
<li>全局的悬浮控件<br>……</li>
</ol>
<p>稍微不优雅的实现可以是分别做成独立的组件，然后每一个页面都引入进来。<br>这种做法，我们会有很多的重复代码，并且每次新建页面，都要引入一遍，后期维护也会很繁琐。</p>
<p>而「全局窗口」的概念是：<strong>希望所有页面之上有一块地方，全局性的逻辑和交互，可以往里面搁。</strong></p>
<h4 id="global-view-组件"><a href="#global-view-组件" class="headerlink" title="global-view 组件"></a>global-view 组件</h4><p>这是一个自定义组件，源码在 <code>/src/components/global-view</code></p>
<p>每个页面的 wxml 只需要在顶层包一层：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">global-view</span> <span class="attr">id</span>=<span class="string">"global-view"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">global-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要全局实现的交互、样式、组件，只需要维护这个组件就足够了。</p>
<h2 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h2><p>在 <code>src/config/</code> 目录中，可以存放各种全局的配置文件，并且支持以 Node.js 的方式运行。（得益于 <a href="/contents/framework/concept/nodejs-power.md">Node.js Power 特性</a>）。</p>
<p>如 <code>src/config/logger.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> env = process.env.RUN_ENV || <span class="string">'dev'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">    prefix: <span class="string">'BeautyWe'</span>,</span><br><span class="line">    level: <span class="string">'debug'</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="comment">// 开发环境的配置</span></span><br><span class="line">    dev: &#123;</span><br><span class="line">        level: <span class="string">'debug'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 测试环境的配置</span></span><br><span class="line">    test: &#123;</span><br><span class="line">        level: <span class="string">'info'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 线上环境的配置</span></span><br><span class="line">    prod: &#123;</span><br><span class="line">        level: <span class="string">'warn'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;[env] || &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.logger = logger;</span><br></pre></td></tr></table></figure>
<p>然后我们可以这样读取到 config 内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; logger &#125; <span class="keyword">from</span> <span class="string">'/config/index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger.level 会根据环境不同而不同。</span></span><br></pre></td></tr></table></figure>
<p>Beautywe Framework 默认会把 config 集成到 <code>getApp()</code> 的示例中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getApp().config;</span><br></pre></td></tr></table></figure>
<h2 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h2><p>BeautyWe Framework 支持多环境开发，其中预设了三套策略：</p>
<ul>
<li>dev</li>
<li>test</li>
<li>prod</li>
</ul>
<p>我们可以通过命令来运行这三个构建策略：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beautywe run dev</span><br><span class="line">beautywe run test</span><br><span class="line">beautywe run prod</span><br></pre></td></tr></table></figure>
<h2 id="三套环境的差异"><a href="#三套环境的差异" class="headerlink" title="三套环境的差异"></a>三套环境的差异</h2><p>Beautywe Framework 源码默认在两方面使用了多环境：</p>
<ul>
<li>构建任务（<code>gulpfile.js/env/...</code>）</li>
<li>全局配置（<code>src/config/...</code>）</li>
</ul>
<h3 id="构建任务的差异"><a href="#构建任务的差异" class="headerlink" title="构建任务的差异"></a>构建任务的差异</h3><table>
<thead>
<tr>
<th>构建任务</th>
<th>说明</th>
<th style="text-align:center">dev</th>
<th style="text-align:center">test</th>
<th style="text-align:center">prod</th>
</tr>
</thead>
<tbody>
<tr>
<td>clean</td>
<td>清除dist文件</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>copy</td>
<td>复制资源文件</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>scripts</td>
<td>编译JS文件</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>sass</td>
<td>编译scss文件</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>npm</td>
<td>编译npm文件</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>nodejs-power</td>
<td>编译Node.js文件</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>watch</td>
<td>监听文件修改</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>scripts-min</td>
<td>压缩JS文件</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>sass-min</td>
<td>压缩scss文件</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>npm-min</td>
<td>压缩npm文件</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>image-min</td>
<td>压缩图片文件</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>clean-example</td>
<td>清除示例页面</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<h3 id="Node-js-Power"><a href="#Node-js-Power" class="headerlink" title="Node.js Power"></a>Node.js Power</h3><p>Beautywe Framework 的代码有两种运行环境：</p>
<ol>
<li>Node.js 运行环境，如构建任务等。</li>
<li>微信小程序运行环境，如打包到 <code>dist</code> 文件夹的代码。</li>
</ol>
<h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><blockquote>
<p>Node.js Power 本质是一种静态编译的实现。<br>把某个文件在 Node.js 环境运行的结果，输出到微信小程序运行环境中，以此来满足特定的需求。</p>
</blockquote>
<p>Node.js Power 会把项目中 <code>src</code> 目录下类似 <code>xxx.nodepower.js</code> 命名的文件，以 Node.js 来运行，<br>然后把运行的结果，以「字面量对象」的形式写到 <code>dist</code> 目录下对应的同名文件 <code>xxx.nodepower.js</code> 文件去。</p>
<p>以 <code>src/config/index.nodepower.js</code> 为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> files = fs.readdirSync(path.join(__dirname));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">files</span><br><span class="line">    .filter(<span class="function"><span class="params">name</span> =&gt;</span> name !== <span class="string">'index.js'</span>)</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.assign(result, <span class="built_in">require</span>(path.join(__dirname, <span class="string">`./<span class="subst">$&#123;name&#125;</span>`</span>)));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = result;</span><br></pre></td></tr></table></figure>
<p>该文件，经过 Node.js Power 构建之后:</p>
<p><code>dist/config/index.nodepower.js</code>: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"appInfo"</span>: &#123;</span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">        <span class="string">"env"</span>: <span class="string">"test"</span>,</span><br><span class="line">        <span class="string">"appid"</span>: <span class="string">"wx85fc0d03fb0b224d"</span>,</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"beautywe-framework-test-app"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"logger"</span>: &#123;</span><br><span class="line">        <span class="string">"prefix"</span>: <span class="string">"BeautyWe"</span>,</span><br><span class="line">        <span class="string">"level"</span>: <span class="string">"info"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就满足了，随意往 <code>src/config/</code> 目录中扩展配置文件，都能被自动打包。</p>
<p>Node.js Power 已经被集成到多环境开发的 dev, test, prod 中去。</p>
<p>当然，你可以手动运行这个构建任务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gulp nodejs-power</span><br></pre></td></tr></table></figure>
<h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>BeautyWe Framework 实现支持 npm 的原理很简单，总结一句话：</p>
<blockquote>
<p>使用 webpack 打包 <code>src/npm/index.js</code> ，以 commonjs 格式输出到 <code>dist/npm/index.js</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181936" alt="npm-works"></p>
<p>这样做的好处：</p>
<ol>
<li>实现简单。</li>
<li>让 npm 包能集中管理，每次引入依赖，都好好的想一下，避免泛滥（尤其在多人开发中）。</li>
<li>使用 <code>ll dist/npm/index.js</code> 命令能快速看到项目中的 npm 包使占了多少容量。</li>
</ol>
<h4 id="新增-npm-依赖"><a href="#新增-npm-依赖" class="headerlink" title="新增 npm 依赖"></a>新增 npm 依赖</h4><p>在 <code>src/npm/index.js</code> 文件中，进行 export：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &#123; default as beautywe &#125; from &apos;@beautywe/core&apos;;</span><br></pre></td></tr></table></figure>
<p>然后在其他文件 import：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; beautywe &#125; <span class="keyword">from</span> <span class="string">'./npm/index'</span>;</span><br></pre></td></tr></table></figure>
<h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>总的来说，BeautyWe 是一套微信小程序的开发范式。</p>
<p><code>core</code> 和 <code>plugins</code> 扩展原生，提供复杂逻辑的封装和插拔式使用。</p>
<p>而 <code>framework</code> 则负责提供一整套针对于微信小程序的企业级项目解决方案，开箱即用。</p>
<p>其中还有更多的内容，欢迎浏览官网：<a href="http://beautywejs.com" target="_blank" rel="external">beautywejs.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/beautywe/docs/master/docs/assets/images/logo-V4.png&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网：&lt;a href=&quot;htt
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="小程序" scheme="http://huang-jerryc.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>记一次「关于沟通」的培训</title>
    <link href="http://huang-jerryc.com/2019/04/13/about-communicate/"/>
    <id>http://huang-jerryc.com/2019/04/13/about-communicate/</id>
    <published>2019-04-13T09:39:00.000Z</published>
    <updated>2019-04-13T09:45:45.626Z</updated>
    
    <content type="html"><![CDATA[<p>周末参与了公司给TL们安排的一个主题为《高效沟通》的课程，为期两天。<br>以往自己对「沟通」自我感觉良好，完全凭借感觉来，只要跟对方能表达清楚自己的想法，足矣。<br>两天下来，重新开始认识，「沟通」，其实是一门很深的学问。<br>这篇像是笔记，也像是我对「沟通」这门学问的重新认识。</p>
<h1 id="萨提亚模型"><a href="#萨提亚模型" class="headerlink" title="萨提亚模型"></a>萨提亚模型</h1><blockquote>
<p>沟通中需要认识到谈话者的状态</p>
</blockquote>
<p><img src="/image/blog/about-communicate/DraggedImage.png" alt="萨提亚沟通模型"></p>
<p>「萨提亚模型」是由美国家庭治疗专家 Virginia Satir 女士所创建的理论体系。这种体系起初是被运用在家庭心理治疗方面。但是在诸多的家庭治疗理论中，萨提亚模型一直是难以归类的，有的教科书将之列为「沟通学派」，有的纳入「人本学派」。究其原因，就是萨提亚模型不强调病态的。</p>
<p>一言蔽之就是：萨提亚模型，不仅仅适用于心理治疗，在人与人沟通中，也能提升我们的认知。</p>
<p>这个模型有两个重要的理论：</p>
<ol>
<li><strong>冰山理论</strong></li>
<li><strong>应对姿态</strong></li>
</ol>
<h2 id="冰山理论"><a href="#冰山理论" class="headerlink" title="冰山理论"></a>冰山理论</h2><p><img src="/image/blog/about-communicate/DraggedImage-1.png" alt="冰山理论"></p>
<p>一个人的「自我」就像一座冰山一样，别人所看到的只是冰山一角。<br>外在的「行为」和「应对方式」，我们是能很快的看得到的。<br>但是内在的「感受」、「观点」、「期待」、「渴望」是没那么容易知道的。</p>
<p>有一个例子特别好：    </p>
<blockquote>
<p>一对年轻夫妻，丈夫的职业是培训师，很能赚钱，但是经常需要出差。她的妻子就经常抱怨他不常回来陪伴她，觉得丈夫不爱他。但是丈夫很纳闷，常常陪伴妻子的话，自己就不能好好的工作了。<br>后来丈夫跟妻子好好谈过之后，才发现，妻子抱怨的原因是因为「安全感」不足。因为丈夫很能赚钱，长期不在身边的话，怕会在外面找小三。<br>那么事情就好办了，丈夫索性把所有的收入都给老婆管了。</p>
</blockquote>
<p>从这个例子中，其实我们来套一下冰山理论：</p>
<ul>
<li>行为：丈夫常常出差</li>
<li>应对方式：埋怨、吵架</li>
<li>观点：有钱的男人长期在外面，容易找小三</li>
<li>期待：多点回家，陪陪老婆</li>
<li>渴望：安全感</li>
</ul>
<p>其实妻子内心深处渴望的是一个「安全感」，从最深处的渴望下手，只要能满足对方的深层次的渴望，问题就引刃而解了。</p>
<h2 id="沟通姿态"><a href="#沟通姿态" class="headerlink" title="沟通姿态"></a>沟通姿态</h2><p>根据萨提亚模型，人有五种的沟通姿态：</p>
<ul>
<li>指责型</li>
<li>讨好型</li>
<li>超理智型</li>
<li>打岔型</li>
<li>表里一致型</li>
</ul>
<p>而这五种的沟通姿态表现在对三个沟通要素的关注度不同：</p>
<ul>
<li>自我</li>
<li>他人</li>
<li>情景</li>
</ul>
<h3 id="指责型"><a href="#指责型" class="headerlink" title="指责型"></a>指责型</h3><blockquote>
<p>关注「自我」、「情景」，忽略「他人」</p>
</blockquote>
<p>指责型的人常常忽略他人，习惯于攻击和批判，将责任推给别人。“都是你的错”，“你到底怎么搞的”是他们的口头语。</p>
<h3 id="讨好型"><a href="#讨好型" class="headerlink" title="讨好型"></a>讨好型</h3><blockquote>
<p>关注「他人」、「情景」，忽略「自我」</p>
</blockquote>
<p>讨好型的人忽略自己，内在价值感比较低。言语中经常流露出“这都是我的错”，“我想要让你高兴”之类的话。行为上则过度和善，习惯于道歉和乞怜。</p>
<h3 id="超理智型"><a href="#超理智型" class="headerlink" title="超理智型"></a>超理智型</h3><blockquote>
<p>关注「情景」、忽略「他人」、「自我」</p>
</blockquote>
<p>超理智型的人极端客观，只关心事情，忽略与个人或情绪。常常给人的感觉是冷漠、冷淡。</p>
<h3 id="打岔型"><a href="#打岔型" class="headerlink" title="打岔型"></a>打岔型</h3><blockquote>
<p>啥也不关注</p>
</blockquote>
<p>打岔型的人则永远不抓重点，不直接回答问题或根本文不对题。总是可以打破各种绝望的氛围，把注意力从任何有压力的话题上转移开</p>
<p>当然，没有人永远是单纯的一种沟通姿态的。而我自己就是那种「有时讨好有时指责有时超理智，而有时候会打岔转移话题」。</p>
<h1 id="沟通的核心技能"><a href="#沟通的核心技能" class="headerlink" title="沟通的核心技能"></a>沟通的核心技能</h1><p>在沟通中，有四种重要的技能：</p>
<ul>
<li>「积极聆听」</li>
<li>「有效提问」</li>
<li>「清晰表达」</li>
<li>「反馈」</li>
</ul>
<h2 id="积极聆听"><a href="#积极聆听" class="headerlink" title="积极聆听"></a>积极聆听</h2><p>在别人说话的时候，积极的聆听，这个过程从你的言行和脸部表情，都能给到对方正向的反馈。</p>
<h2 id="有效提问"><a href="#有效提问" class="headerlink" title="有效提问"></a>有效提问</h2><p>沟通过程中，你往往能通过提问来控制话题的方向、了解对方的想法、增强对方的自信、甚至好的问题能引起对方深层次的思考。<br>提问可以有一个练习的套路：「目标」→「现状」→「方案」→「行动」<br>例如</p>
<ul>
<li>询问目标：你认为怎样的结果是满意的？</li>
<li>询问现状：请问你已经尝试了哪些方案了？</li>
<li>询问方案：还可以采取哪些措施？</li>
<li>询问心动：接下来打算做什么？</li>
</ul>
<h2 id="清晰表达"><a href="#清晰表达" class="headerlink" title="清晰表达"></a>清晰表达</h2><p>在表达中，我们常常会遇到那种前后说了一大通，最后其实只表达了一个意思的人。也有些人表达混乱，思路不清晰的。</p>
<p>这里也有一个可练习的表达套路：</p>
<ol>
<li>「观点 Point」</li>
<li>「原因 Reason」</li>
<li>「举例 Example」</li>
<li>「复述观点 Point again」or 「提出请求 Proposal」</li>
</ol>
<p>例如：</p>
<ol>
<li>提出观点：为了我们更高效的完成目标，我的想法是…</li>
<li>说明原因：我下这个结论是因为…</li>
<li>举个栗子：如果达成了，我们会有这些提升…</li>
<li>提出请求：如果你也同意的话，我希望能得到这些帮助…</li>
</ol>
<h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><p>很喜欢对反馈的一种看法：「反馈是一种礼物！」<br>尤其是建设性的反馈，更能使自己或对方有所进步。<br>那么如何提出一个有建设性的反馈，这也有一个练习的套路：</p>
<ol>
<li>「行为 Action」</li>
<li>「影响 Impact」</li>
<li>「行动 Do」</li>
</ol>
<p>例如：</p>
<ol>
<li>行为：兄弟，厕所的墙上贴着「禁止吸烟」的。</li>
<li>影响：厕所的通风很差的，烟味会久久散不去的，想象一下屎味烟味混杂的厕所，客户来到公司，印象很差的。而且对别人身体也不健康，是吧。</li>
<li>行动：你不知道，其实公司在走廊上是有专门的吸烟区的，在那里风景又好，岂不是更舒畅。</li>
</ol>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>「沟通」既是一门学问，也是一门艺术。<br>尽然有各种理论和研究，但最后还是为「实践」服务。<br>我认为，以上纯属理论，要真正落实到实际应用，还需要多多锻炼，以及应景发挥，还要基于现实来好好感悟。<br>另外，如果有兴趣继续深入研究的话，这里有一个书单：</p>
<ul>
<li>《金字塔原理》</li>
<li>《天资差异》</li>
<li>《类型与原型》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末参与了公司给TL们安排的一个主题为《高效沟通》的课程，为期两天。&lt;br&gt;以往自己对「沟通」自我感觉良好，完全凭借感觉来，只要跟对方能表达清楚自己的想法，足矣。&lt;br&gt;两天下来，重新开始认识，「沟通」，其实是一门很深的学问。&lt;br&gt;这篇像是笔记，也像是我对「沟通」这门学问
    
    </summary>
    
      <category term="三省吾身" scheme="http://huang-jerryc.com/categories/%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>《管理的常识》读后感 「一」</title>
    <link href="http://huang-jerryc.com/2019/03/21/management-of-common-sense-1/"/>
    <id>http://huang-jerryc.com/2019/03/21/management-of-common-sense-1/</id>
    <published>2019-03-21T12:46:40.000Z</published>
    <updated>2019-04-13T09:30:38.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《管理的常识》读后感-「一」"><a href="#《管理的常识》读后感-「一」" class="headerlink" title="《管理的常识》读后感 「一」"></a>《管理的常识》读后感 「一」</h1><p>陈春花的《管理的常识》是一本相见恨晚的书。在读的过程中会有一种「如果能早点遇到你多好啊」的感慨。但换种思路，一年前读与现在读，肯定是完全不同的收获。现在读，能更多结合过去的实际感受，提炼更多的感悟和反思。<br>这本书我读的很慢，它虽然很薄，但是有大量的内容值得深度思考，并且每个人不同的时期不同的经历，也会有不同的理解和感悟。倘若一年后再来读，感受也是不一样的。<br>从3月4日拿到书，到今天为止，我还没有完全读完，我挑了两个最有感悟的点来分享下心得，分别是：「关于管理」和「关于激励」。</p>
<h2 id="关于管理"><a href="#关于管理" class="headerlink" title="关于管理"></a>关于管理</h2><p>很喜欢德鲁克的一句话：「管理是一种实践，其本质不在于知，而在于行；其验证不在于逻辑，而在于成果；其唯一的权威性就是成就」。<br>强调的是，管理是关注「实践」与「结果」的。</p>
<h3 id="管理的目的是为了提升效率"><a href="#管理的目的是为了提升效率" class="headerlink" title="管理的目的是为了提升效率"></a>管理的目的是为了提升效率</h3><p>管理最终是服务于「企业经营」的，而为了实现企业经营，是通过不断提升「效率」来达成。从管理学历史的角度来看，管理学的演变被陈春花老师分为了三个阶段。</p>
<p><strong>第一阶段，科学管理阶段</strong>，这个阶段要解决的问题是「劳动效率最大化」。而使劳动效率最大化的手段就是「分工」，它有四条原理：</p>
<ol>
<li>科学划分工作元素</li>
<li>员工选择、培训和开发</li>
<li>与员工经常沟通</li>
<li>管理者与员工应有平等的工作和责任范围</li>
</ol>
<p><strong>第二阶段，行政组织管理阶段</strong>，这个阶段要解决的问题是「组织效率最大化」，其中最重要的手段是「专业化水平和等级制度的结合」。<br>专业化水平，指的是需要强化各岗位的专业化能力，无论是开发、产品、销售、领导者、管理者，都需要具备岗位独特的专业能力。只有让各岗位贡献了专业化的水平，才算是胜任了管理工作。<br>而分权分责的等级制度，能够是职位和权力两者合为一体，在这个基础上，管理的效能才会有效发挥。</p>
<p><strong>第三阶段，人力资源管理阶段</strong>，这个阶段要解决的问题是「个人效率最大化」，其中重要的手段是「个人创造组织环境，满足需求，挖掘潜力」。<br>管理者其实就是一个微型的人力资源部，而不仅仅关心事务性的事情。这是角色转变很重要的一个观念。管理者也需要更多关注人，关注成员的目标与组织目标的一致性。<br>激励要以团队精神为导向，个人成果要跟团队挂钩，团队的成果要跟业务挂钩。在这方面，我想到了有赞年终奖的分配逻辑上，个人绩效需要乘以团队绩效系数。这就把员工需求和组织发展的目标连接在一起。</p>
<p>综上，管理实现效率，就是实现「劳动效率」、「组织效率」、「个人效率」，并且它们的循序是需要不断递进的过程。</p>
<h3 id="管理是一种分配"><a href="#管理是一种分配" class="headerlink" title="管理是一种分配"></a>管理是一种分配</h3><p>管理其实就是对于「职责」、「权力」、「利益」的分配。<br>这是一个能改变我认知的一个理解方式。<br>把职责分配下去，让每一个成员承担起责任，并且再给予和责任相适应的资源和权力，管理的效能就会发挥出来。<br>最理想的情况下，就是三者都能等分，形成一个铁三角型。<br>但是现实情况往往很难做到，虽然如此，也要有意识地去注意这个问题。</p>
<h3 id="「传统管理者」与「有效管理者」"><a href="#「传统管理者」与「有效管理者」" class="headerlink" title="「传统管理者」与「有效管理者」"></a>「传统管理者」与「有效管理者」</h3><p>在德鲁克先生的观点下，对管理者分了两类，「传统管理者」和「有效管理者」。</p>
<p>传统管理者几个特征：</p>
<ol>
<li>专注于繁琐事务，时间属于别人</li>
<li>屁股指挥脑袋，只从所在岗位的视角看问题</li>
<li>忽略了对人的培养</li>
</ol>
<p>有效管理者的几个特征：</p>
<ol>
<li>进行时间管理，明确的优先级，所有事情都有序和合理</li>
<li>系统性思考，认识到整体与局部的关系</li>
<li>培养人</li>
</ol>
<p>看着这两个分类，感触良多。<br>回想 2018 上半年，刚成为 TL，角色转变。当时实际最紧迫的任务是招人，而我自身还是深陷于业务需求中。后来反省，尽管业务需求很紧急，但是在这个位置上，应当做更加重要的事情。这是当时做的很不好的地方。<br>而 2018 下半年，新成员的加入，让我能够稍微脱离细节，更注重培养人，后来团队能输出不错的小伙伴，还是很欣慰的。<br>而现在，我需要更多的关注在系统性思考上，跳出岗位，跳出职业视角，认识到整体和局部，这不是个短期内容易提升的事情。</p>
<h2 id="关于激励"><a href="#关于激励" class="headerlink" title="关于激励"></a>关于激励</h2><p>我一直认为的一个观念，大家之所以来这里工作，是有个人需求的。可能是一份薪水，可能是进步，发展，和实现个人价值。这里要回答的一个问题是：「人们为什么工作」<br>企业和个人是一个双向选择过程，各取所需，各司其职，双方都会关心投入产出比。<br>所以，关于如何搞清对方需求，给予激励，提高绩效。这方面我会更想找到答案。</p>
<h3 id="激励的两个角度"><a href="#激励的两个角度" class="headerlink" title="激励的两个角度"></a>激励的两个角度</h3><p>对于激励有两个核心的思考角度。<br>第一个，是想办法让工作变成游戏，让人从中获取更多快乐，这就跟有赞强调的 Enjoy 很切合了。<br>第二个，是永远站在对方的角度来思考，理解对方的述求。</p>
<h3 id="「保健因素」与「激励因素」"><a href="#「保健因素」与「激励因素」" class="headerlink" title="「保健因素」与「激励因素」"></a>「保健因素」与「激励因素」</h3><p>在众多的常见激励手段中，陈春花把它们分了两类：「保健因素」和「激励因素」。<br>例如，</p>
<ul>
<li>保健因素：工资、岗位，培训、福利、工作设备等。</li>
<li>激励因素：晋升、奖金、价值的肯定、额外的工作条件等。</li>
</ul>
<p>保健因素，是一个人工作的最基本，最必须的条件，如果缺乏保健因素的话，就会引起不满。另外一个特点是，大部分人都有的，不具有独特性的。</p>
<p>激励因素，是一个人做好工作所需要的条件，他能够带来满足感，能够激起人的欲望和潜力的。另外一个特点是，少部分有的，需要踮脚拿到的。</p>
<p>所以，不同激励与感受的关系是，保健因素 → 降低不满，激励因素 → 提升满足感。</p>
<p>需要注意的是，激励因素是有可能变成保健因素的。例如现在大部分公司都发年终奖，并且人人都有，HR 谈薪资的时候，也会用年薪的概念把年终奖算进收入里面，作为一个 package。那么年终奖，就变成了保健因素了。一旦公司年底发不出年终奖，或者不及预期，那就会引起不满。</p>
<h3 id="「激励」与「绩效」"><a href="#「激励」与「绩效」" class="headerlink" title="「激励」与「绩效」"></a>「激励」与「绩效」</h3><p>时刻不能忘的是，管理最终是服务于企业经营的。激励是重要的管理手段，最终也是要为绩效负责的。「激励」和「绩效」的关系，有些要注意的。</p>
<p><strong> 满足感并不一定带来高绩效 </strong><br>在满足员工的需求，让员工获得满足感的基础下，一定要：<strong>「让员工的满足感来源于工作本身而不是个人需求」</strong></p>
<p>因为人们的需求是很个人化的，例如有的人需求是工作环境，而不是工作中获得绩效。那么当工作环境很好的时候，导致员工很有满足感，但是他并不关心工作本身。</p>
<p><strong>激励有时候不会发挥作用</strong><br>有些情况下，不管采用何种激励措施，都无法达到效果：</p>
<ol>
<li>工作量超量所造成的疲惫</li>
<li>角色不清，任务冲突</li>
<li>不公平待遇</li>
</ol>
<p>在这三种情况下，更应该切实的改变人们所处的状态，合理的工作量设计、清晰的责权利、公平的待遇。在这个基础之上，通过有效的激励措施，才能获得高的工作绩效。</p>
<h3 id="期望理论"><a href="#期望理论" class="headerlink" title="期望理论"></a>期望理论</h3><p>「人会成为他所期望的样子」这是一句大实话，人的进步都源于期望，也许来自于他人，也许来自于自身。<br>期望理论有三个基本条件：</p>
<ol>
<li>期望价，这个目标需要能够实现的，如果太高就没有可行性。</li>
<li>媒介，主要是要获取信任感，相信结果是可获得的，跟目标是一致的。</li>
<li>承诺会兑现，不管多少人达成期望，都一定要能实现当初的承诺。</li>
</ol>
<p>期望理论满足这三个基本条件，才能真正达到效果，激励人们向更高的期望努力。</p>
<h3 id="当下我更多可以做的激励动作"><a href="#当下我更多可以做的激励动作" class="headerlink" title="当下我更多可以做的激励动作"></a>当下我更多可以做的激励动作</h3><p>成本最低的而且最有效的激励措施，也就是性价比最高的激励措施：鼓掌、赞美、鲜花、隆重的仪式、授权与信任。</p>
<p>前三者（鼓掌、赞美、鲜花），我归纳为对付出的肯定，那么就归类为：</p>
<ol>
<li>肯定（鼓掌、赞美、鲜花）</li>
<li>仪式感</li>
<li>授权与信任</li>
</ol>
<p>对人们的结果，要及时的给予肯定，让他们知道有人看得到，并且得到欣赏，这也是人类最基本的社会述求。<br>在重要的事情上，要有一定的仪式感，例如一个项目的建立，一个团队的建立，一件重要事情的达成等等。<br>尤其重要的是授权与信任，这个我回想起两年前初来有赞的时候，跟前司很大不同的是，能得到很好的授权与信任，以及足够的自由和发挥空间。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>《管理的常识》这本书，在物理空间上，它很薄。但这不妨碍它能囊括很强大的内容，这些内容很适合细细品读与感悟。也很庆幸在这个时间遇到一本好书，让自己重新总结和审视过去的经验和见识。<br>另外，标题加了个「一」，是为了立个 Flag，让我继续读完这本书，然后再写一篇心得。<br>最后，管理，确实是一门科学，也是一门艺术。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《管理的常识》读后感-「一」&quot;&gt;&lt;a href=&quot;#《管理的常识》读后感-「一」&quot; class=&quot;headerlink&quot; title=&quot;《管理的常识》读后感 「一」&quot;&gt;&lt;/a&gt;《管理的常识》读后感 「一」&lt;/h1&gt;&lt;p&gt;陈春花的《管理的常识》是一本相见恨晚的书。在
    
    </summary>
    
      <category term="三省吾身" scheme="http://huang-jerryc.com/categories/%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>原汁原味的配方:「微信小程序支持 NPM」</title>
    <link href="http://huang-jerryc.com/2018/05/02/use-npm-in-weapp/"/>
    <id>http://huang-jerryc.com/2018/05/02/use-npm-in-weapp/</id>
    <published>2018-05-01T16:07:00.000Z</published>
    <updated>2019-07-07T10:28:45.723Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序本身不支持 npm 包的使用，目前市面上很多框架也有了相对应的解决方案。</p>
<p>本文旨在为那些不愿意引入第三方框架， 想在小程序环境中写原汁原味代码的人（例如我），提供一种解决问题的思路。</p>
<p>在现代的 Web 开发中，我们对 Webpack 已经再熟悉不过了，简单理解，它就是项目发布之前，把所有资源都打包好，然后提供一个入口文件，在入口模板中引入这个入口文件。</p>
<p>那么我的思路，就是利用 Webpack 把我们所有的 npm 依赖打包好，提供一个入口文件，在小程序开发中，我们通过这个入口文件，进而使用 npm 的依赖。</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181936" alt=""></p>
<p>我们最终实现的效果应该是这样的。</p>
<p>例如我们小程序的首页中，需要使用到 <code>moment</code></p>
<p>pages/home/home.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; moment &#125; <span class="built_in">require</span>(<span class="string">'../npm/index'</span>);</div><div class="line"><span class="keyword">const</span> time = moment();</div></pre></td></tr></table></figure>
<h1 id="Webpack-打包-npm-依赖"><a href="#Webpack-打包-npm-依赖" class="headerlink" title="Webpack 打包 npm 依赖"></a>Webpack 打包 npm 依赖</h1><p>webpack 默认输出的 <code>bundle.js</code> ，是一个立即执行的闭包，如以下：</p>
<p>使用 webpack.config.js 配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: <span class="string">'./foo.js'</span>,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'dist'</span>),</div><div class="line">    <span class="attr">filename</span>: <span class="string">'bundle.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>运行 <code>$ webpack</code> 生成的 <code>bundle.js</code> :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; </div><div class="line"></div><div class="line">  <span class="comment">// webpackBootstrap</span></div><div class="line"></div><div class="line">&#125;)([module1, module2, module3]);</div></pre></td></tr></table></figure>
<blockquote>
<p>示例代码：<a href="https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step1" target="_blank" rel="external">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step1</a></p>
</blockquote>
<p>这样的代码，显然没法达到我们要的效果。<br>幸好 webpack 提供了 <code>output.libraryTarget</code> 的配置项。</p>
<h2 id="output-libraryTarget-“commonjs2”"><a href="#output-libraryTarget-“commonjs2”" class="headerlink" title="output.libraryTarget: “commonjs2”"></a>output.libraryTarget: “commonjs2”</h2><p>对于 <code>output.libraryTarget: &quot;commonjs2&quot;</code> 官方解释：</p>
<blockquote>
<p>The return value of your entry point will be assigned to the module.exports.</p>
</blockquote>
<p>通过配置该属性，我们能保证 webpack 打包出来的 <code>bundle.js</code>，是模块化的。<br>当然 <code>output.libraryTarget</code> 还有其他的选项值，可以查阅<a href="https://webpack.js.org/configuration/output/#output-librarytarget" target="_blank" rel="external">官方文档</a>。</p>
<p>例如，使用 webpack.config.js 配置:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: <span class="string">'./foo.js'</span>,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'dist'</span>),</div><div class="line">    <span class="attr">filename</span>: <span class="string">'bundle.js'</span>,</div><div class="line">    <span class="attr">libraryTarget</span>: <span class="string">'commonjs2'</span>,</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>运行 <code>$ webpack</code> 生成的 <code>bundle.js</code> :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; </div><div class="line"></div><div class="line">  <span class="comment">// webpackBootstrap</span></div><div class="line"></div><div class="line">&#125;)([module1, module2, module3]);</div></pre></td></tr></table></figure>
<blockquote>
<p>示例代码：<a href="https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step2" target="_blank" rel="external">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step2</a></p>
</blockquote>
<p>这样，我们就可以通过 <code>require(&#39;bundle.js&#39;)</code>, 来使用 npm 依赖了。<br>在这个基础上，我们就可以打造一个使用 npm 依赖的入口。</p>
<h2 id="打造-npm-入口"><a href="#打造-npm-入口" class="headerlink" title="打造 npm 入口"></a>打造 npm 入口</h2><p>建立入口文件：npm.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> momennt = <span class="built_in">require</span>(<span class="string">'moment'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    momennt,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>配置文件：webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">entry</span>: <span class="string">'./entry.js'</span>,</div><div class="line">    <span class="attr">output</span>: &#123;</div><div class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'npm'</span>),</div><div class="line">        <span class="attr">filename</span>: <span class="string">'index.js'</span></div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>运行 <code>$ webpack</code>，输出 <code>./npm/index.js</code> 打包文件，对应的目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── entry.js</div><div class="line">├── npm</div><div class="line">│   └── index.js</div><div class="line">└── webpack.config.js</div></pre></td></tr></table></figure>
<blockquote>
<p>示例代码：<a href="https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step3" target="_blank" rel="external">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step3</a></p>
</blockquote>
<p>笨拙点的方法，你只需要把 <code>npm/index.js</code> 拷贝到你的项目中，就可以使用你所引入的 npm 包的内容了。</p>
<p>如果你的项目中使用了构建工具的话，就可以把「 webpack 打包 npm」 的这项任务加入到你的构建流程中。</p>
<p>我是使用 gulp 来做项目构建工作的，下面提供一种基于 gulp 的实现作为参考。</p>
<h1 id="结合-Gulp-做项目工程化"><a href="#结合-Gulp-做项目工程化" class="headerlink" title="结合 Gulp 做项目工程化"></a>结合 Gulp 做项目工程化</h1><p>工程目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── dist</div><div class="line">│   ├── npm</div><div class="line">│   │   └── index.js</div><div class="line">│   └── pages</div><div class="line">│       └── home</div><div class="line">│           └── home.js</div><div class="line">├── gulpfile.js</div><div class="line">└── src</div><div class="line">    ├── npm</div><div class="line">    │   └── index.js</div><div class="line">    └── pages</div><div class="line">        └── home</div><div class="line">            └── home.js</div></pre></td></tr></table></figure>
<p>而 gulpfile 负责两件事：</p>
<ol>
<li>把 src 的 js 文件通过 babel 编译到 dist 目录（示例中忽略其他 wxml、wxss 文件）</li>
<li>把 <code>npm/index.js</code> 通过 webpack 打包到 <code>dist/npm/index.js</code>，并压缩。</li>
</ol>
<p>gulpfile.js:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</div><div class="line"><span class="keyword">const</span> del = <span class="built_in">require</span>(<span class="string">'del'</span>);</div><div class="line"><span class="keyword">const</span> runSequence = <span class="built_in">require</span>(<span class="string">'run-sequence'</span>);</div><div class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">const</span> webpackStream = <span class="built_in">require</span>(<span class="string">'webpack-stream'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> webpackConfig = &#123;</div><div class="line">    <span class="attr">module</span>: &#123;</div><div class="line">        <span class="attr">loaders</span>: [&#123;</div><div class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">            <span class="attr">loader</span>: <span class="string">'babel-loader'</span>,</div><div class="line">            <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</div><div class="line">            <span class="attr">options</span>: &#123;</div><div class="line">                <span class="attr">presets</span>: [<span class="string">'es2015'</span>],</div><div class="line">            &#125;,</div><div class="line">        &#125;],</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">output</span>: &#123;</div><div class="line">        <span class="attr">filename</span>: <span class="string">'index.js'</span>,</div><div class="line">        <span class="attr">libraryTarget</span>: <span class="string">'commonjs2'</span>,        </div><div class="line">    &#125;,</div><div class="line">    <span class="attr">plugins</span>: [</div><div class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</div><div class="line">    ],</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 清空 ./dist 目录</span></div><div class="line">gulp.task(<span class="string">'clean'</span>, () =&gt; del([<span class="string">'./dist/**'</span>]));</div><div class="line"></div><div class="line"><span class="comment">// 打包 npm 依赖</span></div><div class="line">gulp.task(<span class="string">'npm'</span>, () =&gt; &#123;</div><div class="line">    gulp.src(<span class="string">'./src/npm/*.js'</span>)</div><div class="line">        .pipe(webpackStream(webpackConfig), webpack)</div><div class="line">        .pipe(gulp.dest(<span class="string">'./dist/npm'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 编译 JS 文件</span></div><div class="line">gulp.task(<span class="string">'scripts'</span>, () =&gt; &#123;</div><div class="line">    gulp.src([<span class="string">'./src/**/*.js'</span>, <span class="string">'!./src/npm/*.js'</span>])</div><div class="line">        .pipe(babel(&#123;</div><div class="line">            <span class="attr">presets</span>: [<span class="string">'stage-0'</span>, <span class="string">'es2015'</span>],</div><div class="line">        &#125;))</div><div class="line">        .pipe(gulp.dest(<span class="string">'./dist'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 开发模式命令</span></div><div class="line">gulp.task(<span class="string">'build'</span>, [<span class="string">'clean'</span>], () =&gt; runSequence(<span class="string">'scripts'</span>, <span class="string">'npm'</span>));</div></pre></td></tr></table></figure>
<blockquote>
<p>示例代码：<a href="https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step4" target="_blank" rel="external">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step4</a></p>
</blockquote>
<h1 id="关于控制-npm-文件代码量"><a href="#关于控制-npm-文件代码量" class="headerlink" title="关于控制 npm 文件代码量"></a>关于控制 npm 文件代码量</h1><p>微信限制了项目的代码量为 2M，就算使用了分包机制，最多也是 4M 的代码量。<br>区区一个 moment 库的话，就算压缩过，也需要两百多 KB，这对于我们的代码量，是很不友好的。<br>我们需要对 npm 的引入持非常谨慎的态度，去度量每个依赖包的大小，想尽各种办法减少依赖的代码量。<br>譬如<code>moment</code> 我们可以使用 <code>moment-mini</code> 来代替，后者压缩过后只需要 51KB。</p>
<p>而且我认为把 npm 的依赖放在一个入口文件中，会让我们可以对 npm 的依赖有一个全局的把握。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序本身不支持 npm 包的使用，目前市面上很多框架也有了相对应的解决方案。&lt;/p&gt;
&lt;p&gt;本文旨在为那些不愿意引入第三方框架， 想在小程序环境中写原汁原味代码的人（例如我），提供一种解决问题的思路。&lt;/p&gt;
&lt;p&gt;在现代的 Web 开发中，我们对 Webpack 已
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="微信小程序" scheme="http://huang-jerryc.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>「译」JavaScript框架的探索与变迁</title>
    <link href="http://huang-jerryc.com/2017/11/01/change-and-its-detection-in-javascript-frameworks/"/>
    <id>http://huang-jerryc.com/2017/11/01/change-and-its-detection-in-javascript-frameworks/</id>
    <published>2017-11-01T14:22:25.000Z</published>
    <updated>2020-07-21T08:12:37.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="译者言"><a href="#译者言" class="headerlink" title="译者言"></a>译者言</h2><p>近几年可谓是 JavaScript 的大爆炸纪元，各种框架类库层出不穷，它们给前端带来一个又一个的新思想。从以前我们用的 jQuery 直接操作 DOM，到 BackboneJS、Dojo 提供监听器的形式，在到 Ember.js、AngularJS 数据绑定的理念，再到现在的 React、Vue 虚拟 DOM 的思想。都是在当前 Web 应用日益复杂的时代，对于如何处理「应用状态」与「用户界面」之间如何更新的问题，带来更先进的解决方案。</p>
<p>本文是一篇从技术上，以数据变更和UI同步为方向，循序渐进的讲述 JavaScript 框架如何演进过来的。</p>
<p>本篇文章，给了我一个更加高纬度的视角，来看待 JavaScript 这些个框架。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在 2015 年，JavaScript 框架的选择并不少。在 Angular，Ember，React，Backbone 以及它们众多的竞争者中，有足够多的选择。</p>
<p>虽然可以通过不少方面来对比这些框架的不同，但是最让人感兴趣的是它们分别如何管理状态（state）的。特别的，通过思考这些框架分别如何处理状态变化是很有用的。它们都提供了什么样的工具让你把这些变化呈现给用户？ </p>
<p>如何处理应用状态（app state）与用户界面（user interface）之间的同步，长期以来都是用户界面开发如此复杂的主要原因。现在，我们有几个不同的处理方案。本文探索以下：Ember 的数据绑定，Angular 的脏检查、React 的虚拟DOM以及它与不可变数据结构（immutable data structures）之间的联系。</p>
<h2 id="数据映射-Projecting-Data"><a href="#数据映射-Projecting-Data" class="headerlink" title="数据映射 Projecting Data"></a>数据映射 Projecting Data</h2><p>我们首先讨论程序内部的状态与屏幕所看到的内容之间的映射。你把各种诸如 object，arrays，strings，以及 numbers 转换成一颗由诸如 texts、forms、links、buttons 和 images 组成的树状结构。在 Web 中，前者通常指 JavaScript 中的数据结构，而后者指的是 <a href="https://www.w3.org/DOM/" target="_blank" rel="external">DOM （Document Object Model）</a></p>
<p>我们经常称这个过程为渲染（rendering），你可以想象这个过程是从数据模型到用户界面的一个映射。当你把数据渲染成一个模板，你得到的是一个 DOM（或者说 HTML）。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/15B722FCBCB7A5D72D240DC5B55F7DDE.svg" alt="onchange_base.svg"></p>
<p>这个过程本身已经足够简单了，数据模型到用户界面之间的映射，并不总是那么的琐碎。它基本只是一个接受输入然后直接输出的函数。</p>
<p>在我们需要考虑数据开始随着时间而变化的时候，这件事就变得更有挑战性了。当用户进行操作或者其它某些操作导致数据产生变化的时候，用户界面需要呈现出这些变化。而且，由于重新构建 DOM 树的代价是极其昂贵的，我们要尽可能产生小的影响。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/1D6EF2506F41A57871712CBCAD1463F8.svg" alt="onchange_change.svg"></p>
<p>因为状态产生了变化，这比只是一次性渲染用户界面变得更加难。这就到了以下解决方案开始表演的时候了。</p>
<h2 id="服务器渲染-Server-Side-Rendering"><a href="#服务器渲染-Server-Side-Rendering" class="headerlink" title="服务器渲染 Server-Side Rendering"></a>服务器渲染 Server-Side Rendering</h2><blockquote>
<p>宇宙是永恒不变的，没有任何变化</p>
</blockquote>
<p>在 JavaScript 新纪元之前，你的 Web 应用的任何交互都会触发一趟服务器的环绕旅行。每一个点击和每一个表单提交都会卸载当前页面，一个请求发送到服务器，服务器响应一个新的页面，然后浏览器重新渲染。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_reload.svg" alt="onchange_reload.svg"></p>
<p>这种方式不需要前端管理任何的状态（state）。就前端范畴而言，当一些事情发生了(后端返回的数据)，整个过程就结束了。就算有状态，那也只是后端的范畴。前端只是由 HTML 和 CSS 构成，也许有时候会有些 JavaScript 撒在表面调味。</p>
<p>从前端来说，这是一个很简单的实现方式，但也是一个很慢的方式。每一个交互并不仅仅触发UI的重渲染，还涉及服务器的数据查询以及服务端渲染。</p>
<p>大多数人已经不再这样做了，我们可以在服务器端初始化我们的应用，然后转移到前端来做状态的管理（这也是 <a href="http://isomorphic.net/" target="_blank" rel="external">isomorphic JavaScript</a> 致力于的。）。已经有人在类似的<a href="https://signalvnoise.com/posts/3112-how-basecamp-next-got-to-be-so-damn-fast-without-using-much-client-side-ui" target="_blank" rel="external">更复杂的设计思想</a>中取得成功。</p>
<h2 id="JS第一代革命：手动重渲染"><a href="#JS第一代革命：手动重渲染" class="headerlink" title="JS第一代革命：手动重渲染"></a>JS第一代革命：手动重渲染</h2><blockquote>
<p>我不知道哪些需要渲染的，你来告诉我。</p>
</blockquote>
<p>第一代革命的 JavaScript 框架，如：Backbone.js, Ext JS 以及 Dojo。第一次在浏览器端引入了数据模型（Data Model）的概念，代替了以前那些直接操作 DOM 的轻量级的脚本代码。这意味着你终于可以在浏览器端管理状态了。当数据模型的上下文改变时，你需要做一些工作，让改变呈现在用户界面中。</p>
<p>这些框架的体系能分离你的模型和界面代码，但同时也留下了一大部分同步的工作给你。你可以监听某类事件的发生，但是你有义务去计算如何重新渲染以及如何落实到用户界面中。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_manual.svg" alt="onchange_manual.svg"></p>
<p>基于这种模型，作为开发者，你需要考虑大量的性能问题。由于你能控制什么时候和怎么处理更新，你可以从中做任意的做一些调整。这经常会面临一些权衡：简单的处理导致大面积的页面更新，或者强性能的处理来更新一小块页面。</p>
<h2 id="Ember-js-数据绑定"><a href="#Ember-js-数据绑定" class="headerlink" title="Ember.js: 数据绑定"></a>Ember.js: 数据绑定</h2><blockquote>
<p>由于我在控制你的模型和试图，我会确切知道如何重新渲染。</p>
</blockquote>
<p>当应用状态改变的时候，手动处理渲染工作，无可避免的增加了复杂度。很多框架旨在解决这个问题，<a href="https://emberjs.com" target="_blank" rel="external">Ember.js</a> 就是其中之一。</p>
<p>Ember，像 Backbone 一样，当数据模型改变的时候会触发某个事件。不同之处在于 Ember 同时提供了一些方法来接收这些事件。你可以把 UI 绑定到数据模型中，这意味着有一个监听器绑定到了 UI 上。该监听器当收到事件的时候，知道如何更新 UI。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_kvo.svg" alt="onchange_kvo.svg"></p>
<p>这是一个高效率的机制。尽管设置全部的监听器需要在初始化时多出一些工作，但是之后就能保证同步状态时的最小影响。当状态产生变化时， 只有真正需要更新的部分才会发生改变。</p>
<p>这种方式最大的牺牲是 Ember 需要时刻盯着数据模型。这意味着你需要通过 Ember 的 API 封装你的数据，以及你要更新数据的时候是使用 <code>foo.set(&#39;x&#39;,42)</code> 而不是 <code>foo.x = 42</code>，以此类推。</p>
<p>在未来 ES6 的 Proxies 可能会对这种模式产生一定的帮助。它让 Ember 可以通过装饰 object 来绑定那些监听器的代码。这就不用像传统方式那样重写 object 的 setter 方法了。</p>
<h2 id="AngularJS：脏检查"><a href="#AngularJS：脏检查" class="headerlink" title="AngularJS：脏检查"></a>AngularJS：脏检查</h2><blockquote>
<p>我不知道什么更新了，所以当更新的时候，我只能检查所有的东西。</p>
</blockquote>
<p>AngularJS 类似于 Ember，当状态改变的时候，必须人工去处理。但不同的是，AngularJS 从不同的角度来解决问题。</p>
<p>当你在 Angular 模板中引用你的数据，例如这样的语句 <code></code> ，Angular 不仅仅只是渲染数据，而且会这个特定的数据创建一个观察者。如此，只要你的应用中发生任何变化，Angular 都会检查这个观察者检视着的数据是否发生了改变。如果发生了改变，就会重新渲染这个数据对应的用户界面。这个过程称作脏检查（Dirty Checking）。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_watch.svg" alt="onchange_watch.svg"></p>
<p>这种监听改变的风格最大的好处就是，你可以在你的数据模型中使用任何姿势。Angular 对此没有任何限制，它不关心这个。没有基础的对象需要扩展，也没有 API 需要调用。</p>
<p>但坏处就是现在数据模型没有任何内建的检测手段告诉告诉框架哪些东西发生了改变，框架对是否或者哪里发生了改变没有任何洞察力。这意味着数据模型需要通过外部来监听改变，而 Angular 就是这样子做的：所有观察者在任何时间发生的任何改变，都需要被执行一次。点击事件，HTTP 响应，timeout 方法的触发，对于这些，观察者都需要执行一遍。</p>
<p>经常去执行所有观察者，这听起来像是性能的噩梦，但是它令人惊讶的快。这主要是因为在检查到任何改变之前，没有 DOM 的操作过程，而原生的 JavaScript 引用对象的检查平均消耗的性能是廉价的。但是当你要处理大量的 UI 或者经常性触发重新渲染，那么额外的性能优化手段就变得很有必要了。</p>
<p>Ember 和 Angular 都即将得益于即将到来的标准：ECMAScript7 的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe" target="_blank" rel="external">Object.observe</a> 功能，很适合 Angular。它提供了原生的 API 给你用来监听对象属性的变化。尽管这样，Angular 不需要支持所有的用例，因为 Angular 的观察者相对于简单的监听对象属性，可以做到的更好。</p>
<p>即将到来的 Angular 2 在检测改变这件事上带来了很多有趣的更新，最近 <a href="http://victorsavkin.com/post/110170125256/change-detection-in-angular-2" target="_blank" rel="external">Victor Savkin 的一篇文章</a>有介绍到。</p>
<p>关于这个主题，也可以看：<a href="https://www.youtube.com/watch?v=jvKGQSFQf10&amp;feature=youtu.be" target="_blank" rel="external">Victor’s ng-conf talk</a></p>
<h2 id="React-虚拟-DOM"><a href="#React-虚拟-DOM" class="headerlink" title="React: 虚拟 DOM"></a>React: 虚拟 DOM</h2><blockquote>
<p>我不知道到底哪些发生了变化，所以我只能重新渲染所有东西，然后看一下有哪些不同。</p>
</blockquote>
<p>React 有很多有趣的特性，但是我们讨论的最有趣的特性是虚拟 DOM。</p>
<p>像 Angular 一样，React 不会对数据模型进行限制，而是让你使用你认为合适的任何对象和数据结构。那么，它是如何在存在改变的情况下使 UI 保持最新呢？</p>
<p>React 所做的是有效的把我们带回服务器渲染时代，当时我们还不关心状态变化：每当某处发生改变的时候，它会从头重新渲染整个 UI。这可以显著的简化 UI 的代码。大部分情况，你不会关心如何在 React 中维护状态。就像服务器渲染一样，渲染一次就算了。当组件需要变更时，它只能再次重新渲染。组价的初始化渲染和更细它的数据之间，没有任何区别。</p>
<p>如果故事就这么结束的话，它看起来的确非常低效。然而，React 在重新渲染方面，有点特殊。</p>
<p>当 React 进行重新渲染时，它首先会渲染到虚拟 DOM 中，这不是一个实际的 DOM 对象的图。而是一个轻量级的，有纯粹的 object 和 array 组成的纯 JavaScript 的数据结构，它代表着一个真实的 DOM 对象的图。</p>
<p>然后，一个独立的进程会根据虚拟 DOM 的结构来创建那些在屏幕上显示的真实的 DOM 元素。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_vdom_initial.svg" alt="onchange_vdom_initial.svg"></p>
<p>之后，当变化发生的时候，一个新的虚拟 DOM 会被从头到尾创建出来。这个新的虚拟 DOM 将映射出数据模型的新的状态。现在 React 在手上有两个虚拟 DOM：一个新的，一个旧的。然后会对两个虚拟 DOM 进行一个对比算法，得出它们之间的一组变化。有且只有这些更改会被应用到真实 DOM 中：此元素已添加，此属性以改变，等等。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_vdom_change.svg" alt="onchange_vdom_change.svg"></p>
<p>所以 React 起码至少有一个好处，就是你不用追踪变化了。你只需要每次重新渲染整个 UI ，然后无论改变了什么最终都会得到相应的结果。React 的虚拟 DOM 对比算法，能让你做到这一点，并且最大限度的节省昂贵的 DOM 操作。</p>
<h2 id="Om-不可改变的数据结构"><a href="#Om-不可改变的数据结构" class="headerlink" title="Om: 不可改变的数据结构"></a>Om: 不可改变的数据结构</h2><blockquote>
<p>我确切的知道哪些没有改变。</p>
</blockquote>
<p>虽然 React 的虚拟 DOM 相当的块，但是当你的 UI 非常庞大或者经常性渲染的时候（例如：每秒高达 60 次），它依然会面临瓶颈。</p>
<p>问题在于，真的没办法每次都渲染出整个虚拟 DOM，除非你引入一些方法来控制数据模型的改变，就像 Ember 做的一样。</p>
<p>一种控制变化的办法是 <a href="http://en.wikipedia.org/wiki/Persistent_data_structure" target="_blank" rel="external">不可改变的，持久化的数据结构</a>。这些看起来似乎很适合使用在 React 的虚拟 DOM 中，正如 David Nolen 在 <a href="https://github.com/omcljs/om" target="_blank" rel="external">Om</a> 库中所做的 <a href="http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/" target="_blank" rel="external">工作</a> 那样，一个构建于 React 和 <a href="https://github.com/clojure/clojurescript" target="_blank" rel="external">ClojureScript</a> 之上的库。</p>
<p>有一点关于不可改变数据结构的是，顾名思义，你永远不能改变它，只能产生新的版本。如果你想改变一个对象的属性，你只能新建一个对象和属性，因为你不能改变已经存在的那一个。由于持久化数据结构的工作方式，这比听起来更加有效率。</p>
<p>这意味着在检测变化方面，当 React 组件都只由不可变数据组成的时候，只有一个逃生窗口：当你重新渲染一个组件时，组件的状态仍然指向上次渲染时的相同数据结构，你就可以跳过这次重新渲染。你可以使用该组件的先前的虚拟 DOM 以及源自该组件的整个组件树。没有必要进一步挖掘，因为在这个状态中所有东西都不可能改变。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_immutable.svg" alt="onchange_immutable.svg"></p>
<p>就像 Ember 一样，像 Om 的这种库不允许在你的数据中使用旧的 JavaScript 对象图。你必须在不可变数据结构中构建你的数据模型，从而才能在其中得到好处。我会赞同这样的做法，因为这一次你这样做并不是为了取悦框架本身。你这样做只是因为这是一个又简单又好的方式去管理你的应用状态。使用不可变数据结构的主要好处，并不是提升渲染性能，而是简化你的应用结构。</p>
<p>虽然 Om 和 ClojureScript 已经讲 React 和不可变数据结构融合起来，但是他们并不是圈子里面的唯一组合。而仅仅使用 React 和 Facebook 的 <a href="http://facebook.github.io/immutable-js/" target="_blank" rel="external">Immutable-js</a> 是完全可能的。这个库的作者 Lee Byron 在最近的一次 React.js 为主题的会议中进行了一个 <a href="https://www.youtube.com/embed/I7IdS-PbEgI" target="_blank" rel="external">精彩的介绍</a>。</p>
<p>同时我建议看一下 Rich Hickey’s 的 <a href="http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey" target="_blank" rel="external">Persistent Data Structures And Managed References</a>, 去了解状态管理的方法。</p>
<p>我自己现在一直在为不可变数据数据结构 <a href="http://blog.deveo.com/immutability-in-ruby-part-1-data-structures/" target="_blank" rel="external">写诗</a>，但我绝对没有预见到它会进入前端 UI 框架行列。它看起来似乎不遗余力的发生着，而 Angular 的人 <a href="http://victorsavkin.com/post/110170125256/change-detection-in-angular-2" target="_blank" rel="external">正在为支持这个而努力着</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>检测变化时 UI 开发中的核心问题，而 JavaScript 框架们以各种方式解决这个问题。</p>
<p>EmberJS 能在它们发生变化的时候检测到，因为它控制着你的数据模型 API，并且可以在你调用它的时候触发事件。</p>
<p>Angular.js 是事后进行检测， 它通过重新运行你已经在 UI 中注册的所有数据绑定，来检测它们的值是否已经发生变化。</p>
<p>React 的检测方法是通过把整个 UI 重新渲染成一个虚拟 DOM，然后和旧的版本进行对比。无论改变了什么，都可以给真实 DOM 打上个补丁。</p>
<p>React 和 不可变数据结构的组合，对比纯粹的 React 有所增强，通过快速的在组件树中标记不可变的节点。因为组件内的变化是不被允许的。但是，这不是主要出于性能的原因，而是由于它对整个应用程序体系结构有积极的影响。</p>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="http://teropa.info/blog/2015/03/02/change-and-its-detection-in-javascript-frameworks.html" target="_blank" rel="external">Changes and Its detection of JavaScript Framework</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;译者言&quot;&gt;&lt;a href=&quot;#译者言&quot; class=&quot;headerlink&quot; title=&quot;译者言&quot;&gt;&lt;/a&gt;译者言&lt;/h2&gt;&lt;p&gt;近几年可谓是 JavaScript 的大爆炸纪元，各种框架类库层出不穷，它们给前端带来一个又一个的新思想。从以前我们用的 jQuer
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="javascript" scheme="http://huang-jerryc.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>有赞微信小程序分享 — 概念篇</title>
    <link href="http://huang-jerryc.com/2017/08/31/yz-share-about-wxapp--cencept/"/>
    <id>http://huang-jerryc.com/2017/08/31/yz-share-about-wxapp--cencept/</id>
    <published>2017-08-31T05:15:02.000Z</published>
    <updated>2020-07-21T08:12:37.394Z</updated>
    
    <content type="html"><![CDATA[<p>在 2016 年 9 月 23 日 微信小程序内测开始以来，有赞的产品与技术一直紧跟着小程序的步伐。并且在 2017年1月9日 微信小程序发布的同时上线了有赞微商城小程序和有赞精选小程序。并且紧跟着开源了小程序的 UI 库：<a href="https://github.com/youzan/zanui-weapp" target="_blank" rel="external">zanui-weapp</a></p>
<p>在我加入有赞不久后，就参与了微信小程序产品线的开发。<br>随着今年微信官方大力推广和迭代，微信小程序可谓渐渐形成一个新重量级现象，对于自身来说，除了单纯的掌握技术上的开发姿势以外，还需对整个小程序生态以及未来的动向有足够的认识和了解。<br>于是乎本着研究与学习，有了这一次内部分享。<br>趁着课余时间，整理成文，与君分享。</p>
<h1 id="微信开发体系"><a href="#微信开发体系" class="headerlink" title="微信开发体系"></a>微信开发体系</h1><p>微信开发，是一个体系。<br>无论是开发移动应用，网站应用，都可以接入微信生态，例如实现微信账号登录，实现 APP 分享到微信朋友圈和联系人。<br>除了自有的应用，还可以在公众号内进行应用开发，为订阅号或者服务号提供更强大的功能和交互。<br>现在又有了小程序，除了开发工具类应用更简单以外，连接线上线下的场景更丰富。<br>在我认为，国内的互联网产品中，多多少少都会接触到微信的开发体系。<br>因为这是一个庞大的流量入口啊。</p>
<h2 id="三个平台"><a href="#三个平台" class="headerlink" title="三个平台"></a>三个平台</h2><p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/F0C87F9DD75168C4C99AC1BDB4C7AAD4.jpg" alt="三个平台"></p>
<p>在接触微信的开发体系中，接触最多的是这三个平台。<br>我们站在一个更高的维度来看，就知道小程序处于微信开发体系中的哪个位置了。</p>
<h3 id="开放平台"><a href="#开放平台" class="headerlink" title="开放平台"></a>开放平台</h3><p>开放平台下提供了以下支持：</p>
<ul>
<li><strong>微信账号登录</strong>：让你的应用接入微信账号体系。</li>
<li><strong>微信分享与收藏功能</strong>：这个目前在移动应用特有，可以在 APP 中掉起微信分享与收藏。</li>
<li><strong>微信智能接口</strong>：支持调用微信图像、语音等智能识别接口。</li>
<li><strong>微信支付</strong>：调用微信支付接口</li>
<li><strong>第三方平台</strong>：拥有第三方平台资格之后，就能帮助授权用户实现公众号和小程序的代开发服务了。在公众号红利时代，通过该平台就催生了一大波微信公众账号第三方管理平台。</li>
</ul>
<p>根据目的不同，你可能要申请不同的应用：</p>
<ul>
<li><strong>网站应用</strong></li>
<li><strong>移动应用</strong></li>
<li><strong>第三方平台</strong></li>
</ul>
<h3 id="公众平台"><a href="#公众平台" class="headerlink" title="公众平台"></a>公众平台</h3><p>微信是 2011 年 1 月推出的，而公众平台是  2012 年 8 月推出的。<br>公众平台的推出，带来了一个继微博之后的新红利时代。大量的企业、媒体、公共机构、明星名人、个人用户都纷纷进军公众平台。<br>需要搞清楚的一个概念是，起初并没有「订阅号」、「服务号」、「企业号」之分。<br>公众平台推出之后，在 2013 年 8 月的时候分成订阅号和服务号，然后在 2014 年 9 月的时候新增了企业号。<br>所以我们所说的「公众号」统称了「订阅号」、「服务号」、「企业号」。</p>
<p>所以我们在公众平台，根据自身情况，申请以下几类账号：</p>
<ul>
<li><strong>订阅号</strong>：偏向提供传播服务，每天可推送一条消息，但是开放的功能相对服务号来说有限。</li>
<li><strong>服务号</strong>：偏向提供功能服务，每月可推送四条消息，开放出了更多高级功能。</li>
<li><strong>企业号</strong>：偏向员工管理。</li>
<li><strong>小程序</strong>：嗯，这就是我们今天的主题。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</li>
</ul>
<h3 id="商户平台"><a href="#商户平台" class="headerlink" title="商户平台"></a>商户平台</h3><p>如果你需要拥有微信支付能力，首先要注册商户平台。<br>在拥有微信支付资格之后，除了可以在开发过程中通过接口调用，唤起微信支付以外。<br>在线下还可以实现扫码支付、刷卡支付等场景。</p>
<h2 id="账号体系"><a href="#账号体系" class="headerlink" title="账号体系"></a>账号体系</h2><p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/ADD94BAC954A36120ADB41E7A8546FCB.jpg" alt="微信账号体系"></p>
<p>在接入微信账号的时候，在我们申请的应用（网站应用、移动应用、公众号、小程序），对于用户都有一个 OpenID，但是同个用户在多个应用下的 OpenID 是不一样的。<br>而如果想打通多个应用的用户的话，做法就是注册开放平台账号，然后把多个应用绑定到同一个开放平台账号下，这样就能获取 UnionID。</p>
<p>而小程序对于 UnionID 有一个特别注意的地方：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/EB40AFD817F2807B2A1626FACF25FE7C.jpg" alt="UnionID 机制"></p>
<p>小程序中，在绑定同一个开放平台账号的前提下。如果其他相同主体的应用账号被用户授权过之后，在小程序中就无需再次授权，直接获取 UnionID（正常情况下，获取 UnionID 需要用户授权的）。</p>
<h2 id="相同主体"><a href="#相同主体" class="headerlink" title="相同主体"></a>相同主体</h2><p>那么「相同主体」是什么概念？<br>在我们注册应用之后，要真正部署到线上之前，都需要进行「认证主体」的步骤。<br>对于个人来说，主体就是你本人，通过身份证标记唯一性。<br>而对于企业来说，主体就是企业本身，通过营业执照来标记唯一性。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/0ABA321D4E60DC52F7B7F9DB8D444B6C.jpg" alt="相同主体"></p>
<p>在任何一个以上线的公众号或者小程序中的详细信息，都可以查看得到本体信息。</p>
<h1 id="微信小程序的能力"><a href="#微信小程序的能力" class="headerlink" title="微信小程序的能力"></a>微信小程序的能力</h1><p>从 2016 年底发布的小程序，在 2017 年快速推进，每个月都会有迭代，而且大部分更新发布的时间都在凌晨。<br>在此心痛微信小程序团队 10 秒钟。<br>然后我们从截止 8月18日 回顾将近一年的时间，小程序的更新迭代来感受小程序具备哪些能力。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/2EC3DDD2B7877249747FB6CADE85C9C4.png" alt="小程序更新回顾"></p>
<h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/1951C347D0577BA466B972987B288CAE.png" alt="数据分析"></p>
<p>对于数据分析的需求，其实我们可以有很多选择。</p>
<p><strong>【小程序后台】</strong><br>在小程序的后台，除了可以看到常见维度的访问数据以外，还支持收集自定义事件。<br>并且还提供了 API，我们就可以在内部的管理后台中收集这些数据，进行分析和展示。</p>
<p><strong>【官方小程序】</strong><br>我们可以在微信的小程序入口搜索：《小程序数据助手》<br>这是官方开发的在移动端查看小程序运营数据的小程序。</p>
<p><strong>【第三方平台】</strong><br>以下是收集的一些提供数据相关服务的第三方平台 (还没有验证可用性，需要自行判断)：</p>
<ul>
<li><a href="https://www.talkingdata.com/" target="_blank" rel="external">TalkingData</a></li>
<li><a href="http://www.aldwx.com/" target="_blank" rel="external">阿拉丁</a></li>
<li>友盟：目前还找不到支持微信小程序的 SDK。</li>
</ul>
<p><strong>【数据埋点】</strong><br>对于数据埋点需求，以下是收集的一些 Saas 服务(还没有验证可用性，需要自行判断)：</p>
<ul>
<li><a href="http://developer.qq.com/wiki/mta/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5.html" target="_blank" rel="external">腾讯 MTA</a></li>
<li><a href="https://growingio.kf5.com/hc/kb/section/1007183/" target="_blank" rel="external">GrowingIO</a></li>
</ul>
<h1 id="社区与资源"><a href="#社区与资源" class="headerlink" title="社区与资源"></a>社区与资源</h1><p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/9628CBA157FD3EBF8DA6AD6E63D574AB.png" alt="资源"></p>
<p>我们需要关注小程序生态圈的动态，通过关注一些媒体、社区，是很有用的。</p>
<ul>
<li><a href="https://github.com/justjavac/awesome-wechat-weapp" target="_blank" rel="external">awesome-wxapp</a>: justjavac 创建的 github 仓库，收集了大量有关小程序的资源。</li>
<li>知晓程序：是爱范儿旗下专注小程序生态的品牌，会提供很多不错的小程序咨询。</li>
<li><a href="http://www.wxapp-union.com/" target="_blank" rel="external">微信小程序联盟</a>：一个社区网站，有大量的技术教程，以及众多开发者遇到的坑。</li>
<li><a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=1504102317" target="_blank" rel="external">官方文档</a>：再者就是微信的官方文档了。讲真，这是看过微信中最良心的开发文档。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 2016 年 9 月 23 日 微信小程序内测开始以来，有赞的产品与技术一直紧跟着小程序的步伐。并且在 2017年1月9日 微信小程序发布的同时上线了有赞微商城小程序和有赞精选小程序。并且紧跟着开源了小程序的 UI 库：&lt;a href=&quot;https://github.c
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="小程序" scheme="http://huang-jerryc.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>加深对 JavaScript This 的理解</title>
    <link href="http://huang-jerryc.com/2017/07/15/understand-this-of-javascript/"/>
    <id>http://huang-jerryc.com/2017/07/15/understand-this-of-javascript/</id>
    <published>2017-07-15T02:40:00.000Z</published>
    <updated>2017-07-16T03:54:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>我相信你已经看过很多关于 JavaScript 的 <code>this</code>  的谈论了，既然你点进来了，不妨继续看下去，看是否能帮你加深对 <code>this</code> 的理解。</p>
<p>最近在看 <a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="external">《You Dont Know JS》</a> 这本书，不得感叹，就算用了 JS 很多年的老前端来看这本书，我觉得还是会有不少的收获。</p>
<p>其中关于 <code>this</code> 的讲解，更是加深了我对 <code>this</code> 的理解，故整理知识点，再加上自身的理解，以自己的语言来描述。<br>对读者来说，算是二手知识，这本书是开源的，可以到本书的 Github 项目地址学习一手的知识。</p>
<p>首先有一句大家都明白的话，我还是要强调一遍：<br><strong>「<code>this</code> 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。」</strong></p>
<p>这句话很重要，这是理解 <code>this</code> 原理的基础。<br>而在讲解 <code>this</code> 之前，先要理解一下作用域的相关概念。</p>
<h1 id="「词法作用域」与「动态作用域」"><a href="#「词法作用域」与「动态作用域」" class="headerlink" title="「词法作用域」与「动态作用域」"></a>「词法作用域」与「动态作用域」</h1><p>通常来说，作用域一共有两种主要的工作模型。</p>
<ul>
<li>词法作用域</li>
<li>动态作用域</li>
</ul>
<p>词法作用域是大多数编程语言所采用的模式，而动态作用域仍有一些编程语言在用，例如 Bash 脚本。<br>而 JavaScript 就是采用的词法作用域，也就是在编程阶段，作用域就已经明确下来了。</p>
<p>思考下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);   <span class="comment">// 输出 2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">3</span>;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</div><div class="line"></div><div class="line">bar()</div></pre></td></tr></table></figure>
<p>因为 JavaScript 所用的是词法作用域，自然 <code>foo()</code> 声明的阶段，就已经确定了变量 <code>a</code> 的作用域了。</p>
<p>倘若，JavaScript 是采用的动态作用域，<code>foo()</code> 中打印的将是 <code>3</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);   <span class="comment">// 输出 3 （不是 2）</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">3</span>;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</div><div class="line"></div><div class="line">bar()</div></pre></td></tr></table></figure>
<p>而 JavaScript 的 <code>this</code> 机制跟动态作用域很相似，是在运行时在被调用的地方动态绑定的。</p>
<h1 id="this-的四种绑定规则"><a href="#this-的四种绑定规则" class="headerlink" title="this 的四种绑定规则"></a>this 的四种绑定规则</h1><p>在 JavaScript 中，影响 this 指向的绑定规则有四种：</p>
<ul>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>显式绑定</li>
<li>new 绑定</li>
</ul>
<h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>这是最直接的一种方式，就是不加任何的修饰符直接调用函数，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)   <span class="comment">// 输出 a</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;  <span class="comment">//  变量声明到全局对象中</span></div><div class="line"></div><div class="line">foo();</div></pre></td></tr></table></figure>
<p>使用 <code>var</code> 声明的变量 <code>a</code>，被绑定到全局对象中，如果是浏览器，则是在 <code>window</code> 对象。<br><code>foo()</code> 调用时，引用了默认绑定，<code>this</code> 指向了全局对象。</p>
<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>这种情况会发生在调用位置存在「上下文对象」的情况，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj1 = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  foo,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj2 = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">  foo,</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj1.foo();   <span class="comment">// 输出 1</span></div><div class="line">obj2.foo();   <span class="comment">// 输出 2</span></div></pre></td></tr></table></figure>
<p>当函数调用的时候，拥有上下文对象的时候，<code>this</code> 会被绑定到该上下文对象。<br>正如上面的代码，<br><code>obj1.foo()</code> 被调用时，<code>this</code> 绑定到了 <code>obj1</code>,<br>而 <code>obj2.foo()</code> 被调用时，<code>this</code> 绑定到了 <code>obj2</code>。</p>
<h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p>这种就是使用 <code>Function.prototype</code> 中的三个方法 <code>call()</code>, <code>apply()</code>, <code>bind()</code> 了。<br>这三个函数，都可以改变函数的 <code>this</code> 指向到指定的对象，<br>不同之处在于，<code>call()</code> 和 <code>apply()</code> 是立即执行函数，并且接受的参数的形式不同：</p>
<ul>
<li><code>call(this, arg1, arg2, ...)</code></li>
<li><code>apply(this, [arg1, arg2, ...])</code></li>
</ul>
<p>而 <code>bind()</code> 则是创建一个新的包装函数，并且返回，而不是立刻执行。</p>
<ul>
<li><code>bind(this, arg1, arg2, ...)</code></li>
</ul>
<p><code>apply()</code> 接收参数的形式，有助于函数嵌套函数的时候，把 <code>arguments</code> 变量传递到下一层函数中。</p>
<p>思考下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);  <span class="comment">// 输出 1</span></div><div class="line">  bar.apply(&#123;<span class="attr">a</span>: <span class="number">2</span>&#125;, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">b</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a + b);  <span class="comment">// 输出 5</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">foo(<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>上面代码中， <code>foo()</code> 内部的 <code>this</code> 遵循默认绑定规则，绑定到全局变量中。<br>而 <code>bar()</code> 在调用的时候，调用了 <code>apply()</code> 函数，把 <code>this</code> 绑定到了一个新的对象中 <code>{a: 2}</code>，而且原封不动的接收 <code>foo()</code> 接收的函数。</p>
<h2 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h2><p>最后一种，则是使用 <code>new</code> 操作符会产生 <code>this</code> 的绑定。<br>在理解 <code>new</code> 操作符对 <code>this</code> 的影响，首先要理解 <code>new</code> 的原理。<br>在 JavaScript 中，<code>new</code> 操作符并不像其他面向对象的语言一样，而是一种模拟出来的机制。<br>在 JavaScript 中，所有的函数都可以被 <code>new</code> 调用，这时候这个函数一般会被称为「构造函数」，实际上并不存在所谓「构造函数」，更确切的理解应该是对于函数的「构造调用」。</p>
<p>使用 <code>new</code> 来调用函数，会自动执行下面操作：</p>
<ol>
<li>创建一个全新的对象。</li>
<li>这个新对象会被执行 [[Prototype]] 连接。</li>
<li>这个新对象会绑定到函数调用的 this。</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li>
</ol>
<p>所以如果 <code>new</code> 是一个函数的话，会是这样子的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">Constructor, ...args</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> obj = &#123;&#125;;   <span class="comment">// 创建一个新对象</span></div><div class="line">    <span class="built_in">Object</span>.setPrototypeOf(obj, Constructor.prototype);  <span class="comment">// 连接新对象与函数的原型</span></div><div class="line">    <span class="keyword">return</span> Constructor.apply(obj, args) || obj;   <span class="comment">// 执行函数，改变 this 指向新的对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">New(Foo, <span class="number">1</span>);  <span class="comment">// Foo &#123; a: 1 &#125;</span></div></pre></td></tr></table></figure>
<p>所以，在使用 <code>new</code> 来调用函数时候，我们会构造一个新对象并把它绑定到函数调用中的 <code>this</code> 上。</p>
<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>如果一个位置发生了多条改变 this 的规则，那么优先级是如何的呢？</p>
<p>看几段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 显式绑定 &gt; 隐式绑定</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj1 = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">    foo,</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj1.foo();     <span class="comment">// 输出 2</span></div><div class="line">obj1.foo.call(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;);      <span class="comment">// 输出 1</span></div></pre></td></tr></table></figure>
<p>这说明「显式绑定」的优先级大于「隐式绑定」</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// new 绑定 &gt; 显式绑定</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bar = foo.bind(obj1);</div><div class="line">bar(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// 输出 &#123;a:2&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj2 = <span class="keyword">new</span> bar(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// 输出 &#123;a:2&#125;</span></div><div class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// 输出 foo &#123; a: 3 &#125;</span></div></pre></td></tr></table></figure>
<p>这说明「new 绑定」的优先级大于「显式绑定」<br>而「默认绑定」，毫无疑问是优先级最低的。<br>所以优先级顺序为：</p>
<p><strong>「new 绑定」 &gt; 「显式绑定」 &gt; 「隐式绑定」 &gt; 「默认绑定。」</strong></p>
<h1 id="所以，this-到底是什么"><a href="#所以，this-到底是什么" class="headerlink" title="所以，this 到底是什么"></a>所以，this 到底是什么</h1><p><code>this</code> 并不是在编写的时候绑定的，而是在运行时绑定的。它的上下文取决于函数调用时的各种条件。<br><code>this</code> 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。<br>当一个函数被调用时，会创建一个「执行上下文」，这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。<code>this</code> 就是这个记录的一个属性，会在函数执行的过程中用到。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes" target="_blank" rel="external">《You Dont Know JS》- this &amp; Object Prototypes</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我相信你已经看过很多关于 JavaScript 的 &lt;code&gt;this&lt;/code&gt;  的谈论了，既然你点进来了，不妨继续看下去，看是否能帮你加深对 &lt;code&gt;this&lt;/code&gt; 的理解。&lt;/p&gt;
&lt;p&gt;最近在看 &lt;a href=&quot;https://github.co
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="javascript" scheme="http://huang-jerryc.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>谈谈像素以及微信小程序的 rpx</title>
    <link href="http://huang-jerryc.com/2017/05/21/talk-about-pixel-and-rpx/"/>
    <id>http://huang-jerryc.com/2017/05/21/talk-about-pixel-and-rpx/</id>
    <published>2017-05-21T06:21:25.000Z</published>
    <updated>2020-07-21T08:12:37.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在负责有赞的某个业务的微信小程序开发，这是我第一次着手微信小程序的开发，这个过程中发现微信小程序所定义的一套 WXSS (WeiXin Style Sheets) 中有一个有趣的长度单位 <code>rpx</code>，即 responsive pixel。<br>根据官方的描述：</p>
<blockquote>
<p>rpx（responsive pixel）， 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p>
</blockquote>
<p>平时我们一般会用 <code>em</code> 或者 <code>rem</code> 来做屏幕适配，而在微信小程序中，可以方便的借助 <code>rpx</code> 来完成这项工作。</p>
<p>那么怎么理解 <code>rpx</code>，还有它与 <code>px</code> 之间什么关系？什么是物理像素？<br>为了更好理解 <code>rpx</code>，我打算聊聊下面的一些概念：</p>
<ol>
<li>像素 (Pixel)</li>
<li>PPI (Pixels per inch 每英尺像素)</li>
<li>DPR (Device pixel ratio)</li>
</ol>
<h1 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h1><p>像素，英文单词：pixel，是英语单词 「picture」 的简写 「pix」，加上 「element」 的简写 「el」，合成的词汇，表示「图像元素」的意思。<br>一个像素只能表达一个色块，是显示的最小的一个单元。</p>
<p>而在我们写代码的时候，可以把像素分为两种：</p>
<ol>
<li>物理像素 Physical pixels</li>
<li>逻辑像素 Logical pixels</li>
</ol>
<h2 id="物理像素"><a href="#物理像素" class="headerlink" title="物理像素"></a>物理像素</h2><p>也被称为设备像素 (Device independent pixels)，即设备在出厂的时候就已经固定了像素。</p>
<p>我们来看一下 iPhone6 (左图) 与 iPhone6 plus (右图) 的官方显示屏的规格说明：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/518488434BEC1074B675EB42A5A57AEF.png" alt="iPhone6 &amp; iPhone6 plus 规格"></p>
<p>iPhone6 是 <code>1334px x 750px</code> 的像素分辨率，意思是当手机竖放的时候，横向有 750 个物理像素，纵向有 1334 个物理像素。</p>
<h2 id="逻辑像素"><a href="#逻辑像素" class="headerlink" title="逻辑像素"></a>逻辑像素</h2><p>在 CSS 中也被称为 CSS 像素 (CSS pixels)，是为 Web 开发者创造的，在 CSS 和 JavaScript 中使用的一个抽象的层，每一个 CSS 声明和几乎所有的 Javascript 属性都使用 CSS 像素。</p>
<p>例如我们平时使用 Chrome 的设备调试工具的时候，iPhone6 是高 <code>667px</code>，宽是 <code>375px</code>，与苹果官方的 <code>1334px x 750px</code>，长宽分别少了 2 倍，那么面积就少了 4 倍。这就是经常说的 Retina 屏幕用四个(物理)像素表示一个(逻辑)像素。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/9C4CD0061C94690AF81DB8DED8F71252.png" alt="Chrome 下 iPhone6 逻辑像素"></p>
<h1 id="PPI"><a href="#PPI" class="headerlink" title="PPI"></a>PPI</h1><p>Pixels per inch，每英寸像素，也被称为像素密度，意思是一英寸中有多少个物理像素。<br>其中 1英寸 (inch) = 2.54厘米 (cm)。</p>
<p>回顾一下上面的 iPhone6 和 iPhone6 plus 的官方规格说明图，其中有 <code>ppi</code> 这一项，iPhone6 是 <code>326ppi</code>，iphone6 plus 是 <code>401ppi</code>。</p>
<h2 id="PPI-怎么算出来的？"><a href="#PPI-怎么算出来的？" class="headerlink" title="PPI 怎么算出来的？"></a>PPI 怎么算出来的？</h2><p>要计算显示器的每英寸像素值，首先要确定屏幕的尺寸和分辨率。<br>PPI 计算公式：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/855BB6047CE2CA7F9DBBF1791D52C6CC.gif" alt="PPI 计算公式"></p>
<p>其中，</p>
<ul>
<li>dp (device pixel) 为屏幕对角线的分辨率</li>
<li>wp (width pixel) 为屏幕横向分辨率</li>
<li>hp (height piexl) 为屏幕纵向分辨率</li>
<li>di (device inch) 为屏幕对角线的长度(单位为英寸)。</li>
</ul>
<p>以 iPhone6 为例：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/2A67EB1D8C0873E419C676DB430570C2.gif" alt="iPhone6 PPI 计算"></p>
<p>四舍五入那便是 <code>326ppi</code> 了。</p>
<h2 id="物理像素有多大？"><a href="#物理像素有多大？" class="headerlink" title="物理像素有多大？"></a>物理像素有多大？</h2><p>「物理像素」是有特定长度的，这取决于 ppi 值。</p>
<p>那么如何求出一个设备的物理像素的长度？<br>因为绝大多数设备的物理像素都是方形的，我们可以假设当前设备的像素是方形的。<br>那么，</p>
<ul>
<li>iPhone6 中每个像素长度：1inch / 326ppi ≈ 0.003 inch = 0.0762mm</li>
<li>iPhone6 plus 中每个像素长度：1inch / 401ppi ≈ 0.002 inch = 0.0508mm</li>
</ul>
<p>可以看出 iPhone6 plus 的屏幕制作工艺更加精细。<br>因为像素越小，那么单位面积内像素点就越多，显示的效果人眼就越难看出毛刺。<br>用来显示一份图像的像素越多，效果就越接近现实。</p>
<p>和物理像素不同，「逻辑像素」没有特定的物理长度的，只是表示显示设备中最小的显示单元，优秀的显示设备完全可以把显示单元做的更加小，以达到更好的显示效果。</p>
<h1 id="DPR"><a href="#DPR" class="headerlink" title="DPR"></a>DPR</h1><p>Device Pixel Ratio，设备像素比。</p>
<p>在早先的移动设备中，并没有 DPR 的概念。随着技术的发展，移动设备的屏幕像素密度越来越高。<br>从 iPhone4 开始，苹果公司推出了所谓的 Retina 视网膜屏幕。之所以叫做视网膜屏幕，是因为屏幕的 PPI 太高，人的视网膜无法分辨出屏幕上的像素点。<br>iPhone4 的分辨率提高了一倍，但屏幕尺寸却没有变化，这意味着同样大小的屏幕上，像素多了一倍，于是 <code>dpr = 2</code>。</p>
<p>在 Chrome 浏览器可以通过以下代码获取设备的 DPR：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let dpr = window.devicePixelRatio;</div></pre></td></tr></table></figure>
<p>而通过下面的代码可以获取设备的逻辑像素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let logicalHeight = screen.height;</div><div class="line">let logicalWidth = screen.width;</div></pre></td></tr></table></figure>
<p>那么很多人看到这里，就会认为：<code>物理像素 = 逻辑像素 * dpr</code><br>但实际情况并不是这样，<br>留意一下 iPhone6 plus 的物理像素和逻辑像素：</p>
<ul>
<li>物理像素：<code>1080px x 1920px</code></li>
<li>逻辑像素：<code>414px x 736px</code></li>
</ul>
<p>而官方声称 iPhone6 plus 的 <code>dpr = 3</code>，按理应该是：</p>
<ul>
<li><code>414px x 736px</code> → 乘以 3 倍 dpr → <code>1242px x 2208px</code></li>
</ul>
<p>那么 iPhone6 plus 只有 <code>1080px x 1920px</code>，怎么去展示 <code>1241px x 2208px</code> 的分辨率呢？</p>
<p>原来 iPhone6 plus 对逻辑像素做了缩小处理，以适应物理像素，也就是<br><code>1241px x 2208px</code> 除以 <code>115%</code> ，得到 <code>1080px x 1920px</code>。</p>
<p>换句话来说，本来 iPhone6 plus 的 <code>dpr = 2.6</code>，但是通过虚拟技术把物理像素放大 115% ，以达到 <code>dpr = 3</code> 的效果。</p>
<p>所以说是假 3 倍 dpr，其实我们开发和设计的时候也不用管这个，当作它就是 3 倍 dpr 就好了。</p>
<h1 id="回到-rpx"><a href="#回到-rpx" class="headerlink" title="回到 rpx"></a>回到 rpx</h1><p>根据官方给出的 rpx 换算 px 的实例：<br><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/ACED349F80C8D926AB74922C360B2F5A.png" alt="rpx 换算 px"></p>
<p>三款机器的逻辑像素：</p>
<ul>
<li>iPhone5 : <code>320px x 568px</code></li>
<li>iPhone6 : <code>375px x 667px</code></li>
<li>iPhone6 plus : <code>414px x 736px</code></li>
</ul>
<p>rpx 转换成 px 是需要乘以一个系数的：</p>
<ul>
<li><code>px = rpx * n</code></li>
</ul>
<p>其中系数 n，是跟着设备改变的：</p>
<ul>
<li>iPhone5: <code>n = 2.34</code></li>
<li>iPhone6: <code>n = 2</code></li>
<li>iPhone6 plus: <code>n = 1.81</code></li>
</ul>
<p>所以 rpx 只是定义一个绝对值 750 宽度，然后简单的根据不同设备的逻辑像素来进行 rpx 到 px 的换算。</p>
<p>精明的观众可能发现了， rpx 压根就不需要关心 DPR 和 PPI 的概念。<br>呃，其实我就是在理解 rpx 的过程中，拦不住思维的发散，了解了一大堆概念，然后顺道给你们分享一下罢了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.wikiwand.com/zh-sg/%E5%83%8F%E7%B4%A0" target="_blank" rel="external">Wiki - 像素</a><br><a href="https://www.wikiwand.com/zh-sg/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0" target="_blank" rel="external">Wiki - 每英寸像素</a><br><a href="https://www.paintcodeapp.com/news/iphone-6-screens-demystified" target="_blank" rel="external">iPhone 6 Screens Demystified</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在负责有赞的某个业务的微信小程序开发，这是我第一次着手微信小程序的开发，这个过程中发现微信小程序所定义的一套 WXSS (WeiXin 
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="前端" scheme="http://huang-jerryc.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2017 第一季度复盘</title>
    <link href="http://huang-jerryc.com/2017/05/04/reconsidering-for-2017-Q1/"/>
    <id>http://huang-jerryc.com/2017/05/04/reconsidering-for-2017-Q1/</id>
    <published>2017-05-03T16:33:02.000Z</published>
    <updated>2018-05-01T16:16:02.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-Past"><a href="#The-Past" class="headerlink" title="The Past"></a>The Past</h1><ol>
<li><a href="https://github.com/JerryC8080/Memeye" target="_blank" rel="external">Memeye</a> 终于开源了，到目前为止已经有 153 个 star 了，但是后续没有再维护了，打算等我学完 Vue 以及对前端更加熟练之后，对前端部分进行重构，使得界面更加流畅。</li>
<li>输出文章九篇，其中八篇技术文。</li>
<li>输出了一本小书：「<a href="https://github.com/JerryC8080/understand-tcp-udp" target="_blank" rel="external">理解 TCP 和 UDP</a>」，这是我在复习计算机网络的产物，有幸能拿到 123 star （数字很特别）。</li>
<li>从魅族离职，入职有赞，换了个 Title，从「NodeJS 工程师」到「前端工程师」，这是很符合我个人的发展计划的，以 JS 栈为主的全栈道路。当然，前提需要是一个优秀的软件工程师。</li>
</ol>
<p>可惜的是，2017年的开头没有好好整理今年的目标。<br>记得有句话很深刻：「人生中最适合的时机有两个，一个是十年前，一个是现在」<br>虽然过了三分之一了，但现在计划，还来得及。</p>
<h1 id="The-Next"><a href="#The-Next" class="headerlink" title="The Next"></a>The Next</h1><p>希望到了 2018 年的自己：</p>
<ol>
<li><strong>Target</strong>: 能解决大部分前端业务上的开发<ol>
<li>深入前端，补足前端基础，包括 CSS、HTML5、ReactJS、Vue2，移动端开发</li>
<li>学习设计理论、色彩理论、看更多的优秀设计。</li>
<li>寻找设计领域比较好的读物，给读完。</li>
</ol>
</li>
<li><strong>Target</strong>: 在社区有更加多的影响力<ol>
<li>全年至少产出文章 12 - 20 篇</li>
<li>拥有一个 300 star 的开源项目</li>
<li>影响所在团队，逐渐营造技术氛围</li>
</ol>
</li>
<li><strong>Target</strong>: 持续扎实基础实力<ol>
<li>《鸟哥的Linux私房菜》</li>
<li>《设计模式》</li>
<li>《深入理解计算机操作系统》</li>
<li>《深入浅出 NodeJS》、《NodeJS 硬实战》、《Security Your NodeJS Application》</li>
<li>《高性能MySQL》</li>
<li>《CSS 权威指南》、《CSS 揭秘》</li>
<li>《Redis 设计与实现》、《Redis 实战》</li>
<li>《你不知道的 JavaScript》</li>
</ol>
</li>
<li><strong>Target</strong>: 具有敏捷开发的实践经验<ol>
<li>团队沟通</li>
<li>文档沉淀</li>
<li>影响力输出</li>
<li>代码质量</li>
<li>稳定交付</li>
<li>快速迭代流程</li>
</ol>
</li>
<li><strong>Target</strong>: 拓展自身的技术视野<ol>
<li>学习 Python，感受社区</li>
<li>学习 Go，感受社区</li>
</ol>
</li>
<li><strong>Target</strong>: 技术之外<ol>
<li>《软技能》</li>
<li>《浪潮之巅》一二册</li>
<li>《暗时间》第二次阅读</li>
<li>《如何阅读一本书》</li>
</ol>
</li>
</ol>
<p>共勉。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;The-Past&quot;&gt;&lt;a href=&quot;#The-Past&quot; class=&quot;headerlink&quot; title=&quot;The Past&quot;&gt;&lt;/a&gt;The Past&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/JerryC8080/M
    
    </summary>
    
      <category term="三省吾身" scheme="http://huang-jerryc.com/categories/%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>一款 NodeJS 轻量级内存监控工具</title>
    <link href="http://huang-jerryc.com/2017/03/17/the-memeye/"/>
    <id>http://huang-jerryc.com/2017/03/17/the-memeye/</id>
    <published>2017-03-17T07:17:38.000Z</published>
    <updated>2019-07-17T13:52:49.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Memeye"><a href="#Memeye" class="headerlink" title="Memeye"></a><a href="https://github.com/JerryC8080/Memeye" target="_blank" rel="external">Memeye</a></h1><p>Github 链接：<a href="https://github.com/JerryC8080/Memeye" target="_blank" rel="external">https://github.com/JerryC8080/Memeye</a></p>
<p>Memeye 是一个轻量级的 NodeJS 进程监控工具，它提供 进程内存、V8 堆空间内存、操作系统内存 三大维度的数据可视化展示。<br>前端部分，借助 <a href="https://github.com/vuejs/vue" target="_blank" rel="external">Vue2</a> 和 <a href="https://github.com/chartjs/Chart.js" target="_blank" rel="external">ChartJS</a> 提供了一个不错的动态展示面板。<br>Memeye 在宿主进程中，只植入了一个简单的数据收集器，其他工作则启动一个子进程，交由子进程来进行。<br>这样做能把 Memeye 的代码对宿主进程的影响降到最低，以确保数据的真实性。    </p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>轻量级</li>
<li>简单</li>
<li>面向开发环境</li>
<li>可视化</li>
</ul>
<p><em>Note: Memeye 暂时只支持单进程，NodeJS 分布式进程还不适用，所以不建议在产品环境使用。</em></p>
<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>总所周知，NodeJS 对内存是很敏感的。在去年 4 月我用 NodeJS 做的一个营销性的项目，在上线当天 PV 突破了 100W。<br>其中内存就呈现出持续上涨趋势，在排查问题的过程中，想寻找一个轻量级的，只要可视化的呈现内存使用情况的工具，无果。<br>然后就有了这个项目的想法，但当时由于繁忙只做出了一个 Demo 级别的，简单能用就发布了。<br>最近有时间，再次翻出来，重构改版，增加更多维度的数据展示。    </p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><a href="http://jerryc8080.github.io/Memeye/" target="_blank" rel="external">See preview demo</a> (也许需要翻墙)</p>
<h1 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h1><ul>
<li>Node v7.x</li>
<li>Node v6.x</li>
</ul>
<h1 id="安装-amp-使用"><a href="#安装-amp-使用" class="headerlink" title="安装 &amp; 使用"></a>安装 &amp; 使用</h1><p>运行下面命令安装 : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install memeye --save-dev</div></pre></td></tr></table></figure>
<p>然后在你的代码中引入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const memeye = require(&apos;memeye&apos;);</div><div class="line">memeye();</div></pre></td></tr></table></figure>
<p>最后打开你的浏览器，输入下面地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:23333  //23333 port by defaul.</div></pre></td></tr></table></figure>
<p>就这么简单！</p>
<h1 id="Memeye-是如何工作的"><a href="#Memeye-是如何工作的" class="headerlink" title="Memeye 是如何工作的"></a>Memeye 是如何工作的</h1><p>Memeye 有三个核心概念：Collector, Indicators, Dashboard。<br>Collector 运行在宿主进程中（你的NodeJS进程），Indicator 和 Dashboard 运行在子进程中，这样可以尽量减少 Memeye 代码对你的宿主进程的影响。    </p>
<h2 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h2><p>Collector 会监听宿主进程，并且收集数据，然后通过 IPC 通信管道发送数据给子进程，交由子进程处理。    </p>
<h2 id="Indicator"><a href="#Indicator" class="headerlink" title="Indicator"></a>Indicator</h2><p>Indicator 像一个状态机。当它的属性变化的时候，会触发相应事件。所以我们可以用它来处理收集回来的数据。    </p>
<h2 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h2><p>Dashboard 会以子进程的形式唤起。他会创建一个 Indicator 实例，以及启动一个集成 socket.io 的 Http 服务器。<br>然后绑定 Indicator 和进程通信管道，以接收父进程发过来的数据。<br>最后再绑定 Indicator 和 socket.io，这样可以在 Indicator 属性变化的时候发送数据给前端。    </p>
<p>##Collector, Indicator, Dashboard 之间的通信</p>
<p><img src="(https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190717214117.jpg" alt="commication.jpeg"></p>
<h1 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h1><p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190717214216.jpeg" alt="预览"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Memeye&quot;&gt;&lt;a href=&quot;#Memeye&quot; class=&quot;headerlink&quot; title=&quot;Memeye&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/JerryC8080/Memeye&quot; target=&quot;_blank&quot; rel=&quot;
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="Javascript" scheme="http://huang-jerryc.com/tags/Javascript/"/>
    
      <category term="Nodejs" scheme="http://huang-jerryc.com/tags/Nodejs/"/>
    
      <category term="SOAP" scheme="http://huang-jerryc.com/tags/SOAP/"/>
    
  </entry>
  
  <entry>
    <title>理解UDP</title>
    <link href="http://huang-jerryc.com/2017/03/02/understand-udp/"/>
    <id>http://huang-jerryc.com/2017/03/02/understand-udp/</id>
    <published>2017-03-02T08:02:25.000Z</published>
    <updated>2020-07-21T08:12:37.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>更好阅读体验：<a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/" target="_blank" rel="external">《理解 TCP 和 UDP》— By Gitbook</a>    </p>
</blockquote>
<h1 id="UDP-和-TCP-的不同"><a href="#UDP-和-TCP-的不同" class="headerlink" title="UDP 和 TCP 的不同"></a>UDP 和 TCP 的不同</h1><p>TCP 在传送数据之前必须先建立连接，数据传送结束后要释放连接。<br>TCP 不提供广播或多播服务，由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。    </p>
<p>而 UDP 在传送数据之前不需要先建立连接。接收方收到 UDP 报文之后，不需要给出任何确认。<br>虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。    </p>
<p>简单来说就是：</p>
<p><strong>UDP：单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序；</strong></p>
<p><strong>TCP：流式，需要建立连接，复杂，可靠 ，有序。</strong></p>
<h1 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h1><p>UDP 全称 User Datagram Protocol, 与 TCP 同是在网络模型中的传输层的协议。</p>
<p><strong>UDP 的主要特点是：</strong></p>
<ol>
<li><strong>无连接的</strong>，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li>
<li><strong>不保证可靠交付</strong>，因此主机不需要为此复杂的连接状态表</li>
<li><strong>面向报文的</strong>，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。</li>
<li><strong>没有阻塞控制</strong>，因此网络出现的拥塞不会使发送方的发送速率降低。</li>
<li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>，也即是提供广播和多播的功能。</li>
<li><strong>首部开销小</strong>，首部只有 8 个字节，分为四部分。</li>
</ol>
<p><strong>UDP 的常用场景：</strong></p>
<ol>
<li>名字转换（DNS）</li>
<li>文件传送（TFTP）</li>
<li>路由选择协议（RIP）</li>
<li>IP 地址配置（BOOTP，DHTP）</li>
<li>网络管理（SNMP）</li>
<li>远程文件服务（NFS）</li>
<li>IP 电话</li>
<li>流式多媒体通信</li>
</ol>
<h1 id="UDP-报文结构"><a href="#UDP-报文结构" class="headerlink" title="UDP 报文结构"></a>UDP 报文结构</h1><p>UDP 数据报分为数据字段和首部字段。<br>首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/6FCC9F4EDE80F784BD11ED9FA76FA375.png" alt="UDP  数据报结构.png"></p>
<p><strong>首部各字段意义</strong>：</p>
<ol>
<li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要时可全 0.</li>
<li><strong>目的端口</strong>：目的端口号，在终点交付报文时必须要使用到。</li>
<li><strong>长度</strong>：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。</li>
<li><strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。</li>
</ol>
<h1 id="UDP-如何进行校验和"><a href="#UDP-如何进行校验和" class="headerlink" title="UDP 如何进行校验和"></a>UDP 如何进行校验和</h1><h2 id="伪首部"><a href="#伪首部" class="headerlink" title="伪首部"></a>伪首部</h2><p>UDP 数据报首部中检验和的计算方法比较特殊。<br>在计算检验和时，要在数据报之前增加 12 个字节的伪首部，用来计算校验和。<br>伪首部并不是数据报真正的首部，是为了计算校验和而临时添加在数据报前面的，在真正传输的时候并不会把伪首部一并发送。    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/3D9C291187835C3571A111952201B4FF.png" alt="UDP 数据报结构-伪首部.png"></p>
<p><strong>伪首部个字段意义</strong>：</p>
<ol>
<li>第一字段，源 IP 地址</li>
<li>第二字段，目的 IP 地址</li>
<li>第三字段，字段全 0</li>
<li>第四字段，IP 首部中的协议字段的值，对于 UDP，此字段值为 17</li>
<li>第五字段，UDP 用户数据报的长度</li>
</ol>
<h2 id="校验和计算方法"><a href="#校验和计算方法" class="headerlink" title="校验和计算方法"></a>校验和计算方法</h2><p>校验和的计算中，频繁用到了二进制的反码求和运算，运算规则见下：    </p>
<p><strong>二进制反码求和运算</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0 + 0 = 0</div><div class="line">1 + 0 = 0 + 1 = 1</div><div class="line">1 + 1 = 10</div></pre></td></tr></table></figure>
<p>其中 10 中的 1 加到了下一列去，如果是最高列的 1 + 1 ，那么得到的 10 留下 0 , 1 移到最低列，与最低位再做一次二进制加法即可。</p>
<p><strong>检验和计算过程</strong></p>
<ol>
<li>把首部的检验和字段设置为全 0 </li>
<li>把伪首部以及数据段看成是许多 16 位的字串接起来。</li>
<li>若数据段不是偶数个字节，则填充一个全 0 字节，但是这个字节不发送。</li>
<li>通过二进制反码运算，计算出 16 位字的和。<ol>
<li>让第一行和第二行做二进制反码运算。  </li>
<li>将第一行和第二行的结果与第三行做二进制反码计算，以此类推。</li>
</ol>
</li>
<li>最后运算结果取反，得到校验和。</li>
<li>把计算出来的校验和值，填入首部校验和字段。</li>
</ol>
<p>接收方收到数据报之后，按照同样的方法计算校验和，如果有差错，则丢弃这个数据报。    </p>
<p>可以看出校验和，既检查了 UDP 用户数据报的源端口号和目的端口号以及数据报的数据部分，又检查了 IP 数据报的源 IP 地址和目的地址。    </p>
<p><strong>一个校验和例子</strong><br>假设一个 UDP 数据报：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/5DADDF7480F81837145468E2ADA6839F.png" alt="UDP 校验和.png"></p>
<p>各字段以二进制表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">1001 1001 0001 0011 //伪首部源IP地址前16位，值：153.19</div><div class="line">0000 1000 0110 1000 //伪首部源IP地址后16位，值：8.104</div><div class="line">1010 1011 0000 0011 //伪首部目的IP地址前16位，值：171.3</div><div class="line">0000 1110 0000 1011 //伪首部目的IP地址后16位，值：14.11</div><div class="line">0000 0000 0001 0001 //伪首部UDP协议字段代表号，值：17</div><div class="line">0000 0000 0000 1111 //伪首部UDP长度字段，值：15</div><div class="line">0000 0100 0011 1111 //UDP头部源IP地址对应的进程端口号，值：1087</div><div class="line">0000 0000 0000 1101 //UDP头部目的IP地址对应的进程端口号，值：13</div><div class="line">0000 0000 0000 1111 //UDP头部UDP长度字段，值：15</div><div class="line">0000 0000 0000 0000 //UDP头部UDP检验和，值：0</div><div class="line">0101 0100 0100 0101 //数据字段</div><div class="line">0101 0011 0101 0100 //数据字段</div><div class="line">0100 1001 0100 1110 //数据字段</div><div class="line">0100 0111 0000 0000 //数据字段+填充0字段</div></pre></td></tr></table></figure>
<p>按照二进制反码运算求和，结果：<code>10010110 11101101</code><br>结果求反码得出校验和：<code>01101001 00010010</code> </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://jcchan23.github.io/2016/07/12/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8D%E7%A0%81%E6%B1%82%E5%92%8C%E8%BF%90%E7%AE%97/" target="_blank" rel="external">二进制反码求和运算</a><br><a href="https://book.douban.com/subject/26850616/" target="_blank" rel="external">《后台开发 核心技术与应用实践》</a><br><a href="https://book.douban.com/subject/2970300/" target="_blank" rel="external">《计算机网络》</a>    </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更好阅读体验：&lt;a href=&quot;https://jerryc8080.gitbooks.io/understand-tcp-and-udp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《理解 TCP 和 UDP》— By Gi
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="udp" scheme="http://huang-jerryc.com/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>理解TCP（六）：网络编程接口</title>
    <link href="http://huang-jerryc.com/2017/03/02/understand-tcp-6/"/>
    <id>http://huang-jerryc.com/2017/03/02/understand-tcp-6/</id>
    <published>2017-03-02T08:01:25.000Z</published>
    <updated>2020-07-21T08:12:37.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>更好阅读体验：<a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/" target="_blank" rel="external">《理解 TCP 和 UDP》— By Gitbook</a>    </p>
</blockquote>
<h1 id="一切皆-Socket"><a href="#一切皆-Socket" class="headerlink" title="一切皆 Socket"></a>一切皆 Socket</h1><p>我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢？<br>socket 起源于 UNIX，而 UNIX/Linux 基本哲学之一就是「一切皆文件」，都可以用「open → write/read → close」模式来操作。<br>socket 其实就是该模式的一个实现，socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作。    </p>
<p>使用 TCP/IP 协议的应用程序通常采用系统提供的编程接口：<strong>UNIX BSD 的套接字接口（Socket Interfaces）</strong><br>以此来实现网络进程之间的通信。<br>就目前而言，几乎所有的应用程序都是采用 socket，所以说现在的网络时代，网络中进程通信是无处不在，<strong>一切皆 socket</strong>    </p>
<h1 id="套接字接口-Socket-Interfaces"><a href="#套接字接口-Socket-Interfaces" class="headerlink" title="套接字接口 Socket Interfaces"></a>套接字接口 Socket Interfaces</h1><p>套接字接口是一组函数，由操作系统提供，用以创建网络应用。<br>大多数现代操作系统都实现了套接字接口，包括所有 Unix 变种，Windows 和 Macintosh 系统。    </p>
<blockquote>
<p><strong>套接字接口的起源</strong><br>套接字接口是加州大学伯克利分校的研究人员在 20 世纪 80 年代早起提出的。<br>伯克利的研究者使得套接字接口适用于任何底层的协议，第一个实现就是针对 TCP/IP 协议，他们把它包括在 Unix 4.2 BSD 的内核里，并且分发给许多学校和实验室。<br>这在因特网的历史成为了一个重大事件。<br>—— 《深入理解计算机系统》</p>
</blockquote>
<p>从 Linux 内核的角度来看，一个套接字就是通信的一个端点。<br>从 Linux 程序的角度来看，套接字是一个有相应描述符的文件。<br>普通文件的打开操作返回一个文件描述字，而 socket() 用于创建一个 socket 描述符，唯一标识一个 socket。<br>这个 socket 描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些操作。    </p>
<p>常用的函数有：</p>
<ul>
<li>socket()</li>
<li>bind()</li>
<li>listen()</li>
<li>connect()</li>
<li>accept()</li>
<li>write()</li>
<li>read()</li>
<li>close()</li>
</ul>
<h1 id="Socket-的交互流程"><a href="#Socket-的交互流程" class="headerlink" title="Socket 的交互流程"></a>Socket 的交互流程</h1><p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/46872611EB6C0874FE9E4C290E8F3FE9.png" alt="socket 交互过程.png"></p>
<p>图中展示了 TCP 协议的 socket 交互流程，描述如下：</p>
<ol>
<li>服务器根据地址类型、socket 类型、以及协议来创建 socket。</li>
<li>服务器为 socket 绑定 IP 地址和端口号。</li>
<li>服务器 socket 监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的 socket 并没有全部打开。</li>
<li>客户端创建 socket。</li>
<li>客户端打开 socket，根据服务器 IP 地址和端口号试图连接服务器 socket。</li>
<li>服务器 socket 接收到客户端 socket 请求，被动打开，开始接收客户端请求，知道客户端返回连接信息。这时候 socket 进入阻塞状态，阻塞是由于 accept() 方法会一直等到客户端返回连接信息后才返回，然后开始连接下一个客户端的连接请求。</li>
<li>客户端连接成功，向服务器发送连接状态信息。</li>
<li>服务器 accept() 方法返回，连接成功。</li>
<li>服务器和客户端通过网络 I/O 函数进行数据的传输。</li>
<li>客户端关闭 socket。</li>
<li>服务器关闭 socket。</li>
</ol>
<p>这个过程中，服务器和客户端建立连接的部分，就体现了 TCP 三次握手的原理。    </p>
<p>下面详细讲一下 socket 的各函数。    </p>
<h2 id="Socket-接口"><a href="#Socket-接口" class="headerlink" title="Socket 接口"></a>Socket 接口</h2><p>socket 是系统提供的接口，而操作系统大多数都是用 C/C++ 开发的，自然函数库也是 C/C++ 代码。    </p>
<h2 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket 函数"></a>socket 函数</h2><p>该函数会返回一个套接字描述符（socket descriptor），但是该描述符仅是部分打开的，还不能用于读写。<br>如何完成打开套接字的工作，取决于我们是客户端还是服务器。    </p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p><strong>domain</strong>:<br>协议域，决定了 socket 的地质类型，在通信中必须采用对应的地址。<br>常用的协议族有：<code>AF_INET</code>（ipv4地址与端口号的组合）、<code>AF_INET6</code>（ipv6地址与端口号的组合）、<code>AF_LOCAL</code>（绝对路径名作为地址）。<br>该值的常量定义在 <code>sys/socket.h</code> 文件中。    </p>
<p><strong>type</strong>:<br>指定 socket 类型。<br>常用的类型有：<code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、<code>SOCK_RAW</code>、<code>SOCK_PACKET</code>、<code>SOCK_SEQPACKET</code>等。<br>其中 <code>SOCK_STREAM</code> 表示提供面向连接的稳定数据传输，即 TCP 协议。<br>该值的常量定义在 <code>sys/socket.h</code> 文件中。    </p>
<p><strong>protocol</strong>:<br>指定协议。<br>常用的协议有：<code>IPPROTO_TCP</code>（TCP协议）、<code>IPPTOTO_UDP</code>（UDP协议）、<code>IPPROTO_SCTP</code>（STCP协议）。<br>当值位 0 时，会自动选择 <code>type</code> 类型对应的默认协议。    </p>
<h2 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h2><p>由服务端调用，把一个地址族中的特定地址和 socket 联系起来。</p>
<h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><p><strong>sockfd</strong>:<br>即 socket 描述字，由 socket() 函数创建。    </p>
<p><strong>*addr</strong>：<br>一个 <code>const struct sockaddr</code> 指针，指向要绑定给 <code>sockfd</code> 的协议地址。<br>这个地址结构根据地址创建 socket 时的地址协议族不同而不同，例如 ipv4 对应 <code>sockaddr_in</code>，ipv6 对应 <code>sockaddr_in6</code>.<br>这几个结构体在使用的时候，都可以强制转换成 <code>sockaddr</code>。<br>下面是这几个结构体对应的所在的头文件：</p>
<ol>
<li><code>sockaddr</code>： <code>sys/socket.h</code></li>
<li><code>sockaddr_in</code>： <code>netinet/in.h</code></li>
<li><code>sockaddr_in6</code>： <code>netinet6/in.h</code></li>
</ol>
<blockquote>
<p>_in 后缀意义：互联网络(internet)的缩写，而不是输入(input)的缩写。</p>
</blockquote>
<h2 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen 函数"></a>listen 函数</h2><p>服务器调用，将 socket 从一个主动套接字转化为一个监听套接字（listening socket）, 该套接字可以接收来自客户端的连接请求。<br>在默认情况下，操作系统内核会认为 socket 函数创建的描述符对应于主动套接字（active socket）。    </p>
<h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h3><p><strong>sockfd</strong>:<br>即 socket 描述字，由 socket() 函数创建。    </p>
<p><strong>backlog</strong>:<br>指定在请求队列中的最大请求数，进入的连接请求将在队列中等待 accept() 它们。    </p>
<h2 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect 函数"></a>connect 函数</h2><p>由客户端调用，与目的服务器的套接字建立一个连接。    </p>
<h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> clientfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h3><p><strong>clientfd</strong>:<br>目的服务器的 socket 描述符    </p>
<p><strong>*addr</strong>:<br>一个 <code>const struct sockaddr</code> 指针，包含了目的服务器 IP 和端口。    </p>
<p><strong>addrlen</strong>：<br>协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 <code>sizeof(sockaddr_in)</code>;    </p>
<h2 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept 函数"></a>accept 函数</h2><p>服务器调用，等待来自客户端的连接请求。<br>当客户端连接，accept 函数会在 <code>addr</code> 中会填充上客户端的套接字地址，并且返回一个已连接描述符（connected descriptor），这个描述符可以用来利用 Unix I/O 函数与客户端通信。    </p>
<h3 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#indclude <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">int</span> *addrlen)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="参数说明-4"><a href="#参数说明-4" class="headerlink" title="参数说明"></a>参数说明</h3><p><strong>listenfd</strong>:<br>服务器的 socket 描述字，由 socket() 函数创建。    </p>
<p><strong>*addr</strong>:<br>一个 <code>const struct sockaddr</code> 指针，用来存放提出连接请求客户端的主机的信息</p>
<p><strong>*addrlen</strong>:<br>协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 <code>sizeof(sockaddr_in)</code>。    </p>
<h2 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h2><p>在数据传输完成之后，手动关闭连接。    </p>
<h3 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="参数说明-5"><a href="#参数说明-5" class="headerlink" title="参数说明"></a>参数说明</h3><p><strong>fd</strong>:<br>需要关闭的连接 socket 描述符    </p>
<h2 id="网络-I-O-函数"><a href="#网络-I-O-函数" class="headerlink" title="网络 I/O 函数"></a>网络 I/O 函数</h2><p>当客户端和服务器建立连接后，可以使用网络 I/O 进行读写操作。<br>网络 I/O 操作有下面几组：</p>
<ol>
<li>read()/write()</li>
<li>recv()/send()</li>
<li>readv()/writev()</li>
<li>recvmsg()/sendmsg()</li>
<li>recvfrom()/sendto()</li>
</ol>
<p>最常用的是 read()/write()<br>他们的原型是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</div><div class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</div></pre></td></tr></table></figure>
<p>鉴于该文是侧重于描述 socket 的工作原理，就不再详细描述这些函数了。</p>
<h1 id="实现一个简单-TCP-交互"><a href="#实现一个简单-TCP-交互" class="headerlink" title="实现一个简单 TCP 交互"></a>实现一个简单 TCP 交互</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// socket_server.cpp</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096 <span class="comment">// 4 * 1024</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> listenfd, <span class="comment">// 监听端口的 socket 描述符</span></div><div class="line">        connfd;   <span class="comment">// 连接端 socket 描述符</span></div><div class="line">    <span class="keyword">struct</span> sockaddr_in servaddr;</div><div class="line">    <span class="keyword">char</span> buff[MAXLINE];</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line"></div><div class="line">    <span class="comment">// 创建 socket，并且进行错误处理</span></div><div class="line">    <span class="keyword">if</span> ((listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化 sockaddr_in 数据结构</span></div><div class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</div><div class="line">    servaddr.sin_family = AF_INET;</div><div class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</div><div class="line">    servaddr.sin_port = htons(<span class="number">6666</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 绑定 socket 和 端口</span></div><div class="line">    <span class="keyword">if</span> (bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"bind socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 监听连接</span></div><div class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">10</span>) == <span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"listen socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"====== Waiting for client's request======\n"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 持续接收客户端的连接请求</span></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> ((connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)<span class="literal">NULL</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>))</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"accept socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        n = recv(connfd, buff, MAXLINE, <span class="number">0</span>);</div><div class="line">        buff[n] = <span class="string">'\0'</span>;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"recv msg from client: %s\n"</span>, buff);</div><div class="line">        close(connfd);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    close(listenfd);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// socket_client.cpp</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> sockfd, n;</div><div class="line">    <span class="keyword">char</span> recvline[<span class="number">4096</span>], sendline[<span class="number">4096</span>];</div><div class="line">    <span class="keyword">struct</span> sockaddr_in servaddr;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"usage: ./client &lt;ipaddress&gt;\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 创建 socket 描述符</span></div><div class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化目标服务器数据结构</span></div><div class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</div><div class="line">    servaddr.sin_family = AF_INET;</div><div class="line">    servaddr.sin_port = htons(<span class="number">6666</span>);</div><div class="line">    <span class="comment">// 从参数中读取 IP 地址</span></div><div class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"inet_pton error for %s\n"</span>, argv[<span class="number">1</span>]);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 连接目标服务器，并和 sockfd 联系起来。</span></div><div class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"connect error: %s(errno: %d)\n"</span>, strerror(errno), errno);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"send msg to server: \n"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 从标准输入流中读取信息</span></div><div class="line">    fgets(sendline, <span class="number">4096</span>, <span class="built_in">stdin</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 通过 sockfd，向目标服务器发送信息</span></div><div class="line">    <span class="keyword">if</span> (send(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>) &lt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"send msg error: %s(errno: %d)\n"</span>, strerror(errno), errno);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 数据传输完毕，关闭 socket 连接</span></div><div class="line">    close(sockfd);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h1><p>首先创建 <code>makefile</code> 文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">all:server client</div><div class="line">server:socket_server.o</div><div class="line">	g++ -g -o socket_server socket_server.o</div><div class="line">client:socket_client.o</div><div class="line">	g++ -g -o socket_client socket_client.o</div><div class="line">socket_server.o:socket_server.cpp</div><div class="line">	g++ -g -c socket_server.cpp</div><div class="line">socket_client.o:socket_client.cpp</div><div class="line">	g++ -g -c socket_client.cpp</div><div class="line">clean:all</div><div class="line">	rm all</div></pre></td></tr></table></figure>
<p>然后使用命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make</div></pre></td></tr></table></figure>
<p>会生成两个可执行文件：</p>
<ol>
<li><code>socket_server</code></li>
<li><code>socket_client</code></li>
</ol>
<p>分别打开两个终端，运行：</p>
<ol>
<li><code>./socket_server</code></li>
<li><code>./socket_client 127.0.0.1</code></li>
</ol>
<p>然后在 <code>socket_client</code> 中键入发送内容，可以再 <code>socket_server</code> 接收到同样的信息。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://book.douban.com/subject/26850616/" target="_blank" rel="external">《后台开发 核心技术与应用实践》</a><br><a href="https://book.douban.com/subject/2970300/" target="_blank" rel="external">《计算机网络》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更好阅读体验：&lt;a href=&quot;https://jerryc8080.gitbooks.io/understand-tcp-and-udp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《理解 TCP 和 UDP》— By Gi
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="tcp" scheme="http://huang-jerryc.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>理解TCP（五）：可靠性交付的实现</title>
    <link href="http://huang-jerryc.com/2017/03/02/understand-tcp-5/"/>
    <id>http://huang-jerryc.com/2017/03/02/understand-tcp-5/</id>
    <published>2017-03-02T08:00:25.000Z</published>
    <updated>2020-07-21T08:12:37.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>更好阅读体验：<a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/" target="_blank" rel="external">《理解 TCP 和 UDP》— By Gitbook</a>    </p>
</blockquote>
<p>TCP 是一种提供可靠性交付的协议。<br>也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。<br>但是在网络中相连两端之间的介质，是复杂的，并不确保数据的可靠性交付，那么 TCP 是怎么样解决问题的？<br>这就需要了解 TCP 的几种技术：    </p>
<ol>
<li>滑动窗口    </li>
<li>超时重传    </li>
<li>流量控制    </li>
<li>拥塞控制    </li>
</ol>
<p>下面来分别讲一下这几种技术的实现原理。    </p>
<h1 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h1><h2 id="重传时机"><a href="#重传时机" class="headerlink" title="重传时机"></a>重传时机</h2><p>TCP 报文段在传输的过程中，下面的情况都是有可能发生的：</p>
<ol>
<li>数据包中途丢失；</li>
<li>数据包顺利到达，但对方发送的 ACK 报文中途丢失；</li>
<li>数据包顺利到达，但对方异常未响应 ACK 或被对方丢弃；</li>
</ol>
<p>当出现这些异常情况时，TCP 就会超时重传。<br>TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到了，但还没有收到确认，就重传这一报文段，这个就叫做「超时重传」。    </p>
<h2 id="重传算法"><a href="#重传算法" class="headerlink" title="重传算法"></a>重传算法</h2><h3 id="先认识两个概念"><a href="#先认识两个概念" class="headerlink" title="先认识两个概念"></a>先认识两个概念</h3><h4 id="RTO-Retransmission-Time-Out-重传超时时间"><a href="#RTO-Retransmission-Time-Out-重传超时时间" class="headerlink" title="RTO ( Retransmission Time-Out ) 重传超时时间"></a>RTO ( Retransmission Time-Out ) 重传超时时间</h4><p>指发送端发送数据后、重传数据前等待接收方收到该数据 ACK 报文的时间。<br>大白话就是，需要等待多长时间还没收到确认，就重新传一次。    </p>
<p>RTO 的设置对于重传非常重要：    </p>
<ol>
<li>设长了，重发就慢，没有效率，性能差；</li>
<li>设短了，重发得就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ol>
<h4 id="RTT-Round-Trip-Time-连接往返时间"><a href="#RTT-Round-Trip-Time-连接往返时间" class="headerlink" title="RTT ( Round Trip Time ) 连接往返时间"></a>RTT ( Round Trip Time ) 连接往返时间</h4><p>指发送端从发送 TCP 包开始到接收它的 ACK 报文之间所耗费的时间。<br>而在实际的网络传输中，RTT 的值每次都是随机的，无法事先预预知。<br>TCP 通过测量来获得连接当前 RTT 的一个估计值，并以该 RTT 估计值为基准来设置当前的 RTO。<br>这就引入了一类算法的称呼：自适应重传算法（Adaptive Restransmission Algorithm）<br>这类算法的关键就在于对当前 RTT 的准确估计，以便适时调整 RTO。    </p>
<p>关于自适应重传算法，经历过多次的迭代和修正。<br>从 1981 年的 <a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="external">RFC793</a> 提及的经典算法，到 1987 年 Karn 提出的 Karn/Partridge 算法，再到后来的 1988 年的 Jacobson / Karels 算法。<br>最后的这个算法在被用在今天的 TCP 协议中（Linux的源代码在：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609" target="_blank" rel="external"><code>tcp_rtt_estimator</code></a>）。    </p>
<p>自适应重传算法的发展读者有兴趣可以参考其他资料，在这里我拎一个现在在用的算法出来讲讲，随意感受一下。    </p>
<h3 id="Jacobson-Karels-算法"><a href="#Jacobson-Karels-算法" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h3><p>1988年，有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看<a href="https://tools.ietf.org/html/rfc2988" target="_blank" rel="external">RFC6298</a>）。<br>其计算公式：</p>
<blockquote>
<p>SRTT = SRTT + α ( RTT – SRTT )  —— 计算平滑 RTT</p>
<p>DevRTT = ( 1-β ) <em> DevRTT + β </em> ( | RTT - SRTT | ) ——计算平滑 RTT 和真实的差距（加权移动平均）</p>
<p>RTO= µ <em> SRTT + ∂ </em> DevRTT </p>
</blockquote>
<p>其中：</p>
<ul>
<li><p><code>α</code>、<code>β</code>、<code>μ</code>、<code>∂</code> 是可以调整的参数，在 RFC6298 中给出了对应的参考值，而在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4；</p>
</li>
<li><p>SRTT 是 Smoothed RTT 的意思，是 RTT 的平滑计算值，即根据每次测量的 RTT 和旧的 RTT 进行运算，得出新的 RTT。SRTT 的值，会在每一次测量到 RTT 之后进行更新；</p>
</li>
<li><p>DevRTT 是 Deviation RTT 的意思，根据每次测量的 RTT 和旧的 SRTT 值进行运算，得出新的 DevRTT；</p>
</li>
</ul>
<p>由算法可以知道 RTO 的值会根据每次测量的 RTT 值变化而变化，基本要点是 TCP 监视每个连接的性能，由每一个 TCP 的连接情况推算出合适的 RTO 值，根据不同的网络情况，自动修改 RTO 值，以适应负责的网络变化。</p>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h1 id="滑动窗口-Sliding-Window"><a href="#滑动窗口-Sliding-Window" class="headerlink" title="滑动窗口 Sliding Window"></a>滑动窗口 Sliding Window</h1><p>滑动窗口协议比较复杂，也是 TCP 协议的精髓所在。    </p>
<p>TCP 头里有一个字段叫 Window，叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。    </p>
<p>滑动窗口分为「接收窗口」和「发送窗口」<br>因为 TCP 协议是全双工的，会话的双方都可以同时接收和发送，那么就需要各自维护一个「发送窗口」和「接收窗口」。    </p>
<h2 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h2><p>大小取决于对端通告的接受窗口。<br>只有收到对端对于本端发送窗口内字节的 ACK 确认，才会移动发送窗口的左边界。    </p>
<p>下图是发送窗口的示意图：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png" alt="tcps-send-wwindows.png"></p>
<p>对于发送窗口，在缓存内的数据有四种状态：</p>
<ul>
<li>#1 已发送，并得到接收方 ACK 确认；</li>
<li>#2 已发送，但还未收到接收方 ACK；</li>
<li>#3 未发送，但接收方允许发送，接收方还有空间</li>
<li>#4 未发送，且接收方不允许发送，接收方没有空间</li>
</ul>
<p>如果下一刻，收到了接收方对于 32-36 字节序的数据包的 ACK 确认，那么发送方的窗口就会发生「滑动」。<br>并且发送下一个 46-51 字节序的数据包。    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png" alt="tcps-send-wslide.png"></p>
<p>滑动窗口的概念，描述了 TCP 的数据是怎么发送，以及怎么接收的。<br>TCP 的滑动窗口是动态的，我们可以想象成小学常见的一个数学题，一个水池，体积 V，每小时进水量 V1, 出水量 V2。<br>当水池满了就不允许再注入了，如果有个液压系统控制水池大小，那么就可以控制水的注入速率和量了。<br>应用程序可以根据自身的处理能力变化，通过 API 来控制本端 TCP 接收窗口的大小，来进行流量控制。    </p>
<h2 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h2><p>大小取决于应用、系统、硬件的限制。    </p>
<p>下图是接收窗口的示意图（找不到图，唯有自己画了）：    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png" alt="tcps-receive-wwindows.png"></p>
<p>相对于发送窗口，接受窗口在缓存内的数据只有三种状态：</p>
<ul>
<li>已接收已确认；</li>
<li>未接收，准备接收；</li>
<li>未接收，并未准备接收；</li>
</ul>
<p>下一刻接收到来自发送端的 32-36 数据包，然后回送 ACK 确认报，并且移动接收窗口。    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png" alt="tcps-receive-wslide.png"></p>
<p>另外接收端相对于发送端还有不同的一点，只有前面所有的段都确认的情况下才会移动左边界，<br>在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认，以此确保对端会对这些数据重传。<br>假如 32-36 字节不是一个报文段的，而是每个字节一个报文段的话，那么就会分成了 5 个报文段。<br>在实际的网络环境中，不能确保是按序收到的，其中会有一些早达到，一些迟到达。    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png" alt="tcps-receive-disorder.png"></p>
<p>如图中的 34、35 字节序，先收到了，接收窗口也不会移动。<br>因为有可能 32、33 字节序会出现丢包或者超时，这时就需要发送端重发报文段了。    </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo.htm" target="_blank" rel="external">The TCP/IP Guide</a><br><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP 的那些事儿（下）</a><br><a href="https://book.douban.com/subject/26850616/" target="_blank" rel="external">《后台开发 核心技术与应用实践》</a><br><a href="https://book.douban.com/subject/2970300/" target="_blank" rel="external">《计算机网络》</a>    </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更好阅读体验：&lt;a href=&quot;https://jerryc8080.gitbooks.io/understand-tcp-and-udp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《理解 TCP 和 UDP》— By Gi
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="tcp" scheme="http://huang-jerryc.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>理解TCP（四）：状态流转</title>
    <link href="http://huang-jerryc.com/2017/03/02/understand-tcp-4/"/>
    <id>http://huang-jerryc.com/2017/03/02/understand-tcp-4/</id>
    <published>2017-03-02T07:59:25.000Z</published>
    <updated>2020-07-21T08:12:37.394Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>更好阅读体验：<a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/" target="_blank" rel="external">《理解 TCP 和 UDP》— By Gitbook</a>    </p>
</blockquote>
<p>无论客户端还是服务器，在双方 TCP 通讯的过程中，都会有着一个「状态」的概念，状态会随着 TCP 通讯的不同阶段而变化。</p>
<h2 id="TCP-状态流转图"><a href="#TCP-状态流转图" class="headerlink" title="TCP 状态流转图"></a>TCP 状态流转图</h2><p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/DB900F916ECD267746706FEA8DF682CD.png" alt="TCP 状态流转图.png"></p>
<h2 id="各种状态表示的意思"><a href="#各种状态表示的意思" class="headerlink" title="各种状态表示的意思"></a>各种状态表示的意思</h2><p><strong>CLOSED</strong>：表示初始状态</p>
<p><strong>LISTEN</strong>：表示服务器端的某个 socket 处于监听状态，可以接受连接</p>
<p><strong>SYN_SENT</strong>：在服务端监听后，客户端 socket 执行 CONNECT 连接时，客户端发送 SYN 报文，此时客户端就进入 SYN_SENT 状态，等待服务端确认。</p>
<p><strong>SYN_RCVD</strong>：表示服务端接收到了 SYN 报文。</p>
<p><strong>ESTABLISHED</strong>：表示连接已经建立了。</p>
<p><strong>FIN_WAIT_1</strong>：其中一方请求终止连接，等待对方的 FIN 报文。</p>
<p><strong>FIN_WAIT_2</strong>：在 <strong>FIN_WAIT_2</strong> 之后， 当对方回应 ACK 报文之后，进入该状态。</p>
<p><strong>TIME_WAIT</strong>：表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 之后即可回到 CLOSED 状态。</p>
<p><strong>CLOSING</strong>：一种罕见状态，发生在发送 FIN 报文之后，本应是先收到 ACK 报文，却先收到对方的 FIN 报文，那么就从 FIN_WAIT_1 的状态进入 CLOSING 状态。</p>
<p><strong>CLOSE_WAIT</strong>：表示等待关闭，在 ESTABLISHED 过渡到 LAST_ACK 的一个过渡阶段，该阶段需要考虑是否还有数据发送给对方，如果没有，就可以关闭连接，发送 FIN 报文，然后进入 LAST_ACK 状态。</p>
<p><strong>LAST_ACK</strong>：被动关闭一方发送 FIN 报文之后，最后等待对方的 ACK 报文所处的状态。</p>
<p><strong>CLOSED</strong>：当收到 ACK 保温后，就可以进入 CLOSED 状态了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/26850616/" target="_blank" rel="external">《后台开发 核心技术与应用实践》</a><br><a href="https://book.douban.com/subject/2970300/" target="_blank" rel="external">《计算机网络》</a>k.douban.com/subject/2970300/)</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更好阅读体验：&lt;a href=&quot;https://jerryc8080.gitbooks.io/understand-tcp-and-udp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《理解 TCP 和 UDP》— By Gi
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="tcp" scheme="http://huang-jerryc.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>理解TCP（三）：连接的建立和释放</title>
    <link href="http://huang-jerryc.com/2017/03/02/understand-tcp-3/"/>
    <id>http://huang-jerryc.com/2017/03/02/understand-tcp-3/</id>
    <published>2017-03-02T07:58:25.000Z</published>
    <updated>2020-07-21T08:12:37.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>更好阅读体验：<a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/" target="_blank" rel="external">《理解 TCP 和 UDP》— By Gitbook</a>    </p>
</blockquote>
<p>TCP 的整个交流过程可以总结为：先建立连接，然后传输数据，最后释放链接。    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/08EAF7F3E7FFCEF3E781385BF62BA2BC.png" alt="三次握手和四次挥手.png"></p>
<h2 id="三次握手，建立连接"><a href="#三次握手，建立连接" class="headerlink" title="三次握手，建立连接"></a>三次握手，建立连接</h2><p>TCP 连接建立要解决的首要问题就是：<strong>要使每一方能够确知对方的存在。</strong>    </p>
<p>三次握手就像，在一个黑暗的森林，你知道前方十点钟方向好像有人。<br>你喊了一句：Hello？I’am JerryC，Who are you？<br>对面回了一句：Hi! I’am David, and nice to meet you!<br>然后你回了一句：Nice to meet you too!<br>……(自此，你们才算真正认识了双方，开始了后面省略3000字的谈话)    </p>
<p>所以说，两个人需要交朋友（两个端点需要建立连接），至少需要三次的通话（握手）    </p>
<p>其实，网络上的传输是没有连接的，TCP 也是一样的。<br>而 TCP 所谓的「连接」，其实只不过是在通信的双方维护一个「连接状态」，让它看上去好像有连接一样。    </p>
<h3 id="连接建立过程"><a href="#连接建立过程" class="headerlink" title="连接建立过程"></a>连接建立过程</h3><p>TCP 连接的建立采用客户服务器方式，主动发起连接建立的一方叫<strong>客户端（Client）</strong>，被动等待连接建立的一方叫<strong>服务器（Server）</strong>。    </p>
<p>最初的时候，两端都处于 <strong>CLOSED</strong> 的状态，然后服务器打开了 TCP 服务，进入 <strong>LISTEN</strong> 状态，监听特定端口，等待客户端的 TCP 请求。    </p>
<p><strong>第一次握手</strong>：<br>客户端主动打开连接，发送 TCP 报文，进行第一次握手，然后进入 <strong>SYN_SEND</strong> 状态，等待服务器发回确认报文。<br>这时首部的同步位 SYN = 1，同时初始化一个序号 Sequence Number = J。<br>TCP 规定，SYN 报文段不能携带数据，但会消耗一个序号。    </p>
<p><strong>第二次握手</strong>：<br>服务器收到了 SYN 报文，如果同意建立连接，则向客户端发送一个确认报文，然后服务器进入 <strong>SYN_RCVD</strong> 状态。<br>这时首部的 SYN = 1，ACK = 1，而确认号 Acknowledgemt Number = J + 1，同时也为自己初始化一个序号 Sequence Number = K。<br>这个报文同样不携带数据。    </p>
<p><strong>第三次握手</strong>：<br>客户端收到了服务器发过来的确认报文，还要向服务器给出确认，然后进入 <strong>ESTABLISHED</strong> 状态。<br>这时首部的 SYN 不再置为 1，而 ACK = 1，确认号 Acknowledgemt Number = K + 1，序号 Sequence Number = J + 1。<br>第三次握手，一般会携带真正需要传输的数据，当服务器收到该数据报文的时候，就会同样进入 <strong>ESTABLISHED</strong> 状态。<br>此时，TCP 连接已经建立。    </p>
<p>对于建立连接的三次握手，主要目的是初始化序号 Sequence Number，并且通信的双方都需要告知对方自己的初始化序号，所以这个过程也叫 SYN。<br>这个序号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，因为TCP 会用这个序号来拼接数据。    </p>
<h3 id="利用连接设计缺陷实施-TCP-Flood-攻击"><a href="#利用连接设计缺陷实施-TCP-Flood-攻击" class="headerlink" title="利用连接设计缺陷实施 TCP Flood 攻击"></a>利用连接设计缺陷实施 TCP Flood 攻击</h3><p>知道了 TCP 建立一个连接，需要进行三次握手。<br>但如果你开始思考「三次握手的必要性」的时候，就会知道，其实网络是很复杂的，一个信息在途中丢失的可能性是有的。<br>如果数据丢失了，那么，就需要重新发送，这时候就要知道数据是否真的送达了。<br>这就是三次握手的必要性。<br>但是再向深一层思考，你给我发信息，我收到了，我回复，因为我是君子。<br>如果是小人，你给我发信息，我就算收到了，我也不回复，你就一直等我着我的回复。<br>那么很多小人都这样做，你就要一直记住你在等待着小人1号、小人2号、小人3号……直到你的脑容量爆棚，烧坏脑袋。<br>黑客就是利用这样的设计缺陷，实施 TCP Flood 攻击，属于 DDOS 攻击的一种。<br>想了解更多 SYN Flood 攻击请看：<a href="https://www.wikiwand.com/en/SYN_flood" target="_blank" rel="external">SYN flood - wiki</a> </p>
<h2 id="四次挥手，释放连接"><a href="#四次挥手，释放连接" class="headerlink" title="四次挥手，释放连接"></a>四次挥手，释放连接</h2><p>TCP 有一个特别的概念叫做<strong>半关闭</strong>，这个概念是说，TCP 的连接是全双工（可以同时发送和接收）的连接，因此在关闭连接的时候，必须关闭传送和接收两个方向上的连接。<br>客户端给服务器发送一个携带 FIN 的 TCP 结束报文段，然后服务器返回给客户端一个 确认报文段，同时发送一个 结束报文段，当客户端回复一个 确认报文段 之后，连接就结束了。    </p>
<h3 id="释放连接过程"><a href="#释放连接过程" class="headerlink" title="释放连接过程"></a>释放连接过程</h3><p>在结束之前，通信双方都是处于 <strong>ESTABLISHED</strong> 状态，然后其中一方主动断开连接。<br>下面假如客户端先主动断开连接。    </p>
<p><strong>第一次挥手：</strong><br>客户端向服务器发送结束报文段，然后进入 <strong>FIN_WAIT_1</strong> 状态。<br>此报文段 FIN = 1， Sequence Number = M。    </p>
<p><strong>第二次挥手：</strong><br>服务端收到客户端的结束报文段，然后发送确认报文段，进入 <strong>CLOSE_WAIT</strong> 状态。<br>此报文段 ACK = 1， Sequence Number = M + 1。    </p>
<p>客户端收到该报文，会进入 <strong>FIN_WAIT_2</strong> 状态。    </p>
<p><strong>第三次挥手：</strong><br>同时服务端向客户端发送结束报文段，然后进入 <strong>LAST_ACK</strong> 状态。<br>此报文段 FIN = 1，Sequence Number = N。    </p>
<p><strong>第四次挥手：</strong><br>客户端收到服务端的结束报文段，然后发送确认报文段，进入 <strong>TIME_WAIT</strong> 状态，经过 2MSL 之后，自动进入 <strong>CLOSED</strong> 状态。<br>此报文段 ACK = 1, Sequence Number = N + 1。    </p>
<p>服务端收到该报文之后，进入 <strong>CLOSED</strong> 状态。    </p>
<p><strong>关于 TIME_WAIT 过渡到 CLOSED 状态说明</strong>：<br>从 <strong>TIME_WAIT</strong> 进入 <strong>CLOSED</strong> 需要经过 2MSL，其中 MSL 就叫做 最长报文段寿命（Maxinum Segment Lifetime），根据 RFC 793 建议该值这是为 2 分钟，也就是说需要经过 4 分钟，才进入 <strong>CLOSED</strong> 状态。    </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://book.douban.com/subject/26850616/" target="_blank" rel="external">《后台开发 核心技术与应用实践》</a><br><a href="https://book.douban.com/subject/2970300/" target="_blank" rel="external">《计算机网络》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更好阅读体验：&lt;a href=&quot;https://jerryc8080.gitbooks.io/understand-tcp-and-udp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《理解 TCP 和 UDP》— By Gi
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="tcp" scheme="http://huang-jerryc.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>理解TCP（二）：报文结构</title>
    <link href="http://huang-jerryc.com/2017/03/02/understand-tcp-2/"/>
    <id>http://huang-jerryc.com/2017/03/02/understand-tcp-2/</id>
    <published>2017-03-02T07:57:25.000Z</published>
    <updated>2020-07-21T08:12:37.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>更好阅读体验：<a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/" target="_blank" rel="external">《理解 TCP 和 UDP》— By Gitbook</a>    </p>
</blockquote>
<p>TCP 是面向字节流的，但传送的数据单元却是报文段。</p>
<p><strong>什么是报文？</strong><br>例如一个 100kb 的 HTML 文档需要传送到另外一台计算机，并不会整个文档直接传送过去，可能会切割成几个部分，比如四个分别为 25kb 的数据段。<br>而每个数据段再加上一个 TCP 首部，就组成了 TCP 报文。<br>一共四个 TCP 报文，发送到另外一个端。<br>另外一端收到数据包，然后再剔除 TCP 首部，组装起来。<br>等到四个数据包都收到了，就能还原出来一个完整的 HTML 文档了。    </p>
<p>在 OSI 的七层协议中，第二层（数据链路层）的数据叫「Frame」，第三层（网络层）上的数据叫「Packet」，第四层（传输层）的数据叫「Segment」。</p>
<p>TCP 报文 (Segment)，包括首部和数据部分。    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/3A60080FBC8767DB575C2D2919097613.png" alt="报文结构.png"></p>
<p>而 TCP 的全部功能都体现在它首部中各字段的作用，只有弄清 TCP 首部各字段的作用才能掌握 TCP 的工作原理。<br>TCP 报文段首部的前20个字节是固定的，后面有 4N 字节是根据需要而增加的。<br>下图是把 TCP 报文中的首部放大来看。    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/CFC6314E4B2FD039C450821D946E93E2.png" alt="报文首部结构.png"></p>
<p>TCP 的首部包括以下内容：    </p>
<ol>
<li>源端口 source port    </li>
<li>目的端口 destination port    </li>
<li>序号 sequence number    </li>
<li>确认号 acknowledgment number    </li>
<li>数据偏移 offset    </li>
<li>保留 reserved    </li>
<li>标志位 tcp flags    </li>
<li>窗口大小 window size    </li>
<li>检验和 checksum    </li>
<li>紧急指针 urgent pointer    </li>
<li>选项 tcp options    </li>
</ol>
<p>下面展开来描述个字段的意义和作用。    </p>
<h2 id="TCP-首部各字段的意义和作用"><a href="#TCP-首部各字段的意义和作用" class="headerlink" title="TCP 首部各字段的意义和作用"></a>TCP 首部各字段的意义和作用</h2><h3 id="源端口和目的端口-Port"><a href="#源端口和目的端口-Port" class="headerlink" title="源端口和目的端口 Port"></a>源端口和目的端口 Port</h3><p>各占 2 个 字节，共 4 个字节。<br>用来告知主机该报文段是来自哪里以及传送给哪个应用程序（应用程序绑定了端口）的。<br>进行 TCP 通讯时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。    </p>
<h3 id="序号-Sequence-Number"><a href="#序号-Sequence-Number" class="headerlink" title="序号 Sequence Number"></a>序号 Sequence Number</h3><p>占 4 个字节。<br>TCP 是面向字节流的，在一个 TCP 连接中传输的字节流中的每个字节都按照顺序编号。<br>例如 100 kb 的 HTML 文档数据，一共 102400 (100 * 1024) 个字节，那么每一个字节就都有了编号，整个文档的编号的范围是 0 ~ 102399。    </p>
<p>序号字段值指的是<strong>本报文段</strong>所发送的数据的第一个字节的序号。<br>那么 100 的 HTML 文档分割成四个等分之后，<br>第一个 TCP 报文段包含的是第一个 25kb 的数据，0 ~ 25599 字节， 该报文的序号的值就是：0<br>第二个 TCP 报文段包含的是第二个 25kb 的数据，25600 ~ 51199 字节，该报文的序号的值就是：25600<br>……    </p>
<p>根据 8 位 = 1 字节，那么 4 个字节可以表示的数值范围：[0, 2^32]，一共 2^32 (4294967296) 个序号。<br>序号增加到最大值的时候，下一个序号又回到了 0.<br>也就是说 TCP 协议可对 4GB  的数据进行编号，在一般情况下可保证当序号重复使用时，旧序号的数据早已经通过网络到达终点或者丢失了。    </p>
<h3 id="确认号-Acknowledgemt-Number"><a href="#确认号-Acknowledgemt-Number" class="headerlink" title="确认号 Acknowledgemt Number"></a>确认号 Acknowledgemt Number</h3><p>占 4 个字节。<br>表示<strong>期望收到对方下一个报文段的序号值</strong>。<br>TCP 的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。<br>就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。<br><strong>那么，确认报文，就会包含确认号</strong>。<br>例如，通讯的一方收到了第一个 25kb 的报文，该报文的 序号值=0，那么就需要回复一个<strong>确认报文</strong>，其中的确认号 = 25600.    </p>
<h3 id="数据偏移-Offset"><a href="#数据偏移-Offset" class="headerlink" title="数据偏移 Offset"></a>数据偏移 Offset</h3><p>占 0.5 个字节 (4 位)。<br>这个字段实际上是指出了 <strong>TCP 报文段的首部长度</strong> ，它指出了 TCP报文段的数据起始处 距离 TCP报文的起始处 有多远。（注意 数据起始处 和 报文起始处 的意思）    </p>
<p>一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大长度。    </p>
<h3 id="保留-Reserved"><a href="#保留-Reserved" class="headerlink" title="保留 Reserved"></a>保留 Reserved</h3><p>占 0.75 个字节 (6 位)。<br>保留为今后使用，但目前应置为 0。    </p>
<h3 id="标志位-TCP-Flags"><a href="#标志位-TCP-Flags" class="headerlink" title="标志位 TCP Flags"></a>标志位 TCP Flags</h3><p>标志位，一共有 6 个，分别占 1 位，共 6 位 。<br>每一位的值只有 0 和 1，分别表达不同意思。    </p>
<h4 id="紧急-URG-Urgent"><a href="#紧急-URG-Urgent" class="headerlink" title="紧急 URG (Urgent)"></a>紧急 URG (Urgent)</h4><p>当 URG = 1 的时候，表示紧急指针（Urgent Pointer）有效。<br>它告诉系统此报文段中有紧急数据，应尽快传送，而不要按原来的排队顺序来传送。<br>URG 要与首部中的 紧急指针 字段配合使用。    </p>
<h4 id="确认-ACK-Acknowlegemt"><a href="#确认-ACK-Acknowlegemt" class="headerlink" title="确认 ACK (Acknowlegemt)"></a>确认 ACK (Acknowlegemt)</h4><p>当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。<br>一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。<br>TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。    </p>
<h4 id="推送-PSH-Push"><a href="#推送-PSH-Push" class="headerlink" title="推送 PSH (Push)"></a>推送 PSH (Push)</h4><p>当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。    </p>
<h4 id="复位-RST-Reset"><a href="#复位-RST-Reset" class="headerlink" title="复位 RST (Reset)"></a>复位 RST (Reset)</h4><p>当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。<br>一般称携带 RST 标志的 TCP 报文段为「复位报文段」。    </p>
<h4 id="同步-SYN-SYNchronization"><a href="#同步-SYN-SYNchronization" class="headerlink" title="同步 SYN (SYNchronization)"></a>同步 SYN (SYNchronization)</h4><p>当 SYN = 1 的时候，表明这是一个请求连接报文段。<br>一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。<br>在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。<br>对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。    </p>
<h4 id="终止-FIN-Finis"><a href="#终止-FIN-Finis" class="headerlink" title="终止 FIN (Finis)"></a>终止 FIN (Finis)</h4><p>当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。<br>一般称携带 FIN 的报文段为「结束报文段」。<br>在 TCP 四次挥手释放连接的时候，就会用到该标志。    </p>
<h3 id="窗口大小-Window-Size"><a href="#窗口大小-Window-Size" class="headerlink" title="窗口大小 Window Size"></a>窗口大小 Window Size</h3><p>占 2 字节。<br>该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。<br>窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。<br>例如，假如确认号是 701 ，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。    </p>
<h3 id="校验和-TCP-Checksum"><a href="#校验和-TCP-Checksum" class="headerlink" title="校验和 TCP Checksum"></a>校验和 TCP Checksum</h3><p>占 2 个字节。<br>由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。<br>检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。    </p>
<h3 id="紧急指针-Urgent-Pointer"><a href="#紧急指针-Urgent-Pointer" class="headerlink" title="紧急指针 Urgent Pointer"></a>紧急指针 Urgent Pointer</h3><p>占 2 个字节。<br>仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。<br>当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的<strong>最前面</strong>，而在紧急数据后面的数据仍是普通数据。<br>因此，紧急指针指出了紧急数据的末尾在报文段中的位置。    </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://book.douban.com/subject/26850616/" target="_blank" rel="external">《后台开发 核心技术与应用实践》</a><br><a href="https://book.douban.com/subject/2970300/" target="_blank" rel="external">《计算机网络》</a>ect/2970300/)</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更好阅读体验：&lt;a href=&quot;https://jerryc8080.gitbooks.io/understand-tcp-and-udp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《理解 TCP 和 UDP》— By Gi
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="tcp" scheme="http://huang-jerryc.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>理解TCP（一）：端口</title>
    <link href="http://huang-jerryc.com/2017/03/02/understand-tcp-1/"/>
    <id>http://huang-jerryc.com/2017/03/02/understand-tcp-1/</id>
    <published>2017-03-02T07:56:25.000Z</published>
    <updated>2018-05-01T16:16:02.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>更好阅读体验：<a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/" target="_blank" rel="external">《理解 TCP 和 UDP》— By Gitbook</a>    </p>
</blockquote>
<h2 id="端口与进程"><a href="#端口与进程" class="headerlink" title="端口与进程"></a>端口与进程</h2><p>TCP 的包是不包含 IP 地址信息的，那是 IP 层上的事，但是有源端口和目的端口。<br>就是说，端口这一东西，是属于 TCP 知识范畴的。    </p>
<p>我们知道两个进程，在计算机内部进行通信，可以有管道、内存共享、信号量、消息队列等方法。<br>而两个进程如果需要进行通讯最基本的一个前提是能够唯一的标识一个进程，在本地进程通讯中我们可以使用 <strong>「PID(进程标识符)」</strong> 来唯一标识一个进程。<br>但 PID 只在本地唯一，如果把两个进程放到了不同的两台计算机，然后他们要通信的话，PID 就不够用了，这样就需要另外一种手段了。    </p>
<p>解决这个问题的方法就是在运输层使用 <strong>「协议端口号 (protocol port number)」</strong>，简称 <strong>「端口 (port)」</strong>.<br>我们知道 IP 层的 ip 地址可以唯一标识主机，而 TCP 层协议和端口号可以唯一标识主机的一个进程，这样我们可以利用：<strong>「ip地址＋协议＋端口号」</strong>唯一标示网络中的一个进程。<br>在一些场合，也把这种唯一标识的模式称为<strong>「套接字 (Socket)」</strong>。    </p>
<p>这就是说，虽然通信的重点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的端口，剩下的工作就由 TCP 来完成了。    </p>
<h2 id="认识端口"><a href="#认识端口" class="headerlink" title="认识端口"></a>认识端口</h2><p>TCP 用一个 16 位端口号来标识一个端口，可允许有 65536 ( 2的16次方) 个不同的端口号，范围在 0 ~ 65535 之间。    </p>
<p>端口号根据服务器使用还是客户端使用，以及常见不常见的维度来区分，主要有以下类别：</p>
<ol>
<li>服务器端使用的端口号<ul>
<li>熟知端口号</li>
<li>登记端口号</li>
</ul>
</li>
<li>客户端使用的端口号</li>
</ol>
<p>下面展开来说说。    </p>
<h3 id="端口号的分类"><a href="#端口号的分类" class="headerlink" title="端口号的分类"></a>端口号的分类</h3><h4 id="服务器端使用的端口号"><a href="#服务器端使用的端口号" class="headerlink" title="服务器端使用的端口号"></a>服务器端使用的端口号</h4><p><strong>熟知端口号</strong>：<br>取值范围：0 ~ 1023。<br>可以在 www.iana.org 查到，服务器机器一接通电源，服务器程序就运行起来，为了让因特网上所有的客户程序都能找到服务器程序，服务器程序所使用的端口就必须是固定的，并且总所众所周知的。    </p>
<p>一些常见的端口号：    </p>
<table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>TFTP</th>
<th>HTTP</th>
<th>HTTPS</th>
<th>SNMP</th>
</tr>
</thead>
<tbody>
<tr>
<td>熟知端口号</td>
<td><strong>21</strong></td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>69</td>
<td><strong>80</strong></td>
<td><strong>443</strong></td>
<td>161</td>
</tr>
</tbody>
</table>
<p><strong>登记端口号</strong>：<br>取值范围：1024 ~ 49151。<br>这类端口没有熟知的应用程序使用，但是需要登记，以防重复</p>
<h4 id="客户端使用的端口号"><a href="#客户端使用的端口号" class="headerlink" title="客户端使用的端口号"></a>客户端使用的端口号</h4><p>取值范围：49152 ~ 65535。<br>这类端口仅在客户端进程运行时才动态选择。<br>又叫 短暂端口号，表示这种端口的存在时间是短暂的，客户进程并不在意操作系统给它分配的是哪一个端口号，因为客户进程之所以必须有一个端口号，是为了让传输层的实体能够找到自己。    </p>
<p><em>PS：在<code>/etc/services</code>文件中可以查看所有知名服务使用的端口。</em></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://book.douban.com/subject/26850616/" target="_blank" rel="external">《后台开发 核心技术与应用实践》</a><br><a href="https://book.douban.com/subject/2970300/" target="_blank" rel="external">《计算机网络》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更好阅读体验：&lt;a href=&quot;https://jerryc8080.gitbooks.io/understand-tcp-and-udp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《理解 TCP 和 UDP》— By Gi
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="tcp" scheme="http://huang-jerryc.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>Gulp 基础与原理</title>
    <link href="http://huang-jerryc.com/2017/02/28/gulp-base/"/>
    <id>http://huang-jerryc.com/2017/02/28/gulp-base/</id>
    <published>2017-02-28T05:49:00.000Z</published>
    <updated>2017-02-28T05:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gulp-概述"><a href="#Gulp-概述" class="headerlink" title="Gulp 概述"></a>Gulp 概述</h1><p>Gulp 是基于 NodeJS 的项目，一个用作自动化构建的工具，业界一般用来建造前端的工作流。</p>
<p>它的核心原理其实很简单，最主要是通过各种 Transform Stream 来实现文件的处理，然后再进行输出。Transform Streams 是 NodeJS Stream 的一种，是可读又可写的，它会对传给它的对象做一些转换的操作。</p>
<blockquote>
<p>文件输入 →  Gulp 插件处理 → 文件输出</p>
</blockquote>
<p>原则上，gulp 可以针对文件做任何有趣、有创造力事情。<br>而自动化构建，只是大家主要比较喜欢使用的方向。</p>
<p>Gulp 的特点：</p>
<ul>
<li><strong>自动化</strong> - Gulp 为你的工作流而服务，自动运行那些费事费力任务。</li>
<li><strong>平台透明</strong> - Gulp 被集成到各种 IDE 中，并且除了 NodeJS 之外，其他如 PHP、.NET、Java 平台都可以使用 Gulp。</li>
<li><strong>强大生态系统</strong> - 你可以使用 npm 上 2000+ 的插件来构造你的工作流。</li>
<li><strong>简单</strong> - Gulp 只提供几个 API，这可以很快地学习和上手。</li>
</ul>
<h1 id="使用-Gulp"><a href="#使用-Gulp" class="headerlink" title="使用 Gulp"></a>使用 Gulp</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install gulp-cli -g // 全局安装 Gulp 命令行工具</div><div class="line">$ npm install gulp -D // 在项目中，作为 devDependencies 依赖安装 gulp</div></pre></td></tr></table></figure>
<h2 id="Gulpfile-js"><a href="#Gulpfile-js" class="headerlink" title="Gulpfile.js"></a>Gulpfile.js</h2><p>在使用 CLI 工具的时候，会执行该文件，它是一个可执行的 NodeJS 文件。原理上，你可以在里面运行任何 NodeJS 代码，然后通过调用 gulp 提供的 API，来执行 gulp 任务。<br><code>gulpfile.js</code>  文件一般都会放在项目的根目录中。</p>
<p>一个使用 <strong><a href="https://www.npmjs.com/package/gulp-babel2/" target="_blank" rel="external">gulp-babel</a></strong> 插件来支持 es2015 语法的案例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const gulp = require(&apos;gulp&apos;);</div><div class="line">const babel = require(&apos;gulp-babel&apos;);</div><div class="line"></div><div class="line">gulp.task(&apos;default&apos;, () =&gt; &#123;</div><div class="line">    gulp.src(&apos;src/app.js&apos;)</div><div class="line">        .pipe(babel(&#123;</div><div class="line">            presets: [&apos;es2015&apos;]</div><div class="line">        &#125;))</div><div class="line">        .pipe(gulp.dest(&apos;dist&apos;));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="基本概念与原理"><a href="#基本概念与原理" class="headerlink" title="基本概念与原理"></a>基本概念与原理</h1><p>了解这些概念，对于了解 Gulp 的工作原理，和 API 的使用是很有帮助的。</p>
<h2 id="认识-Glob"><a href="#认识-Glob" class="headerlink" title="认识 Glob"></a>认识 Glob</h2><p>Glob 是一种用来匹配路径与文件的模式。有点类似于正则表达式，但是语法又有点差异。<br>这种模式，被广泛用于命令行、Shell 等场景，大家熟悉的 <code>.gitignore</code> 文件也是使用这种模式。</p>
<p>各大语言都有对于 Glob 的实现，例如 Go 和 PHP 的 <code>Glob</code> 函数，Python 中的 <code>glob</code> 模块。<br>而 NodeJS 的实现是 <strong><a href="https://github.com/isaacs/minimatch" target="_blank" rel="external">minimatch</a></strong>, 而在 Gulp 源码中，就用了对 minimatch 进行封装的 <strong><a href="https://github.com/isaacs/node-glob" target="_blank" rel="external">node-glob</a></strong> 模块。<br>Gulp 的 API <code>gulp.watch</code> 和 <code>gulp.src</code> 都有用到 Glob 来匹配对应的路径和文件。<br>下面是部分语法：</p>
<ul>
<li><code>*</code><br>匹配该路径段中 0 个或多个任意字符，<br>如：<code>js/*.js</code>， 匹配 js 目录下的所有 js 文件</li>
<li><code>?</code><br>匹配该路径段中 1 个任意字符，<br>如：<code>js/?.js</code>，匹配 js 目录下所有名字只有 1 个字的 js</li>
<li><p><code>[...]</code><br>匹配该路径段中在指定范围内字符，<br>如：<code>js/a[0-3].js</code>，匹配 js 目录下 a 开头,第二个字符为 0-3 之间（ 包括0和3 ）的 js（ a03.js不能被匹配到 ）</p>
</li>
<li><p><code>!(pattern|pattern|pattern)</code><br>匹配除所给出的模型以外的情况，<br>如：<code>js/!(a|b).js</code>，匹配 js 目录下名字中不包含 a ,也不包含 b 的所有文件.</p>
</li>
<li><p><code>?(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 0 个或任意 1 个，<br>如：<code>js/?(a|a2|b).js</code>, 匹配 js 目录下 a.js , a2.js , b.js</p>
</li>
<li><p><code>+(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 1 个或者多个，<br>如：<code>js/+(a|a1|b).js</code>, 匹配 js 目录下 a.js , a1.js , b.js , 或者 a, a1, b 这几个字符的组合的 js , 比如 ab.js</p>
</li>
<li><p><code>*(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 0 个或多个或任意个的组合.<br>如：<code>js/*(a|a1|b).js</code>，匹配 js 目录下 a.js, a1.js, b.js 或者 a, a1, b这几个字符的组合的 js , 比如 ab.js</p>
</li>
<li><p><code>@(pattern|pat*|pat?erN)</code><br>匹配所给出的模型中的任意 1 个，<br>如：<code>js/@(a|a1|b)</code>, 匹配 js 目录下的 a.js, a1.js, b.js</p>
</li>
<li><p><code>**</code><br>与 <code>*</code> 一样可以匹配任何内容，但 <code>**</code>不仅匹配路径中的某一段,而且可以匹配 <code>a/b/c</code> 这样带有 <code>/</code> 的内容，所以，它还可以匹配子文件夹下的文件.<br>如：<code>js/**/*.js</code>，匹配 js 目录下及子文件夹中所有的 js 文件。</p>
</li>
</ul>
<p>更多 Glob 的知识和语法，可以参考：<br><a href="https://www.wikiwand.com/en/Glob_(programming" target="_blank" rel="external">Glob - Wiki</a><br><a href="https://github.com/isaacs/node-glob#glob-primer" target="_blank" rel="external">Glob Primer</a></p>
<h2 id="认识-Vinyl"><a href="#认识-Vinyl" class="headerlink" title="认识 Vinyl"></a>认识 Vinyl</h2><p><a href="https://github.com/gulpjs/vinyl" target="_blank" rel="external">Vinyl</a> 是 Gulp 自创的一种用来描述一个虚拟文件的类，其中主要包括文件的内容和文件的路径两大信息。vinyl 模块，只是提供了一个类，而实现却交由 <code>vinyl-fs</code></p>
<p><a href="https://github.com/gulpjs/vinyl-fs" target="_blank" rel="external">Vinyl-fs</a>，它主要的工作是接受 glob 模式的参数，然后读取匹配的文件。然后利用 Vinyl 制作一个 Transform Stream，称为 Vinyl Stream 对象，并返回。</p>
<p>在 Gulp 中的 API <code>gulp.src</code>、<code>gulp.watch</code>、<code>gulp.dest</code> 都返回一个 Vinyl Stream 实例对象。Vinyl Stream 实例之间可以通过管道（ <code>vinyl1.pipe(vinyl2)</code> ）的形式来互相传输数据。 </p>
<p>从 Gulp 的 <a href="https://github.com/gulpjs/gulp/blob/master/index.js#L25-L41" target="_blank" rel="external">源码</a> 中也能看出，这三个 API 都是由 vinyl-fs 提供全部的实现。</p>
<p>再一点是，从这两个模块的实现来看，Gulp 是把文件内容以 Buffer 的形式读到内存中，然后再进行处理的。</p>
<h2 id="认识-Orchestrator"><a href="#认识-Orchestrator" class="headerlink" title="认识 Orchestrator"></a>认识 Orchestrator</h2><p><a href="https://github.com/robrich/orchestrator" target="_blank" rel="external">Orchestartor</a>，为 <code>gulp.task</code> 提供了全部实现，这可以从 <a href="https://github.com/gulpjs/gulp/blob/master/index.js#L14" target="_blank" rel="external">源码</a> 中看出。<br>它为 Gulp 提供了任务相关的功能，包括任务注册、任务执行以及相对应的任务进度、错误监控等功能。</p>
<p>Orchestartor 模块，只提供了一个 Orchestartor 类，该类的实例维护着一个 tasks 数组，该数组的内容就是一个我们使用 <code>gulp.task</code> 时注册的函数列表，以及函数的依赖和名字。<br>通过 <a href="https://github.com/robrich/orchestrator/blob/master/index.js#L54-L57" target="_blank" rel="external">源码</a> 中，可以看到 tasks 的数据结构：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">this.tasks[name] = &#123;</div><div class="line">  <span class="attr">fn</span>: fn,   <span class="comment">// 任务的函数体</span></div><div class="line">  dep: dep,   <span class="comment">// 任务所依赖的其他任务名称</span></div><div class="line">  name: name  <span class="comment">// 该任务的名称</span></div><div class="line">&#125;;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<h1 id="Gulp-核心-API"><a href="#Gulp-核心-API" class="headerlink" title="Gulp 核心 API"></a>Gulp 核心 API</h1><ul>
<li>gulp.src：获取文件</li>
<li>gulp.dest：写入文件</li>
<li>gulp.tasks：注册任务</li>
<li>gulp.watch：监控文件的改动</li>
</ul>
<h2 id="gulp-src"><a href="#gulp-src" class="headerlink" title="gulp.src"></a>gulp.src</h2><p><code>gulp.src( globs [, options] )</code></p>
<p>接收一个 globs 模式的对象，可以是 Array 或者 String，返回一个 Vinyl Stream 实例。<br>而 options 有下面的值：</p>
<ul>
<li>buffer - Boolean, 控制 <code>file.contents</code> 是返回 buffer 还是 stream。</li>
<li>read - Boolean，控制是否读取文件，如果 false，则 <code>file.contents</code> 为 <code>null</code></li>
<li>base - String，控制 glob 的 base，默认值是 glob 所有表达式的前置，例如 <code>client/js/**/*.js</code>, base 值就为 <code>client/js/</code>。而 glob 在保存输出路径的时候，取的是 base 之后的路径。所以可以通过该值，来进行输出路径的改写。</li>
</ul>
<h2 id="gulp-dest"><a href="#gulp-dest" class="headerlink" title="gulp.dest"></a>gulp.dest</h2><p><code>gulp.dest( path [, options] )</code></p>
<p>接收输出路径，返回一个 Vinyl Stream 实例。<br>而 options 有以下的值：</p>
<ul>
<li>cwd - String， 默认值 <code>process.pwd()</code>，输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。</li>
<li>mode -  String，八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。</li>
</ul>
<h2 id="gulp-task"><a href="#gulp-task" class="headerlink" title="gulp.task"></a>gulp.task</h2><p><code>gulp.task( name [, deps ], fn )</code></p>
<p>定义一个使用 Orchestrator 实现的任务（task）。<br>参数的描述如下：</p>
<ul>
<li>name - 任务名称</li>
<li>deps - 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数</li>
<li>fn - 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。</li>
</ul>
<h2 id="gulp-watch"><a href="#gulp-watch" class="headerlink" title="gulp.watch"></a>gulp.watch</h2><p><code>gulp.watch( glob [, opts ], tasks )</code><br>or<br><code>gulp.watch( glob [, opts, cb ] )</code></p>
<p>用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务。<br>各参数的描述如下：</p>
<ul>
<li>glob - 为要监视的文件 Glob 匹配模式。</li>
<li>opts - 为一个可选的配置对象。</li>
<li>tasks - 为文件变化后要执行的任务，为一个数组</li>
</ul>
<h1 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h1><ul>
<li><a href="https://www.npmjs.com/package/gulp-load-plugins" target="_blank" rel="external">gulp-load-plugins</a>：自动加载 <code>package.json</code> 中的 gulp 插件</li>
<li><a href="https://www.npmjs.com/package/gulp-rename" target="_blank" rel="external">gulp-rename</a>： 重命名</li>
<li><a href="https://www.npmjs.com/package/gulp-uglify" target="_blank" rel="external">gulp-uglify</a>：文件压缩</li>
<li><a href="https://www.npmjs.com/package/gulp-concat" target="_blank" rel="external">gulp-concat</a>：文件合并</li>
<li><a href="https://www.npmjs.com/package/gulp-less" target="_blank" rel="external">gulp-less</a>：编译 less</li>
<li><a href="https://www.npmjs.com/package/gulp-sass" target="_blank" rel="external">gulp-sass</a>：编译 sass</li>
<li><a href="https://github.com/scniro/gulp-clean-css" target="_blank" rel="external">gulp-clean-css</a>：压缩 CSS 文件</li>
<li><a href="https://github.com/jonschlinkert/gulp-htmlmin" target="_blank" rel="external">gulp-htmlmin</a>：压缩 HTML 文件</li>
<li><a href="https://github.com/babel/gulp-babel" target="_blank" rel="external">gulp-babel</a>: 使用 babel 编译 JS 文件</li>
<li><a href="https://www.npmjs.com/package/gulp-jshint" target="_blank" rel="external">gulp-jshint</a>：jshint 检查</li>
<li><a href="https://github.com/sindresorhus/gulp-imagemin" target="_blank" rel="external">gulp-imagemin</a>：压缩jpg、png、gif等图片</li>
<li><a href="https://github.com/vohof/gulp-livereload" target="_blank" rel="external">gulp-livereload</a>：当代码变化时，它可以帮我们自动刷新页面</li>
</ul>
<p>更多插件，可以搜索<a href="http://gulpjs.com/plugins/" target="_blank" rel="external">官方插件库</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Gulp-概述&quot;&gt;&lt;a href=&quot;#Gulp-概述&quot; class=&quot;headerlink&quot; title=&quot;Gulp 概述&quot;&gt;&lt;/a&gt;Gulp 概述&lt;/h1&gt;&lt;p&gt;Gulp 是基于 NodeJS 的项目，一个用作自动化构建的工具，业界一般用来建造前端的工作流。&lt;/
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="前端构建" scheme="http://huang-jerryc.com/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
</feed>
