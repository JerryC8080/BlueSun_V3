<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BlueSun</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huang-jerryc.com/"/>
  <updated>2022-04-20T03:06:27.393Z</updated>
  <id>http://huang-jerryc.com/</id>
  
  <author>
    <name>JerryC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何构建可控,可靠,可扩展的 PWA 应用</title>
    <link href="http://huang-jerryc.com/2022/04/20/build-a-extensible-reliable-controllable-PWA-app/"/>
    <id>http://huang-jerryc.com/2022/04/20/build-a-extensible-reliable-controllable-PWA-app/</id>
    <published>2022-04-20T03:06:27.393Z</published>
    <updated>2022-04-20T03:06:27.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="u5982_u4F55_u6784_u5EFA_u53EF_u63A7_2C_u53EF_u9760_2C_u53EF_u6269_u5C55_u7684_PWA__u5E94_u7528"><a href="#u5982_u4F55_u6784_u5EFA_u53EF_u63A7_2C_u53EF_u9760_2C_u53EF_u6269_u5C55_u7684_PWA__u5E94_u7528" class="headerlink" title="如何构建可控,可靠,可扩展的 PWA 应用"></a>如何构建可控,可靠,可扩展的 PWA 应用</h1><h2 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h2><p>PWA （Progressive Web App）指的是使用指定技术和标准模式来开发的 Web 应用，让 Web 应用具有原生应用的特性和体验。比如我们觉得本地应用使用便捷，响应速度更加快等。</p>
<p>PWA 由 Google 于 2016 年提出，于 2017 年正式技术落地，并在 2018 年迎来重大突破，全球顶级的浏览器厂商，Google、Microsoft、Apple 已经全数宣布支持 PWA 技术。</p>
<p>PWA 的关键技术有两个：</p>
<ol>
<li>Manifest：浏览器允许你提供一个清单文件，从而实现 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Add_to_home_screen" target="_blank" rel="external">A2HS</a></li>
<li>ServiceWorker：通过对网络请求的代理，从而实现资源缓存、站点加速、离线应用等场景。</li>
</ol>
<p>这两个是目前绝大部分开发者构建 PWA 应用所使用的最多的技术。</p>
<p>其次还有诸如：消息推送、WebStream、Web蓝牙、Web分享、硬件访问等API。出于浏览器厂商的支持不一，普及度还不高。</p>
<p>不管怎么样，使用 ServiceWorker 来优化用户体验，已经成为Web前端优化的主流技术。</p>
<h2 id="u5DE5_u5177_u4E0E_u6846_u67B6"><a href="#u5DE5_u5177_u4E0E_u6846_u67B6" class="headerlink" title="工具与框架"></a>工具与框架</h2><p>2018 年之前，主流的工具是：</p>
<ol>
<li><a href="https://github.com/GoogleChromeLabs/sw-toolbox" target="_blank" rel="external">google/sw-toolbox</a>: 提供了一套工具，用于方便的构建 ServiceWorker。</li>
<li><a href="https://github.com/GoogleChromeLabs/sw-precache" target="_blank" rel="external">google/sw-precache</a>: 提供在构建阶段，注入资源清单到 ServiceWorker 中，从而实现预缓存功能。 </li>
<li><a href="https://github.com/lavas-project/lavas" target="_blank" rel="external">baidu/Lavas</a>: 百度开发的基于 Vue 的 PWA 集成解决方案。</li>
</ol>
<p>后来由于 Google 开发了更加优秀的工具集 <a href="https://developers.google.com/web/tools/workbox" target="_blank" rel="external">Workbox</a>，<code>sw-toolbox</code> 和 <code>sw-precache</code> 得以退出舞台。</p>
<p>而 Lavas 由于团队解散，主要作者离职，已处于停止维护状态。</p>
<h2 id="u75DB_u70B9"><a href="#u75DB_u70B9" class="headerlink" title="痛点"></a>痛点</h2><p>Workbox 提供了一套工具集合，用以帮助我们管理 ServiceWorker ，它对 CacheStorage 的封装，也得以让我们更轻松的去管理资源。</p>
<p>但是在构建实际的 PWA 应用的时候，我们还需要关心很多问题：</p>
<ol>
<li>如何组织工程和代码？</li>
<li>如何进行单元测试？</li>
<li>如何解决 MPA (Multiple Page Application) 应用间的 ServiceWorker 作用域冲突问题？</li>
<li>如何远程控制我们的 ServiceWorker？</li>
<li>最优的资源缓存方案？</li>
<li>如何监控我们的 ServiceWorker，收集数据？</li>
</ol>
<p>由于 Workbox 的定位是 <strong>「Library」</strong>，而我们需要一个 <strong>「Framework」</strong> 去为这些通用问题提供统一的解决方案。</p>
<p>并且， 我们希望它是渐进式（Progressive）的，就犹如 PWA 所提倡的那样。</p>
<h2 id="u4EE3_u7801_u89E3_u8026"><a href="#u4EE3_u7801_u89E3_u8026" class="headerlink" title="代码解耦"></a>代码解耦</h2><p><strong>是什么问题？</strong></p>
<p>当我们的 ServiceWorker 程序代码越来越多的时候，会造成代码臃肿，管理混乱，复用困难。<br>同时一些常见的实现，如：远程控制、进程通讯、数据上报等，希望能实现按需插拔式的复用，这样才能达到「渐进式」的目的。</p>
<p>我们都知道，ServiceWorker 在运行时提供了一系列事件，常用的有：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'install'</span>, event =&gt; &#123; &#125;);</span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, event =&gt; &#123; &#125;);</span><br><span class="line">self.addEventListener(<span class="string">"fetch"</span>, event =&gt; &#123; &#125;);</span><br><span class="line">self.addEventListener(<span class="string">'message'</span>, event =&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>
<p>当我们有多个功能实现都要监听相同的事件，就会导致同个文件的代码越来越臃肿：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'install'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// 远程控制模块 - 配置初始化</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 资源预缓存模块 - 缓存资源</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 数据上报模块 - 收集事件</span></span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// 远程控制模块 - 刷新配置</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 数据上报模块 - 收集事件</span></span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">self.addEventListener(<span class="string">"fetch"</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// 远程控制模块 - 心跳检查</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 资源缓存模块 - 缓存匹配</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 数据上报模块 - 收集事件</span></span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'message'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// 数据上报模块 - 收集事件</span></span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你可能会说可以进行「模块化」：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> remoteController from <span class="string">'./remoete-controller.ts'</span>;  <span class="comment">// 远程控制模块</span></span><br><span class="line"><span class="keyword">import</span> assetsCache from <span class="string">'./assets-cache.ts'</span>;  <span class="comment">// 资源缓存模块</span></span><br><span class="line"><span class="keyword">import</span> collector from <span class="string">'./collector.ts'</span>;  <span class="comment">// 数据收集模块</span></span><br><span class="line"><span class="keyword">import</span> precache from <span class="string">'./pre-cache.ts'</span>;  <span class="comment">// 资源预缓存模块</span></span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// 远程控制模块 - 配置初始化</span></span><br><span class="line">  remoteController.init(...);</span><br><span class="line">  <span class="comment">// 资源预缓存模块 - 缓存资源</span></span><br><span class="line">  assetsCache.store(...);</span><br><span class="line">  <span class="comment">// 数据上报模块 - 收集事件</span></span><br><span class="line">  collector.log(...);</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// 远程控制模块 - 刷新配置</span></span><br><span class="line">  remoteController.refresh(..);</span><br><span class="line">  <span class="comment">// 数据上报模块 - 收集事件</span></span><br><span class="line">  collector.log(...);</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">self.addEventListener(<span class="string">"fetch"</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// 远程控制模块 - 心跳检查</span></span><br><span class="line">  remoteController.heartbeat(...);</span><br><span class="line">  <span class="comment">// 资源缓存模块 - 缓存匹配</span></span><br><span class="line">  assetsCache.match(...);</span><br><span class="line">  <span class="comment">// 数据上报模块 - 收集事件</span></span><br><span class="line">  collector.log(...);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'message'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// 数据上报模块 - 收集事件</span></span><br><span class="line">  collector.log(...);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>模块化能减少主文件的代码量，同时也一定程度上对功能进行了解耦，但是这种方式还存在一些问题：</p>
<ol>
<li><strong>复用困难</strong>：当要使用一个模块的功能时，要在多个事件中去正确的调用模块的接口。同样，要去掉一个模块事，也要多个事件中去修改。</li>
<li><strong>使用成本高</strong>：模块暴露各种接口，使用者必须了解透彻模块的运转方式，以及接口的使用，才能很好的使用。</li>
<li><strong>解耦有限</strong>：如果模块更多，甚至要解决同域名下多个前端应用的命名空间冲突问题，就会显得捉襟见肘。</li>
</ol>
<p>要达到我们目的：<strong>「渐进式」</strong>，我们需要对代码的组织再优化一下。</p>
<p><strong>插件化实现</strong></p>
<p>我们可以把 ServiceWorker 的一系列事件的控制权交出去，各模块通过插件的方式来使用这些事件。</p>
<p>我们知道 Koa.js 著名的洋葱模型：</p>
<p align="center"><br>  <img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20200827101330.png"><br></p>



<p>洋葱模型是「插件化」的很好的思想，但是它是 <strong>「一维」</strong> 的，Koa 完成一次网络请求的应答，各个中间件只需要监听一个事件。</p>
<p>而在 ServiceWorker 中，除了上面提及到的常用四个事件，他还有更多事件，如：<a href="https://developer.mozilla.org/en-US/docs/Web/API/SyncEvent" target="_blank" rel="external"><code>SyncEvent</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/NotificationEvent" target="_blank" rel="external"><code>NotificationEvent</code></a>。</p>
<p>所以，我们还要多弄几个「洋葱」去满足更多的事件。</p>
<p>同时由于 PWA 应用的代码一般会运行在两个线程：主线程、ServiceWorker 线程。</p>
<p>最后，我们去封装原生的事件，去提供插件化支持，从而有了：<strong>「多维洋葱插件系统」</strong>：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204121006999.png" alt="GlacierJS 多维洋葱插件系统"></p>
<p>对原生事件和生命周期进行封装之后，我们为每一个插件提供更优雅的生命周期钩子函数：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204121158786.png" alt="GlacierJS 生命周期图示"></p>
<p>我们基于 <a href="https://jerryc8080.github.io/GlacierJS" target="_blank" rel="external">GlacierJS</a> 的话，可以很容易做到模块的插件化。</p>
<p>在 ServiceWorker 线程的主文件中注册插件：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; GlacierSW &#125; from <span class="string">'@glacierjs/sw'</span>;</span><br><span class="line"><span class="keyword">import</span> RemoteController from <span class="string">'./remoete-controller.ts'</span>;  <span class="comment">// 远程控制模块</span></span><br><span class="line"><span class="keyword">import</span> AssetsCache from <span class="string">'./assets-cache.ts'</span>;  <span class="comment">// 资源缓存模块</span></span><br><span class="line"><span class="keyword">import</span> Collector from <span class="string">'./collector.ts'</span>;  <span class="comment">// 数据收集模块</span></span><br><span class="line"><span class="keyword">import</span> Precache from <span class="string">'./pre-cache.ts'</span>;  <span class="comment">// 资源预缓存模块</span></span><br><span class="line"><span class="keyword">import</span> MyPluginSW from <span class="string">'./my-plugin.ts'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> glacier = <span class="keyword">new</span> GlacierSW();</span><br><span class="line"></span><br><span class="line">glacier.use(<span class="keyword">new</span> Log(...));</span><br><span class="line">glacier.use(<span class="keyword">new</span> RemoteController(...));</span><br><span class="line">glacier.use(<span class="keyword">new</span> AssetsCache(...));</span><br><span class="line">glacier.use(<span class="keyword">new</span> Collector(...));</span><br><span class="line">glacier.use(<span class="keyword">new</span> Precache(...));</span><br><span class="line"></span><br><span class="line">glacier.listen();</span><br></pre></td></tr></table></figure>
<p>而在插件中，我们可以通过监听事件去收归一个独立模块的逻辑：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ServiceWorkerPlugin &#125; from <span class="string">'@glacierjs/sw'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; FetchContext, UseContext  &#125; from <span class="string">'@glacierjs/sw'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyPluginSW <span class="keyword">implements</span> ServiceWorkerPlugin &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>() </span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> async onUse(context: UseContext) &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> async onInstall(event) &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> async onActivate() &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> async onFetch(context: FetchContext) &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> async onMessage(event) &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> async onUninstall() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4F5C_u7528_u57DF_u51B2_u7A81"><a href="#u4F5C_u7528_u57DF_u51B2_u7A81" class="headerlink" title="作用域冲突"></a>作用域冲突</h2><p>我们都知道关于 ServiceWorker 的作用域有两个关键特性：</p>
<ol>
<li><strong>默认的作用域是注册时候的 Path。</strong></li>
<li><strong>同个路径下同时间只能有一个 ServiceWorker 得到控制权。</strong></li>
</ol>
<p><strong>作用域缩小与扩大</strong></p>
<p>关于第一个特性，例如注册 Service Worker 文件为 <code>/a/b/sw.js</code>，则 scope 默认为 <code>/a/b/</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/a/b/sw.js'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">reg</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reg.scope);</span><br><span class="line">        <span class="comment">// scope =&gt; https://yourhost/a/b/</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们可以在注册的的时候指定 <code>scope</code> 去向下缩小作用域，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/a/b/sw.js'</span>, &#123;scope: <span class="string">'/a/b/c/'</span>&#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">reg</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(reg.scope);</span><br><span class="line">            <span class="comment">// scope =&gt; https://yourhost/a/b/c/</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过服务器对 ServiceWorker 文件的响应设置 <code>Service-Worker-Allowed</code> 头部，去扩大作用域。</p>
<p>例如 Google Docs 在作用域 <code>https://docs.google.com/document/u/0/</code> 注册了一个来自于 <code>https://docs.google.com/document/offline/serviceworker.js</code> 的 ServiceWorker</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/202204131004508.png" alt="img"></p>
<p><strong>MPA下的 ServiceWorker 治理</strong></p>
<p>现代 Web App 项目主要有两种架构形式存在： <strong>SPA(Single Page Application)</strong> 和 <strong>MPA(Multiple Page Application)</strong></p>
<p>MPA 这种架构的模式在现如今的大型 Web App 非常常见，这种 Web App 相比较于 SPA 能够承受更重的业务体量，并且利于大型 Web App 的后期维护和扩展，它往往会有多个团队去维护。</p>
<p>假设我们有一个 MPA 的站点：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- app1</span><br><span class="line">|   |-- app1-service-worker.js</span><br><span class="line">|   `-- index.html</span><br><span class="line">|-- app2</span><br><span class="line">|   `-- index.html</span><br><span class="line">|-- index.html</span><br><span class="line">`-- root-service-worker.js</span><br></pre></td></tr></table></figure>
<p><strong>app1</strong> 和 <strong>app2</strong> 分别由不同的团队维护。</p>
<p>如果我们在根目录 <code>&#39;/&#39;</code> 注册了 <code>root-service-worker.js</code>，去完成一些通用的功能，例如：「日志收集」、「静态资源缓存」等。</p>
<p>然后 <strong>app1</strong> 团队利用 ServiceWorker 的能力开发了一些特定的功能需要，例如 app1 的「离线化功能」。</p>
<p>他们在 <code>app1/index.html</code>目录注册了 <code>app1-service-worker.js</code>。</p>
<p>这时候，访问 <code>app1/*</code> 下的所有页面，ServiceWorker 控制权会交给 <code>app1-service-worker.js</code>，也就是只有app1的「离线化功能」在工作，而原来的「日志收集」、「静态缓存」等功能会失效。</p>
<p>显然这种情况是我们不希望看到的，并且在实际的开发中发生的概率会很大。</p>
<p>解决这个问题有两种方案：</p>
<ol>
<li>封装「日志收集」、「静态资源缓存」功能，<code>app1-service-worker.js</code>引入并使用这些功能。</li>
<li>把「离线化功能」整合到 <code>root-service-worker.js</code>，只允许注册该 ServiceWorker。</li>
</ol>
<p>关于方案一，封装通用功能这是正确的，但是主域下的功能可能完全没办法一一拆解，并且后续主域的 ServiceWorker 更新了新功能，子域下的 ServiceWorker 还需要主动去更新和升级。</p>
<p>关于方案二，显然可以解决方案一的问题，但是其他应用，例如 <strong>app2</strong> 可能不需要「离线化功能」。</p>
<p><strong>基于此，我们引入方案三：功能整合到主域，支持功能的组合按照作用域隔离。</strong></p>
<p>基于  <a href="https://jerryc8080.github.io/GlacierJS" target="_blank" rel="external">GlacierJS</a>  的话代码上可能会是这样的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mainPlugins = [</span><br><span class="line">  <span class="keyword">new</span> Collector(); <span class="comment">// 日志收集功能</span></span><br><span class="line">  <span class="keyword">new</span> AssetsCache(); <span class="comment">// 静态资源缓存功能</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">glacier.use(<span class="string">'/'</span>, mainPlugins)；</span><br><span class="line">glacier.use(<span class="string">'/app1'</span>, [</span><br><span class="line">  ...mainPlugins,</span><br><span class="line">  <span class="keyword">new</span> Offiline(),  <span class="comment">// 离线化功能</span></span><br><span class="line">])；</span><br></pre></td></tr></table></figure>
<h2 id="u8D44_u6E90_u7F13_u5B58"><a href="#u8D44_u6E90_u7F13_u5B58" class="headerlink" title="资源缓存"></a>资源缓存</h2><p>ServiceWorker 一个很核心的能力就是能结合 CacheAPI  进行灵活的缓存资源，从而达到优化站点的加载速度、弱网访问、离线应用等。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220414092530.png" alt="image-20220414092525515"></p>
<p>对于静态资源有五种常用的缓存策略：</p>
<ol>
<li><strong>stale-while-revalidate</strong><br>该模式允许您使用缓存（如果可用）尽快响应请求，如果没有缓存则回退到网络请求，然后使用网络请求来更新缓存，它是一种比较安全的缓存策略。</li>
<li><strong>cache-first</strong><br>离线 Web 应用程序将严重依赖缓存，但对于非关键且可以逐渐缓存的资源，<strong>「缓存优先」</strong>是最佳选择。<br>如果缓存中有响应，则将使用缓存的响应来满足请求，并且根本不会使用网络。<br>如果没有缓存响应，则请求将由网络请求完成，然后响应会被缓存，以便下次直接从缓存中提供下一个请求。</li>
<li><strong>network-first</strong><br>对于频繁更新的请求，<strong>「网络优先」</strong>策略是理想的解决方案。<br>默认情况下，它会尝试从网络获取最新响应。如果请求成功，它会将响应放入缓存中。如果网络未能返回响应，则将使用缓存的响应。</li>
<li><strong>network-only</strong><br>如果您需要从网络满足特定请求，network-only 模式会将资源请求进行透传到网络。</li>
<li><strong>cache-only</strong><br>该策略确保从缓存中获取响应。这种场景不太常见，它一般匹配着「预缓存」策略会比较有用。</li>
</ol>
<p>那这些策略中，我们应该使用哪种呢？答案是根据资源的种类具体选择。</p>
<p>例如一些资源如果只是在 Web 应用发布的时候才会更新，我们就可以使用 cache-first 策略，例如一些 JS、样式、图片等。</p>
<p>而 index.html 作为页面的加载的主入口，更加适宜使用 stale-while-revalidate 策略。</p>
<p>我们以 GlacierJS 的缓存插件（<a href="https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-assets-cache" target="_blank" rel="external">@glacierjs/plugin-assets-cache</a>）为例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in service-worker.js</span></span><br><span class="line">importScripts(<span class="string">"//cdn.jsdelivr.net/npm/@glacierjs/core/dist/index.min.js"</span>);</span><br><span class="line">importScripts(<span class="string">'//cdn.jsdelivr.net/npm/@glacierjs/sw/dist/index.min.js'</span>);</span><br><span class="line">importScripts(<span class="string">'//cdn.jsdelivr.net/npm/@glacierjs/plugin-assets-cache/dist/index.min.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; GlacierSW &#125; = self[<span class="string">'@glacierjs/sw'</span>];</span><br><span class="line"><span class="keyword">const</span> &#123; AssetsCacheSW, Strategy &#125; = self[<span class="string">'@glacierjs/plugin-assets-cache'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> glacierSW = <span class="keyword">new</span> GlacierSW();</span><br><span class="line"></span><br><span class="line">glacierSW.use(<span class="keyword">new</span> AssetsCacheSW(&#123;</span><br><span class="line">    routes: [&#123;</span><br><span class="line">        <span class="comment">// capture as string: store index.html with stale-while-revalidate strategy.</span></span><br><span class="line">        capture: <span class="string">'https://mysite.com/index.html'</span>,</span><br><span class="line">        strategy: Strategy.STALE_WHILE_REVALIDATE,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="comment">// capture as RegExp: store all images with cache-first strategy</span></span><br><span class="line">        capture: <span class="regexp">/\.(png|jpg)$/</span>,</span><br><span class="line">        strategy: Strategy.CACHE_FIRST</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="comment">// capture as function: store all stylesheet with cache-first strategy</span></span><br><span class="line">        capture: (&#123; request &#125;) =&gt; request.destination === <span class="string">'style'</span>,</span><br><span class="line">        strategy: Strategy.CACHE_FIRST</span><br><span class="line">    &#125;],</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<h2 id="u8FDC_u7A0B_u63A7_u5236"><a href="#u8FDC_u7A0B_u63A7_u5236" class="headerlink" title="远程控制"></a>远程控制</h2><p>基于 ServiceWorker 的原理，一旦在浏览器安装上了，如果遇到紧急线上问题，唯有发布新的 ServiceWorker 才能解决问题。但是 ServiceWorker 的安装是有时延的，再加上有些团队从修改代码到发布的流程，这个反射弧就很长了。我们有什么办法能缩短对于线上问题的反射弧呢？</p>
<p><strong>我们可以在远程存储一个配置，针对可预见的场景，进行「远程控制」</strong>：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417015441.png" alt="remote-controller.drawio"></p>
<p><strong>那么我们怎么去获取配置呢？</strong></p>
<p><strong>方案一</strong>，如果我们在主线程中获取配置：</p>
<ol>
<li>需要用户主动刷新页面才会生效。</li>
<li>做不到轻量的功能关闭，什么意思呢，我们会有开关的场景，主线程只能通过卸载或者清理缓存去实现「关闭」，这个太重了。</li>
</ol>
<p><strong>方案二</strong>，如果我们在 ServiceWorker 线程去获取配置：</p>
<ol>
<li>可以实现轻量功能关闭，透传请求就行了。</li>
<li>但是如果遇到要干净的清理用户环境的需要，去卸载 ServiceWorker 的时候，就会导致主进程每次注册，到了 ServiceWorker  就卸载，造成频繁安装卸载。</li>
</ol>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417013001.png" alt="image-20220417012859191"></p>
<p>所以我们的 <strong>最后方案</strong> 是 <strong>「基于双线程的实时配置获取」</strong>。</p>
<p>主线程也要获取配置，然后配置前面要加上防抖保护，防止 <strong>onFetch</strong> 事件短时间并发的问题。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220417013006.png" alt="image-20220417012934418"></p>
<p>代码上，我们使用 Glacier  的插件 <a href="https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-remote-controller" target="_blank" rel="external">@glacierjs/plugin-remote-controller</a> 可以轻松实现远程控制：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in ./remote-controller-sw.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; RemoteControllerSW &#125; from <span class="string">'@glacierjs/plugin-remote-controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; GlacierSW &#125; from <span class="string">'@glacierjs/sw'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; options &#125; from <span class="string">'./options'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> glacierSW = <span class="keyword">new</span> GlacierSW();</span><br><span class="line">glacierSW.use(<span class="keyword">new</span> RemoteControllerSW(&#123;</span><br><span class="line">  fetchConfig: () =&gt; getMyRemoteConfig();</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中 getMyRemoteConfig 用于获取你存在远端的配置，返回的格式规定如下：</span></span><br><span class="line"><span class="keyword">const</span> getMyRemoteConfig = async () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> config: RemoteConfig = &#123;</span><br><span class="line">        <span class="comment">// 全局关闭，卸载 ServiceWorker</span></span><br><span class="line">        <span class="keyword">switch</span>: <span class="literal">true</span>,</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 缓存功能开关</span></span><br><span class="line">      	assetsEnable: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 精细控制特定缓存</span></span><br><span class="line">        assetsCacheRoutes: [&#123;</span><br><span class="line">            capture: <span class="string">'https://mysite.com/index.html'</span>,</span><br><span class="line">            strategy: Strategy.STALE_WHILE_REVALIDATE,</span><br><span class="line">        &#125;],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6570_u636E_u6536_u96C6"><a href="#u6570_u636E_u6536_u96C6" class="headerlink" title="数据收集"></a>数据收集</h2><p>ServiceWorker 发布之后，我们需要保持对线上情况的把控。 对于一些必要的统计指标，我们可能需要进行上统计和上报。</p>
<p><a href="https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-collector" target="_blank" rel="external">@glacierjs/plugin-collector</a> 内置了五个常见的数据事件：</p>
<ol>
<li>ServiceWorker 注册：<a href="https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_REGISTER" target="_blank" rel="external">SW_REGISTER</a></li>
<li>ServiceWorker 安装成功：<a href="https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_INSTALLED" target="_blank" rel="external">SW_INSTALLED</a></li>
<li>ServiceWorker 控制中：<a href="https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_CONTROLLED" target="_blank" rel="external">SW_CONTROLLED</a></li>
<li>命中 onFetch 事件：<a href="https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#SW_FETCH" target="_blank" rel="external">SW_FETCH</a></li>
<li>命中浏览器缓存：<a href="https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#CACHE_HIT" target="_blank" rel="external">CACHE_HIT</a> of <a href="https://jerryc8080.github.io/GlacierJS/api/enums/plugin_assets_cache_src.CacheFrom.html#WINDOW" target="_blank" rel="external">CacheFrom.Window</a></li>
<li>命中 CacheAPI 缓存：<a href="https://jerryc8080.github.io/GlacierJS/api/enums/plugin_collector_src.CollectedDataType.html#CACHE_HIT" target="_blank" rel="external">CACHE_HIT</a> of <a href="https://jerryc8080.github.io/GlacierJS/api/enums/plugin_assets_cache_src.CacheFrom.html#SW" target="_blank" rel="external">CacheFrom.SW</a></li>
</ol>
<p>基于以上数据的收集，我们就可以得到一些常见的通用指标：</p>
<ol>
<li>ServiceWorker 安装率 = SW_REGISTER / SW_INSTALLED</li>
<li>ServiceWorker 控制率 = SW_REGISTER / SW_CONTROLLED</li>
<li>ServiceWorker 缓存命中率 = SW_FETCH / CACHE_HIT (of CacheFrom.SW)</li>
</ol>
<p>首先我们在 ServiceWorker 线程中注册 plugin-collector：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AssetsCacheSW &#125; from <span class="string">'@glacierjs/plugin-assets-cache'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CollectorSW &#125; from <span class="string">'@glacierjs/plugin-collector'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; GlacierSW &#125; from <span class="string">'@glacierjs/sw'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> glacierSW = <span class="keyword">new</span> GlacierSW();</span><br><span class="line"></span><br><span class="line"><span class="comment">// should use plugin-assets-cache first in order to make CollectedDataType.CACHE_HIT work.</span></span><br><span class="line">glacierSW.use(<span class="keyword">new</span> AssetsCacheSW(&#123;...&#125;));</span><br><span class="line">glacierSW.use(<span class="keyword">new</span> CollectorSW());</span><br></pre></td></tr></table></figure>
<p>然后在主线程中注册 plugin-collector，并且监听数据事件，进行数据上报：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  CollectorWindow,</span><br><span class="line">  CollectedData,</span><br><span class="line">  CollectedDataType,</span><br><span class="line">&#125; from <span class="string">'@glacierjs/plugin-collector'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CacheFrom &#125; from <span class="string">'@glacierjs/plugin-assets-cache'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; GlacierWindow &#125; from <span class="string">'@glacierjs/window'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> glacierWindow = <span class="keyword">new</span> GlacierWindow(<span class="string">'./service-worker.js'</span>);</span><br><span class="line"></span><br><span class="line">glacierWindow.use(<span class="keyword">new</span> CollectorWindow(&#123;</span><br><span class="line">    send(data: CollectedData) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="keyword">type</span>, data &#125; = data;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> CollectedDataType.SW_REGISTER:</span><br><span class="line">          myReporter.event(<span class="string">'sw-register-count'</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> CollectedDataType.SW_INSTALLED:</span><br><span class="line">          myReporter.event(<span class="string">'sw-installed-count'</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> CollectedDataType.SW_CONTROLLED:</span><br><span class="line">          myReporter.event(<span class="string">'sw-controlled-count'</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> CollectedDataType.SW_FETCH:</span><br><span class="line">          myReporter.event(<span class="string">'sw-fetch-count'</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> CollectedDataType.CACHE_HIT:</span><br><span class="line">          <span class="comment">// hit service worker cache</span></span><br><span class="line">          <span class="keyword">if</span> (data?.from === CacheFrom.SW) &#123;</span><br><span class="line">            myReporter.event(`sw-assets-count:hit-sw-$&#123;data?.url&#125;`);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// hit browser cache or network</span></span><br><span class="line">          <span class="keyword">if</span> (data?.from === CacheFrom.Window) &#123;</span><br><span class="line">            myReporter.event(`sw-assets-count:hit-<span class="built_in">window</span>-$&#123;data?.url&#125;`);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>其中 <code>myReporter.event</code> 是你可能会实现的数据上报库。</p>
<h2 id="u5355_u5143_u6D4B_u8BD5"><a href="#u5355_u5143_u6D4B_u8BD5" class="headerlink" title="单元测试"></a>单元测试</h2><p>ServiceWorker 测试可以分解为常见的测试组。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/jerryc/20220418092022.png" alt="img"></p>
<p>在顶层的是 <strong>「集成测试」</strong>，在这一层，我们检查整体的行为，例如：测试页面可加载，ServiceWorker注册，离线功能等。集成测试是最慢的，但是也是最接近现实情况的。</p>
<p>再往下一层的是 <strong>「浏览器单元测试」</strong>，由于 ServiceWorker 的生命周期，以及一些 API 只有在浏览器环境下才能有，所以我们使用浏览器去进行单元测试，会减少很多环境的问题。</p>
<p>接着是 <strong>「ServiceWorker 单元测试」</strong>，这种测试也是在浏览器环境中注册了测试用的 ServiceWorker 为前提进行的单元测试。</p>
<p>最后一种是 <strong>「模拟 ServiceWorker」</strong>，这种测试粒度会更加精细，精细到某个类某个方法，只检测入参和返回。这意味着没有了浏览器启动成本，并且最终是一种可预测的方式测试代码的方式。</p>
<p>但是模拟 ServiceWorker 是一件困难的事情，如果 mock 的 API 表面不正确，则在集成测试或者浏览器单元测试之前问题不会被发现。我们可以使用 <a href="https://www.npmjs.com/package/service-worker-mock" target="_blank" rel="external">service-worker-mock</a> 或者 <a href="https://github.com/mswjs/msw/issues/170" target="_blank" rel="external">MSW</a> 在 NodeJS 环境中进行 ServiceWorker 的单元测试。</p>
<p>由于篇幅有限，后续我另开专题来讲讲 ServiceWorker 单元测试的实践。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>本文开篇描述了关于 PWA 的基本概念，然后介绍了一些现在社区优秀的工具，以及要去构建一个「可控、可靠、可扩展的 PWA 应用」所面临的的实际的痛点。</p>
<p>于是在三个「可」给出了一些实践性的建议：</p>
<ol>
<li>通过「数据收集」、「远程控制」保证我们对已发布的 PWA 应用的 <strong>「可控性」</strong></li>
<li>通过「单元测试」、「集成测试」去保障我们 PWA 应用的 <strong>「可靠性」</strong></li>
<li>通过「多维洋葱插件模型」支持插件化和 MPA 应用，以及整合多个插件，从而达到 PWA 应用的 <strong>「可扩展性」</strong>。</li>
</ol>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.amazon.com/PWA%E5%AE%9E%E6%88%98%EF%BC%9A%E9%9D%A2%E5%90%91%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84Progressive-Web-Dean-Alan-Hume%EF%BC%88%E8%BF%AA%E6%81%A9%E8%89%BE%E4%BC%A6%E4%BC%91%E5%A7%86%EF%BC%89/dp/B07D4ZSQYP/ref=sr_1_2?keywords=PWA+%E5%AE%9E%E6%88%98&amp;qid=1650419306&amp;sr=8-2" target="_blank" rel="external">《PWA实战：面向下一代的Progressive Web APP》</a></li>
<li><a href="https://lavas-project.github.io/pwa-book/chapter04/2-service-worker-register.html" target="_blank" rel="external">Service Worker 注册</a></li>
<li><a href="https://medium.com/dev-channel/two-http-headers-related-to-service-workers-you-never-may-have-heard-of-c8862f76cc60" target="_blank" rel="external">Two HTTP headers related to Service Workers you never may have heard of</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28161855" target="_blank" rel="external">如何优雅的为 PWA 注册 Service Worker</a></li>
<li><a href="https://developers.google.com/web/tools/workbox" target="_blank" rel="external">Workbox</a></li>
<li><a href="https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin" target="_blank" rel="external">GlacierJS - 多维洋葱插件系统</a></li>
<li><a href="https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-assets-cache" target="_blank" rel="external">GlacierJS - 资源缓存</a></li>
<li><a href="https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-remote-controller" target="_blank" rel="external">GlacierJS - 远程控制</a></li>
<li><a href="https://jerryc8080.github.io/GlacierJS/#/contents/zh-cn/plugin-collector" target="_blank" rel="external">GlacierJS - 数据收集</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;u5982_u4F55_u6784_u5EFA_u53EF_u63A7_2C_u53EF_u9760_2C_u53EF_u6269_u5C55_u7684_PWA__u5E94_u7528&quot;&gt;&lt;a href=&quot;#u5982_u4F55_u6784_u5EFA_u5
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="PWA" scheme="http://huang-jerryc.com/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>一个失眠夜的胡思乱想</title>
    <link href="http://huang-jerryc.com/2022/03/30/a-thinking-on-insomnia-night/"/>
    <id>http://huang-jerryc.com/2022/03/30/a-thinking-on-insomnia-night/</id>
    <published>2022-03-30T13:11:07.446Z</published>
    <updated>2019-08-16T19:26:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在是凌晨 2:06，今晚喝了两瓶科罗娜。<br>以为喝了酒能好好睡，结果，还是失眠了。</p>
<p>是兴奋也罢，是焦虑也罢。既然明天不用上班，那么就让这个失眠夜来的更放纵些。</p>
<p>刚才躺在床上，竟然在构想起自己的退休生活。<br>希望自己的退休生活，会更有趣些，在衣食上没有基本的担忧，身体虽然有些毛病，但还是能健康的活着，然后和老伴持续的二人世界。有一个独立的孩子，有空可以来看看我们。以及有一两个能持续以恒的爱好。然后，还顺利的养成了终身学习的习惯，作为一个 fasion 的老头。</p>
<p>培养个啥兴趣好呢？回顾过去的众多爱好，找一个能持续发展的。就拿音乐来说，假如我能把音乐这件事学深了，学广了，把玩几门乐器，就算是个糟老头，也能搞搞创作吧。然后有些积蓄，结合着年轻时的阅历和朋友，也能做些小生意吧？又或者也能做做教育吧？</p>
<p>顺着思考如何去过上喜欢的退休生活，似乎有了个更长远的目标，时间跨度更大的目标。</p>
<p>于是乎，才意识到这几年来，只凭借着年少轻狂的那股劲在奔跑，却没有一个可以长远追逐的愿景。</p>
<p>以至于，在碰到人生大事上，如结婚、买房、小孩这些问题上，却有了一种却步感。在碰到职业发展瓶颈上，会满满的焦虑感。还常常回忆过去，留恋过去。</p>
<p>看过一个说法：20 岁年轻人和 50 岁老人做计划，年轻人最多只能做 2 年计划，老人却可以做 5 年甚至 10 年计划。因为 5 年，对年轻人来说是他生命的 1/4，而对老人来说只是他生命的 1/10。 唯一忧桑的是，老人所剩的生命时间不敌年轻的。</p>
<p>从这个例子来看，我认为人类对时间的感受，是相对的，并且是可变化的。<br>那么假如年轻人能够去模拟感受老人对时间维度的感受，是不是也能做出更长远些的计划？然后更加淡定？</p>
<p>倘若把时间维度拉长，如果 30 年后来看今天，却稍稍有一种豁达的感觉。虽然离想清楚，想明白，还有些距离。</p>
<p>这样回去看，所谓的中年危机，互联网 35 岁命劫，在一个更长远的时间跨度中，也只能是件小事情，那么一跨，就过去了。</p>
<p>那么如何回来看当下？<br>毕竟我还是 27 岁的年龄，那就应该在这个时期，去好好感受属于这个时期的生活。<br>好好去感受职场，持续提高个体价值，给这个社会输出贡献，以换取个体生活条件。<br>好好去感受生活，结婚、买房、生子、赡养老人，去感受人生这个阶段必须经历的生活。<br>还有，好好爱惜身体，毕竟生命只有一次。</p>
<p>在历史长流的维度来看，一个人就几十年光景的寿命，诞生、成长、衰老，然后回归自然。<br>那么，这短短的生命，该怎么演绎？<br>第一，感谢父母亲把我们带到这个世界上。<br>第二，去好好感受生命的整个周期。</p>
<p>现在是凌晨 3:16，祝晚安。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在是凌晨 2:06，今晚喝了两瓶科罗娜。&lt;br&gt;以为喝了酒能好好睡，结果，还是失眠了。&lt;/p&gt;
&lt;p&gt;是兴奋也罢，是焦虑也罢。既然明天不用上班，那么就让这个失眠夜来的更放纵些。&lt;/p&gt;
&lt;p&gt;刚才躺在床上，竟然在构想起自己的退休生活。&lt;br&gt;希望自己的退休生活，会更有趣些
    
    </summary>
    
      <category term="三省吾身" scheme="http://huang-jerryc.com/categories/%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序路由实战</title>
    <link href="http://huang-jerryc.com/2021/03/21/wxapp-router-experience/"/>
    <id>http://huang-jerryc.com/2021/03/21/wxapp-router-experience/</id>
    <published>2021-03-21T12:28:00.000Z</published>
    <updated>2021-11-16T01:59:22.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-__u76EE_u5F55"><a href="#0-__u76EE_u5F55" class="headerlink" title="0. 目录"></a>0. 目录</h1><ul>
<li><a href="#1-前言">1. 前言</a></li>
<li><a href="#2-智能路由跳转--navigator-模块">2. 智能路由跳转 — Navigator 模块</a></li>
<li><a href="#3-虚拟路由策略--router-模块">3. 虚拟路由策略 — Router 模块</a></li>
<li><a href="#4-落地中转策略--landtransfer-模块">4. 落地中转策略 — LandTransfer 模块</a><ul>
<li><a href="#41-对于要解决的第一个问题统一的落地页">4.1. 对于要解决的第一个问题：统一的落地页</a></li>
<li><a href="#42-对于第二个要解决的问题短链参数">4.2. 对于第二个要解决的问题：短链参数</a></li>
<li><a href="#43-landtransfer-模块设计">4.3. LandTransfer 模块设计</a></li>
</ul>
</li>
<li><a href="#5-更好的开发体验">5. 更好的开发体验</a><ul>
<li><a href="#51-typescript--router">5.1. Typescript + Router</a></li>
<li><a href="#52-智能生成路由配置">5.2. 智能生成路由配置</a></li>
<li><a href="#53-自定义组件跳转">5.3. 自定义组件跳转</a></li>
</ul>
</li>
<li><a href="#6-整体架构图">6. 整体架构图</a></li>
<li><a href="#7-最后的最后">7. 最后的最后</a></li>
</ul>
<h1 id="1-__u524D_u8A00"><a href="#1-__u524D_u8A00" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>在微信小程序由一个 <code>App()</code>实例，和众多<code>Page()</code>组成。而在小程序中所有页面的路由全部由框架进行管理，框架以栈的形式维护了所有页面，然后提供了以下 API 来进行路由之间的跳转：</p>
<ol>
<li><code>wx.navigateTo</code></li>
<li><code>wx.redirectTo</code></li>
<li><code>wx.navigateBack</code></li>
<li><code>wx.switchTab</code></li>
<li><code>wx.reLaunch</code> </li>
</ol>
<p>但是，对于一个企业应用，把这些问题留给了开发者：</p>
<ol>
<li>原生 API 使用了 <code>Callback</code> 的函数实现形式，与我们现代普遍的 <code>Promise</code> 和 <code>async/await</code> 存在 gap。</li>
<li>基于小程序路由的设计，暴露给外部的是真实路由（如扫码，公众号链接等方式），对后续项目重构留下历史包袱。</li>
<li>小程序页面栈最多十层， 在超过十层后 <code>wx.navigateTo</code> 失效，需要开发者判断使用 <code>wx.redirectTo</code> 或其他API</li>
<li>小程序页面栈存在一种特殊的页面：Tab 页面，需要使用 <code>wx.switchTab</code> 才能跳转。需要开发者主动判断，不方便后期改动 Tab 页面属性。</li>
<li>额外的，对于小程序码，要使用无数量限制 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="external">wxacode.getUnlimited</a> ，存在参数长度限制32位以内。需要开发者自行解决。</li>
</ol>
<p>而本文，期望能对这若干问题，逐个提供解决方案。</p>
<h1 id="2-__u667A_u80FD_u8DEF_u7531_u8DF3_u8F6C__u2014_Navigator__u6A21_u5757"><a href="#2-__u667A_u80FD_u8DEF_u7531_u8DF3_u8F6C__u2014_Navigator__u6A21_u5757" class="headerlink" title="2. 智能路由跳转 — Navigator 模块"></a>2. 智能路由跳转 — Navigator 模块</h1><p>在这里我们一起解决：</p>
<ol>
<li>原生 API 非 Promsie</li>
<li>页面栈突破十层时特殊处理</li>
<li>特殊页面 Tab 的跳转处理</li>
</ol>
<p>我们的思路是，希望能设计一种逻辑，根据场景来自动判断使用哪个微信路由 API，然后对外只提供一个函数，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gotoPage(<span class="string">'/pages/goods/index'</span>)</span><br></pre></td></tr></table></figure>
<p>具体逻辑如下：</p>
<ol>
<li>当跳转的路由为小程序 tab 页面时，则使用 <code>wx.switchTab</code>。</li>
<li>当页面栈达到 10 层之后，如果要跳转的页面在页面栈中，使用 <code>wx.navigateBack({ delta: X })</code> 出栈到目标页面。</li>
<li>当页面栈达到 10 层之后，目标页面不存在页面栈中，使用 <code>wx.redirectTo</code> 替换栈顶页面。</li>
<li>其他情况使用 <code>wx.navigateTo</code></li>
</ol>
<p>顺带的，我们把这个函数以 Promise 形式实现，以及支持参数作为 <code>object</code>传入，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gotoPage(<span class="string">'/pages/goods/index'</span>, &#123; name: <span class="string">'jc'</span> &#125;).then(...).catch(...);</span><br></pre></td></tr></table></figure>
<p>大部分场景下，只要使用<code>gotoPage</code>就能满足。</p>
<p>那肯定也会有特定的情况，需要显式的指定使用 <code>navigateTo/switchTab/redirectTo/navigateBack</code>的哪一个。</p>
<p>那么我们也按照类似的实现，满足相同模式的 API</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">navigateTo(<span class="string">'/pages/goods/index'</span>, &#123; name: <span class="string">'jc'</span> &#125;).then(...).catch(...);</span><br><span class="line">switchTab(<span class="string">'/pages/goods/index'</span>, &#123; name: <span class="string">'jc'</span> &#125;).then(...).catch(...);</span><br><span class="line">redirectTo(<span class="string">'/pages/goods/index'</span>, &#123; name: <span class="string">'jc'</span> &#125;).then(...).catch(...);</span><br><span class="line">navigateBack(<span class="string">'/pages/goods/index'</span>, &#123; name: <span class="string">'jc'</span> &#125;).then(...).catch(...);</span><br></pre></td></tr></table></figure>
<p>这些函数都可以内聚到同一个模块，我们称其为：<strong>Navigator</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> navigator = <span class="keyword">new</span> Navigator();</span><br><span class="line">navigator.gotoPage(...);</span><br><span class="line">navigator.navigateTo(...);</span><br><span class="line">navigator.switchTab(...);</span><br><span class="line">navigator.redirectTo(...);</span><br><span class="line">navigator.navigateBack(...);</span><br></pre></td></tr></table></figure>
<p>模块设计：</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202552.png" alt="navigator-class"></p>
<h1 id="3-__u865A_u62DF_u8DEF_u7531_u7B56_u7565__u2014_Router__u6A21_u5757"><a href="#3-__u865A_u62DF_u8DEF_u7531_u7B56_u7565__u2014_Router__u6A21_u5757" class="headerlink" title="3. 虚拟路由策略 — Router 模块"></a>3. 虚拟路由策略 — Router 模块</h1><p>在这里，我们解决：</p>
<ol>
<li>对外暴露了真实路由，导致历史包袱沉重的问题。</li>
</ol>
<p>在许多应用开发中，我们经常需要把某种模式匹配到的所有路由，全都映射到同个页面中去。<br>例如，我们有一个 Goods 页面，对于所有 ID 各不相同的商品，都要使用这个页面来承载。  </p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202632.png" alt></p>
<p>那么在代码层面上，期望能实现这样的调用方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建路由实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册路由</span></span><br><span class="line">router.register(&#123;</span><br><span class="line">  path: <span class="string">'/goods/:id'</span>, <span class="comment">// 虚拟路由</span></span><br><span class="line">  route: <span class="string">'/pages/goods/index'</span>, <span class="comment">// 真实路由</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到 /pages/goods/index，参数: onLoad(options) 的 options = &#123; id: '123' &#125;</span></span><br><span class="line">router.gotoPage(<span class="string">'/goods/123'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到 /pages/goods/index，参数: onLoad(options) 的 options = &#123; id: '456' &#125;</span></span><br><span class="line">router.gotoPage(<span class="string">'/goods/456'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Class Router</strong> 的核心逻辑是完成：</p>
<ol>
<li>路由的注册，完成「虚拟路径」和「真实路径」关系的存储。</li>
<li>满足「虚拟路径」到「真实路径」的转换，并且识别「动态路径参数」（dynamic segment）。</li>
<li>路由跳转。</li>
</ol>
<p>对于「路由的注册」，我们在其内部存储一个 map 就能完成。</p>
<p>而对于「路径的转换」， <code>vue-router</code> 有类似的实现，通过其源码发现，内部是使用  <a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="external">path-to-regexp</a> 作为路径匹配引擎，我们可以拿来用之。</p>
<p>然后对于「路由的跳转」，我们可以直接复用上面提到的 <strong>Navigator</strong> 模块，通过输入真实路径，来完成路由的跳转。</p>
<p>模块设计：</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202636.png" alt="route-class"></p>
<p>其中：</p>
<ol>
<li>RouteMatcher：提供动态路由参数匹配功能，内部使用  <a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="external">path-to-regexp</a> 作为路径匹配引擎。</li>
<li>Route: 为每个路径创建路由器，存储每个路由的虚拟路径和真实路由的关系。</li>
<li>Router：整合内部各模块，对外提供统一且优雅的调用方式。</li>
</ol>
<h1 id="4-__u843D_u5730_u4E2D_u8F6C_u7B56_u7565__u2014_LandTransfer__u6A21_u5757"><a href="#4-__u843D_u5730_u4E2D_u8F6C_u7B56_u7565__u2014_LandTransfer__u6A21_u5757" class="headerlink" title="4. 落地中转策略 — LandTransfer 模块"></a>4. 落地中转策略 — LandTransfer 模块</h1><p>在这里，我们解决：</p>
<ol>
<li>小程序扫码、公众号链接等场景下的落地页统一。</li>
<li>小程序码，对于无限量API <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="external">wxacode.getUnlimited</a> ，突破参数32位长度限制。</li>
</ol>
<h2 id="4-1-__u5BF9_u4E8E_u8981_u89E3_u51B3_u7684_u7B2C_u4E00_u4E2A_u95EE_u9898_uFF1A_u7EDF_u4E00_u7684_u843D_u5730_u9875"><a href="#4-1-__u5BF9_u4E8E_u8981_u89E3_u51B3_u7684_u7B2C_u4E00_u4E2A_u95EE_u9898_uFF1A_u7EDF_u4E00_u7684_u843D_u5730_u9875" class="headerlink" title="4.1. 对于要解决的第一个问题：统一的落地页"></a>4.1. 对于要解决的第一个问题：统一的落地页</h2><p>我们把如：扫小程序码、公众号菜单、公众号文章等方式打开小程序某个页面的路径称为「外部路由」。</p>
<p>根据小程序的设计，暴露给外部的连接是真实的页面路径，如：<code>/pages/home/index</code>，该设计在实践中存在的弊端：<strong>各个落地页分散，后期修改真实文件路径难度大。</strong></p>
<p>在 <strong>「中长生命周期」</strong> 产品中，随着产品的迭代，我们难免会遇到项目的重构。如果分发出去的都是没经过处理的真实路径的话，我们重构时就会束手束脚，要做很多的兼容操作。因为你不知道，分发出去的小程序二维码， 有多少被打印到实体物料中。</p>
<p>那么，<strong>「虚拟路由」+「落地中转」</strong> 的策略就显得基本且重要了。</p>
<p>「虚拟路由」的功能，<strong>Router </strong>模块给我们提供了支持了，我们还需要对外提供一个统一的落地页面，让它来完成对内部路由的中转。</p>
<p>基本逻辑：</p>
<ol>
<li>分发出去的真实路由，指向到唯一的落地页面，如：<code>$LAND_PAGE: /pages/land-page/index</code></li>
<li>由这个落地页面，进行内部路由的重定向转发，通过接收 参数，如：<code>path=/user&amp;name=jc&amp;age=18</code></li>
</ol>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210309185153.png" alt="普通模式"></p>
<p>在代码层面上，我们希望能实现这样的使用：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /pages/land-page/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> landTransfer = <span class="keyword">new</span> LandTransfer(landTransferOptions);</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  onLoad(options) &#123;</span><br><span class="line">      landTransfer</span><br><span class="line">        .run(options)</span><br><span class="line">        .then(() =&gt; &#123;...&#125;)</span><br><span class="line">        .catch(() =&gt; &#123;...&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后针对 TS，我们还可以使用装饰器版本，更加简便：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; landTransferDecorator &#125; from <span class="string">'wxapp-router'</span>;</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  @landTransferDecorator(landTransferOptions)</span><br><span class="line">  onLoad(options) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="4-2-__u5BF9_u4E8E_u7B2C_u4E8C_u4E2A_u8981_u89E3_u51B3_u7684_u95EE_u9898_uFF1A_u77ED_u94FE_u53C2_u6570"><a href="#4-2-__u5BF9_u4E8E_u7B2C_u4E8C_u4E2A_u8981_u89E3_u51B3_u7684_u95EE_u9898_uFF1A_u77ED_u94FE_u53C2_u6570" class="headerlink" title="4.2. 对于第二个要解决的问题：短链参数"></a>4.2. 对于第二个要解决的问题：短链参数</h2><p>微信小程序主要提供了两个接口去生成小程序码：</p>
<ol>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.get.html" target="_blank" rel="external">wxacode.get</a>: 获取小程序码，适用于需要的码数量较少的业务场景。<strong>通过该接口生成的小程序码，永久有效，数量限制为 100,000</strong> 个</li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="external">wxacode.getUnlimited</a>: 获取小程序码，适用于需要的码数量极多的业务场景。<strong>通过该接口生成的小程序码，永久有效，数量暂无限制。</strong></li>
</ol>
<p>第一种方式，<code>wxacode.get</code> 数量限制为 10w 个，虽然量很大了，绝大多数的小程序可能用不到这个量。</p>
<p>但如果我们运营的是一个中大型电商小程序的话，假如：1w 种商品 x 10 种商品规格，那就会超过这个数量。到时候再进行改造，就困难了。</p>
<p>所以，如果抱着是运营一个 <strong>「中长生命周期」</strong> 的产品的话，我们会使用第二种方式：<code>wxacode.getUnlimited</code></p>
<p>不尽人意的是，虽然它没有数量限制，但是对参数会有 32 个字符的限制，显然是不够用的（一个 uuid 就 32 字符了）。</p>
<p>对于这种情况，我们可以使用「短链参数」的形式解决，由于<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="external">wxacode.getUnlimited</a> 会通过 <code>scene</code>字段作为 query 参数传递给小程序的，那么我们可以通过 <code>scene</code>参数来实现短链服务，这需要后端配合。</p>
<p>前后端交互如下：</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210312182826.png" alt="Scene短链模式"></p>
<ol>
<li>当小程序需要生成小程序码的时候，请求后端提供的接口，例如：<code>/api/encodeShortParams</code></li>
<li>后端把内容转换为 32 字符内的字符串，存储到数据库中。</li>
<li>后端通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="external">wxacode.getUnlimited</a> 接口，以短链字符串作为 <code>scene</code>的值，以商定好的统一落地页 <code>$LAND_PAGE</code>作为 <code>page</code>值，生成小程序码。</li>
<li>当通过小程序码进入小程序，小程序获取到 <code>scene</code>参数，请求后端提供的接口，例如：<code>/api/decodeShrotParams</code></li>
<li>小程序理解内容，跳转到目标页面中去。</li>
</ol>
<p>而前端对于统一落地页的逻辑处理，我们只需要在第一个问题的基础上，增加一个<strong>转换短链参数内容</strong>的逻辑就行了：</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210309185154.png" alt="短链模式"></p>
<p>代码层面上，我们我们只需要多定义转换短链参数的方式：<code>convertScenePrams</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in /pages/land-page/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; landTransferDecorator &#125; from <span class="string">'wxapp-router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> landTransferOptions = &#123;</span><br><span class="line">  <span class="comment">// 此处接收 onLoad(options) 中的 options.scene</span></span><br><span class="line">  convertSceneParams: (sceneParams) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> API.convertScene(&#123; sceneParams &#125;).then((content) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 假如后端存的是 JSON 字符串，前端decode</span></span><br><span class="line">      <span class="comment">// 要求 content = &#123; path: '/home', a: 1, b:2 &#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(content);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  @landTransferDecorator(landTransferOptions)</span><br><span class="line">  onLoad(options) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>而其中的 <code>API.convertScene</code> 就对接服务端提供 HTTP 接口服务来完成。</p>
<h2 id="4-3-_LandTransfer__u6A21_u5757_u8BBE_u8BA1"><a href="#4-3-_LandTransfer__u6A21_u5757_u8BBE_u8BA1" class="headerlink" title="4.3. LandTransfer 模块设计"></a>4.3. LandTransfer 模块设计</h2><p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202654.png" alt="land-transfer"></p>
<h1 id="5-__u66F4_u597D_u7684_u5F00_u53D1_u4F53_u9A8C"><a href="#5-__u66F4_u597D_u7684_u5F00_u53D1_u4F53_u9A8C" class="headerlink" title="5. 更好的开发体验"></a>5. 更好的开发体验</h1><h2 id="5-1-_Typescript_+_Router"><a href="#5-1-_Typescript_+_Router" class="headerlink" title="5.1. Typescript + Router"></a>5.1. Typescript + Router</h2><p>对于小程序内部的路由跳转，我们除了指定一个字符串的路由，我们是否也可以通过链式调用，像调用函数那样去跳转页面呢？类似这样；</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routes.pages.user.go(&#123; name: <span class="string">'jc'</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>这样做的好处是：</p>
<ol>
<li>更自然的调用方式。</li>
<li>能结合 TS，来做到类型提示和联想。</li>
</ol>
<p>由于事先 <code>wxapp-router</code> 并不知道开发者需要注册的路由是什么样的，所以路由的 TS 声明文件，需要开发者来定义。</p>
<p>例如，我们在项目中维护一份路由文件：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/routes.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routesConfig = [&#123;</span><br><span class="line">  path: <span class="string">'/user'</span>,</span><br><span class="line">  route: <span class="string">'/pages/user/index'</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: <span class="string">'/goods'</span>,</span><br><span class="line">  route: <span class="string">'/pages/goods/index'</span>,</span><br><span class="line">&#125;]；</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RoutesType &#123;</span><br><span class="line">  paegs: &#123;</span><br><span class="line">    user: Route&lt;&#123;name: <span class="built_in">string</span>&#125;&gt;,</span><br><span class="line">    goods: Route,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册路由</span></span><br><span class="line">router.batchRegister(routesConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 routes</span></span><br><span class="line"><span class="keyword">const</span> routes: RoutesType = router.getRoutes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> routes;</span><br></pre></td></tr></table></figure>
<p>然后在别的地方使用它：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> routes from <span class="string">'./routes.ts'</span>;</span><br><span class="line"></span><br><span class="line">routes.pages.user.go(&#123; name: <span class="string">'jc'</span> &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="5-2-__u667A_u80FD_u751F_u6210_u8DEF_u7531_u914D_u7F6E"><a href="#5-2-__u667A_u80FD_u751F_u6210_u8DEF_u7531_u914D_u7F6E" class="headerlink" title="5.2. 智能生成路由配置"></a>5.2. 智能生成路由配置</h2><p>如果路由变多的时候，我们还需要对每个路由手动去编写 <code>RoutesType</code> 的话，就有点难受了。</p>
<p>在小程序中，我们把正式路由都配置到 <code>app.json</code> ，那么在遵循既定的项目结构情况下，我们可以通过自动构建，完成大部分工作，例如：</p>
<ol>
<li>智能注册路由</li>
<li>智能识别页面入参声明</li>
</ol>
<h2 id="5-3-__u81EA_u5B9A_u4E49_u7EC4_u4EF6_u8DF3_u8F6C"><a href="#5-3-__u81EA_u5B9A_u4E49_u7EC4_u4EF6_u8DF3_u8F6C" class="headerlink" title="5.3. 自定义组件跳转"></a>5.3. 自定义组件跳转</h2><p>以上都是脚本层面的使用，小程序中还有 <code>wxml</code>, 我们希望能在有个组件快速使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Router</span> <span class="attribute">path</span>=<span class="value">"/pageA"</span> <span class="attribute">query</span>=<span class="value">"&#123;&#123;pageAQuery&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="title">Router</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">Router</span> <span class="attribute">path</span>=<span class="value">"/pageB"</span> <span class="attribute">query</span>=<span class="value">"&#123;&#123;pageBQuery&#125;&#125;"</span> <span class="attribute">type</span>=<span class="value">"redirectTo"</span>&gt;</span><span class="tag">&lt;/<span class="title">Router</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">Router</span> <span class="attribute">path</span>=<span class="value">"/pageC/katy"</span>&gt;</span><span class="tag">&lt;/<span class="title">Router</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么，实现一个自定义组件，然后把 <strong>Router</strong>模块包装一下，问题就不大了。</p>
<p>示例代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// components/router.wxml</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">view</span> <span class="attribute">class</span>=<span class="value">"wxapp-router"</span> <span class="attribute">bind:tap</span>=<span class="value">"gotoPage"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">slot</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// components/router.ts</span></span><br><span class="line"></span><br><span class="line">Component(&#123;</span><br><span class="line">    properties: &#123;</span><br><span class="line">        path: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">type</span>: &#123;</span><br><span class="line">            <span class="keyword">type</span>: <span class="built_in">String</span>,</span><br><span class="line">            value: <span class="string">'gotoPage'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        route: <span class="built_in">String</span>,</span><br><span class="line">        query: <span class="built_in">Object</span>,</span><br><span class="line">        delta: <span class="built_in">Number</span>,</span><br><span class="line">        setData: <span class="built_in">Object</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    methods: &#123;</span><br><span class="line">        gotoPage(event) &#123;</span><br><span class="line">            <span class="keyword">const</span> router = getApp().router;</span><br><span class="line">            <span class="keyword">const</span> &#123; path, route, <span class="keyword">type</span>, query&#125; = <span class="keyword">this</span>.data;</span><br><span class="line">            <span class="keyword">const</span> toPath = route || path;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ([<span class="string">'gotoPage'</span>, <span class="string">'navigateTo'</span>, <span class="string">'switchTab'</span>, <span class="string">'redirectTo'</span>].includes(<span class="keyword">type</span>)) &#123;</span><br><span class="line">                (router as <span class="built_in">any</span>)[<span class="keyword">type</span>](toPath, query);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">'navigateBack'</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; delta, setData &#125; = <span class="keyword">this</span>.data;</span><br><span class="line">                router.navigateBack(&#123; delta &#125;, &#123; setData &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="6-__u6574_u4F53_u67B6_u6784_u56FE"><a href="#6-__u6574_u4F53_u67B6_u6784_u56FE" class="headerlink" title="6. 整体架构图"></a>6. 整体架构图</h1><p>最后，我们来整体回顾一下各模块的设计</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20210321202700.png" alt="架构设计"></p>
<ol>
<li>Navigator：封装微信原生路由 API，提供智能跳转策略。</li>
<li>LandTransfer：提供落地页中转策略。</li>
<li>RouteMatcher：提供动态路由参数匹配功能。</li>
<li>Route: 为每个路径创建路由器。</li>
<li>Router：整合内部各模块，对外提供优雅的调用方式。</li>
<li>Logger：内部日志器。</li>
<li>Path-to-regexp: 开源社区的路由匹配引擎。</li>
</ol>
<h1 id="7-__u6700_u540E_u7684_u6700_u540E"><a href="#7-__u6700_u540E_u7684_u6700_u540E" class="headerlink" title="7. 最后的最后"></a>7. 最后的最后</h1><p>鉴于写过很多的实战类的文章，会有不少同学想要到整体的示例代码，这次我就索性写了一个工具，Enjoy it!</p>
<p><a href="https://github.com/JerryC8080/wxapp-router" target="_blank" rel="external">wxapp-router</a>： 🛵 The router for Wechat Miniprogram</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-__u76EE_u5F55&quot;&gt;&lt;a href=&quot;#0-__u76EE_u5F55&quot; class=&quot;headerlink&quot; title=&quot;0. 目录&quot;&gt;&lt;/a&gt;0. 目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-前言&quot;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;
&lt;
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="微信小程序" scheme="http://huang-jerryc.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Module Seed: 一套优雅的 Github 工作流</title>
    <link href="http://huang-jerryc.com/2021/01/28/github-workflow/"/>
    <id>http://huang-jerryc.com/2021/01/28/github-workflow/</id>
    <published>2021-01-28T09:51:00.000Z</published>
    <updated>2021-01-28T09:52:36.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>平时喜欢写一些 NPM 模块，写得多了，整理出一套工作流，解放一些重复的搭建工作。<br>如果你喜欢，请直接拿去用，也可以参照该项目的一些 Feature ，给你一些提示与帮助。</p>
<h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ol>
<li>支持 Typescript</li>
<li>支持单元测试，与测试覆盖率</li>
<li>快速生成文档站点</li>
<li>接入 Circle CLI，构建、发包、文档站点一条龙服务</li>
<li>规范 ESLint + Prettier</li>
<li>快速生成 Change Log</li>
<li>生成同时支持 CommonJS 和 ES Module 的 NPM 包</li>
</ol>
<h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:JerryC8080/module-seed.git</span><br></pre></td></tr></table></figure>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><h3 id="1-_Architecture"><a href="#1-_Architecture" class="headerlink" title="1. Architecture"></a>1. Architecture</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#10;&#9500;&#9472;&#9472; .circleci // CircleCI &#33050;&#26412;&#10;&#9474;   &#9500;&#9472;&#9472; config.yml&#10;&#9500;&#9472;&#9472; coverage // &#33258;&#21160;&#29983;&#25104;&#30340;&#27979;&#35797;&#35206;&#30422;&#29575;&#25253;&#21578;&#10;&#9500;&#9472;&#9472; docs  // &#33258;&#21160;&#29983;&#25104;&#30340;&#25991;&#26723;&#10;&#9500;&#9472;&#9472; build  // &#26500;&#24314;&#20195;&#30721;&#10;&#9474;   &#9500;&#9472;&#9472; main  // &#20860;&#23481; CommonJS&#10;&#9474;   &#9474;   &#9500;&#9472;&#9472; index.d.ts&#10;&#9474;   &#9474;   &#9500;&#9472;&#9472; index.js&#10;&#9474;   &#9474;   &#9492;&#9472;&#9472; lib&#10;&#9474;   &#9492;&#9472;&#9472; module  // &#20860;&#23481; ES Module&#10;&#9474;       &#9500;&#9472;&#9472; index.d.ts&#10;&#9474;       &#9500;&#9472;&#9472; index.js&#10;&#9474;       &#9492;&#9472;&#9472; lib&#10;&#9500;&#9472;&#9472; src  // &#28304;&#30721;&#10;&#9474;   &#9500;&#9472;&#9472; index.ts&#10;&#9474;   &#9492;&#9472;&#9472; lib&#10;&#9474;       &#9500;&#9472;&#9472; hello-world.spec.ts // &#21333;&#20803;&#27979;&#35797;&#10;&#9474;       &#9492;&#9472;&#9472; hello-world.ts&#10;&#9500;&#9472;&#9472; CHANGELOG.md&#10;&#9500;&#9472;&#9472; LICENSE&#10;&#9500;&#9472;&#9472; README.md&#10;&#9500;&#9472;&#9472; package.json&#10;&#9500;&#9472;&#9472; tsconfig.json&#10;&#9492;&#9472;&#9472; tsconfig.module.json</span><br></pre></td></tr></table></figure>
<h3 id="2-_Npm_Script"><a href="#2-_Npm_Script" class="headerlink" title="2. Npm Script"></a>2. Npm Script</h3><table>
<thead>
<tr>
<th>Script</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>build</td>
<td>构建代码，生成 ./build 文件夹</td>
</tr>
<tr>
<td>fix</td>
<td>快速格式化代码</td>
</tr>
<tr>
<td>test</td>
<td>构建单元测试</td>
</tr>
<tr>
<td>watch:build</td>
<td>动态构建代码，用于开发模式</td>
</tr>
<tr>
<td>watch:test</td>
<td>动态构建单元测试，用于开发模式</td>
</tr>
<tr>
<td>cov</td>
<td>构建单元测试覆盖率，生成 ./coverage 文件夹</td>
</tr>
<tr>
<td>doc</td>
<td>构建文档站点，生成 ./docs 文件夹</td>
</tr>
<tr>
<td>doc:publish</td>
<td>发布文档站点到 github pages</td>
</tr>
<tr>
<td>version</td>
<td>强制以 patch 模式更新 version，如：v0.0.1 → v0.0.2</td>
</tr>
</tbody>
</table>
<h3 id="3-_Coverage"><a href="#3-_Coverage" class="headerlink" title="3. Coverage"></a>3. Coverage</h3><p>通过运行 <code>npm run cov</code>，命令会构建单元测试，并且输出网页版本的测试报告：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open coverage/index.html</span><br></pre></td></tr></table></figure>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212173414.png" alt="coverage"></p>
<h3 id="4-_Docs"><a href="#4-_Docs" class="headerlink" title="4. Docs"></a>4. Docs</h3><p>通过运行 <code>npm run doc</code>，会构建 TS API 文档，并且输出网页版本：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open docs/index.html</span><br></pre></td></tr></table></figure>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212173820.png" alt="docs"></p>
<h3 id="5-_CircleCI_Config"><a href="#5-_CircleCI_Config" class="headerlink" title="5. CircleCI Config"></a>5. CircleCI Config</h3><p>本项目选择 <a href="https://circleci.com/" target="_blank" rel="external">CircleCI</a> 来完成项目构建、发布 NPM、发布文档站点等自动化构建工作。</p>
<h4 id="1-_Add_Repo_to_CircleCI"><a href="#1-_Add_Repo_to_CircleCI" class="headerlink" title="1. Add Repo to CircleCI"></a>1. Add Repo to CircleCI</h4><p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212174309.png" alt></p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212174310.png" alt></p>
<h4 id="2-_Test_Coverage_to_Coveralls"><a href="#2-_Test_Coverage_to_Coveralls" class="headerlink" title="2. Test Coverage to Coveralls"></a>2. Test Coverage to Coveralls</h4><p>如果想拥有一个这样的 Status: <img src="https://coveralls.io/repos/github/JerryC8080/module-seed/badge.svg?branch=master" alt="Coverage Status"></p>
<p>需要把你的 repo 添加到 <a href="https://coveralls.io/" target="_blank" rel="external">coveralls.io</a></p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175434.png" alt></p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175435.png" alt></p>
<p>然后，在 CircleCI 添加环境变量 <code>COVERALLS_REPO_TOKEN</code></p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175703.png" alt></p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212175850.png" alt></p>
<p>那么，每次 CircleCI 发生构建的时候，就会上报单元测试覆盖率到 coveralls 去。</p>
<p>参考 <code>.circleci/config.yml</code> 相关脚本:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#10;upload-coveralls:&#10;  &#60;&#60;: *defaults&#10;  steps:&#10;    - attach_workspace:&#10;        at: ~/repo&#10;    - run:&#10;        name: Test Coverage&#10;        command: npm run cov&#10;    - run:&#10;        name: Report for coveralls&#10;        command: |&#10;          npm install coveralls --save-dev&#10;          ./node_modules/.bin/nyc report --reporter=text-lcov | ./node_modules/.bin/coveralls&#10;    - store_artifacts:&#10;        path: coverage&#10;...</span><br></pre></td></tr></table></figure>
<h4 id="3-_Doc_Site_to_Github_Pages"><a href="#3-_Doc_Site_to_Github_Pages" class="headerlink" title="3. Doc Site to Github Pages"></a>3. Doc Site to Github Pages</h4><p>本地可以通过命令来构建和发布文档站点到 Github Pages</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run doc&#10;npm run doc:publish</span><br></pre></td></tr></table></figure>
<p>如果这个动作交给 CircleCI 来完成，则需要为 Repo 添加一个 <code>Read/Write</code> 权限的 <code>User Key</code></p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212180750.png" alt></p>
<p>那么，每次 CircleCI 发生构建的时候，就会构建文档，并发布到 Github Pages 中去。</p>
<p>例如本项目，就可以通过以下地址访问：</p>
<p><a href="https://jerryc8080.github.io/module-seed" target="_blank" rel="external">https://jerryc8080.github.io/module-seed</a></p>
<p>参考 <code>.circleci/config.yml</code> 相关脚本:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#10; deploy-docs:&#10;    &#60;&#60;: *defaults&#10;    steps:&#10;      - attach_workspace:&#10;          at: ~/repo&#10;      - run:&#10;          name: Avoid hosts unknown for github&#10;          command: mkdir ~/.ssh/ &#38;&#38; echo -e &#34;Host github.com\n\tStrictHostKeyChecking no\n&#34; &#62; ~/.ssh/config&#10;      - run:&#10;          name: Set github email and user&#10;          command: |&#10;            git config --global user.email &#34;huangjerryc@gmail.com&#34;&#10;            git config --global user.name &#34;CircleCI-Robot&#34;&#10;      - run:&#10;          name: Show coverage&#10;          command: ls coverage&#10;      - run:&#10;          name: Show docs&#10;          command: ls docs&#10;      - run:&#10;          name: Copy to docs folder&#10;          command: |&#10;            mkdir docs/coverage&#10;            cp -rf coverage/* docs/coverage&#10;      - run:&#10;          name: Show docs&#10;          command: ls docs&#10;      - run:&#10;          name: Publish to gh-pages&#10;          command: npm run doc:publish&#10;...</span><br></pre></td></tr></table></figure>
<h4 id="4-_Coverage_site"><a href="#4-_Coverage_site" class="headerlink" title="4. Coverage site"></a>4. Coverage site</h4><p>在 CircleCI 的 <code>deploy-docs</code> 任务中，会构建 Coverage Site ，然后一起发布到 Github Pages 的 <code>/coverage</code> 目录中。</p>
<p>例如本项目，就可以通过以下地址访问：</p>
<p><a href="https://jerryc8080.github.io/module-seed/coverage/index.html" target="_blank" rel="external">https://jerryc8080.github.io/module-seed/coverage/index.html</a></p>
<h4 id="5-_NPM_Deploy"><a href="#5-_NPM_Deploy" class="headerlink" title="5. NPM Deploy"></a>5. NPM Deploy</h4><p>自动化脚本会以 <code>patch</code> 的形式升级版本号，例如：<code>v0.0.1</code> → <code>v0.0.2</code>。<br>然后发布到 <a href="http://npmjs.com/" target="_blank" rel="external">npmjs.com</a> 去。</p>
<p>如果需要启用这一功能，需要为 CircleCI Repo 添加 <code>npm token</code>。</p>
<p>首先，获取 <code>npm token</code></p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182501.png" alt><br><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182500.png" alt></p>
<p>然后，为 CircleCI Repo 添加环境变量：<code>npm_TOKEN</code></p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201212182819.png" alt></p>
<p>那么，每次 CircleCI 发生构建的时候，就会构建和发布 NPM 包。</p>
<p>参考 <code>.circleci/config.yml</code> 相关脚本:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#10;deploy:&#10;  &#60;&#60;: *defaults&#10;  steps:&#10;    - attach_workspace:&#10;        at: ~/repo&#10;    - run:&#10;        name: Set github email and user&#10;        command: |&#10;          # You should change email to yours.&#10;          git config --global user.email &#34;huangjerryc@gmail.com&#34;&#10;          git config --global user.name &#34;CircleCI-Robot&#34;&#10;    - run:&#10;        name: Authenticate with registry&#10;        command: echo &#34;//registry.npmjs.org/:_authToken=$npm_TOKEN&#34; &#62; ~/repo/.npmrc&#10;    - run:&#10;        name: Update version as patch&#10;        command: npm run version&#10;    - run:&#10;        name: Publish package&#10;        command: npm publish&#10;...</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Motivation&quot;&gt;&lt;a href=&quot;#Motivation&quot; class=&quot;headerlink&quot; title=&quot;Motivation&quot;&gt;&lt;/a&gt;Motivation&lt;/h2&gt;&lt;p&gt;平时喜欢写一些 NPM 模块，写得多了，整理出一套工作流，解放一些重复的搭建
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>函数保险丝：避免函数过热调用</title>
    <link href="http://huang-jerryc.com/2021/01/28/method-fuse/"/>
    <id>http://huang-jerryc.com/2021/01/28/method-fuse/</id>
    <published>2021-01-28T07:34:00.000Z</published>
    <updated>2021-01-28T09:36:07.795Z</updated>
    
    <content type="html"><![CDATA[<p>  <img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20210128154439.png" width="300"></p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>在日常开发中，我们会遇到很多这样的场景：</p>
<ol>
<li>在抢购活动中，用户往往会频繁刷新接口，要给接口加上防护，频繁调用停止响应。</li>
<li>在弱网环境中，往往会实现失败重试功能，如果失败次数多了，频繁的重试需要制止。</li>
<li>在股票市场中，当价格波动的幅度在交易时间中达到某一个限定的熔断点时，对其暂停交易一段时间的机制。</li>
<li>……</li>
</ol>
<p>这类问题，本质是：<strong>「过热的调用」</strong></p>
<p>在物理电路中，对于「过热的调用」有一种大家生活中都常见的电子元件：<strong>保险丝</strong></p>
<p>保险丝会在电流异常升高到一定的高度和热度的时候，自身熔断切断电流，保护电路安全运行。</p>
<p>我们可以模仿这样的思路，去解决编程中的「过热的调用」问题：</p>
<ol>
<li>设定一个阈值，如果函数在短时间内调用次数达到这个阈值，就熔断一段时间。</li>
<li>在函数有一段时间没有被调用了，让函数的热度降下来。</li>
</ol>
<h2 id="u51FD_u6570_u4FDD_u9669_u4E1D_u7684_u529F_u80FD_u5B9E_u73B0"><a href="#u51FD_u6570_u4FDD_u9669_u4E1D_u7684_u529F_u80FD_u5B9E_u73B0" class="headerlink" title="函数保险丝的功能实现"></a>函数保险丝的功能实现</h2><p>基于以上的思路，我实现了一个 npm 库：<a href="https://github.com/JerryC8080/method-fuse" target="_blank" rel="external">Method Fuse</a></p>
<p>使用方式如下：</p>
<h3 id="Step1_uFF1A_u5B89_u88C5"><a href="#Step1_uFF1A_u5B89_u88C5" class="headerlink" title="Step1：安装"></a>Step1：安装</h3><p><code>npm install @jerryc/method-fuse</code></p>
<h3 id="Step2_uFF1A_u5FEB_u901F_u4F7F_u7528"><a href="#Step2_uFF1A_u5FEB_u901F_u4F7F_u7528" class="headerlink" title="Step2：快速使用"></a>Step2：快速使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; MethodFuse &#125; <span class="keyword">from</span> <span class="string">'@jerryc/method-fuse'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个请求远程资源的异步函数</span></span><br><span class="line"><span class="keyword">const</span> getAssets = <span class="keyword">async</span> () =&gt; API.requestAssets();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 MethodFuse 实例</span></span><br><span class="line"><span class="keyword">const</span> fuse = <span class="keyword">new</span> MethodFuse(&#123;</span><br><span class="line">  <span class="comment">// 命名，用于日志输出</span></span><br><span class="line">  name: <span class="string">'TestFuse'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大负荷，默认：3</span></span><br><span class="line">  maxLoad: <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次熔断时间。每次熔断之后，间隔 N 毫秒之后重铸，默认：5000ms</span></span><br><span class="line">  breakingTime: <span class="number">5000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自动冷却时间。在最后一次调用间隔 N 毫秒之后自动重铸，默认：1000ms</span></span><br><span class="line">  coolDownTime: <span class="number">1000</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理原函数</span></span><br><span class="line"><span class="keyword">const</span> getAssetsProxy = fuse.proxy(getAssets);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高频并发调用 getAssetsProxy。</span></span><br><span class="line">getAssetsProxy();</span><br><span class="line">getAssetsProxy();</span><br><span class="line">getAssetsProxy();</span><br><span class="line">getAssetsProxy(); <span class="comment">// 此次调用会熔断</span></span><br><span class="line">setTimeout(() =&gt; getAssetsProxy(), <span class="number">5000</span>); <span class="comment">// 等待熔断重铸后，方可重新调用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上会打印日志：</span></span><br><span class="line"><span class="comment">// [method-fuse:info] TestFuse-通过保险丝(1/3)</span></span><br><span class="line"><span class="comment">// [method-fuse:info] TestFuse-通过保险丝(2/3)</span></span><br><span class="line"><span class="comment">// [method-fuse:info] TestFuse-通过保险丝(3/3)</span></span><br><span class="line"><span class="comment">// [method-fuse:error] TestFuse-保险丝熔断，5000ms 之后重铸</span></span><br><span class="line"><span class="comment">// [method-fuse:info] TestFuse-保险丝重置</span></span><br><span class="line"><span class="comment">// [method-fuse:info] TestFuse-通过保险丝(1/3)</span></span><br></pre></td></tr></table></figure>
<h3 id="Step3_uFF1A_u4F7F_u7528_u88C5_u9970_u5668"><a href="#Step3_uFF1A_u4F7F_u7528_u88C5_u9970_u5668" class="headerlink" title="Step3：使用装饰器"></a>Step3：使用装饰器</h3><p>如果你的项目中支持 <code>TS</code> 或者 <code>ES Decorator</code>，那么 <code>MethodFuse</code> 提供了快捷使用的装饰器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; decorator <span class="keyword">as</span> methodFuse &#125; <span class="keyword">from</span> <span class="string">'@jerryc/method-fuse'</span>;</span><br><span class="line"></span><br><span class="line">@methodFuse(&#123; name: <span class="string">'TestFuse'</span> &#125;)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getAsset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> API.requestAssets();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Step4_uFF1A_u4FEE_u6539_u65E5_u5FD7_u7EA7_u522B"><a href="#Step4_uFF1A_u4FEE_u6539_u65E5_u5FD7_u7EA7_u522B" class="headerlink" title="Step4：修改日志级别"></a>Step4：修改日志级别</h3><p><code>MethodFuse</code> 内置了一个迷你 logger（power by <a href="https://github.com/JerryC8080/mini-logger" target="_blank" rel="external">@jerryc/mini-logger</a>），方便内部日志打印，外部可以获得 <code>Logger</code> 的实例，进行 log level 的控制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; LoggerLevel &#125; <span class="keyword">from</span> <span class="string">'@jerryc/mini-logger'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; logger, MethodFuse &#125; <span class="keyword">from</span> <span class="string">'@jerryc/method-fuse'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 MethodFuse 实例</span></span><br><span class="line"><span class="keyword">const</span> MethodFuse = <span class="keyword">new</span> MethodFuse(&#123; name: <span class="string">'TestFuse'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下调 Log level</span></span><br><span class="line">logger.level = LoggerLevel.ERROR;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;img src=&quot;https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20210128154439.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a hre
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序登录的前端设计与实现</title>
    <link href="http://huang-jerryc.com/2020/10/16/wxapp-login-design/"/>
    <id>http://huang-jerryc.com/2020/10/16/wxapp-login-design/</id>
    <published>2020-10-16T14:22:25.000Z</published>
    <updated>2020-10-19T02:24:42.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="u4E00-__u524D_u8A00"><a href="#u4E00-__u524D_u8A00" class="headerlink" title="一. 前言"></a>一. 前言</h1><p>对于登录/注册的设计如此精雕细琢的目的，当然是想让这个作为应用的基础能力，有足够的健壮性，避免出现全站性的阻塞。</p>
<p>同时要充分考虑如何解耦和封装，在开展新的小程序的时候，能更快的去复用能力，避免重复采坑。</p>
<p>登录注册这模块，就像个冰山，我们以为它就是「输入账号密码，就完成登录了」，但实际下面还有各种需要考虑的问题。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016104626.jpg" alt></p>
<p>在此，跟在座的各位分享一下，最近做完一个小程序登录/注册模块之后，沉淀下来的一些设计经验和想法。</p>
<h1 id="u4E8C-__u4E1A_u52A1_u573A_u666F"><a href="#u4E8C-__u4E1A_u52A1_u573A_u666F" class="headerlink" title="二. 业务场景"></a>二. 业务场景</h1><p>在用户浏览小程序的过程中，由业务需要，往往需要获取用户的一些基本信息，常见的有：</p>
<ol>
<li>微信昵称</li>
<li>微信手机号</li>
</ol>
<p>而不同的产品，对于用户的信息要求不尽相同，也会有不一样的授权流程。</p>
<p>第一种，常见于电商系统中，用户购买商品的时候，为了识别用户多平台的账号，往往用手机号去做一个联系，这时候需要用户去授权手机号。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111059.jpg" alt="授权手机号"></p>
<p>第二种，为了让用户信息得到基本的初始化，往往需要更进一步获取用户信息：如微信昵称，<code>unionId</code> 等，就需要询问用户授权。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111042.jpg" alt="授权用户信息"></p>
<p>第三种，囊括第一种，第二种。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111006.jpg" alt="完整授权流程"></p>
<h1 id="u4E09-__u6982_u5FF5"><a href="#u4E09-__u6982_u5FF5" class="headerlink" title="三. 概念"></a>三. 概念</h1><p>秉着沉淀一套通用的小程序登录方案和服务为目标，我们去分析一下业务，得出变量。</p>
<p>在做技术设计之前，讲点必要的废话，对一些概念进行基本调频。</p>
<h2 id="2-1__u5173_u4E8E_u300C_u767B_u5F55_u300D"><a href="#2-1__u5173_u4E8E_u300C_u767B_u5F55_u300D" class="headerlink" title="2.1 关于「登录」"></a>2.1 关于「登录」</h2><p>登录在英文中是 「login」，对应的还有 「logout」。而登录之前，你需要拥有一个账号，就要 「register」（or sign up）。</p>
<p>话说一开始的产品是没有登录/注册功能的，用的人多了就慢慢有了。出于产品本身的需求，需要对「用户」进行身份识别。</p>
<p>在现实社会中，我们每个人都有一个身份ID：身份证。当我到了16岁的时候，第一次去公安局领身份证的时候，就完成了一次「注册」行为。然后我去网吧上网，身份证刷一下，完成了一次「登录」行为。</p>
<p>那么对于虚拟世界的互联网来说，这个身份证明就是「账号+密码」。</p>
<p>常见的登录/注册方式有：</p>
<ol>
<li><p><strong>账号密码注册</strong></p>
<p> 在互联网的早期，个人邮箱和手机覆盖度小。所以，就需要用户自己想一个账号名，我们注册个QQ号，就是这种形式。</p>
<p> <img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105159.png" alt="from 汽车之家">    </p>
</li>
<li><p><strong>邮箱地址注册</strong></p>
<p> 千禧年之后，PC互联网时代快速普及，我们都创建了属于自己的个人邮箱。加上QQ也自带邮箱账号。由于邮箱具有个人私密性，且能够进行信息的沟通，因此，大部分网站开始采用邮箱账号作为用户名来进行注册，并且会在注册的过程中要求登录到相应邮箱内查收激活邮件，验证我们对该注册邮箱的所有权。</p>
<p> <img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105005.png" alt="from 支付宝"></p>
</li>
<li><p><strong>手机号码注册</strong></p>
<p> 在互联网普及之后，智能手机与移动互联网发展迅猛。手机也成为每个人必不可少的移动设备，同时移动互联网也已经深深融入每个人的现代生活当中。所以，相较于邮箱，目前手机号码与个人的联系更加紧密，而且越来越多的移动应用出现，采用手机号码作为用户名的注册方式也得到了广泛的使用。   </p>
<p> <img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016105120.png" alt="from 知乎"></p>
</li>
</ol>
<p>到了 2020 年，微信用户规模达 12 亿。那么，微信账号，起码在中国，已成为新一代互联网世界的「身份标识」。</p>
<p>而对微信小程序而言，天然就能知道当前用户的微信账号ID。微信允许小程序应用，能在用户无感知的情况下，悄无声息的「登录」到我们的小程序应用中去，这个就是我们经常称之为的「静默登录」。</p>
<p>其实微信小程序的登录，跟传统 Web 应用的「单点登录」本质是一样的概念。</p>
<ol>
<li>单点登录：在 A 站登录了，C 站和 B 站能实现快速的「静默登录」。</li>
<li>微信小程序登录：在微信中，登录了微信账号，那么在整个小程序生态中，都可以实现「静默登录」。</li>
</ol>
<p>由于 Http 本来是无状态的，业界基本对于登录态的一般做法：</p>
<ol>
<li>cookie-session：常用于浏览器应用中</li>
<li>access token：常用于移动端等非浏览器应用</li>
</ol>
<p>在微信小程序来说，对于「JS逻辑层」并不是一个浏览器环境，自然没有 <code>Cookie</code>，那么通常会使用 <code>access token</code> 的方式。</p>
<h2 id="2-2__u5173_u4E8E_u300C_u6388_u6743_u300D"><a href="#2-2__u5173_u4E8E_u300C_u6388_u6743_u300D" class="headerlink" title="2.2 关于「授权」"></a>2.2 关于「授权」</h2><p>对于需要更进一步获取用的用户昵称、用户手机号等信息的产品来说。微信出于用户隐私的考虑，需要用户主动同意授权。小程序应用才能获取到这部分信息，这就有了目前流行的小程序「授权用户信息」、「授权手机号」的交互了。</p>
<p>出于不同的用户信息敏感度不同的考虑，微信小程序对于不同的用户信息提供「授权」的方式不尽相同：</p>
<ol>
<li>调用具体 API 方式，弹窗授权。<ol>
<li>例如调用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getLocation.html" target="_blank" rel="external"><code>wx.getLocation()</code></a> 的时候，如果用户未授权，则会弹出地址授权界面。</li>
<li>如果拒绝了，就不会再次弹窗，<code>wx.getLocation()</code>直接返回失败。</li>
</ol>
</li>
<li><code>&lt;button open-type=&quot;xxx&quot; /&gt;</code> 方式。<ol>
<li>仅支持：用户敏感信息，用户手机号，需要配合后端进行对称加解密，方能拿到数据。</li>
<li>用户已拒绝，再次点击按钮，仍然会弹窗。</li>
</ol>
</li>
<li>通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/authorize/wx.authorize.html" target="_blank" rel="external"><code>wx.authorize()</code></a>，提前询问授权，之后需要获取相关信息的时候不用再次弹出授权。</li>
</ol>
<h1 id="u56DB-__u8BE6_u7EC6_u8BBE_u8BA1"><a href="#u56DB-__u8BE6_u7EC6_u8BBE_u8BA1" class="headerlink" title="四. 详细设计"></a>四. 详细设计</h1><p>梳理清楚了概念之后，我们模块的划分上，可以拆分为两大块：</p>
<ol>
<li><strong>登录</strong>：负责与服务端创建起一个会话，这个会话实现静默登录以及相关的容错处理等，模块命名为：<code>Session</code></li>
<li><strong>授权</strong>：负责与用户交互，获取与更新信息，以及权限的控制处理等，模块命名为：<code>Auth</code></li>
</ol>
<h2 id="3-1__u767B_u5F55_u7684_u5B9E_u73B0"><a href="#3-1__u767B_u5F55_u7684_u5B9E_u73B0" class="headerlink" title="3.1 登录的实现"></a>3.1 登录的实现</h2><h3 id="3-1-1__u9759_u9ED8_u767B_u5F55"><a href="#3-1-1__u9759_u9ED8_u767B_u5F55" class="headerlink" title="3.1.1 静默登录"></a>3.1.1 静默登录</h3><p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111135.png" alt="微信登录"></p>
<p>微信官方提供的登录方案，总结为三步：</p>
<ol>
<li>前端通过 <code>wx.login()</code> 获取一次性加密凭证 code，交给后端。</li>
<li>后端把这个 code 传输给微信服务器端，换取用户唯一标识 <code>openId</code> 和授权凭证 <code>session_key</code>。（用于后续服务器端和微信服务器的特殊 API 调用，具体看：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html" target="_blank" rel="external">微信官方文档-服务端获取开放数据</a>）。</li>
<li>后端把从微信服务器获取到的用户凭证与自行生成的登录态凭证（token），传输给前端。前端保存起来，下次请求的时候带给后端，就能识别哪个用户。</li>
</ol>
<p>如果只是实现这个流程的话，挺简单的。</p>
<p>但要实现一个健壮的登录过程，还需要注意更多的边界情况：</p>
<ol>
<li><p><strong>收拢 <code>wx.login()</code> 的调用</strong>：</p>
<p> 由于 <code>wx.login()</code> 会产生不可预测的副作用，例如会可能导致<code>session_key</code>失效，从而导致后续的授权解密场景中的失败。我们这里可以提供一个像 <code>session.login()</code> 的方法，掌握 <code>wx.login()</code> 控制权，对其做一系列的封装和容错处理。</p>
</li>
<li><p><strong>调用的时机</strong>：</p>
<p> 通常我们会在应用启动的时候（ <code>app.onLaunch()</code> ），去发起静默登录。但这里会由小程序生命周期设计问题而导致的一个异步问题：加载页面的时候，去调用一个需要登录态的后端 API 的时候，前面异步的静态登录过程有可能还没有完成，从而导致请求失败。</p>
<p> 当然也可以在第一个需要登录态的接口调用的时候以异步阻塞的方式发起登录调用，这个需要结合良好设计的接口层。</p>
<p> 以上讲到的两种场景的详细设计思路下文会讲到。</p>
</li>
<li><p><strong>并发调用的问题</strong>：</p>
<p> 在业务场景中，难免会出现多处代码需要触发登录，如果遇到极端情况，这多处代码同时间发起调用。那就会造成短时间多次发起登录过程，尽管之前的请求还没有完成。针对这种情况，我们可以以第一个调用为阻塞，后续调用等待结果，就像精子和卵子结合的过程。</p>
</li>
<li><p><strong>未过期调用的问题</strong>：</p>
<p> 如果我们的登录态未过期，完全可以正常使用的，默认情况就不需再去发起登录过程了。这时候我们可以默认情况下先去检查登录态是否可用，不能用，我们再发起请求。然后还可以提供一个类似 <code>session.login({ force: true })</code>的参数去强行发起登录。</p>
</li>
</ol>
<h3 id="3-1-2__u9759_u9ED8_u767B_u5F55_u5F02_u6B65_u72B6_u6001_u7684_u5904_u7406"><a href="#3-1-2__u9759_u9ED8_u767B_u5F55_u5F02_u6B65_u72B6_u6001_u7684_u5904_u7406" class="headerlink" title="3.1.2 静默登录异步状态的处理"></a>3.1.2 静默登录异步状态的处理</h3><p><strong>1. 应用启动的时候调用</strong></p>
<p>因为大部分情况都需要依赖登录态，我们会很自然而然的想到把这个调用的时机放到应用启动的时候（ <code>app.onLaunch()</code> ）来调用。</p>
<p>但是由于原生的小程序启动流程中， <code>App</code>，<code>Page</code>，<code>Component</code> 的生命周期钩子函数，都不支持异步阻塞。</p>
<p>那么我们很容易会遇到 <code>app.onLaunch</code> 发起的「登录过程」在 <code>page.onLoad</code> 的时候还没有完成，我们就无法正确去做一些依赖登录态的操作。</p>
<p>针对这种情况，我们设计了一个状态机的工具：<a href="http://beautywejs.com/#/remote/plugin-status?id=plugin-statusl" target="_blank" rel="external">status</a></p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016110706.png" alt="状态机"></p>
<p>基于状态机，我们就可以编写这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Status &#125; <span class="keyword">from</span> <span class="string">'@beautywe/plugin-status'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// on app.js</span></span><br><span class="line">App(&#123;</span><br><span class="line">    status: &#123;</span><br><span class="line">       login: <span class="keyword">new</span> Status(<span class="string">'login'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    onLaunch() &#123;</span><br><span class="line">        session</span><br><span class="line">            <span class="comment">// 发起静默登录调用</span></span><br><span class="line">            .login()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把状态机设置为 success</span></span><br><span class="line">            .then(() =&gt; <span class="keyword">this</span>.status.login.success())</span><br><span class="line">      </span><br><span class="line">            <span class="comment">// 把状态机设置为 fail</span></span><br><span class="line">            .catch(() =&gt; <span class="keyword">this</span>.status.login.fail());</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// on page.js</span></span><br><span class="line">Page(&#123;</span><br><span class="line">    onLoad() &#123;</span><br><span class="line">      <span class="keyword">const</span> loginStatus = getApp().status.login;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// must 里面会进行状态的判断，例如登录中就等待，登录成功就直接返回，登录失败抛出等。</span></span><br><span class="line">      loginStatus().status.login.must(() =&gt; &#123;</span><br><span class="line">        <span class="comment">// 进行一些需要登录态的操作...</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>2. 在「第一个需要登录态接口」被调用的时候去发起登录</strong></p>
<p>更进一步，我们会发现，需要登录态的更深层次的节点是在发起的「需要登录态的后端 API 」的时候。</p>
<p>那么我们可以在调用「需要登录态的后端 API」的时候再去发起「静默登录」，对于并发的场景，让其他请求等待一下就好了。</p>
<p>以 <a href="https://wendux.github.io/dist/#/doc/flyio/readme" target="_blank" rel="external">fly.js</a> 作为 <code>wx.request()</code> 封装的「网络请求层」，做一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起请求，并表明该请求是需要登录态的</span></span><br><span class="line">fly.post(<span class="string">'https://...'</span>, params, &#123; needLogin: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 fly 拦截器中处理逻辑</span></span><br><span class="line">fly.interceptors.request.use(<span class="keyword">async</span> (req)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在请求需要登录态的时候</span></span><br><span class="line">  <span class="keyword">if</span> (req.needLogin !== <span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensureLogin 核心逻辑是：判断是否已登录，如否发起登录调用，如果正在登录，则进入队列等待回调。</span></span><br><span class="line">    <span class="keyword">await</span> session.ensureLogin();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 登录成功后，获取 token，通过 headers 传递给后端。</span></span><br><span class="line">    <span class="keyword">const</span> token = <span class="keyword">await</span> session.getToken();</span><br><span class="line">    <span class="built_in">Object</span>.assign(req.headers, &#123; [AUTH_KEY_NAME]: token &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> req;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-1-3__u81EA_u5B9A_u4E49_u767B_u5F55_u6001_u8FC7_u671F_u7684_u5BB9_u9519_u5904_u7406"><a href="#3-1-3__u81EA_u5B9A_u4E49_u767B_u5F55_u6001_u8FC7_u671F_u7684_u5BB9_u9519_u5904_u7406" class="headerlink" title="3.1.3 自定义登录态过期的容错处理"></a>3.1.3 自定义登录态过期的容错处理</h3><p>当自定义登录态过期的时候，后端需要返回特定的状态码，例如：<code>AUTH_EXPIRED</code> 、 <code>AUTH_INVALID</code> 等。</p>
<p>前端可以在「网络请求层」去监听所有请求的这个状态码，然后发起刷新登录态，再去重放失败的请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">fly.interceptors.response.use(</span><br><span class="line">    (response) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> code = res.data;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 登录态过期或失效</span></span><br><span class="line">      <span class="keyword">if</span> ( [<span class="string">'AUTH_EXPIRED'</span>, <span class="string">'AUTH_INVALID'</span>].includes(code) ) &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 刷新登录态</span></span><br><span class="line">        <span class="keyword">await</span> session.refreshLogin();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 然后重新发起请求</span></span><br><span class="line">        <span class="keyword">return</span> fly.request(request);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>那么如果并发的发起多个请求，都返回了登录态失效的状态码，上述代码就会被执行多次。</p>
<p>我们需要对 <code>session.refreshLogin()</code> 做一些特殊的容错处理：</p>
<ol>
<li><strong>请求锁</strong>：同一时间，只允许一个正在过程中的网络请求。</li>
<li><strong>等待队列</strong>：请求被锁定之后，调用该方法的所有调用，都推入一个队列中，等待网络请求完成之后共用返回结果。</li>
<li><strong>熔断机制</strong>：如果短时间内多次调用，则停止响应一段时间，类似于 TCP 慢启动。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 刷新登录保险丝，最多重复 3 次，然后熔断，5s 后恢复</span></span><br><span class="line">  refreshLoginFuseLine = REFRESH_LOGIN_FUSELINE_DEFAULT;</span><br><span class="line">  refreshLoginFuseLocked = <span class="literal">false</span>;</span><br><span class="line">  refreshLoginFuseRestoreTime = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 熔断控制</span></span><br><span class="line">  refreshLoginFuse(): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.refreshLoginFuseLocked) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'刷新登录-保险丝已熔断，请稍后'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.refreshLoginFuseLine &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.refreshLoginFuseLine = <span class="keyword">this</span>.refreshLoginFuseLine - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.refreshLoginFuseLocked = <span class="literal">true</span>;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.refreshLoginFuseLocked = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.refreshLoginFuseLine = REFRESH_LOGIN_FUSELINE_DEFAULT;</span><br><span class="line">        logger.info(<span class="string">'刷新登录-保险丝熔断解除'</span>);</span><br><span class="line">      &#125;, <span class="keyword">this</span>.refreshLoginFuseRestoreTime);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'刷新登录-保险丝熔断!!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 并发回调队列</span></span><br><span class="line">  refreshLoginQueueMaxLength = <span class="number">100</span>;</span><br><span class="line">  refreshLoginQueue: any[] = [];</span><br><span class="line">  refreshLoginLocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 刷新登录态</span></span><br><span class="line">  refreshLogin(): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 回调队列 + 熔断 控制</span></span><br><span class="line">      .then(() =&gt; <span class="keyword">this</span>.refreshLoginFuse())</span><br><span class="line">      .then(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.refreshLoginLocked) &#123;</span><br><span class="line">          <span class="keyword">const</span> maxLength = <span class="keyword">this</span>.refreshLoginQueueMaxLength;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.refreshLoginQueue.length &gt;= maxLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">`refreshLoginQueue 超出容量：<span class="subst">$&#123;maxLength&#125;</span>`</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.refreshLoginQueue.push([resolve, reject]);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.refreshLoginLocked = <span class="literal">true</span>;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过前置控制之后，发起登录过程</span></span><br><span class="line">      .then(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.clearSession();</span><br><span class="line">        wx.showLoading(&#123; title: <span class="string">'刷新登录态中'</span>, mask: <span class="literal">true</span> &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.login()</span><br><span class="line">          .then(() =&gt; &#123;</span><br><span class="line">            wx.hideLoading();</span><br><span class="line">            wx.showToast(&#123; icon: <span class="string">'none'</span>, title: <span class="string">'登录成功'</span> &#125;);</span><br><span class="line">            <span class="keyword">this</span>.refreshLoginQueue.forEach(([resolve]) =&gt; resolve());</span><br><span class="line">            <span class="keyword">this</span>.refreshLoginLocked = <span class="literal">false</span>;</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(err =&gt; &#123;</span><br><span class="line">            wx.hideLoading();</span><br><span class="line">            wx.showToast(&#123; icon: <span class="string">'none'</span>, title: <span class="string">'登录失败'</span> &#125;);</span><br><span class="line">            <span class="keyword">this</span>.refreshLoginQueue.forEach(([, reject]) =&gt; reject());</span><br><span class="line">            <span class="keyword">this</span>.refreshLoginLocked = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-4__u5FAE_u4FE1_session_key__u8FC7_u671F_u7684_u5BB9_u9519_u5904_u7406"><a href="#3-1-4__u5FAE_u4FE1_session_key__u8FC7_u671F_u7684_u5BB9_u9519_u5904_u7406" class="headerlink" title="3.1.4 微信 session_key 过期的容错处理"></a>3.1.4 微信 session_key 过期的容错处理</h3><p>我们从上面的「静默登录」之后，微信服务器端会下发一个 <code>session_key</code> 给后端，而这个会在需要获取<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html" target="_blank" rel="external">微信开放数据</a>的时候会用到。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016110824.png" alt="微信开放数据"></p>
<p>而 <code>session_key</code> 是有时效性的，以下摘自微信官方描述：</p>
<blockquote>
<h4 id="u4F1A_u8BDD_u5BC6_u94A5_session_key__u6709_u6548_u6027"><a href="#u4F1A_u8BDD_u5BC6_u94A5_session_key__u6709_u6548_u6027" class="headerlink" title="会话密钥 session_key 有效性"></a>会话密钥 session_key 有效性</h4><p>开发者如果遇到因为 session_key 不正确而校验签名失败或解密失败，请关注下面几个与 session_key 有关的注意事项。</p>
<ol>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html" target="_blank" rel="external">wx.login</a> 调用时，用户的 session_key <strong>可能</strong>会被更新而致使旧 session_key 失效（刷新机制存在最短周期，如果同一个用户短时间内多次调用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html" target="_blank" rel="external">wx.login</a>，并非每次调用都导致 session_key 刷新）。开发者应该在明确需要重新登录时才调用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html" target="_blank" rel="external">wx.login</a>，及时通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html" target="_blank" rel="external">auth.code2Session</a> 接口更新服务器存储的 session_key。</li>
<li>微信不会把 session_key 的有效期告知开发者。我们会根据用户使用小程序的行为对 session_key 进行续期。用户越频繁使用小程序，session_key 有效期越长。</li>
<li>开发者在 session_key 失效时，可以通过重新执行登录流程获取有效的 session_key。使用接口 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.checkSession.html" target="_blank" rel="external">wx.checkSession</a>可以校验 session_key 是否有效，从而避免小程序反复执行登录流程。</li>
<li>当开发者在实现自定义登录态时，可以考虑以 session_key 有效期作为自身登录态有效期，也可以实现自定义的时效性策略。</li>
</ol>
</blockquote>
<p>翻译成简单的两句话：</p>
<ol>
<li><code>session_key</code> 时效性由微信控制，开发者不可预测。</li>
<li><code>wx.login</code> 可能会导致 <code>session_key</code> 过期，可以在使用接口之前用<code>wx.checkSession</code> 检查一下。</li>
</ol>
<p>而对于第二点，我们通过实验发现，偶发性的在 <code>session_key</code> 已过期的情况下，<code>wx.checkSession</code> 会概率性返回 <code>true</code></p>
<p>社区也有相关的反馈未得到解决：</p>
<ul>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000424005b89983f337a622c751000?highLine=wx.checkSession" target="_blank" rel="external">小程序解密手机号,隔一小段时间后,checksession:ok,但是解密失败</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/0008e429bd0c886e10699f59c51000?_at=1602745291452" target="_blank" rel="external">wx.checkSession有效，但是解密数据失败</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000a04ab4546d80d5428ffcee51800?_at=1602745291452" target="_blank" rel="external">checkSession判断session_key未失效，但是解密手机号失败</a></li>
</ul>
<p><strong>所以结论是：<code>wx.checkSession</code>可靠性是不达 100% 的。</strong></p>
<p>基于以上，我们需要对 <code>session_key</code> 的过期做一些容错处理：</p>
<ol>
<li>发起需要使用 <code>session_key</code> 的请求前，做一次 <code>wx.checkSession</code> 操作，如果失败了刷新登录态。</li>
<li>后端使用 <code>session_key</code> 解密开放数据失败之后，返回特定错误码（如：<code>DECRYPT_WX_OPEN_DATA_FAIL</code>），前端刷新登录态。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义检查 session_key 有效性的操作</span></span><br><span class="line"><span class="keyword">const</span> ensureSessionKey = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> hasSession = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve =&gt; &#123;</span><br><span class="line">    wx.checkSession(&#123;</span><br><span class="line">      success: () =&gt; resolve(<span class="literal">true</span>),</span><br><span class="line">      fail: () =&gt; resolve(<span class="literal">false</span>),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!hasSession) &#123;</span><br><span class="line">    logger.info(<span class="string">'sessionKey 已过期，刷新登录态'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接上面提到的刷新登录逻辑</span></span><br><span class="line">    <span class="keyword">return</span> session.refreshLogin();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在发起请求的时候，先做一次确保 session_key 最新的操作（以 fly.js 作为网络请求层为例）</span></span><br><span class="line"><span class="keyword">const</span> updatePhone = <span class="keyword">async</span> (params) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> ensureSessionKey();</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fly.post(<span class="string">'https://xxx'</span>, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器, 监听网络请求返回</span></span><br><span class="line">fly.interceptors.response.use(</span><br><span class="line">    (response) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> code = res.data;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 登录态过期或失效</span></span><br><span class="line">      <span class="keyword">if</span> ( [<span class="string">'DECRYPT_WX_OPEN_DATA_FAIL'</span>].includes(code)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新登录态</span></span><br><span class="line">        <span class="keyword">await</span> session.refreshLogin();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 由于加密场景的加密数据由用户点击产生，session_key 可能已经更改，需要用户重新点击一遍。</span></span><br><span class="line">        wx.showToast(&#123; title: <span class="string">'网络出小差了，请稍后重试'</span>, icon: <span class="string">'none'</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="3-2__u6388_u6743_u7684_u5B9E_u73B0"><a href="#3-2__u6388_u6743_u7684_u5B9E_u73B0" class="headerlink" title="3.2 授权的实现"></a>3.2 授权的实现</h2><h3 id="3-2-1__u7EC4_u4EF6_u62C6_u5206_u4E0E_u8BBE_u8BA1"><a href="#3-2-1__u7EC4_u4EF6_u62C6_u5206_u4E0E_u8BBE_u8BA1" class="headerlink" title="3.2.1 组件拆分与设计"></a>3.2.1 组件拆分与设计</h3><p>在用户信息和手机号获取的方式上，微信是以 <code>&lt;button open-type=&#39;xxx&#39; /&gt;</code> 的方式，让用户主动点击授权的。</p>
<p>那么为了让代码更解耦，我们设计这样三个组件：</p>
<ol>
<li><code>&lt;user-contaienr getUserInfo=&quot;onUserInfoAuth&quot;&gt;</code>: 包装点击交互，通过 <code>&lt;slot&gt;</code> 支持点击区域的自定义UI。</li>
<li><code>&lt;phone-container getPhonenNmber=&quot;onPhoneAuth&quot;&gt;</code> : 与 <code>&lt;user-container&gt;</code> 同理。</li>
<li><code>&lt;auth-flow&gt;</code>: 根据业务需要，组合 <code>&lt;user-container&gt;</code>、<code>&lt;phone-container&gt;</code> 组合来定义不同的授权流程。</li>
</ol>
<p>以开头的业务场景的流程为例，它有这样的要求：</p>
<ol>
<li>有多个步骤。</li>
<li>如果中途断掉了，可以从中间接上。</li>
<li>有些场景中，只要求达到「用户信息授权」，而不需要完成「用户手机号」。</li>
</ol>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016111006.jpg" alt="完整授权流程"></p>
<p>那么授权的阶段可以分三层：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户登录的阶段</span></span><br><span class="line"><span class="keyword">export</span> enum AuthStep &#123;</span><br><span class="line">  <span class="comment">// 阶段一：只有登录态，没有用户信息，没有手机号</span></span><br><span class="line">  ONE = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阶段二：有用户信息，没有手机号</span></span><br><span class="line">  TWO = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阶段三：有用户信息，有手机号</span></span><br><span class="line">  THREE = <span class="number">3</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AuthStep</code> 的推进过程是不可逆的，我们可以定义一个 <code>nextStep</code> 函数来封装 AuthStep 更新的逻辑。外部使用的话，只要无脑调用 <code>nextStep</code> 方法，等待回调结果就行。</p>
<p>示例伪代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auth-flow component</span></span><br><span class="line"></span><br><span class="line">Component(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="comment">// 默认情况下，只需要到达阶段二。</span></span><br><span class="line">    mustAuthStep: AuthStep.TWO</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 允许临时更改组件的需要达到的阶段。</span></span><br><span class="line">  setMustAuthStep(mustAuthStep: AuthStep) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123; mustAuthStep &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据用户当前的信息，计算用户处在授权的阶段</span></span><br><span class="line">  getAuthStep() &#123;</span><br><span class="line">    <span class="keyword">let</span> currAuthStep;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有用户信息，尚在第一步</span></span><br><span class="line">    <span class="keyword">if</span> (!session.hasUser() || !session.hasUnionId()) &#123;</span><br><span class="line">      currAuthStep = AuthStepType.ONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有手机号，尚在第二步</span></span><br><span class="line">    <span class="keyword">if</span> (!session.hasPhone()) &#123;</span><br><span class="line">      currAuthStep = AuthStepType.TWO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 都有，尚在第三步</span></span><br><span class="line">    currAuthStep = AuthStepType.THREE;</span><br><span class="line">    <span class="keyword">return</span> currAuthStep;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发起下一步授权，如果都已经完成，就直接返回成功。</span></span><br><span class="line">  nextStep(e) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; mustAuthStep &#125; = <span class="keyword">this</span>.data;</span><br><span class="line">    <span class="keyword">const</span> currAuthStep = <span class="keyword">this</span>.updateAuthStep();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 已完成授权</span></span><br><span class="line">    <span class="keyword">if</span> (currAuthStep &gt;= mustAuthStep || currAuthStep === AuthStepType.THREE) &#123;</span><br><span class="line">      <span class="comment">// 更新全局的授权状态机，广播消息给订阅者。</span></span><br><span class="line">      <span class="keyword">return</span> getApp().status.auth.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：更新用户信息</span></span><br><span class="line">    <span class="keyword">if</span> (currAuthStep === AuthStepType.ONE) &#123;</span><br><span class="line">      <span class="comment">// 已有密文信息，更新用户信息</span></span><br><span class="line">      <span class="keyword">if</span> (e) session.updateUser(e);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新到视图层，展示对应UI，等待获取用户信息</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">this</span>.setData(&#123; currAuthStep &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：更新手机信息</span></span><br><span class="line">    <span class="keyword">if</span> (currAuthStep === AuthStepType.TWO) &#123;</span><br><span class="line">      <span class="comment">// 已有密文信息，更新手机号</span></span><br><span class="line">      <span class="keyword">if</span> (e) <span class="keyword">this</span>.bindPhone(e);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 未有密文信息，弹出获取窗口</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">this</span>.setData(&#123; currAuthStep &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'auth.nextStep 错误'</span>, &#123; currAuthStep, mustAuthStep &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那么我们的 <code>&lt;auth-flow&gt;</code> 中就可以根据 <code>currAuthStep</code> 和 <code>mustAuthStep</code> 来去做不同的 UI 展示。需要注意的是使用 <code>&lt;user-container&gt;</code>、<code>&lt;phone-container&gt;</code> 的时候连接上 <code>nextStep(e)</code> 函数。</p>
<p>示例伪代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">view</span> <span class="attribute">class</span>=<span class="value">"auth-flow"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 已完成授权 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">block</span> <span class="attribute">wx:if</span>=<span class="value">"&#123;&#123;currAuthStep === mustAuthStep || currAuthStep === AuthStep.THREE&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">view</span>&gt;</span>已完成授权<span class="tag">&lt;/<span class="title">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">block</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 未完成授权，第一步：授权用户信息 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">block</span> <span class="attribute">wx:elif</span>=<span class="value">"&#123;&#123;currAuthStep === AuthStep.ONE&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">user-container</span> <span class="attribute">bind:getuserinfo</span>=<span class="value">"nextStep"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">view</span>&gt;</span>授权用户信息<span class="tag">&lt;/<span class="title">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">user-container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">block</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 未完成授权，第二步：授权手机号 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">block</span> <span class="attribute">wx:elif</span>=<span class="value">"&#123;&#123;currAuthStep === AuthStep.TWO&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">phone-container</span> <span class="attribute">bind:getphonenumber</span>=<span class="value">"nextStep"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">view</span>&gt;</span>授权手机号<span class="tag">&lt;/<span class="title">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">phone-container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">block</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="title">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-2__u6743_u9650_u62E6_u622A_u7684_u5904_u7406"><a href="#3-2-2__u6743_u9650_u62E6_u622A_u7684_u5904_u7406" class="headerlink" title="3.2.2 权限拦截的处理"></a>3.2.2 权限拦截的处理</h3><p>到这里，我们制作好了用来承载授权流程的组件 <code>&lt;auth-flow&gt;</code> ，那么接下来就是决定要使用它的时机了。</p>
<p>我们梳理需要授权的场景：</p>
<ol>
<li><p>点击某个按钮，例如：购买某个商品。</p>
<p>对于这种场景，常见的是通过弹窗完成授权，用户可以选择关闭。</p>
</li>
</ol>
<p>   <img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016113312.png" alt="授权模型-弹窗"></p>
<ol start="2">
<li><p>浏览某个页面，例如：访问个人中心。</p>
<p>对于这种场景，我们可以在点击跳转某个页面的时候，进行拦截，弹窗处理。但这样的缺点是，跳转到目标页面的地方可能会很多，每个都拦截，难免会错漏。而且当目标页面作为「小程序落地页面」的时候，就避免不了。</p>
<p>这时候，我们可以通过重定向到授权页面来完成授权流程，完成之后，再回来。</p>
</li>
</ol>
<p>   <img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016113324.png" alt="授权模型-页面"></p>
<p>那么我们定义一个枚举变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 授权的展示形式</span></span><br><span class="line"><span class="keyword">export</span> enum AuthDisplayMode &#123;</span><br><span class="line">  <span class="comment">// 以弹窗形式</span></span><br><span class="line">  POPUP = <span class="string">'button'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以页面形式</span></span><br><span class="line">  PAGE = <span class="string">'page'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以设计一个 <code>mustAuth</code> 方法，在点击某个按钮，或者页面加载的时候，进行授权控制。</p>
<p>伪代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  mustAuth(&#123;</span><br><span class="line">    mustAuthStep = AuthStepType.TWO, <span class="comment">// 需要授权的LEVEL，默认需要获取用户资料</span></span><br><span class="line">    popupCompName = <span class="string">'auth-popup'</span>,	<span class="comment">// 授权弹窗组件的 id</span></span><br><span class="line">    mode = AuthDisplayMode.POPUP, <span class="comment">// 默认以弹窗模式</span></span><br><span class="line">  &#125; = &#123;&#125;): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前的授权步骤已经达标，则返回成功</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentAuthStep() &gt;= mustAuthStep) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取当前页面的 &lt;auth-popup id="auth-popup" /&gt; 组件实例</span></span><br><span class="line">    <span class="keyword">const</span> pages = getCurrentPages();</span><br><span class="line">    <span class="keyword">const</span> curPage = pages[pages.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> popupComp = curPage.selectComponent(<span class="string">`#<span class="subst">$&#123;popupCompName&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件不存在或者显示指定页面，跳转到授权页面</span></span><br><span class="line">    <span class="keyword">if</span> (!popupComp || mode === AuthDisplayMode.PAGE) &#123;</span><br><span class="line">      <span class="keyword">const</span> curRoute = curPage.route;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 跳转到授权页面，带上当前页面路由，授权完成之后，回到当前页面。</span></span><br><span class="line">      wx.redirectTo(&#123; url: <span class="string">`authPage?backTo=<span class="subst">$&#123;encodeURIComponent(curRoute)&#125;</span>`</span> &#125;);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置授权 LEVEL，然后调用 &lt;auth-popup&gt; 的 nextStep 方法，进行进一步的授权。</span></span><br><span class="line">    popupComp.setMustAuthStep(mustAuthStep);</span><br><span class="line">    popupComp.nextStep();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待成功回调或者失败回调</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> authStatus = getApp().status.auth;</span><br><span class="line">      authStatus.onceSuccess(resolve);</span><br><span class="line">      authStatus.onceFail(reject);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们就能在按钮点击，或者页面加载的时候进行授权拦截：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  onLoad() &#123;</span><br><span class="line">    session.mustAuth().then(() =&gt; &#123;</span><br><span class="line">      <span class="comment">// 开始初始化页面...</span></span><br><span class="line">    &#125;)；</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  onClick(e) &#123;</span><br><span class="line">    session.mustAuth().then(() =&gt; &#123;</span><br><span class="line">      <span class="comment">// 开始处理回调逻辑...</span></span><br><span class="line">    &#125;)；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当然，如果项目使用了 TS 的话，或者支持 ES7 Decorator 特性的话，我们可以为 <code>mustAuth</code> 提供一个装饰器版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mustAuth</span>(<span class="params">option = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span><br><span class="line">    _target,</span><br><span class="line">    _propertyName,</span><br><span class="line">    descriptor,</span><br><span class="line">  </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 劫持目标方法</span></span><br><span class="line">    <span class="keyword">const</span> method = descriptor.value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写目标方法</span></span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params">...args: any[]</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> session.mustAuth(option).then(() =&gt; &#123;</span><br><span class="line">        <span class="comment">// 登录完成之后，重放原来方法</span></span><br><span class="line">        <span class="keyword">if</span> (method) <span class="keyword">return</span> method.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么使用方式就简单一些了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  @mustAuth();</span><br><span class="line">  onLoad() &#123;</span><br><span class="line">    <span class="comment">// 开始初始化页面...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @mustAuth();</span><br><span class="line">  onClick(e) &#123;</span><br><span class="line">    <span class="comment">// 开始处理回调逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="3-3-__u524D_u540E_u7AEF_u4EA4_u4E92_u534F_u8BAE_u6574_u7406"><a href="#3-3-__u524D_u540E_u7AEF_u4EA4_u4E92_u534F_u8BAE_u6574_u7406" class="headerlink" title="3.3. 前后端交互协议整理"></a>3.3. 前后端交互协议整理</h2><p>作为一套可复用的小程序登录方案，当然需要去定义好前后端的交互协议。</p>
<p>那么整套登录流程下来，需要的接口有这么几个：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/img/20201016162606.png" alt="登录注册前后端接口协议"></p>
<ol>
<li><p><strong>静默登录 silentLogin</strong></p>
<ol>
<li>入参：<ol>
<li>code: 产自 wx.login()</li>
</ol>
</li>
<li>出参：<ol>
<li>token: 自定义登录态凭证</li>
<li>userInfo: 用户信息</li>
</ol>
</li>
<li>说明：<ol>
<li>后端利用 code 跟微信客户端换取用户标识，然后注册并登录用户，返回自定义登录态 <code>token</code> 给前端</li>
<li><code>token</code> 前端会存起来，每个请求都会带上</li>
<li>userInfo 需要包含<code>nickname</code>和<code>phone</code>字段，前端用于计算当前用户的授权阶段。当然这个状态的记录可以放在后端，但是我们认为放在前端，会更加灵活。</li>
</ol>
</li>
</ol>
</li>
<li><strong>更新用户信息 updateUser</strong><ol>
<li>入参：<ol>
<li>nickname: 用户昵称</li>
<li>encrypt: 微信开放数据相关的 <code>iv</code>, <code>encryptedData</code></li>
<li>以及其他如性别地址等非必要字段</li>
</ol>
</li>
<li>出参：<ol>
<li>userInfo：更新后的最新用户信息</li>
</ol>
</li>
<li>说明：<ol>
<li>后端解密微信开放数据，获取隐蔽数据，如：<code>unionId</code>等</li>
<li>后端支持更新包括 <code>nickname</code>等用户基本信息。</li>
<li>前端会把 userInfo 信息更新到 <code>session</code> 中，用于计算授权阶段。</li>
</ol>
</li>
</ol>
</li>
<li><strong>更新用户手机号 updatePhone</strong><ol>
<li>入参：<ol>
<li>encrypt：微信开放数据相关的 <code>iv</code>, <code>encryptedData</code></li>
</ol>
</li>
<li>出参：<ol>
<li>userInfo：更新后的最新用户信息</li>
</ol>
</li>
<li>说明：<ol>
<li>后端解密开放式局，获取手机号，并更新到用户信息中。 </li>
<li>前端会把 userInfo 信息更新到 <code>session</code> 中，用于计算授权阶段。</li>
</ol>
</li>
</ol>
</li>
<li><strong>解绑手机号 unbindPhone</strong><ol>
<li>入参：-</li>
<li>出参：-</li>
<li>说明：后端解绑用户手机号，成功与否，走业务定义的前后端协议。</li>
</ol>
</li>
<li><strong>登录 logout</strong><ol>
<li>入参：-</li>
<li>出参：-</li>
<li>说明：后端主动过期登录态，成功与否，走业务定义的前后端协议。</li>
</ol>
</li>
</ol>
<h1 id="u4E94-__u67B6_u6784_u56FE"><a href="#u4E94-__u67B6_u6784_u56FE" class="headerlink" title="五. 架构图"></a>五. 架构图</h1><p>最后我们来梳理一下整体的「登录服务」的架构图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjqk8sm9dbj30v60fp0uc.jpg" alt="微信小程序登录服务架构图"></p>
<p>由「登录服务」和「底层建设」组合提供的通用服务，业务层只需要去根据产品需求，定制授权的流程 <code>&lt;auth-flow&gt;</code> ，就能满足大部分场景了。</p>
<h1 id="u516D-__u603B_u7ED3"><a href="#u516D-__u603B_u7ED3" class="headerlink" title="六. 总结"></a>六. 总结</h1><p>本篇文章通过一些常见的登录授权场景来展开来描述细节点。</p>
<p>整理了「登录」、「授权」的概念。</p>
<p>然后分别针对「登录」介绍了一些关键的技术实现：</p>
<ol>
<li>静默登录</li>
<li>静默登录异步状态的处理</li>
<li>自定义登录态过期的容错处理</li>
<li>微信 <code>session_key</code> 过期的容错处理</li>
</ol>
<p>而对于「授权」，会有设计UI部分的逻辑，还需要涉及到组件的拆分：</p>
<ol>
<li>组件拆分与设计</li>
<li>权限拦截的处理</li>
</ol>
<p>然后，梳理了这套登录授权方案所依赖的后端接口，和给出最简单的参考协议。</p>
<p>最后，站在「秉着沉淀一套通用的小程序登录方案和服务为目标」的角度，梳理了一下架构层面上的分层。</p>
<ol>
<li>业务定制层</li>
<li>登录服务层</li>
<li>底层建设</li>
</ol>
<h1 id="u4E03-__u53C2_u8003"><a href="#u4E03-__u53C2_u8003" class="headerlink" title="七. 参考"></a>七. 参考</h1><ol>
<li><a href="https://wendux.github.io/dist/#/doc/flyio/readme" target="_blank" rel="external">fly.js 官网</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html" target="_blank" rel="external">微信官方文档-授权</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html" target="_blank" rel="external">微信官方文档-服务端获取开放数据</a></li>
<li>微信官方社区<ol>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000424005b89983f337a622c751000?highLine=wx.checkSession" target="_blank" rel="external">小程序解密手机号,隔一小段时间后,checksession:ok,但是解密失败</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/0008e429bd0c886e10699f59c51000?_at=1602745291452" target="_blank" rel="external">wx.checkSession有效，但是解密数据失败</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000a04ab4546d80d5428ffcee51800?_at=1602745291452" target="_blank" rel="external">checkSession判断session_key未失效，但是解密手机号失败</a></li>
</ol>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;u4E00-__u524D_u8A00&quot;&gt;&lt;a href=&quot;#u4E00-__u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h1&gt;&lt;p&gt;对于登录/注册的设计如此精雕细琢的目的，当然是想让这个作为应
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="登录 微信小程序" scheme="http://huang-jerryc.com/tags/%E7%99%BB%E5%BD%95-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>关于 OKR 的一些方法论</title>
    <link href="http://huang-jerryc.com/2019/07/06/about-okr/"/>
    <id>http://huang-jerryc.com/2019/07/06/about-okr/</id>
    <published>2019-07-06T14:53:00.000Z</published>
    <updated>2019-07-06T15:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>OKR 是由前 Intel CEO，<a href="https://www.wikiwand.com/zh-hk/%E5%AE%89%E8%BF%AA%C2%B7%E8%91%9B%E6%B4%9B%E5%A4%AB" target="_blank" rel="external">安迪·葛洛夫</a> 构建的基本框架。</p>
<p>全称是：「Objective - Key Result」，既强调「目标」与衡量目标的「关键结果」</p>
<p>它是一套管理目标，让目标能落地的工具。<br>它在硅谷科技公司中广为人知，并被世界各地的许多组织采用。<br>它可以应用在组织中，也可以应用在个人的生活中，就像一种思考的模式。</p>
<p>过去两年多的 OKR 实践，有一些体会。<br>作为一个程序员，会自然的去寻找一个工具的最佳实践。</p>
<p>于是，有了这篇文章。</p>
<h1 id="u57FA_u672C_u539F_u7406"><a href="#u57FA_u672C_u539F_u7406" class="headerlink" title="基本原理"></a>基本原理</h1><p>OKR 原理很简单。</p>
<p>要用好 OKR，我的理解，需要把握三个核心：</p>
<ul>
<li>目标</li>
<li>关键结果</li>
<li>过程管理</li>
</ul>
<p>它们分别回答了三个问题：</p>
<ul>
<li>应该做什么？</li>
<li>如何衡量做到了？</li>
<li>怎么落地？</li>
</ul>
<p>然后，思考 OKR，我认为还需要 cover 到两点：</p>
<ul>
<li>看得到的结果</li>
<li>说得出的价值</li>
</ul>
<p><strong>先抛一个不好的例子</strong></p>
<p>来自于我曾经定过的一个 OKR：</p>
<blockquote>
<p>O: 持续学习，提高自身战斗力</p>
<ul>
<li>KR1: CSS3 学习，阅读《CSS揭秘》产出阅读笔记。</li>
<li>KR2: 提高英文阅读能力，阅读《Security Your NodeJS Application》，产出一篇译文。</li>
<li>KR3: 对 Eggjs 或 Vue2 框架的源码进行解读，产出一篇源码解析。</li>
</ul>
</blockquote>
<p>我想先按顺序来讲讲「目标」、「关键结果」、「过程管理」。<br>然后，再回过头来，看看这个例子为啥糟糕，可以怎样修改。</p>
<h3 id="u76EE_u6807_Objective"><a href="#u76EE_u6807_Objective" class="headerlink" title="目标 Objective"></a>目标 Objective</h3><blockquote>
<p>欲望让我们起航，但只有专注、规划和学习才能到达成功的彼岸</p>
</blockquote>
<h5 id="u7EC4_u7EC7_u7684_u8BDE_u751F"><a href="#u7EC4_u7EC7_u7684_u8BDE_u751F" class="headerlink" title="组织的诞生"></a>组织的诞生</h5><p>回到最初的时候，一个组织的诞生，绝大多数情况是由于一两个人的想法，然后以此为中心，开始聚拢更多有共同目标的人加入进来。</p>
<p>1976年，乔布斯成功说服沃茲尼克組裝机器之后再拿去推销，他们的另一位朋友韦恩随后加入，三人在1976年4月1日成立苹果电脑公司。最初，Apple 仅仅是在卖组装电脑。</p>
<p>1996年，佩奇和布林在学校开始一项关于搜索的研究项目，开发出了搜索引擎 PageRank，后续改名 Google。最初，Google 仅仅是一个搜索引擎。</p>
<h5 id="u7EC4_u7EC7_u7684_u4F7F_u547D"><a href="#u7EC4_u7EC7_u7684_u4F7F_u547D" class="headerlink" title="组织的使命"></a>组织的使命</h5><p>随着组织发展，人员壮大，这个能聚拢人的目标，必须要看得远。然后这个目标提升到用另一个词来形容 —「使命」。</p>
<p>Apple 的使命：「藉推广公平的资料使用惯例，建立用户对互联网之信任和信心」<br>Google 的使命：「整合全球信息，使人人皆可访问和收益」<br>阿里巴巴的使命：「让天下没有难做的生意」<br>有赞的使命：「帮助每一位重视产品和服务的商家成功」<br>以及最近我们团队的前端技术委员的使命：「以极致的技术高效支撑业务」</p>
<p>使命描述一般都很简洁，并且容易记忆，像一句广告词，能深深的刻在脑海里。<br>在工作中遇到问题的时候，这个使命就会一下子从脑海里蹦出来指引你找到答案。</p>
<p>其实在某个市场闲逛都有可能让你意识到这个市场有某个问题需要解决，而帮市场解决这个问题，就是一个使命。</p>
<h5 id="u9636_u6BB5_u6027_u7684_u76EE_u6807"><a href="#u9636_u6BB5_u6027_u7684_u76EE_u6807" class="headerlink" title="阶段性的目标"></a>阶段性的目标</h5><p>为了一步步的达成「使命」，我们需要有目标。相对于使命，它粒度更小，且有时间限制。</p>
<p>所以，目标（Objective）应该：</p>
<ul>
<li>是阶段性的</li>
<li>是有优先级的</li>
<li>它需要能明确方向且鼓舞人心</li>
</ul>
<p>目标，是 OKR 中最重要，最需要想清楚，最首要确定的。<br>在这里，需要回答：你有什么？你要什么？你能放弃什么？</p>
<h5 id="u91CD_u8981_u4E0E_u7D27_u6025"><a href="#u91CD_u8981_u4E0E_u7D27_u6025" class="headerlink" title="重要与紧急"></a>重要与紧急</h5><p>「鱼与熊掌不可得兼」，所以我们要有所取舍，事情排个优先级。<br>「重要-紧急象限」是一个不错的指导工具，第一次看到它是在柯维《高效能人士的7个习惯》中的第三个习惯「要事第一」。</p>
<p><img src="https://img.yzcdn.cn/public_files/2019/07/06/e5ce3614f98f98d538944350bd505993.png" alt="重要-紧急"></p>
<p>但在实施的过程中中很有可能会遇到这样一个问题，紧急不重要的事情很紧急，总需要花时间和精力去处理它。然后重要不紧急的事情，会常常分配不到时间和精力。</p>
<p><strong>那么就让重要不紧急的事情也变得紧急起来。</strong></p>
<h5 id="u76EE_u6807_u9700_u8981_u81EA_u4E0A_u800C_u4E0B_u7684_u5173_u8054"><a href="#u76EE_u6807_u9700_u8981_u81EA_u4E0A_u800C_u4E0B_u7684_u5173_u8054" class="headerlink" title="目标需要自上而下的关联"></a>目标需要自上而下的关联</h5><p>如果基础的商业问题没有解决，不论实现多少产品功能，团队整体的绩效一定会大打折扣。</p>
<p>在一个组织中，如果没有充分的理解上一层的目标，就很容易跑偏，没有真正在刀刃上使力，造成效率上的浪费。</p>
<p>达到充分的理解目标，是有难度的，对人的眼界、目标理解能力有很高的要求。这不仅仅是执行者责任，更是管理者的责任。</p>
<h3 id="u5173_u952E_u7ED3_u679C_Key_Result"><a href="#u5173_u952E_u7ED3_u679C_Key_Result" class="headerlink" title="关键结果 Key Result"></a>关键结果 Key Result</h3><h5 id="u8861_u91CF_u76EE_u6807_u662F_u5426_u8FBE_u6210"><a href="#u8861_u91CF_u76EE_u6807_u662F_u5426_u8FBE_u6210" class="headerlink" title="衡量目标是否达成"></a>衡量目标是否达成</h5><p>目标定下来了，如果不去执行和落地，那么它永远就只是一个目标。如何去衡量目标是否达到了，就是「关键结果」的任务。</p>
<p>在互联网产品中，通常可以量化的条件有：用户增长、用户激活、收入增长、产品性能、产品质量。</p>
<p>作为技术团队，会更加集中注意力在产品性能和产品质量上面，那么如何去找到这些方向的衡量指标，就要从实际出发了。</p>
<p>比如我们团队会用「质量系数 = BUG数/估时」，来感受一个项目的质量情况。虽然它会有些漏洞，但如果建立在互相信任的基础上，可以提供一定的参考价值。</p>
<h5 id="u6709_u4E9B_u6311_u6218_u6027"><a href="#u6709_u4E9B_u6311_u6218_u6027" class="headerlink" title="有些挑战性"></a>有些挑战性</h5><blockquote>
<p>当达到成结果的时候，我们应该是欢呼雀跃般的兴奋，而不是理所应当的淡定。</p>
</blockquote>
<p>定下一个关键结果之后，问一下自己，有多少信心可以完成。如果信心爆棚，就把目标定高些。如果信心不足，就把目标调低些。因为 OKR 的意义不在于完成目标，更重要的是它能挖掘团队以及个人的潜力。</p>
<p>如果觉得有必要的话，我们可以建立一个「信心指数」，用来帮助确定结果有足够的挑战性而不会让人失去信心。这个指数的开始值最好是 50%，然后通过过程管理来动态变更和追踪。</p>
<p>比如去年我负责的一个「优化微信小程序加载性能」项目中的关键结果：</p>
<ul>
<li>首屏加载时间 3s 内</li>
</ul>
<p>未优化的加载时间是 6s+，回顾当时对目标的信心指数的话，大概是 20%。虽然最后因为部分不可控因素没有达到这个目标，只能维持在 3s-4s 之间。但是这个过程中能让人费尽脑汁的找到各种方法，大幅的提升了除首屏加载以外其他方面的加载体验，这也是额外的收获。</p>
<p>作为管理者，你要清楚的知道哪些人推一推会有更高的产出，哪些人实际执行情况会出现问题，要能看得到看得懂目前组织的目标和进度，并与成员进行同步。</p>
<h3 id="u8FC7_u7A0B_u7BA1_u7406"><a href="#u8FC7_u7A0B_u7BA1_u7406" class="headerlink" title="过程管理"></a>过程管理</h3><p>OKR 定下来了，在期限内，就要奔着目标努力奋进。尽管中途发现问题，也尽量不要在中途更改 OKR，让我们尽力跑完计划的阶段再回来总结。我们也可以把时间维度切小，比如把年度切分为半年度，把半年度切分为季度。</p>
<p>并且，目标定下来之后，要经常定期共同回顾，共同看见。而不是定下来了，就放在那里，否则过程中团队发生了问题，成员遇到了困难，很大可能会不被看到。</p>
<p>比较好的形式是每周都一起坐下来看看，每个人分享一下成果，或者说说遇到的困难，看能不能得到其他人的帮助。这个过程，能及时的看到问题，也能让成员对目标有更强的参与感。</p>
<p>那么，OKR应该以什么方式来呈现？《OKR工作法》一书中提供了一种参考：「四象限呈现形式」</p>
<p><img src="https://img.yzcdn.cn/public_files/2019/07/06/989bdd617bc44bab7dcfdd18120ac8a8.jpeg" alt="四象限呈现"></p>
<ul>
<li>第一象限：本周3-4件最重要的事情，并且进行优先级的排序</li>
<li>第二象限：把OKR内容罗列出来，关注和更新每一项KR的信心指数</li>
<li>第三象限：未来中长段时间中的计划，能让我们稍微看远一些。</li>
<li>第四象限：关注那些影响目标的关键因素会不会掉链子，例如团队状态，系统状态等。也可以用红蓝黄颜色表示出来。</li>
</ul>
<h1 id="u56DE_u8FC7_u5934_u770B_u770B_u90A3_u4E2A_u7CDF_u7CD5_u7684_u4F8B_u5B50"><a href="#u56DE_u8FC7_u5934_u770B_u770B_u90A3_u4E2A_u7CDF_u7CD5_u7684_u4F8B_u5B50" class="headerlink" title="回过头看看那个糟糕的例子"></a>回过头看看那个糟糕的例子</h1><p>糟糕的例子：</p>
<blockquote>
<p>O: 持续学习，提高自身战斗力</p>
<ul>
<li>KR1:CSS3 学习，阅读《CSS揭秘》 产出阅读笔记。</li>
<li>KR2:提高英文阅读能力，阅读《Security Your NodeJS Application》，产出一篇译文。</li>
<li>KR3: Vue2 框架的源码进行解读，产出一篇源码解析。</li>
</ul>
</blockquote>
<p>这个例子的背景是我 2017 年 4 月份加入到有赞，当时定的试用期内的其中一个目标。那时是我第一次认识和使用 OKR，只是单纯的把自身的技能提升计划给罗列了出来，看起来更像是一个 Todo List</p>
<p>现在回过头来看这一份 OKR，有不少问题：</p>
<ol>
<li>目标没有描述出来价值，提升了自身战斗力，然后呢？并没有自上而下的关联团队和组织的目标。所以从目标上，就已经走偏了。</li>
<li>假设目标正确，KR 也没有起到能衡量目标是否达成的作用。例如 KR1 完成了，对目标的推进，并没有说服力。</li>
<li>最后把 OKR 用成了 Todo List。</li>
</ol>
<p>那么我们从目标开始分析，当时作为一个新人加入到一个新的团队，对团队的技术栈和项目都很陌生，需要填补部分空白，快速上手。所以提升自身实力的底层诉求是：快速上手，胜任开发工作。</p>
<p>然后怎么衡量目的达到了呢？我们可以通过项目质量直接衡量，通过项目的熟悉程度来间接衡量。</p>
<p>修正后：</p>
<blockquote>
<p>O: 快速上手，以专业的姿态胜任开发工作。</p>
<ul>
<li>KR1: 质量系数平均在 0.3 以内。（质量系数 = BUG数/估时）</li>
<li>KR2: 代码评审评分平均 3.5 以上。（我们有 Code Review 机制，并且有评分环节）</li>
<li>KR3: 所参与项目评分在 4 以上。（项目也有评分环节）</li>
<li>KR4: 进行两次的项目分享。</li>
</ul>
</blockquote>
<p>那么如果达到这些关键结果，要通过学习框架，还是研究项目，还是熟悉业务，那就是根据实际迎刃而解的事情了。</p>
<h1 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>凡事预则立，不预则废 ——《礼记·中庸》</p>
</blockquote>
<p>最后要注意的是，OKR 只是一个工具，当你有一个目标，它会给你一种落实目标的方法论。而如果一开始目标没有想清楚，想明白，那就很容易在错的路上越走越远。</p>
<p>每个团队都会有不同的风格，和不同的实际情况。理解方法和工具的原理，明白这么做是为了解决什么问题，然后再调整定制真正适合此时此刻的团队，才是最好的方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;OKR 是由前 Intel CEO，&lt;a href=&quot;https://www.wikiwand.com/
    
    </summary>
    
      <category term="三省吾身" scheme="http://huang-jerryc.com/categories/%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>BeautyWe.js 一套专注于微信小程序的开发范式</title>
    <link href="http://huang-jerryc.com/2019/06/11/beautywe-intro/"/>
    <id>http://huang-jerryc.com/2019/06/11/beautywe-intro/</id>
    <published>2019-06-11T06:22:25.000Z</published>
    <updated>2019-07-17T13:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/beautywe/docs/master/docs/assets/images/logo-V4.png" alt></p>
<blockquote>
<p>官网：<a href="http://beautywejs.com" target="_blank" rel="external">beautywejs.com</a><br>Repo: <a href="https://github.com/beautywe/beautywe" target="_blank" rel="external">beautywe</a></p>
</blockquote>
<h1 id="u4E00_u4E2A_u7B80_u5355_u7684_u4ECB_u7ECD"><a href="#u4E00_u4E2A_u7B80_u5355_u7684_u4ECB_u7ECD" class="headerlink" title="一个简单的介绍"></a>一个简单的介绍</h1><p><strong>BeautyWe.js 是什么？</strong></p>
<p>它是一套专注于微信小程序的企业级开发范式，它的愿景是：</p>
<blockquote>
<p>让企业级的微信小程序项目中的代码，更加简单、漂亮。</p>
</blockquote>
<p><strong>为什么要这样命名呢？</strong></p>
<blockquote>
<p>Write <strong>beautiful</strong> code for <strong>we</strong>chat mini program by the <strong>beautiful</strong> <strong>we</strong>!</p>
</blockquote>
<p>「We」 既是我们的 <strong>We</strong>，也是微信的 <strong>We</strong>，Both beautiful！</p>
<p><strong>那么它有什么卖点呢？</strong></p>
<ol>
<li>专注于微信小程序环境，写原汁原味的微信小程序代码。</li>
<li>由于只专注于微信小程序，它的源码也很简单。</li>
<li>插件化的编程方式，让复杂逻辑更容易封装。</li>
<li>再加上一些配套设施：<ol>
<li>一些官方插件。</li>
<li>一套开箱即用，包含了工程化、项目规范以及微信小程序环境独特问题解决方案的框架。</li>
<li>一个CLI工具，帮你快速创建应用，页面，组件等。</li>
</ol>
</li>
</ol>
<p><strong>它由以下几部分组成：</strong></p>
<ul>
<li><p><strong>一个插件化的核心</strong> - <a href="https://github.com/beautywe/beautywe" target="_blank" rel="external">BeautyWe Core</a><br>  对 App、Page 进行抽象和包装，保持传统微信小程序开发姿势，同时开放部分原生能力，让其具有「可插件化」的能力。</p>
</li>
<li><p><strong>一些官方插件</strong> — <a href="https://www.npmjs.com/search?q=keywords%3Abeautywe-plugin" target="_blank" rel="external">BeautyWe Plugins</a><br>  得益于 Core 的「可插件化」特性，封装复杂逻辑，实现可插拔。官方对于常见的需求提供了一些插件：如增强存储、发布/订阅、状态机、Logger、缓存策略等。</p>
</li>
<li><p><strong>一套开箱即用的项目框架</strong> - <a href="https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/contents/framework/introduce" target="_blank" rel="external">BeautyWe Framework</a><br>  描述了一种项目的组织形式，开箱即用，集成了 <code>BeautyWe Core</code> ，并且提供了如：全局窗口、开发规范、多环境开发、全局配置、NPM 等解决方案。</p>
</li>
<li><p><strong>一个CLI工具</strong> - <a href="https://user-gold-cdn.xitu.io/2019/6/10/16b40250bcbe53fb#/remote/cli" target="_blank" rel="external">BeautyWe Cli</a><br>  提供快速创建应用、页面、插件，以及项目构建功能的命令行工具。并且还支持自定义的创建模板。</p>
</li>
</ul>
<h1 id="u4E00_u4E2A_u7B80_u5355_u7684_u4F8B_u5B50"><a href="#u4E00_u4E2A_u7B80_u5355_u7684_u4F8B_u5B50" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><p>下载</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181427" alt></p>
<p>用 BeautyWe 包装你的应用</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181445" alt></p>
<p>之后，你就能使用 BeautyWe Plugin 提供的能力了。</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181337" alt></p>
<h1 id="u5F00_u653E_u539F_u751FApp/Page_uFF0C_u652F_u6301_u63D2_u4EF6_u5316"><a href="#u5F00_u653E_u539F_u751FApp/Page_uFF0C_u652F_u6301_u63D2_u4EF6_u5316" class="headerlink" title="开放原生App/Page，支持插件化"></a>开放原生App/Page，支持插件化</h1><p><code>new BtApp({...})</code> 的执行结果是对原生的应用进行包装，其中包含了「插件化」的处理，然后返回一个新的实例，这个实例适配原生的 <code>App()</code> 方法。</p>
<p>下面来讲讲「插件化」到底做了什么事情。</p>
<p>首先，插件化开放了原生 App 的四种能力：</p>
<ol>
<li><p><strong>Data 域</strong><br> 把插件的 Data 域合并到原生 App 的 Data 域中，这一块很容易理解。</p>
</li>
<li><p><strong>原生钩子函数</strong><br> 使原生钩子函数（如 <code>onShow</code>, <code>onLoad</code>）可插件化。让原生App与多个插件可以同时监听同一个钩子函数。如何工作的，下面会细说。</p>
</li>
<li><p><strong>事件钩子函数</strong><br> 使事件钩子函数（与 view 层交互的钩子函数），尽管在实现上有一些差异，但是实现原理跟「原生钩子函数」一样的。</p>
</li>
<li><p><strong>自定义方法</strong><br> 让插件能够给使用者提供 API。为了保证插件提供的 API 足够的优雅，支持当调用插件 API 的时候（如 event 插件 <code>this.event.on(...)</code>)，API 方法内部仍然能通过 <code>this</code> 获取到原生实例。</p>
</li>
</ol>
<h4 id="u94A9_u5B50_u51FD_u6570_u7684_u63D2_u4EF6_u5316"><a href="#u94A9_u5B50_u51FD_u6570_u7684_u63D2_u4EF6_u5316" class="headerlink" title="钩子函数的插件化"></a>钩子函数的插件化</h4><p>原生钩子函数，事件钩子函数我们统一称为「钩子函数」。</p>
<p>对于每一个钩子函数，内部是维护一个以 Series Promise 方式执行的执行队列。</p>
<p>以 <code>onShow</code> 为例，将会以这样的形式执行：</p>
<blockquote>
<p>native.onShow → pluginA.onShow → pluginB.onShow → …</p>
</blockquote>
<p><strong>下面深入一下插件化的原理</strong>：</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181648" alt="beautywe pluggable"></p>
<p>工作原理是这样的：    </p>
<ol>
<li>经过 <code>new BtApp(...)</code> 包装，所有的钩子函数，都会有一个独立的执行队列，    </li>
<li>首先会把原生的各个钩子函数 <code>push</code> 到对应的队列中。然后每 <code>use</code> 插件的时候，都会分解插件的钩子函数，往对应的队列 <code>push</code>。    </li>
<li>当 <code>Native App</code>（原生）触发某个钩子的时候，<code>BtApp</code> 会以 Promise Series 的形式按循序执行对应队列里面的函数。    </li>
<li>特殊的，<code>onLaunch</code> 和 <code>onLoad</code> 的执行队列中，会在队列顶部插入一个初始化的任务（<code>initialize</code>），它会以同步的方式按循序执行 <code>Initialize Queue</code> 里面的函数。这正是插件生命周期函数中的 <code>plugin.initialize</code>。</li>
</ol>
<p>这种设计能提供以下功能：</p>
<ol>
<li><p>可插件化。<br> 只需要往对应钩子函数的事件队列中插入任务。</p>
</li>
<li><p>支持异步。<br> 由于是以 Promise Series 方式运行的，其中一个任务返回一个 Promise，下一个任务会等待这个任务完成再开始。如果发生错误，会流转到原生的 <code>onError()</code> 中。</p>
</li>
<li><p>解决了微信小程序 <code>app.js</code> 中 <code>getApp() === undefinded</code>问题。<br> 造成这个问题，本质是因为 <code>App()</code> 的时候，原生实例未创建。但是由于 Promise 在 event loop 中是一个微任务，被注册在下一次循环。所以 Promise 执行的时候 <code>App()</code> 早已经完成了。</p>
</li>
</ol>
<h1 id="u4E00_u4E9B_u5B98_u65B9_u63D2_u4EF6"><a href="#u4E00_u4E9B_u5B98_u65B9_u63D2_u4EF6" class="headerlink" title="一些官方插件"></a>一些官方插件</h1><p>BeautyWe 官方提供了一系列的插件：</p>
<ol>
<li>增强存储: Storage</li>
<li>数据列表：List Page</li>
<li>缓存策略：Cache</li>
<li>日志：Logger</li>
<li>事件发布/订阅：Event</li>
<li>状态机：Status</li>
</ol>
<p>它们的使用很简单，哪里需要插哪里。<br>由于篇幅的原因，下面挑几个比较有趣的来讲讲，更多的可以看看官方文档：<a href="http://beautywejs.com" target="_blank" rel="external">BeautyWe</a></p>
<h2 id="u589E_u5F3A_u5B58_u50A8_Storage"><a href="#u589E_u5F3A_u5B58_u50A8_Storage" class="headerlink" title="增强存储 Storage"></a>增强存储 Storage</h2><p>该功能由 <a href="https://github.com/beautywe/plugin-storage" target="_blank" rel="external">@beautywe/plugin-storage</a> 提供。</p>
<p>由于微信小程序原生的数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。</p>
<p>所以该插件在 <code>wx.getStorage/setStorage</code> 的基础上，提供了两种扩展能力：</p>
<ol>
<li>过期控制</li>
<li>版本隔离</li>
</ol>
<p><strong>一些简单的例子</strong></p>
<p>安装<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BtApp &#125; <span class="keyword">from</span> <span class="string">'@beautywe/core'</span>;</span><br><span class="line"><span class="keyword">import</span> storage <span class="keyword">from</span> <span class="string">'@beautywe/plugin-storage'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> BtApp();</span><br><span class="line">app.use(storage());</span><br></pre></td></tr></table></figure></p>
<p>过期控制<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7天后过期</span></span><br><span class="line">app.storage.set(<span class="string">'name'</span>, <span class="string">'jc'</span>, &#123; expire: <span class="number">7</span> &#125;)；</span><br></pre></td></tr></table></figure></p>
<p>版本隔离<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.use(&#123; appVersion: <span class="string">'0.0.1'</span> &#125;);</span><br><span class="line">app.set(<span class="string">'name'</span>, <span class="string">'jc'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 jc</span></span><br><span class="line">app.get(<span class="string">'name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当版本更新后</span></span><br><span class="line">app.use(&#123; appVersion: <span class="string">'0.0.2'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 undefined;</span></span><br><span class="line">app.get(<span class="string">'name'</span>);</span><br></pre></td></tr></table></figure></p>
<p>更多的查看 <a href="https://github.com/beautywe/plugin-storage" target="_blank" rel="external">@beautywe/plugin-storage 官方文档</a></p>
<h2 id="u6570_u636E_u5217_u8868_List_Page"><a href="#u6570_u636E_u5217_u8868_List_Page" class="headerlink" title="数据列表 List Page"></a>数据列表 List Page</h2><p>对于十分常见的数据列表分页的业务场景，<code>@beautywe/plugin-listpage</code> 提供了一套打包方案：</p>
<ol>
<li>满足常用「数据列表分页」的业务场景</li>
<li>支持分页</li>
<li>支持多个数据列表</li>
<li>自动捕捉下拉重载：<code>onPullDownRefresh</code></li>
<li>自动捕捉上拉加载：<code>onReachBottom</code></li>
<li>自带请求锁，防止帕金森氏手抖用户</li>
<li>简单优雅的 API</li>
</ol>
<p>一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BeautyWe <span class="keyword">from</span> <span class="string">'@beautywe/core'</span>;</span><br><span class="line"><span class="keyword">import</span> listpage <span class="keyword">from</span> <span class="string">'@beautywe/plugin-listpage'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> page = <span class="keyword">new</span> BeautyWe.BtPage();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 listpage 插件</span></span><br><span class="line">page.use(listpage(&#123;</span><br><span class="line">    lists: [&#123;</span><br><span class="line">        name: <span class="string">'goods'</span>,  <span class="comment">// 数据名</span></span><br><span class="line">        pageSize: <span class="number">20</span>,   <span class="comment">// 每页多少条数据，默认 10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一页的数据源，没次加载页面时，会调用函数，然后取返回的数据。</span></span><br><span class="line">        fetchPageData(&#123; pageNo, pageSize &#125;) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 获取数据</span></span><br><span class="line">            <span class="keyword">return</span> API.getGoodsList(&#123; pageNo, pageSize &#125;)</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 有时候，需要对服务器的数据进行处理，dataCooker 是你定义的函数。</span></span><br><span class="line">                .then((rawData) =&gt; dataCooker(rawData));</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;],</span><br><span class="line">    enabledPullDownRefresh: <span class="literal">true</span>,    <span class="comment">// 开启下拉重载， 默认 false</span></span><br><span class="line">    enabledReachBottom: <span class="literal">true</span>,    <span class="comment">// 开启上拉加载， 默认 false</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// goods 数据会被加载到，goods 为上面定义的 name</span></span><br><span class="line"><span class="comment">// this.data.listPage.goods = &#123;</span></span><br><span class="line"><span class="comment">//     data: [...],     // 视图层，通过该字段来获取具体的数据</span></span><br><span class="line"><span class="comment">//     hasMore: true,   // 视图层，通过该字段来识别是否有下一页</span></span><br><span class="line"><span class="comment">//     currentPage: 1,  // 视图层，通过该字段来识别当前第几页</span></span><br><span class="line"><span class="comment">//     totalPage: undefined,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>只需要告诉 <code>listpage</code> 如何获取数据，它会自动处理「下拉重载」、「上拉翻页」的操作，然后把数据更新到 <code>this.data.listPage.goods</code> 下。</p>
<p>View 层只需要描述数据怎么展示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">view</span> <span class="attribute">class</span>=<span class="value">"good"</span> <span class="attribute">wx:for</span>=<span class="value">"listPage.goods.data"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">view</span> <span class="attribute">class</span>=<span class="value">"no-more"</span> <span class="attribute">wx:if</span>=<span class="value">"listPage.goods.hasMore === false"</span>&gt;</span></span><br><span class="line">    没有更多了</span><br><span class="line"><span class="tag">&lt;/<span class="title">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>listpage</code> 还支持多数据列表等其他更多配置，详情看：<a href="https://github.com/beautywe/plugin-listpage" target="_blank" rel="external">@beautywe/plugin-listpage</a></p>
<h2 id="u7F13_u5B58_u7B56_u7565_Cache"><a href="#u7F13_u5B58_u7B56_u7565_Cache" class="headerlink" title="缓存策略 Cache"></a>缓存策略 Cache</h2><p><code>@beautywe/plugin-cache</code> 提供了一个微信小程序端缓存策略，其底层由 <a href="https://github.com/JerryC8080/super-cache" target="_blank" rel="external">super-cache</a> 提供支持。</p>
<h4 id="u7279_u6027"><a href="#u7279_u6027" class="headerlink" title="特性"></a>特性</h4><ol>
<li>提供一套「服务端接口耗时慢，但加载性能要求高」场景的解决方案</li>
<li>满足最基本的缓存需求，读取（get）和保存（set）</li>
<li>支持针对缓存进行逻辑代理</li>
<li>灵活可配置的数据存储方式</li>
</ol>
<h4 id="How_it_work"><a href="#How_it_work" class="headerlink" title="How it work"></a>How it work</h4><p>一般的请求数据的形式是，页面加载的时候，从服务端获取数据，然后等待数据返回之后，进行页面渲染：</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181755" alt></p>
<p>但这种模式，会受到服务端接口耗时，网络环境等因素影响到加载性能。   </p>
<p>对于加载性能要求高的页面（如首页），一般的 Web 开发我们有很多解决方案（如服务端渲染，服务端缓存，SSR 等）。<br>但是也有一些环境不能使用这种技术（如微信小程序）。</p>
<p>Super Cache 提供了一个中间数据缓存的解决方案：</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181847" alt></p>
<p>思路：    </p>
<ol>
<li>当你需要获取一个数据的时候，如果有缓存，先把旧的数据给你。</li>
<li>然后再从服务端获取新的数据，刷新缓存。</li>
<li>如果一开始没有缓存，则请求服务端数据，再把数据返回。</li>
<li>下一次请求缓存，从第一步开始。</li>
</ol>
<p>这种解决方案，舍弃了一点数据的实时性（非第一次请求，只能获取上一次最新数据），大大提高了前端的加载性能。<br>适合的场景：    </p>
<ol>
<li>数据实时性要求不高。</li>
<li>服务端接口耗时长。</li>
</ol>
<h4 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BtApp &#125; <span class="keyword">from</span> <span class="string">'@beautywe/core'</span>;</span><br><span class="line"><span class="keyword">import</span> cache <span class="keyword">from</span> <span class="string">'@beautywe/plugin-cache'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> BtApp();</span><br><span class="line">app.use(cache(&#123;</span><br><span class="line">    adapters: [&#123;</span><br><span class="line">        key: <span class="string">'name'</span>,</span><br><span class="line">        data() &#123;</span><br><span class="line">            <span class="keyword">return</span> API.fetch(<span class="string">'xxx/name'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>假设 <code>API.fetch(&#39;xxx/name&#39;)</code> 是请求服务器接口，返回数据：<code>data_from_server</code></p>
<p>那么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.cache.get(<span class="string">'name'</span>).then((value) =&gt; &#123;</span><br><span class="line">    <span class="comment">// value: 'data_from_server'  </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>更多的配置，详情看：<a href="https://github.com/beautywe/plugin-cache" target="_blank" rel="external">@beautywe/plugin-cache</a></p>
<h2 id="u65E5_u5FD7_Logger"><a href="#u65E5_u5FD7_Logger" class="headerlink" title="日志 Logger"></a>日志 Logger</h2><p>由 <code>@beautywe/logger-plugin</code> 提供的一个轻量的日志处理方案，它支持：</p>
<ol>
<li>可控的 log level</li>
<li>自定义前缀</li>
<li>日志统一处理</li>
</ol>
<h4 id="u4F7F_u7528-1"><a href="#u4F7F_u7528-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BtApp &#125; <span class="keyword">from</span> <span class="string">'@beautywe/core'</span>;</span><br><span class="line"><span class="keyword">import</span> logger <span class="keyword">from</span> <span class="string">'@beautywe/plugin-logger'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> page = <span class="keyword">new</span> BtApp();</span><br><span class="line"></span><br><span class="line">page.use(logger(&#123;</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p><strong>API</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">page.logger.info(<span class="string">'this is info'</span>);</span><br><span class="line">page.logger.warn(<span class="string">'this is warn'</span>);</span><br><span class="line">page.logger.error(<span class="string">'this is error'</span>);</span><br><span class="line">page.logger.debug(<span class="string">'this is debug'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// [info] this is info</span></span><br><span class="line"><span class="comment">// [warn] this is warn</span></span><br><span class="line"><span class="comment">// [error] this is error</span></span><br><span class="line"><span class="comment">// [debug] this is debug</span></span><br></pre></td></tr></table></figure>
<p><strong>Level control</strong></p>
<p>可通过配置来控制哪些 level 该打印：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page.use(logger(&#123;</span><br><span class="line">    level: <span class="string">'warn'</span>,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>那么 <code>warn</code> 以上的 log （<code>info</code>, <code>debug</code>）就不会被打印，这种满足于开发和生成环境对 log 的不同需求。</p>
<p>level 等级如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Logger.LEVEL = &#123;</span><br><span class="line">    error: <span class="number">1</span>,</span><br><span class="line">    warn: <span class="number">2</span>,</span><br><span class="line">    info: <span class="number">3</span>,</span><br><span class="line">    debug: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更多的配置，详情看：<a href="https://github.com/beautywe/plugin-logger" target="_blank" rel="external">@beautywe/plugin-logger</a></p>
<h1 id="BeautyWe_Framework"><a href="#BeautyWe_Framework" class="headerlink" title="BeautyWe Framework"></a>BeautyWe Framework</h1><p><code>@beautywe/core</code> 和 <code>@beautywe/plugin-...</code> 给小程序提供了：</p>
<ol>
<li>开放原生，支持插件化 —— by core</li>
<li>各种插件 —— by plugins</li>
</ol>
<p>但是，还有很多的开发中实际还会遇到的痛点，是上面两个解决不到的。<br>如项目的组织、规范、工程化、配置、多环境等等</p>
<p>这些就是，「BeautyWe Framework」要解决的范畴。</p>
<p>它作为一套开箱即用的项目框架，提供了这些功能：</p>
<ul>
<li>集成 BeautyWe Core</li>
<li>NPM 支持</li>
<li>全局窗口</li>
<li>全局 Page，Component</li>
<li>全局配置文件</li>
<li>多环境开发</li>
<li>Example Pages</li>
<li>正常项目需要的标配：ES2015+,sass,uglify,watch 等</li>
<li>以及我们认为良好的项目规范（eslint，commit log，目录结构等）</li>
</ul>
<p>也是由于篇幅原因，挑几个有趣的来讲讲，更多的可以看看官方文档：<a href="http://beautywejs.com" target="_blank" rel="external">BeautyWe</a></p>
<h2 id="u5FEB_u901F_u521B_u5EFA"><a href="#u5FEB_u901F_u521B_u5EFA" class="headerlink" title="快速创建"></a>快速创建</h2><p>首先安装 <code>@beautywe/cli</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i @beautywe/cli -g</span><br></pre></td></tr></table></figure>
<h4 id="u521B_u5EFA_u5E94_u7528"><a href="#u521B_u5EFA_u5E94_u7528" class="headerlink" title="创建应用"></a>创建应用</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ beautywe new app&#10;&#10;&#62; appName: my-app&#10;&#62; version: 0.0.1&#10;&#62; appid: 123456&#10;&#62; &#36825;&#26679;&#21487;&#20197;&#20040;:&#10;&#62; &#123;&#10;&#62;    &#34;appName&#34;: &#34;my-app&#34;,&#10;&#62;    &#34;version&#34;: &#34;0.0.1&#34;,&#10;&#62;    &#34;appid&#34;: &#34;123456&#34;&#10;&#62; &#125;</span><br></pre></td></tr></table></figure>
<p>回答几个问题之后，项目就生成了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my-app&#10;&#9500;&#9472;&#9472; gulpfile.js&#10;&#9500;&#9472;&#9472; package.json&#10;&#9492;&#9472;&#9472; src&#10;    &#9500;&#9472;&#9472; app.js&#10;    &#9500;&#9472;&#9472; app.json&#10;    &#9500;&#9472;&#9472; app.scss&#10;    &#9500;&#9472;&#9472; assets&#10;    &#9500;&#9472;&#9472; components&#10;    &#9500;&#9472;&#9472; config&#10;    &#9500;&#9472;&#9472; examples&#10;    &#9500;&#9472;&#9472; libs&#10;    &#9500;&#9472;&#9472; npm&#10;    &#9500;&#9472;&#9472; pages&#10;    &#9492;&#9472;&#9472; project.config.json</span><br></pre></td></tr></table></figure>
<h4 id="u521B_u5EFA_u9875_u9762_u3001_u7EC4_u4EF6_u3001_u63D2_u4EF6"><a href="#u521B_u5EFA_u9875_u9762_u3001_u7EC4_u4EF6_u3001_u63D2_u4EF6" class="headerlink" title="创建页面、组件、插件"></a>创建页面、组件、插件</h4><p><strong>页面</strong></p>
<ol>
<li>主包页面：<code>beautywe new page &lt;path|name&gt;</code></li>
<li>分包页面：<code>beautywe new page --subpkg &lt;subPackageName&gt; &lt;path|name&gt;</code></li>
</ol>
<p><strong>组件</strong></p>
<ol>
<li><code>beautywe new component &lt;name&gt;</code></li>
</ol>
<p><strong>插件</strong></p>
<ol>
<li><code>beautywe new plugin &lt;name&gt;</code></li>
</ol>
<h4 id="u81EA_u5B9A_u4E49_u6A21_u677F"><a href="#u81EA_u5B9A_u4E49_u6A21_u677F" class="headerlink" title="自定义模板"></a>自定义模板</h4><p>在 <code>./.templates</code> 目录中，存放着快速创建命令的创建模板：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tree .templates&#10;&#10;.templates&#10;&#9500;&#9472;&#9472; component&#10;&#9474;   &#9500;&#9472;&#9472; index.js&#10;&#9474;   &#9500;&#9472;&#9472; index.json&#10;&#9474;   &#9500;&#9472;&#9472; index.scss&#10;&#9474;   &#9492;&#9472;&#9472; index.wxml&#10;&#9500;&#9472;&#9472; page&#10;&#9474;   &#9500;&#9472;&#9472; index.js&#10;&#9474;   &#9500;&#9472;&#9472; index.json&#10;&#9474;   &#9500;&#9472;&#9472; index.scss&#10;&#9474;   &#9492;&#9472;&#9472; index.wxml&#10;&#9492;&#9472;&#9472; plugin&#10;    &#9492;&#9472;&#9472; index.js</span><br></pre></td></tr></table></figure>
<p>可以修改里面的模板，来满足项目级别的自定义模板创建。</p>
<h2 id="u5168_u5C40_u7A97_u53E3"><a href="#u5168_u5C40_u7A97_u53E3" class="headerlink" title="全局窗口"></a>全局窗口</h2><p>我们都知道微信小程序是「单窗口」的交互平台，一个页面对应一个窗口。<br>而在业务开发中，往往会有诸如这种述求：</p>
<ol>
<li>自定义的 toast 样式</li>
<li>页面底部 copyright</li>
<li>全局的 loading 样式</li>
<li>全局的悬浮控件<br>……</li>
</ol>
<p>稍微不优雅的实现可以是分别做成独立的组件，然后每一个页面都引入进来。<br>这种做法，我们会有很多的重复代码，并且每次新建页面，都要引入一遍，后期维护也会很繁琐。</p>
<p>而「全局窗口」的概念是：<strong>希望所有页面之上有一块地方，全局性的逻辑和交互，可以往里面搁。</strong></p>
<h4 id="global-view__u7EC4_u4EF6"><a href="#global-view__u7EC4_u4EF6" class="headerlink" title="global-view 组件"></a>global-view 组件</h4><p>这是一个自定义组件，源码在 <code>/src/components/global-view</code></p>
<p>每个页面的 wxml 只需要在顶层包一层：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">global-view</span> <span class="attribute">id</span>=<span class="value">"global-view"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">global-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要全局实现的交互、样式、组件，只需要维护这个组件就足够了。</p>
<h2 id="u5168_u5C40_u914D_u7F6E_u6587_u4EF6"><a href="#u5168_u5C40_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="全局配置文件"></a>全局配置文件</h2><p>在 <code>src/config/</code> 目录中，可以存放各种全局的配置文件，并且支持以 Node.js 的方式运行。（得益于 <a href="/contents/framework/concept/nodejs-power.md">Node.js Power 特性</a>）。</p>
<p>如 <code>src/config/logger.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> env = process.env.RUN_ENV || <span class="string">'dev'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">    prefix: <span class="string">'BeautyWe'</span>,</span><br><span class="line">    level: <span class="string">'debug'</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="comment">// 开发环境的配置</span></span><br><span class="line">    dev: &#123;</span><br><span class="line">        level: <span class="string">'debug'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 测试环境的配置</span></span><br><span class="line">    test: &#123;</span><br><span class="line">        level: <span class="string">'info'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 线上环境的配置</span></span><br><span class="line">    prod: &#123;</span><br><span class="line">        level: <span class="string">'warn'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;[env] || &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.logger = logger;</span><br></pre></td></tr></table></figure>
<p>然后我们可以这样读取到 config 内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; logger &#125; <span class="keyword">from</span> <span class="string">'/config/index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger.level 会根据环境不同而不同。</span></span><br></pre></td></tr></table></figure>
<p>Beautywe Framework 默认会把 config 集成到 <code>getApp()</code> 的示例中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getApp().config;</span><br></pre></td></tr></table></figure>
<h2 id="u591A_u73AF_u5883_u5F00_u53D1"><a href="#u591A_u73AF_u5883_u5F00_u53D1" class="headerlink" title="多环境开发"></a>多环境开发</h2><p>BeautyWe Framework 支持多环境开发，其中预设了三套策略：</p>
<ul>
<li>dev</li>
<li>test</li>
<li>prod</li>
</ul>
<p>我们可以通过命令来运行这三个构建策略：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beautywe run dev&#10;beautywe run test&#10;beautywe run prod</span><br></pre></td></tr></table></figure>
<h2 id="u4E09_u5957_u73AF_u5883_u7684_u5DEE_u5F02"><a href="#u4E09_u5957_u73AF_u5883_u7684_u5DEE_u5F02" class="headerlink" title="三套环境的差异"></a>三套环境的差异</h2><p>Beautywe Framework 源码默认在两方面使用了多环境：</p>
<ul>
<li>构建任务（<code>gulpfile.js/env/...</code>）</li>
<li>全局配置（<code>src/config/...</code>）</li>
</ul>
<h3 id="u6784_u5EFA_u4EFB_u52A1_u7684_u5DEE_u5F02"><a href="#u6784_u5EFA_u4EFB_u52A1_u7684_u5DEE_u5F02" class="headerlink" title="构建任务的差异"></a>构建任务的差异</h3><table>
<thead>
<tr>
<th>构建任务</th>
<th>说明</th>
<th style="text-align:center">dev</th>
<th style="text-align:center">test</th>
<th style="text-align:center">prod</th>
</tr>
</thead>
<tbody>
<tr>
<td>clean</td>
<td>清除dist文件</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>copy</td>
<td>复制资源文件</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>scripts</td>
<td>编译JS文件</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>sass</td>
<td>编译scss文件</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>npm</td>
<td>编译npm文件</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>nodejs-power</td>
<td>编译Node.js文件</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>watch</td>
<td>监听文件修改</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>scripts-min</td>
<td>压缩JS文件</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>sass-min</td>
<td>压缩scss文件</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>npm-min</td>
<td>压缩npm文件</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>image-min</td>
<td>压缩图片文件</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>clean-example</td>
<td>清除示例页面</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<h3 id="Node-js_Power"><a href="#Node-js_Power" class="headerlink" title="Node.js Power"></a>Node.js Power</h3><p>Beautywe Framework 的代码有两种运行环境：</p>
<ol>
<li>Node.js 运行环境，如构建任务等。</li>
<li>微信小程序运行环境，如打包到 <code>dist</code> 文件夹的代码。</li>
</ol>
<h4 id="u8FD0_u884C_u8FC7_u7A0B"><a href="#u8FD0_u884C_u8FC7_u7A0B" class="headerlink" title="运行过程"></a>运行过程</h4><blockquote>
<p>Node.js Power 本质是一种静态编译的实现。<br>把某个文件在 Node.js 环境运行的结果，输出到微信小程序运行环境中，以此来满足特定的需求。</p>
</blockquote>
<p>Node.js Power 会把项目中 <code>src</code> 目录下类似 <code>xxx.nodepower.js</code> 命名的文件，以 Node.js 来运行，<br>然后把运行的结果，以「字面量对象」的形式写到 <code>dist</code> 目录下对应的同名文件 <code>xxx.nodepower.js</code> 文件去。</p>
<p>以 <code>src/config/index.nodepower.js</code> 为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> files = fs.readdirSync(path.join(__dirname));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">files</span><br><span class="line">    .filter(name =&gt; name !== <span class="string">'index.js'</span>)</span><br><span class="line">    .forEach((name) =&gt; &#123;</span><br><span class="line">        <span class="built_in">Object</span>.assign(result, <span class="built_in">require</span>(path.join(__dirname, <span class="string">`./<span class="subst">$&#123;name&#125;</span>`</span>)));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = result;</span><br></pre></td></tr></table></figure>
<p>该文件，经过 Node.js Power 构建之后:</p>
<p><code>dist/config/index.nodepower.js</code>: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"appInfo"</span>: &#123;</span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">        <span class="string">"env"</span>: <span class="string">"test"</span>,</span><br><span class="line">        <span class="string">"appid"</span>: <span class="string">"wx85fc0d03fb0b224d"</span>,</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"beautywe-framework-test-app"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"logger"</span>: &#123;</span><br><span class="line">        <span class="string">"prefix"</span>: <span class="string">"BeautyWe"</span>,</span><br><span class="line">        <span class="string">"level"</span>: <span class="string">"info"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就满足了，随意往 <code>src/config/</code> 目录中扩展配置文件，都能被自动打包。</p>
<p>Node.js Power 已经被集成到多环境开发的 dev, test, prod 中去。</p>
<p>当然，你可以手动运行这个构建任务：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp nodejs-power</span><br></pre></td></tr></table></figure>
<h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>BeautyWe Framework 实现支持 npm 的原理很简单，总结一句话：</p>
<blockquote>
<p>使用 webpack 打包 <code>src/npm/index.js</code> ，以 commonjs 格式输出到 <code>dist/npm/index.js</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181936" alt="npm-works"></p>
<p>这样做的好处：</p>
<ol>
<li>实现简单。</li>
<li>让 npm 包能集中管理，每次引入依赖，都好好的想一下，避免泛滥（尤其在多人开发中）。</li>
<li>使用 <code>ll dist/npm/index.js</code> 命令能快速看到项目中的 npm 包使占了多少容量。</li>
</ol>
<h4 id="u65B0_u589E_npm__u4F9D_u8D56"><a href="#u65B0_u589E_npm__u4F9D_u8D56" class="headerlink" title="新增 npm 依赖"></a>新增 npm 依赖</h4><p>在 <code>src/npm/index.js</code> 文件中，进行 export：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &#123; default as beautywe &#125; from &#39;@beautywe/core&#39;;</span><br></pre></td></tr></table></figure>
<p>然后在其他文件 import：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; beautywe &#125; <span class="keyword">from</span> <span class="string">'./npm/index'</span>;</span><br></pre></td></tr></table></figure>
<h1 id="u66F4_u591A"><a href="#u66F4_u591A" class="headerlink" title="更多"></a>更多</h1><p>总的来说，BeautyWe 是一套微信小程序的开发范式。</p>
<p><code>core</code> 和 <code>plugins</code> 扩展原生，提供复杂逻辑的封装和插拔式使用。</p>
<p>而 <code>framework</code> 则负责提供一整套针对于微信小程序的企业级项目解决方案，开箱即用。</p>
<p>其中还有更多的内容，欢迎浏览官网：<a href="http://beautywejs.com" target="_blank" rel="external">beautywejs.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/beautywe/docs/master/docs/assets/images/logo-V4.png&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网：&lt;a href=&quot;htt
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="小程序" scheme="http://huang-jerryc.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>记一次「关于沟通」的培训</title>
    <link href="http://huang-jerryc.com/2019/04/13/about-communicate/"/>
    <id>http://huang-jerryc.com/2019/04/13/about-communicate/</id>
    <published>2019-04-13T09:39:00.000Z</published>
    <updated>2019-04-13T09:45:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>周末参与了公司给TL们安排的一个主题为《高效沟通》的课程，为期两天。<br>以往自己对「沟通」自我感觉良好，完全凭借感觉来，只要跟对方能表达清楚自己的想法，足矣。<br>两天下来，重新开始认识，「沟通」，其实是一门很深的学问。<br>这篇像是笔记，也像是我对「沟通」这门学问的重新认识。</p>
<h1 id="u8428_u63D0_u4E9A_u6A21_u578B"><a href="#u8428_u63D0_u4E9A_u6A21_u578B" class="headerlink" title="萨提亚模型"></a>萨提亚模型</h1><blockquote>
<p>沟通中需要认识到谈话者的状态</p>
</blockquote>
<p><img src="/image/blog/about-communicate/DraggedImage.png" alt="萨提亚沟通模型"></p>
<p>「萨提亚模型」是由美国家庭治疗专家 Virginia Satir 女士所创建的理论体系。这种体系起初是被运用在家庭心理治疗方面。但是在诸多的家庭治疗理论中，萨提亚模型一直是难以归类的，有的教科书将之列为「沟通学派」，有的纳入「人本学派」。究其原因，就是萨提亚模型不强调病态的。</p>
<p>一言蔽之就是：萨提亚模型，不仅仅适用于心理治疗，在人与人沟通中，也能提升我们的认知。</p>
<p>这个模型有两个重要的理论：</p>
<ol>
<li><strong>冰山理论</strong></li>
<li><strong>应对姿态</strong></li>
</ol>
<h2 id="u51B0_u5C71_u7406_u8BBA"><a href="#u51B0_u5C71_u7406_u8BBA" class="headerlink" title="冰山理论"></a>冰山理论</h2><p><img src="/image/blog/about-communicate/DraggedImage-1.png" alt="冰山理论"></p>
<p>一个人的「自我」就像一座冰山一样，别人所看到的只是冰山一角。<br>外在的「行为」和「应对方式」，我们是能很快的看得到的。<br>但是内在的「感受」、「观点」、「期待」、「渴望」是没那么容易知道的。</p>
<p>有一个例子特别好：    </p>
<blockquote>
<p>一对年轻夫妻，丈夫的职业是培训师，很能赚钱，但是经常需要出差。她的妻子就经常抱怨他不常回来陪伴她，觉得丈夫不爱他。但是丈夫很纳闷，常常陪伴妻子的话，自己就不能好好的工作了。<br>后来丈夫跟妻子好好谈过之后，才发现，妻子抱怨的原因是因为「安全感」不足。因为丈夫很能赚钱，长期不在身边的话，怕会在外面找小三。<br>那么事情就好办了，丈夫索性把所有的收入都给老婆管了。</p>
</blockquote>
<p>从这个例子中，其实我们来套一下冰山理论：</p>
<ul>
<li>行为：丈夫常常出差</li>
<li>应对方式：埋怨、吵架</li>
<li>观点：有钱的男人长期在外面，容易找小三</li>
<li>期待：多点回家，陪陪老婆</li>
<li>渴望：安全感</li>
</ul>
<p>其实妻子内心深处渴望的是一个「安全感」，从最深处的渴望下手，只要能满足对方的深层次的渴望，问题就引刃而解了。</p>
<h2 id="u6C9F_u901A_u59FF_u6001"><a href="#u6C9F_u901A_u59FF_u6001" class="headerlink" title="沟通姿态"></a>沟通姿态</h2><p>根据萨提亚模型，人有五种的沟通姿态：</p>
<ul>
<li>指责型</li>
<li>讨好型</li>
<li>超理智型</li>
<li>打岔型</li>
<li>表里一致型</li>
</ul>
<p>而这五种的沟通姿态表现在对三个沟通要素的关注度不同：</p>
<ul>
<li>自我</li>
<li>他人</li>
<li>情景</li>
</ul>
<h3 id="u6307_u8D23_u578B"><a href="#u6307_u8D23_u578B" class="headerlink" title="指责型"></a>指责型</h3><blockquote>
<p>关注「自我」、「情景」，忽略「他人」</p>
</blockquote>
<p>指责型的人常常忽略他人，习惯于攻击和批判，将责任推给别人。“都是你的错”，“你到底怎么搞的”是他们的口头语。</p>
<h3 id="u8BA8_u597D_u578B"><a href="#u8BA8_u597D_u578B" class="headerlink" title="讨好型"></a>讨好型</h3><blockquote>
<p>关注「他人」、「情景」，忽略「自我」</p>
</blockquote>
<p>讨好型的人忽略自己，内在价值感比较低。言语中经常流露出“这都是我的错”，“我想要让你高兴”之类的话。行为上则过度和善，习惯于道歉和乞怜。</p>
<h3 id="u8D85_u7406_u667A_u578B"><a href="#u8D85_u7406_u667A_u578B" class="headerlink" title="超理智型"></a>超理智型</h3><blockquote>
<p>关注「情景」、忽略「他人」、「自我」</p>
</blockquote>
<p>超理智型的人极端客观，只关心事情，忽略与个人或情绪。常常给人的感觉是冷漠、冷淡。</p>
<h3 id="u6253_u5C94_u578B"><a href="#u6253_u5C94_u578B" class="headerlink" title="打岔型"></a>打岔型</h3><blockquote>
<p>啥也不关注</p>
</blockquote>
<p>打岔型的人则永远不抓重点，不直接回答问题或根本文不对题。总是可以打破各种绝望的氛围，把注意力从任何有压力的话题上转移开</p>
<p>当然，没有人永远是单纯的一种沟通姿态的。而我自己就是那种「有时讨好有时指责有时超理智，而有时候会打岔转移话题」。</p>
<h1 id="u6C9F_u901A_u7684_u6838_u5FC3_u6280_u80FD"><a href="#u6C9F_u901A_u7684_u6838_u5FC3_u6280_u80FD" class="headerlink" title="沟通的核心技能"></a>沟通的核心技能</h1><p>在沟通中，有四种重要的技能：</p>
<ul>
<li>「积极聆听」</li>
<li>「有效提问」</li>
<li>「清晰表达」</li>
<li>「反馈」</li>
</ul>
<h2 id="u79EF_u6781_u8046_u542C"><a href="#u79EF_u6781_u8046_u542C" class="headerlink" title="积极聆听"></a>积极聆听</h2><p>在别人说话的时候，积极的聆听，这个过程从你的言行和脸部表情，都能给到对方正向的反馈。</p>
<h2 id="u6709_u6548_u63D0_u95EE"><a href="#u6709_u6548_u63D0_u95EE" class="headerlink" title="有效提问"></a>有效提问</h2><p>沟通过程中，你往往能通过提问来控制话题的方向、了解对方的想法、增强对方的自信、甚至好的问题能引起对方深层次的思考。<br>提问可以有一个练习的套路：「目标」→「现状」→「方案」→「行动」<br>例如</p>
<ul>
<li>询问目标：你认为怎样的结果是满意的？</li>
<li>询问现状：请问你已经尝试了哪些方案了？</li>
<li>询问方案：还可以采取哪些措施？</li>
<li>询问心动：接下来打算做什么？</li>
</ul>
<h2 id="u6E05_u6670_u8868_u8FBE"><a href="#u6E05_u6670_u8868_u8FBE" class="headerlink" title="清晰表达"></a>清晰表达</h2><p>在表达中，我们常常会遇到那种前后说了一大通，最后其实只表达了一个意思的人。也有些人表达混乱，思路不清晰的。</p>
<p>这里也有一个可练习的表达套路：</p>
<ol>
<li>「观点 Point」</li>
<li>「原因 Reason」</li>
<li>「举例 Example」</li>
<li>「复述观点 Point again」or 「提出请求 Proposal」</li>
</ol>
<p>例如：</p>
<ol>
<li>提出观点：为了我们更高效的完成目标，我的想法是…</li>
<li>说明原因：我下这个结论是因为…</li>
<li>举个栗子：如果达成了，我们会有这些提升…</li>
<li>提出请求：如果你也同意的话，我希望能得到这些帮助…</li>
</ol>
<h2 id="u53CD_u9988"><a href="#u53CD_u9988" class="headerlink" title="反馈"></a>反馈</h2><p>很喜欢对反馈的一种看法：「反馈是一种礼物！」<br>尤其是建设性的反馈，更能使自己或对方有所进步。<br>那么如何提出一个有建设性的反馈，这也有一个练习的套路：</p>
<ol>
<li>「行为 Action」</li>
<li>「影响 Impact」</li>
<li>「行动 Do」</li>
</ol>
<p>例如：</p>
<ol>
<li>行为：兄弟，厕所的墙上贴着「禁止吸烟」的。</li>
<li>影响：厕所的通风很差的，烟味会久久散不去的，想象一下屎味烟味混杂的厕所，客户来到公司，印象很差的。而且对别人身体也不健康，是吧。</li>
<li>行动：你不知道，其实公司在走廊上是有专门的吸烟区的，在那里风景又好，岂不是更舒畅。</li>
</ol>
<h1 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h1><p>「沟通」既是一门学问，也是一门艺术。<br>尽然有各种理论和研究，但最后还是为「实践」服务。<br>我认为，以上纯属理论，要真正落实到实际应用，还需要多多锻炼，以及应景发挥，还要基于现实来好好感悟。<br>另外，如果有兴趣继续深入研究的话，这里有一个书单：</p>
<ul>
<li>《金字塔原理》</li>
<li>《天资差异》</li>
<li>《类型与原型》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末参与了公司给TL们安排的一个主题为《高效沟通》的课程，为期两天。&lt;br&gt;以往自己对「沟通」自我感觉良好，完全凭借感觉来，只要跟对方能表达清楚自己的想法，足矣。&lt;br&gt;两天下来，重新开始认识，「沟通」，其实是一门很深的学问。&lt;br&gt;这篇像是笔记，也像是我对「沟通」这门学问
    
    </summary>
    
      <category term="三省吾身" scheme="http://huang-jerryc.com/categories/%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>《管理的常识》读后感 「一」</title>
    <link href="http://huang-jerryc.com/2019/03/21/management-of-common-sense-1/"/>
    <id>http://huang-jerryc.com/2019/03/21/management-of-common-sense-1/</id>
    <published>2019-03-21T12:46:40.000Z</published>
    <updated>2019-04-13T09:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="u300A_u7BA1_u7406_u7684_u5E38_u8BC6_u300B_u8BFB_u540E_u611F__u300C_u4E00_u300D"><a href="#u300A_u7BA1_u7406_u7684_u5E38_u8BC6_u300B_u8BFB_u540E_u611F__u300C_u4E00_u300D" class="headerlink" title="《管理的常识》读后感 「一」"></a>《管理的常识》读后感 「一」</h1><p>陈春花的《管理的常识》是一本相见恨晚的书。在读的过程中会有一种「如果能早点遇到你多好啊」的感慨。但换种思路，一年前读与现在读，肯定是完全不同的收获。现在读，能更多结合过去的实际感受，提炼更多的感悟和反思。<br>这本书我读的很慢，它虽然很薄，但是有大量的内容值得深度思考，并且每个人不同的时期不同的经历，也会有不同的理解和感悟。倘若一年后再来读，感受也是不一样的。<br>从3月4日拿到书，到今天为止，我还没有完全读完，我挑了两个最有感悟的点来分享下心得，分别是：「关于管理」和「关于激励」。</p>
<h2 id="u5173_u4E8E_u7BA1_u7406"><a href="#u5173_u4E8E_u7BA1_u7406" class="headerlink" title="关于管理"></a>关于管理</h2><p>很喜欢德鲁克的一句话：「管理是一种实践，其本质不在于知，而在于行；其验证不在于逻辑，而在于成果；其唯一的权威性就是成就」。<br>强调的是，管理是关注「实践」与「结果」的。</p>
<h3 id="u7BA1_u7406_u7684_u76EE_u7684_u662F_u4E3A_u4E86_u63D0_u5347_u6548_u7387"><a href="#u7BA1_u7406_u7684_u76EE_u7684_u662F_u4E3A_u4E86_u63D0_u5347_u6548_u7387" class="headerlink" title="管理的目的是为了提升效率"></a>管理的目的是为了提升效率</h3><p>管理最终是服务于「企业经营」的，而为了实现企业经营，是通过不断提升「效率」来达成。从管理学历史的角度来看，管理学的演变被陈春花老师分为了三个阶段。</p>
<p><strong>第一阶段，科学管理阶段</strong>，这个阶段要解决的问题是「劳动效率最大化」。而使劳动效率最大化的手段就是「分工」，它有四条原理：</p>
<ol>
<li>科学划分工作元素</li>
<li>员工选择、培训和开发</li>
<li>与员工经常沟通</li>
<li>管理者与员工应有平等的工作和责任范围</li>
</ol>
<p><strong>第二阶段，行政组织管理阶段</strong>，这个阶段要解决的问题是「组织效率最大化」，其中最重要的手段是「专业化水平和等级制度的结合」。<br>专业化水平，指的是需要强化各岗位的专业化能力，无论是开发、产品、销售、领导者、管理者，都需要具备岗位独特的专业能力。只有让各岗位贡献了专业化的水平，才算是胜任了管理工作。<br>而分权分责的等级制度，能够是职位和权力两者合为一体，在这个基础上，管理的效能才会有效发挥。</p>
<p><strong>第三阶段，人力资源管理阶段</strong>，这个阶段要解决的问题是「个人效率最大化」，其中重要的手段是「个人创造组织环境，满足需求，挖掘潜力」。<br>管理者其实就是一个微型的人力资源部，而不仅仅关心事务性的事情。这是角色转变很重要的一个观念。管理者也需要更多关注人，关注成员的目标与组织目标的一致性。<br>激励要以团队精神为导向，个人成果要跟团队挂钩，团队的成果要跟业务挂钩。在这方面，我想到了有赞年终奖的分配逻辑上，个人绩效需要乘以团队绩效系数。这就把员工需求和组织发展的目标连接在一起。</p>
<p>综上，管理实现效率，就是实现「劳动效率」、「组织效率」、「个人效率」，并且它们的循序是需要不断递进的过程。</p>
<h3 id="u7BA1_u7406_u662F_u4E00_u79CD_u5206_u914D"><a href="#u7BA1_u7406_u662F_u4E00_u79CD_u5206_u914D" class="headerlink" title="管理是一种分配"></a>管理是一种分配</h3><p>管理其实就是对于「职责」、「权力」、「利益」的分配。<br>这是一个能改变我认知的一个理解方式。<br>把职责分配下去，让每一个成员承担起责任，并且再给予和责任相适应的资源和权力，管理的效能就会发挥出来。<br>最理想的情况下，就是三者都能等分，形成一个铁三角型。<br>但是现实情况往往很难做到，虽然如此，也要有意识地去注意这个问题。</p>
<h3 id="u300C_u4F20_u7EDF_u7BA1_u7406_u8005_u300D_u4E0E_u300C_u6709_u6548_u7BA1_u7406_u8005_u300D"><a href="#u300C_u4F20_u7EDF_u7BA1_u7406_u8005_u300D_u4E0E_u300C_u6709_u6548_u7BA1_u7406_u8005_u300D" class="headerlink" title="「传统管理者」与「有效管理者」"></a>「传统管理者」与「有效管理者」</h3><p>在德鲁克先生的观点下，对管理者分了两类，「传统管理者」和「有效管理者」。</p>
<p>传统管理者几个特征：</p>
<ol>
<li>专注于繁琐事务，时间属于别人</li>
<li>屁股指挥脑袋，只从所在岗位的视角看问题</li>
<li>忽略了对人的培养</li>
</ol>
<p>有效管理者的几个特征：</p>
<ol>
<li>进行时间管理，明确的优先级，所有事情都有序和合理</li>
<li>系统性思考，认识到整体与局部的关系</li>
<li>培养人</li>
</ol>
<p>看着这两个分类，感触良多。<br>回想 2018 上半年，刚成为 TL，角色转变。当时实际最紧迫的任务是招人，而我自身还是深陷于业务需求中。后来反省，尽管业务需求很紧急，但是在这个位置上，应当做更加重要的事情。这是当时做的很不好的地方。<br>而 2018 下半年，新成员的加入，让我能够稍微脱离细节，更注重培养人，后来团队能输出不错的小伙伴，还是很欣慰的。<br>而现在，我需要更多的关注在系统性思考上，跳出岗位，跳出职业视角，认识到整体和局部，这不是个短期内容易提升的事情。</p>
<h2 id="u5173_u4E8E_u6FC0_u52B1"><a href="#u5173_u4E8E_u6FC0_u52B1" class="headerlink" title="关于激励"></a>关于激励</h2><p>我一直认为的一个观念，大家之所以来这里工作，是有个人需求的。可能是一份薪水，可能是进步，发展，和实现个人价值。这里要回答的一个问题是：「人们为什么工作」<br>企业和个人是一个双向选择过程，各取所需，各司其职，双方都会关心投入产出比。<br>所以，关于如何搞清对方需求，给予激励，提高绩效。这方面我会更想找到答案。</p>
<h3 id="u6FC0_u52B1_u7684_u4E24_u4E2A_u89D2_u5EA6"><a href="#u6FC0_u52B1_u7684_u4E24_u4E2A_u89D2_u5EA6" class="headerlink" title="激励的两个角度"></a>激励的两个角度</h3><p>对于激励有两个核心的思考角度。<br>第一个，是想办法让工作变成游戏，让人从中获取更多快乐，这就跟有赞强调的 Enjoy 很切合了。<br>第二个，是永远站在对方的角度来思考，理解对方的述求。</p>
<h3 id="u300C_u4FDD_u5065_u56E0_u7D20_u300D_u4E0E_u300C_u6FC0_u52B1_u56E0_u7D20_u300D"><a href="#u300C_u4FDD_u5065_u56E0_u7D20_u300D_u4E0E_u300C_u6FC0_u52B1_u56E0_u7D20_u300D" class="headerlink" title="「保健因素」与「激励因素」"></a>「保健因素」与「激励因素」</h3><p>在众多的常见激励手段中，陈春花把它们分了两类：「保健因素」和「激励因素」。<br>例如，</p>
<ul>
<li>保健因素：工资、岗位，培训、福利、工作设备等。</li>
<li>激励因素：晋升、奖金、价值的肯定、额外的工作条件等。</li>
</ul>
<p>保健因素，是一个人工作的最基本，最必须的条件，如果缺乏保健因素的话，就会引起不满。另外一个特点是，大部分人都有的，不具有独特性的。</p>
<p>激励因素，是一个人做好工作所需要的条件，他能够带来满足感，能够激起人的欲望和潜力的。另外一个特点是，少部分有的，需要踮脚拿到的。</p>
<p>所以，不同激励与感受的关系是，保健因素 → 降低不满，激励因素 → 提升满足感。</p>
<p>需要注意的是，激励因素是有可能变成保健因素的。例如现在大部分公司都发年终奖，并且人人都有，HR 谈薪资的时候，也会用年薪的概念把年终奖算进收入里面，作为一个 package。那么年终奖，就变成了保健因素了。一旦公司年底发不出年终奖，或者不及预期，那就会引起不满。</p>
<h3 id="u300C_u6FC0_u52B1_u300D_u4E0E_u300C_u7EE9_u6548_u300D"><a href="#u300C_u6FC0_u52B1_u300D_u4E0E_u300C_u7EE9_u6548_u300D" class="headerlink" title="「激励」与「绩效」"></a>「激励」与「绩效」</h3><p>时刻不能忘的是，管理最终是服务于企业经营的。激励是重要的管理手段，最终也是要为绩效负责的。「激励」和「绩效」的关系，有些要注意的。</p>
<p><strong> 满足感并不一定带来高绩效 </strong><br>在满足员工的需求，让员工获得满足感的基础下，一定要：<strong>「让员工的满足感来源于工作本身而不是个人需求」</strong></p>
<p>因为人们的需求是很个人化的，例如有的人需求是工作环境，而不是工作中获得绩效。那么当工作环境很好的时候，导致员工很有满足感，但是他并不关心工作本身。</p>
<p><strong>激励有时候不会发挥作用</strong><br>有些情况下，不管采用何种激励措施，都无法达到效果：</p>
<ol>
<li>工作量超量所造成的疲惫</li>
<li>角色不清，任务冲突</li>
<li>不公平待遇</li>
</ol>
<p>在这三种情况下，更应该切实的改变人们所处的状态，合理的工作量设计、清晰的责权利、公平的待遇。在这个基础之上，通过有效的激励措施，才能获得高的工作绩效。</p>
<h3 id="u671F_u671B_u7406_u8BBA"><a href="#u671F_u671B_u7406_u8BBA" class="headerlink" title="期望理论"></a>期望理论</h3><p>「人会成为他所期望的样子」这是一句大实话，人的进步都源于期望，也许来自于他人，也许来自于自身。<br>期望理论有三个基本条件：</p>
<ol>
<li>期望价，这个目标需要能够实现的，如果太高就没有可行性。</li>
<li>媒介，主要是要获取信任感，相信结果是可获得的，跟目标是一致的。</li>
<li>承诺会兑现，不管多少人达成期望，都一定要能实现当初的承诺。</li>
</ol>
<p>期望理论满足这三个基本条件，才能真正达到效果，激励人们向更高的期望努力。</p>
<h3 id="u5F53_u4E0B_u6211_u66F4_u591A_u53EF_u4EE5_u505A_u7684_u6FC0_u52B1_u52A8_u4F5C"><a href="#u5F53_u4E0B_u6211_u66F4_u591A_u53EF_u4EE5_u505A_u7684_u6FC0_u52B1_u52A8_u4F5C" class="headerlink" title="当下我更多可以做的激励动作"></a>当下我更多可以做的激励动作</h3><p>成本最低的而且最有效的激励措施，也就是性价比最高的激励措施：鼓掌、赞美、鲜花、隆重的仪式、授权与信任。</p>
<p>前三者（鼓掌、赞美、鲜花），我归纳为对付出的肯定，那么就归类为：</p>
<ol>
<li>肯定（鼓掌、赞美、鲜花）</li>
<li>仪式感</li>
<li>授权与信任</li>
</ol>
<p>对人们的结果，要及时的给予肯定，让他们知道有人看得到，并且得到欣赏，这也是人类最基本的社会述求。<br>在重要的事情上，要有一定的仪式感，例如一个项目的建立，一个团队的建立，一件重要事情的达成等等。<br>尤其重要的是授权与信任，这个我回想起两年前初来有赞的时候，跟前司很大不同的是，能得到很好的授权与信任，以及足够的自由和发挥空间。</p>
<h2 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h2><p>《管理的常识》这本书，在物理空间上，它很薄。但这不妨碍它能囊括很强大的内容，这些内容很适合细细品读与感悟。也很庆幸在这个时间遇到一本好书，让自己重新总结和审视过去的经验和见识。<br>另外，标题加了个「一」，是为了立个 Flag，让我继续读完这本书，然后再写一篇心得。<br>最后，管理，确实是一门科学，也是一门艺术。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;u300A_u7BA1_u7406_u7684_u5E38_u8BC6_u300B_u8BFB_u540E_u611F__u300C_u4E00_u300D&quot;&gt;&lt;a href=&quot;#u300A_u7BA1_u7406_u7684_u5E38_u8BC6_u300B_
    
    </summary>
    
      <category term="三省吾身" scheme="http://huang-jerryc.com/categories/%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>原汁原味的配方:「微信小程序支持 NPM」</title>
    <link href="http://huang-jerryc.com/2018/05/02/use-npm-in-weapp/"/>
    <id>http://huang-jerryc.com/2018/05/02/use-npm-in-weapp/</id>
    <published>2018-05-01T16:07:00.000Z</published>
    <updated>2019-07-07T10:28:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序本身不支持 npm 包的使用，目前市面上很多框架也有了相对应的解决方案。</p>
<p>本文旨在为那些不愿意引入第三方框架， 想在小程序环境中写原汁原味代码的人（例如我），提供一种解决问题的思路。</p>
<p>在现代的 Web 开发中，我们对 Webpack 已经再熟悉不过了，简单理解，它就是项目发布之前，把所有资源都打包好，然后提供一个入口文件，在入口模板中引入这个入口文件。</p>
<p>那么我的思路，就是利用 Webpack 把我们所有的 npm 依赖打包好，提供一个入口文件，在小程序开发中，我们通过这个入口文件，进而使用 npm 的依赖。</p>
<p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190707181936" alt></p>
<p>我们最终实现的效果应该是这样的。</p>
<p>例如我们小程序的首页中，需要使用到 <code>moment</code></p>
<p>pages/home/home.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; moment &#125; <span class="built_in">require</span>(<span class="string">'../npm/index'</span>);</span><br><span class="line"><span class="keyword">const</span> time = moment();</span><br></pre></td></tr></table></figure>
<h1 id="Webpack__u6253_u5305_npm__u4F9D_u8D56"><a href="#Webpack__u6253_u5305_npm__u4F9D_u8D56" class="headerlink" title="Webpack 打包 npm 依赖"></a>Webpack 打包 npm 依赖</h1><p>webpack 默认输出的 <code>bundle.js</code> ，是一个立即执行的闭包，如以下：</p>
<p>使用 webpack.config.js 配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./foo.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行 <code>$ webpack</code> 生成的 <code>bundle.js</code> :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// webpackBootstrap</span></span><br><span class="line"></span><br><span class="line">&#125;)([module1, module2, module3]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例代码：<a href="https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step1" target="_blank" rel="external">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step1</a></p>
</blockquote>
<p>这样的代码，显然没法达到我们要的效果。<br>幸好 webpack 提供了 <code>output.libraryTarget</code> 的配置项。</p>
<h2 id="output-libraryTarget_3A__u201Ccommonjs2_u201D"><a href="#output-libraryTarget_3A__u201Ccommonjs2_u201D" class="headerlink" title="output.libraryTarget: “commonjs2”"></a>output.libraryTarget: “commonjs2”</h2><p>对于 <code>output.libraryTarget: &quot;commonjs2&quot;</code> 官方解释：</p>
<blockquote>
<p>The return value of your entry point will be assigned to the module.exports.</p>
</blockquote>
<p>通过配置该属性，我们能保证 webpack 打包出来的 <code>bundle.js</code>，是模块化的。<br>当然 <code>output.libraryTarget</code> 还有其他的选项值，可以查阅<a href="https://webpack.js.org/configuration/output/#output-librarytarget" target="_blank" rel="external">官方文档</a>。</p>
<p>例如，使用 webpack.config.js 配置:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./foo.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'commonjs2'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行 <code>$ webpack</code> 生成的 <code>bundle.js</code> :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// webpackBootstrap</span></span><br><span class="line"></span><br><span class="line">&#125;)([module1, module2, module3]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例代码：<a href="https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step2" target="_blank" rel="external">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step2</a></p>
</blockquote>
<p>这样，我们就可以通过 <code>require(&#39;bundle.js&#39;)</code>, 来使用 npm 依赖了。<br>在这个基础上，我们就可以打造一个使用 npm 依赖的入口。</p>
<h2 id="u6253_u9020_npm__u5165_u53E3"><a href="#u6253_u9020_npm__u5165_u53E3" class="headerlink" title="打造 npm 入口"></a>打造 npm 入口</h2><p>建立入口文件：npm.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> momennt = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    momennt,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>配置文件：webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./entry.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'npm'</span>),</span><br><span class="line">        filename: <span class="string">'index.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行 <code>$ webpack</code>，输出 <code>./npm/index.js</code> 打包文件，对应的目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#10;&#9500;&#9472;&#9472; entry.js&#10;&#9500;&#9472;&#9472; npm&#10;&#9474;   &#9492;&#9472;&#9472; index.js&#10;&#9492;&#9472;&#9472; webpack.config.js</span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例代码：<a href="https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step3" target="_blank" rel="external">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step3</a></p>
</blockquote>
<p>笨拙点的方法，你只需要把 <code>npm/index.js</code> 拷贝到你的项目中，就可以使用你所引入的 npm 包的内容了。</p>
<p>如果你的项目中使用了构建工具的话，就可以把「 webpack 打包 npm」 的这项任务加入到你的构建流程中。</p>
<p>我是使用 gulp 来做项目构建工作的，下面提供一种基于 gulp 的实现作为参考。</p>
<h1 id="u7ED3_u5408_Gulp__u505A_u9879_u76EE_u5DE5_u7A0B_u5316"><a href="#u7ED3_u5408_Gulp__u505A_u9879_u76EE_u5DE5_u7A0B_u5316" class="headerlink" title="结合 Gulp 做项目工程化"></a>结合 Gulp 做项目工程化</h1><p>工程目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#10;&#9500;&#9472;&#9472; dist&#10;&#9474;   &#9500;&#9472;&#9472; npm&#10;&#9474;   &#9474;   &#9492;&#9472;&#9472; index.js&#10;&#9474;   &#9492;&#9472;&#9472; pages&#10;&#9474;       &#9492;&#9472;&#9472; home&#10;&#9474;           &#9492;&#9472;&#9472; home.js&#10;&#9500;&#9472;&#9472; gulpfile.js&#10;&#9492;&#9472;&#9472; src&#10;    &#9500;&#9472;&#9472; npm&#10;    &#9474;   &#9492;&#9472;&#9472; index.js&#10;    &#9492;&#9472;&#9472; pages&#10;        &#9492;&#9472;&#9472; home&#10;            &#9492;&#9472;&#9472; home.js</span><br></pre></td></tr></table></figure>
<p>而 gulpfile 负责两件事：</p>
<ol>
<li>把 src 的 js 文件通过 babel 编译到 dist 目录（示例中忽略其他 wxml、wxss 文件）</li>
<li>把 <code>npm/index.js</code> 通过 webpack 打包到 <code>dist/npm/index.js</code>，并压缩。</li>
</ol>
<p>gulpfile.js:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"><span class="keyword">const</span> del = <span class="built_in">require</span>(<span class="string">'del'</span>);</span><br><span class="line"><span class="keyword">const</span> runSequence = <span class="built_in">require</span>(<span class="string">'run-sequence'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackStream = <span class="built_in">require</span>(<span class="string">'webpack-stream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                presets: [<span class="string">'es2015'</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;],</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'index.js'</span>,</span><br><span class="line">        libraryTarget: <span class="string">'commonjs2'</span>,        </span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空 ./dist 目录</span></span><br><span class="line">gulp.task(<span class="string">'clean'</span>, () =&gt; del([<span class="string">'./dist/**'</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包 npm 依赖</span></span><br><span class="line">gulp.task(<span class="string">'npm'</span>, () =&gt; &#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/npm/*.js'</span>)</span><br><span class="line">        .pipe(webpackStream(webpackConfig), webpack)</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist/npm'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译 JS 文件</span></span><br><span class="line">gulp.task(<span class="string">'scripts'</span>, () =&gt; &#123;</span><br><span class="line">    gulp.src([<span class="string">'./src/**/*.js'</span>, <span class="string">'!./src/npm/*.js'</span>])</span><br><span class="line">        .pipe(babel(&#123;</span><br><span class="line">            presets: [<span class="string">'stage-0'</span>, <span class="string">'es2015'</span>],</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开发模式命令</span></span><br><span class="line">gulp.task(<span class="string">'build'</span>, [<span class="string">'clean'</span>], () =&gt; runSequence(<span class="string">'scripts'</span>, <span class="string">'npm'</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例代码：<a href="https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step4" target="_blank" rel="external">https://github.com/JerryC8080/use-npm-in-weapp/tree/master/step4</a></p>
</blockquote>
<h1 id="u5173_u4E8E_u63A7_u5236_npm__u6587_u4EF6_u4EE3_u7801_u91CF"><a href="#u5173_u4E8E_u63A7_u5236_npm__u6587_u4EF6_u4EE3_u7801_u91CF" class="headerlink" title="关于控制 npm 文件代码量"></a>关于控制 npm 文件代码量</h1><p>微信限制了项目的代码量为 2M，就算使用了分包机制，最多也是 4M 的代码量。<br>区区一个 moment 库的话，就算压缩过，也需要两百多 KB，这对于我们的代码量，是很不友好的。<br>我们需要对 npm 的引入持非常谨慎的态度，去度量每个依赖包的大小，想尽各种办法减少依赖的代码量。<br>譬如<code>moment</code> 我们可以使用 <code>moment-mini</code> 来代替，后者压缩过后只需要 51KB。</p>
<p>而且我认为把 npm 的依赖放在一个入口文件中，会让我们可以对 npm 的依赖有一个全局的把握。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序本身不支持 npm 包的使用，目前市面上很多框架也有了相对应的解决方案。&lt;/p&gt;
&lt;p&gt;本文旨在为那些不愿意引入第三方框架， 想在小程序环境中写原汁原味代码的人（例如我），提供一种解决问题的思路。&lt;/p&gt;
&lt;p&gt;在现代的 Web 开发中，我们对 Webpack 已
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="微信小程序" scheme="http://huang-jerryc.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>「译」JavaScript框架的探索与变迁</title>
    <link href="http://huang-jerryc.com/2017/11/01/change-and-its-detection-in-javascript-frameworks/"/>
    <id>http://huang-jerryc.com/2017/11/01/change-and-its-detection-in-javascript-frameworks/</id>
    <published>2017-11-01T14:22:25.000Z</published>
    <updated>2020-07-21T08:12:37.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u8BD1_u8005_u8A00"><a href="#u8BD1_u8005_u8A00" class="headerlink" title="译者言"></a>译者言</h2><p>近几年可谓是 JavaScript 的大爆炸纪元，各种框架类库层出不穷，它们给前端带来一个又一个的新思想。从以前我们用的 jQuery 直接操作 DOM，到 BackboneJS、Dojo 提供监听器的形式，在到 Ember.js、AngularJS 数据绑定的理念，再到现在的 React、Vue 虚拟 DOM 的思想。都是在当前 Web 应用日益复杂的时代，对于如何处理「应用状态」与「用户界面」之间如何更新的问题，带来更先进的解决方案。</p>
<p>本文是一篇从技术上，以数据变更和UI同步为方向，循序渐进的讲述 JavaScript 框架如何演进过来的。</p>
<p>本篇文章，给了我一个更加高纬度的视角，来看待 JavaScript 这些个框架。</p>
<h2 id="u6B63_u6587"><a href="#u6B63_u6587" class="headerlink" title="正文"></a>正文</h2><p>在 2015 年，JavaScript 框架的选择并不少。在 Angular，Ember，React，Backbone 以及它们众多的竞争者中，有足够多的选择。</p>
<p>虽然可以通过不少方面来对比这些框架的不同，但是最让人感兴趣的是它们分别如何管理状态（state）的。特别的，通过思考这些框架分别如何处理状态变化是很有用的。它们都提供了什么样的工具让你把这些变化呈现给用户？ </p>
<p>如何处理应用状态（app state）与用户界面（user interface）之间的同步，长期以来都是用户界面开发如此复杂的主要原因。现在，我们有几个不同的处理方案。本文探索以下：Ember 的数据绑定，Angular 的脏检查、React 的虚拟DOM以及它与不可变数据结构（immutable data structures）之间的联系。</p>
<h2 id="u6570_u636E_u6620_u5C04_Projecting_Data"><a href="#u6570_u636E_u6620_u5C04_Projecting_Data" class="headerlink" title="数据映射 Projecting Data"></a>数据映射 Projecting Data</h2><p>我们首先讨论程序内部的状态与屏幕所看到的内容之间的映射。你把各种诸如 object，arrays，strings，以及 numbers 转换成一颗由诸如 texts、forms、links、buttons 和 images 组成的树状结构。在 Web 中，前者通常指 JavaScript 中的数据结构，而后者指的是 <a href="https://www.w3.org/DOM/" target="_blank" rel="external">DOM （Document Object Model）</a></p>
<p>我们经常称这个过程为渲染（rendering），你可以想象这个过程是从数据模型到用户界面的一个映射。当你把数据渲染成一个模板，你得到的是一个 DOM（或者说 HTML）。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/15B722FCBCB7A5D72D240DC5B55F7DDE.svg" alt="onchange_base.svg"></p>
<p>这个过程本身已经足够简单了，数据模型到用户界面之间的映射，并不总是那么的琐碎。它基本只是一个接受输入然后直接输出的函数。</p>
<p>在我们需要考虑数据开始随着时间而变化的时候，这件事就变得更有挑战性了。当用户进行操作或者其它某些操作导致数据产生变化的时候，用户界面需要呈现出这些变化。而且，由于重新构建 DOM 树的代价是极其昂贵的，我们要尽可能产生小的影响。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/1D6EF2506F41A57871712CBCAD1463F8.svg" alt="onchange_change.svg"></p>
<p>因为状态产生了变化，这比只是一次性渲染用户界面变得更加难。这就到了以下解决方案开始表演的时候了。</p>
<h2 id="u670D_u52A1_u5668_u6E32_u67D3_Server-Side_Rendering"><a href="#u670D_u52A1_u5668_u6E32_u67D3_Server-Side_Rendering" class="headerlink" title="服务器渲染 Server-Side Rendering"></a>服务器渲染 Server-Side Rendering</h2><blockquote>
<p>宇宙是永恒不变的，没有任何变化</p>
</blockquote>
<p>在 JavaScript 新纪元之前，你的 Web 应用的任何交互都会触发一趟服务器的环绕旅行。每一个点击和每一个表单提交都会卸载当前页面，一个请求发送到服务器，服务器响应一个新的页面，然后浏览器重新渲染。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_reload.svg" alt="onchange_reload.svg"></p>
<p>这种方式不需要前端管理任何的状态（state）。就前端范畴而言，当一些事情发生了(后端返回的数据)，整个过程就结束了。就算有状态，那也只是后端的范畴。前端只是由 HTML 和 CSS 构成，也许有时候会有些 JavaScript 撒在表面调味。</p>
<p>从前端来说，这是一个很简单的实现方式，但也是一个很慢的方式。每一个交互并不仅仅触发UI的重渲染，还涉及服务器的数据查询以及服务端渲染。</p>
<p>大多数人已经不再这样做了，我们可以在服务器端初始化我们的应用，然后转移到前端来做状态的管理（这也是 <a href="http://isomorphic.net/" target="_blank" rel="external">isomorphic JavaScript</a> 致力于的。）。已经有人在类似的<a href="https://signalvnoise.com/posts/3112-how-basecamp-next-got-to-be-so-damn-fast-without-using-much-client-side-ui" target="_blank" rel="external">更复杂的设计思想</a>中取得成功。</p>
<h2 id="JS_u7B2C_u4E00_u4EE3_u9769_u547D_uFF1A_u624B_u52A8_u91CD_u6E32_u67D3"><a href="#JS_u7B2C_u4E00_u4EE3_u9769_u547D_uFF1A_u624B_u52A8_u91CD_u6E32_u67D3" class="headerlink" title="JS第一代革命：手动重渲染"></a>JS第一代革命：手动重渲染</h2><blockquote>
<p>我不知道哪些需要渲染的，你来告诉我。</p>
</blockquote>
<p>第一代革命的 JavaScript 框架，如：Backbone.js, Ext JS 以及 Dojo。第一次在浏览器端引入了数据模型（Data Model）的概念，代替了以前那些直接操作 DOM 的轻量级的脚本代码。这意味着你终于可以在浏览器端管理状态了。当数据模型的上下文改变时，你需要做一些工作，让改变呈现在用户界面中。</p>
<p>这些框架的体系能分离你的模型和界面代码，但同时也留下了一大部分同步的工作给你。你可以监听某类事件的发生，但是你有义务去计算如何重新渲染以及如何落实到用户界面中。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_manual.svg" alt="onchange_manual.svg"></p>
<p>基于这种模型，作为开发者，你需要考虑大量的性能问题。由于你能控制什么时候和怎么处理更新，你可以从中做任意的做一些调整。这经常会面临一些权衡：简单的处理导致大面积的页面更新，或者强性能的处理来更新一小块页面。</p>
<h2 id="Ember-js_3A__u6570_u636E_u7ED1_u5B9A"><a href="#Ember-js_3A__u6570_u636E_u7ED1_u5B9A" class="headerlink" title="Ember.js: 数据绑定"></a>Ember.js: 数据绑定</h2><blockquote>
<p>由于我在控制你的模型和试图，我会确切知道如何重新渲染。</p>
</blockquote>
<p>当应用状态改变的时候，手动处理渲染工作，无可避免的增加了复杂度。很多框架旨在解决这个问题，<a href="https://emberjs.com" target="_blank" rel="external">Ember.js</a> 就是其中之一。</p>
<p>Ember，像 Backbone 一样，当数据模型改变的时候会触发某个事件。不同之处在于 Ember 同时提供了一些方法来接收这些事件。你可以把 UI 绑定到数据模型中，这意味着有一个监听器绑定到了 UI 上。该监听器当收到事件的时候，知道如何更新 UI。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_kvo.svg" alt="onchange_kvo.svg"></p>
<p>这是一个高效率的机制。尽管设置全部的监听器需要在初始化时多出一些工作，但是之后就能保证同步状态时的最小影响。当状态产生变化时， 只有真正需要更新的部分才会发生改变。</p>
<p>这种方式最大的牺牲是 Ember 需要时刻盯着数据模型。这意味着你需要通过 Ember 的 API 封装你的数据，以及你要更新数据的时候是使用 <code>foo.set(&#39;x&#39;,42)</code> 而不是 <code>foo.x = 42</code>，以此类推。</p>
<p>在未来 ES6 的 Proxies 可能会对这种模式产生一定的帮助。它让 Ember 可以通过装饰 object 来绑定那些监听器的代码。这就不用像传统方式那样重写 object 的 setter 方法了。</p>
<h2 id="AngularJS_uFF1A_u810F_u68C0_u67E5"><a href="#AngularJS_uFF1A_u810F_u68C0_u67E5" class="headerlink" title="AngularJS：脏检查"></a>AngularJS：脏检查</h2><blockquote>
<p>我不知道什么更新了，所以当更新的时候，我只能检查所有的东西。</p>
</blockquote>
<p>AngularJS 类似于 Ember，当状态改变的时候，必须人工去处理。但不同的是，AngularJS 从不同的角度来解决问题。</p>
<p>当你在 Angular 模板中引用你的数据，例如这样的语句 <code></code> ，Angular 不仅仅只是渲染数据，而且会这个特定的数据创建一个观察者。如此，只要你的应用中发生任何变化，Angular 都会检查这个观察者检视着的数据是否发生了改变。如果发生了改变，就会重新渲染这个数据对应的用户界面。这个过程称作脏检查（Dirty Checking）。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_watch.svg" alt="onchange_watch.svg"></p>
<p>这种监听改变的风格最大的好处就是，你可以在你的数据模型中使用任何姿势。Angular 对此没有任何限制，它不关心这个。没有基础的对象需要扩展，也没有 API 需要调用。</p>
<p>但坏处就是现在数据模型没有任何内建的检测手段告诉告诉框架哪些东西发生了改变，框架对是否或者哪里发生了改变没有任何洞察力。这意味着数据模型需要通过外部来监听改变，而 Angular 就是这样子做的：所有观察者在任何时间发生的任何改变，都需要被执行一次。点击事件，HTTP 响应，timeout 方法的触发，对于这些，观察者都需要执行一遍。</p>
<p>经常去执行所有观察者，这听起来像是性能的噩梦，但是它令人惊讶的快。这主要是因为在检查到任何改变之前，没有 DOM 的操作过程，而原生的 JavaScript 引用对象的检查平均消耗的性能是廉价的。但是当你要处理大量的 UI 或者经常性触发重新渲染，那么额外的性能优化手段就变得很有必要了。</p>
<p>Ember 和 Angular 都即将得益于即将到来的标准：ECMAScript7 的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe" target="_blank" rel="external">Object.observe</a> 功能，很适合 Angular。它提供了原生的 API 给你用来监听对象属性的变化。尽管这样，Angular 不需要支持所有的用例，因为 Angular 的观察者相对于简单的监听对象属性，可以做到的更好。</p>
<p>即将到来的 Angular 2 在检测改变这件事上带来了很多有趣的更新，最近 <a href="http://victorsavkin.com/post/110170125256/change-detection-in-angular-2" target="_blank" rel="external">Victor Savkin 的一篇文章</a>有介绍到。</p>
<p>关于这个主题，也可以看：<a href="https://www.youtube.com/watch?v=jvKGQSFQf10&amp;feature=youtu.be" target="_blank" rel="external">Victor’s ng-conf talk</a></p>
<h2 id="React_3A__u865A_u62DF_DOM"><a href="#React_3A__u865A_u62DF_DOM" class="headerlink" title="React: 虚拟 DOM"></a>React: 虚拟 DOM</h2><blockquote>
<p>我不知道到底哪些发生了变化，所以我只能重新渲染所有东西，然后看一下有哪些不同。</p>
</blockquote>
<p>React 有很多有趣的特性，但是我们讨论的最有趣的特性是虚拟 DOM。</p>
<p>像 Angular 一样，React 不会对数据模型进行限制，而是让你使用你认为合适的任何对象和数据结构。那么，它是如何在存在改变的情况下使 UI 保持最新呢？</p>
<p>React 所做的是有效的把我们带回服务器渲染时代，当时我们还不关心状态变化：每当某处发生改变的时候，它会从头重新渲染整个 UI。这可以显著的简化 UI 的代码。大部分情况，你不会关心如何在 React 中维护状态。就像服务器渲染一样，渲染一次就算了。当组件需要变更时，它只能再次重新渲染。组价的初始化渲染和更细它的数据之间，没有任何区别。</p>
<p>如果故事就这么结束的话，它看起来的确非常低效。然而，React 在重新渲染方面，有点特殊。</p>
<p>当 React 进行重新渲染时，它首先会渲染到虚拟 DOM 中，这不是一个实际的 DOM 对象的图。而是一个轻量级的，有纯粹的 object 和 array 组成的纯 JavaScript 的数据结构，它代表着一个真实的 DOM 对象的图。</p>
<p>然后，一个独立的进程会根据虚拟 DOM 的结构来创建那些在屏幕上显示的真实的 DOM 元素。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_vdom_initial.svg" alt="onchange_vdom_initial.svg"></p>
<p>之后，当变化发生的时候，一个新的虚拟 DOM 会被从头到尾创建出来。这个新的虚拟 DOM 将映射出数据模型的新的状态。现在 React 在手上有两个虚拟 DOM：一个新的，一个旧的。然后会对两个虚拟 DOM 进行一个对比算法，得出它们之间的一组变化。有且只有这些更改会被应用到真实 DOM 中：此元素已添加，此属性以改变，等等。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_vdom_change.svg" alt="onchange_vdom_change.svg"></p>
<p>所以 React 起码至少有一个好处，就是你不用追踪变化了。你只需要每次重新渲染整个 UI ，然后无论改变了什么最终都会得到相应的结果。React 的虚拟 DOM 对比算法，能让你做到这一点，并且最大限度的节省昂贵的 DOM 操作。</p>
<h2 id="Om_3A__u4E0D_u53EF_u6539_u53D8_u7684_u6570_u636E_u7ED3_u6784"><a href="#Om_3A__u4E0D_u53EF_u6539_u53D8_u7684_u6570_u636E_u7ED3_u6784" class="headerlink" title="Om: 不可改变的数据结构"></a>Om: 不可改变的数据结构</h2><blockquote>
<p>我确切的知道哪些没有改变。</p>
</blockquote>
<p>虽然 React 的虚拟 DOM 相当的块，但是当你的 UI 非常庞大或者经常性渲染的时候（例如：每秒高达 60 次），它依然会面临瓶颈。</p>
<p>问题在于，真的没办法每次都渲染出整个虚拟 DOM，除非你引入一些方法来控制数据模型的改变，就像 Ember 做的一样。</p>
<p>一种控制变化的办法是 <a href="http://en.wikipedia.org/wiki/Persistent_data_structure" target="_blank" rel="external">不可改变的，持久化的数据结构</a>。这些看起来似乎很适合使用在 React 的虚拟 DOM 中，正如 David Nolen 在 <a href="https://github.com/omcljs/om" target="_blank" rel="external">Om</a> 库中所做的 <a href="http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/" target="_blank" rel="external">工作</a> 那样，一个构建于 React 和 <a href="https://github.com/clojure/clojurescript" target="_blank" rel="external">ClojureScript</a> 之上的库。</p>
<p>有一点关于不可改变数据结构的是，顾名思义，你永远不能改变它，只能产生新的版本。如果你想改变一个对象的属性，你只能新建一个对象和属性，因为你不能改变已经存在的那一个。由于持久化数据结构的工作方式，这比听起来更加有效率。</p>
<p>这意味着在检测变化方面，当 React 组件都只由不可变数据组成的时候，只有一个逃生窗口：当你重新渲染一个组件时，组件的状态仍然指向上次渲染时的相同数据结构，你就可以跳过这次重新渲染。你可以使用该组件的先前的虚拟 DOM 以及源自该组件的整个组件树。没有必要进一步挖掘，因为在这个状态中所有东西都不可能改变。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/change-and-its-detection-in-javascript-frameworks/onchange_immutable.svg" alt="onchange_immutable.svg"></p>
<p>就像 Ember 一样，像 Om 的这种库不允许在你的数据中使用旧的 JavaScript 对象图。你必须在不可变数据结构中构建你的数据模型，从而才能在其中得到好处。我会赞同这样的做法，因为这一次你这样做并不是为了取悦框架本身。你这样做只是因为这是一个又简单又好的方式去管理你的应用状态。使用不可变数据结构的主要好处，并不是提升渲染性能，而是简化你的应用结构。</p>
<p>虽然 Om 和 ClojureScript 已经讲 React 和不可变数据结构融合起来，但是他们并不是圈子里面的唯一组合。而仅仅使用 React 和 Facebook 的 <a href="http://facebook.github.io/immutable-js/" target="_blank" rel="external">Immutable-js</a> 是完全可能的。这个库的作者 Lee Byron 在最近的一次 React.js 为主题的会议中进行了一个 <a href="https://www.youtube.com/embed/I7IdS-PbEgI" target="_blank" rel="external">精彩的介绍</a>。</p>
<p>同时我建议看一下 Rich Hickey’s 的 <a href="http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey" target="_blank" rel="external">Persistent Data Structures And Managed References</a>, 去了解状态管理的方法。</p>
<p>我自己现在一直在为不可变数据数据结构 <a href="http://blog.deveo.com/immutability-in-ruby-part-1-data-structures/" target="_blank" rel="external">写诗</a>，但我绝对没有预见到它会进入前端 UI 框架行列。它看起来似乎不遗余力的发生着，而 Angular 的人 <a href="http://victorsavkin.com/post/110170125256/change-detection-in-angular-2" target="_blank" rel="external">正在为支持这个而努力着</a>。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>检测变化时 UI 开发中的核心问题，而 JavaScript 框架们以各种方式解决这个问题。</p>
<p>EmberJS 能在它们发生变化的时候检测到，因为它控制着你的数据模型 API，并且可以在你调用它的时候触发事件。</p>
<p>Angular.js 是事后进行检测， 它通过重新运行你已经在 UI 中注册的所有数据绑定，来检测它们的值是否已经发生变化。</p>
<p>React 的检测方法是通过把整个 UI 重新渲染成一个虚拟 DOM，然后和旧的版本进行对比。无论改变了什么，都可以给真实 DOM 打上个补丁。</p>
<p>React 和 不可变数据结构的组合，对比纯粹的 React 有所增强，通过快速的在组件树中标记不可变的节点。因为组件内的变化是不被允许的。但是，这不是主要出于性能的原因，而是由于它对整个应用程序体系结构有积极的影响。</p>
<h2 id="u539F_u6587_u94FE_u63A5"><a href="#u539F_u6587_u94FE_u63A5" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="http://teropa.info/blog/2015/03/02/change-and-its-detection-in-javascript-frameworks.html" target="_blank" rel="external">Changes and Its detection of JavaScript Framework</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u8BD1_u8005_u8A00&quot;&gt;&lt;a href=&quot;#u8BD1_u8005_u8A00&quot; class=&quot;headerlink&quot; title=&quot;译者言&quot;&gt;&lt;/a&gt;译者言&lt;/h2&gt;&lt;p&gt;近几年可谓是 JavaScript 的大爆炸纪元，各种框架类库层出不穷，它们
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="javascript" scheme="http://huang-jerryc.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>有赞微信小程序分享 — 概念篇</title>
    <link href="http://huang-jerryc.com/2017/08/31/yz-share-about-wxapp--cencept/"/>
    <id>http://huang-jerryc.com/2017/08/31/yz-share-about-wxapp--cencept/</id>
    <published>2017-08-31T05:15:02.000Z</published>
    <updated>2020-07-21T08:12:37.394Z</updated>
    
    <content type="html"><![CDATA[<p>在 2016 年 9 月 23 日 微信小程序内测开始以来，有赞的产品与技术一直紧跟着小程序的步伐。并且在 2017年1月9日 微信小程序发布的同时上线了有赞微商城小程序和有赞精选小程序。并且紧跟着开源了小程序的 UI 库：<a href="https://github.com/youzan/zanui-weapp" target="_blank" rel="external">zanui-weapp</a></p>
<p>在我加入有赞不久后，就参与了微信小程序产品线的开发。<br>随着今年微信官方大力推广和迭代，微信小程序可谓渐渐形成一个新重量级现象，对于自身来说，除了单纯的掌握技术上的开发姿势以外，还需对整个小程序生态以及未来的动向有足够的认识和了解。<br>于是乎本着研究与学习，有了这一次内部分享。<br>趁着课余时间，整理成文，与君分享。</p>
<h1 id="u5FAE_u4FE1_u5F00_u53D1_u4F53_u7CFB"><a href="#u5FAE_u4FE1_u5F00_u53D1_u4F53_u7CFB" class="headerlink" title="微信开发体系"></a>微信开发体系</h1><p>微信开发，是一个体系。<br>无论是开发移动应用，网站应用，都可以接入微信生态，例如实现微信账号登录，实现 APP 分享到微信朋友圈和联系人。<br>除了自有的应用，还可以在公众号内进行应用开发，为订阅号或者服务号提供更强大的功能和交互。<br>现在又有了小程序，除了开发工具类应用更简单以外，连接线上线下的场景更丰富。<br>在我认为，国内的互联网产品中，多多少少都会接触到微信的开发体系。<br>因为这是一个庞大的流量入口啊。</p>
<h2 id="u4E09_u4E2A_u5E73_u53F0"><a href="#u4E09_u4E2A_u5E73_u53F0" class="headerlink" title="三个平台"></a>三个平台</h2><p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/F0C87F9DD75168C4C99AC1BDB4C7AAD4.jpg" alt="三个平台"></p>
<p>在接触微信的开发体系中，接触最多的是这三个平台。<br>我们站在一个更高的维度来看，就知道小程序处于微信开发体系中的哪个位置了。</p>
<h3 id="u5F00_u653E_u5E73_u53F0"><a href="#u5F00_u653E_u5E73_u53F0" class="headerlink" title="开放平台"></a>开放平台</h3><p>开放平台下提供了以下支持：</p>
<ul>
<li><strong>微信账号登录</strong>：让你的应用接入微信账号体系。</li>
<li><strong>微信分享与收藏功能</strong>：这个目前在移动应用特有，可以在 APP 中掉起微信分享与收藏。</li>
<li><strong>微信智能接口</strong>：支持调用微信图像、语音等智能识别接口。</li>
<li><strong>微信支付</strong>：调用微信支付接口</li>
<li><strong>第三方平台</strong>：拥有第三方平台资格之后，就能帮助授权用户实现公众号和小程序的代开发服务了。在公众号红利时代，通过该平台就催生了一大波微信公众账号第三方管理平台。</li>
</ul>
<p>根据目的不同，你可能要申请不同的应用：</p>
<ul>
<li><strong>网站应用</strong></li>
<li><strong>移动应用</strong></li>
<li><strong>第三方平台</strong></li>
</ul>
<h3 id="u516C_u4F17_u5E73_u53F0"><a href="#u516C_u4F17_u5E73_u53F0" class="headerlink" title="公众平台"></a>公众平台</h3><p>微信是 2011 年 1 月推出的，而公众平台是  2012 年 8 月推出的。<br>公众平台的推出，带来了一个继微博之后的新红利时代。大量的企业、媒体、公共机构、明星名人、个人用户都纷纷进军公众平台。<br>需要搞清楚的一个概念是，起初并没有「订阅号」、「服务号」、「企业号」之分。<br>公众平台推出之后，在 2013 年 8 月的时候分成订阅号和服务号，然后在 2014 年 9 月的时候新增了企业号。<br>所以我们所说的「公众号」统称了「订阅号」、「服务号」、「企业号」。</p>
<p>所以我们在公众平台，根据自身情况，申请以下几类账号：</p>
<ul>
<li><strong>订阅号</strong>：偏向提供传播服务，每天可推送一条消息，但是开放的功能相对服务号来说有限。</li>
<li><strong>服务号</strong>：偏向提供功能服务，每月可推送四条消息，开放出了更多高级功能。</li>
<li><strong>企业号</strong>：偏向员工管理。</li>
<li><strong>小程序</strong>：嗯，这就是我们今天的主题。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</li>
</ul>
<h3 id="u5546_u6237_u5E73_u53F0"><a href="#u5546_u6237_u5E73_u53F0" class="headerlink" title="商户平台"></a>商户平台</h3><p>如果你需要拥有微信支付能力，首先要注册商户平台。<br>在拥有微信支付资格之后，除了可以在开发过程中通过接口调用，唤起微信支付以外。<br>在线下还可以实现扫码支付、刷卡支付等场景。</p>
<h2 id="u8D26_u53F7_u4F53_u7CFB"><a href="#u8D26_u53F7_u4F53_u7CFB" class="headerlink" title="账号体系"></a>账号体系</h2><p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/ADD94BAC954A36120ADB41E7A8546FCB.jpg" alt="微信账号体系"></p>
<p>在接入微信账号的时候，在我们申请的应用（网站应用、移动应用、公众号、小程序），对于用户都有一个 OpenID，但是同个用户在多个应用下的 OpenID 是不一样的。<br>而如果想打通多个应用的用户的话，做法就是注册开放平台账号，然后把多个应用绑定到同一个开放平台账号下，这样就能获取 UnionID。</p>
<p>而小程序对于 UnionID 有一个特别注意的地方：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/EB40AFD817F2807B2A1626FACF25FE7C.jpg" alt="UnionID 机制"></p>
<p>小程序中，在绑定同一个开放平台账号的前提下。如果其他相同主体的应用账号被用户授权过之后，在小程序中就无需再次授权，直接获取 UnionID（正常情况下，获取 UnionID 需要用户授权的）。</p>
<h2 id="u76F8_u540C_u4E3B_u4F53"><a href="#u76F8_u540C_u4E3B_u4F53" class="headerlink" title="相同主体"></a>相同主体</h2><p>那么「相同主体」是什么概念？<br>在我们注册应用之后，要真正部署到线上之前，都需要进行「认证主体」的步骤。<br>对于个人来说，主体就是你本人，通过身份证标记唯一性。<br>而对于企业来说，主体就是企业本身，通过营业执照来标记唯一性。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/0ABA321D4E60DC52F7B7F9DB8D444B6C.jpg" alt="相同主体"></p>
<p>在任何一个以上线的公众号或者小程序中的详细信息，都可以查看得到本体信息。</p>
<h1 id="u5FAE_u4FE1_u5C0F_u7A0B_u5E8F_u7684_u80FD_u529B"><a href="#u5FAE_u4FE1_u5C0F_u7A0B_u5E8F_u7684_u80FD_u529B" class="headerlink" title="微信小程序的能力"></a>微信小程序的能力</h1><p>从 2016 年底发布的小程序，在 2017 年快速推进，每个月都会有迭代，而且大部分更新发布的时间都在凌晨。<br>在此心痛微信小程序团队 10 秒钟。<br>然后我们从截止 8月18日 回顾将近一年的时间，小程序的更新迭代来感受小程序具备哪些能力。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/2EC3DDD2B7877249747FB6CADE85C9C4.png" alt="小程序更新回顾"></p>
<h1 id="u6570_u636E_u5206_u6790"><a href="#u6570_u636E_u5206_u6790" class="headerlink" title="数据分析"></a>数据分析</h1><p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/1951C347D0577BA466B972987B288CAE.png" alt="数据分析"></p>
<p>对于数据分析的需求，其实我们可以有很多选择。</p>
<p><strong>【小程序后台】</strong><br>在小程序的后台，除了可以看到常见维度的访问数据以外，还支持收集自定义事件。<br>并且还提供了 API，我们就可以在内部的管理后台中收集这些数据，进行分析和展示。</p>
<p><strong>【官方小程序】</strong><br>我们可以在微信的小程序入口搜索：《小程序数据助手》<br>这是官方开发的在移动端查看小程序运营数据的小程序。</p>
<p><strong>【第三方平台】</strong><br>以下是收集的一些提供数据相关服务的第三方平台 (还没有验证可用性，需要自行判断)：</p>
<ul>
<li><a href="https://www.talkingdata.com/" target="_blank" rel="external">TalkingData</a></li>
<li><a href="http://www.aldwx.com/" target="_blank" rel="external">阿拉丁</a></li>
<li>友盟：目前还找不到支持微信小程序的 SDK。</li>
</ul>
<p><strong>【数据埋点】</strong><br>对于数据埋点需求，以下是收集的一些 Saas 服务(还没有验证可用性，需要自行判断)：</p>
<ul>
<li><a href="http://developer.qq.com/wiki/mta/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5.html" target="_blank" rel="external">腾讯 MTA</a></li>
<li><a href="https://growingio.kf5.com/hc/kb/section/1007183/" target="_blank" rel="external">GrowingIO</a></li>
</ul>
<h1 id="u793E_u533A_u4E0E_u8D44_u6E90"><a href="#u793E_u533A_u4E0E_u8D44_u6E90" class="headerlink" title="社区与资源"></a>社区与资源</h1><p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/yz-share-about-wxapp--cencept/9628CBA157FD3EBF8DA6AD6E63D574AB.png" alt="资源"></p>
<p>我们需要关注小程序生态圈的动态，通过关注一些媒体、社区，是很有用的。</p>
<ul>
<li><a href="https://github.com/justjavac/awesome-wechat-weapp" target="_blank" rel="external">awesome-wxapp</a>: justjavac 创建的 github 仓库，收集了大量有关小程序的资源。</li>
<li>知晓程序：是爱范儿旗下专注小程序生态的品牌，会提供很多不错的小程序咨询。</li>
<li><a href="http://www.wxapp-union.com/" target="_blank" rel="external">微信小程序联盟</a>：一个社区网站，有大量的技术教程，以及众多开发者遇到的坑。</li>
<li><a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=1504102317" target="_blank" rel="external">官方文档</a>：再者就是微信的官方文档了。讲真，这是看过微信中最良心的开发文档。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 2016 年 9 月 23 日 微信小程序内测开始以来，有赞的产品与技术一直紧跟着小程序的步伐。并且在 2017年1月9日 微信小程序发布的同时上线了有赞微商城小程序和有赞精选小程序。并且紧跟着开源了小程序的 UI 库：&lt;a href=&quot;https://github.c
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="小程序" scheme="http://huang-jerryc.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>加深对 JavaScript This 的理解</title>
    <link href="http://huang-jerryc.com/2017/07/15/understand-this-of-javascript/"/>
    <id>http://huang-jerryc.com/2017/07/15/understand-this-of-javascript/</id>
    <published>2017-07-15T02:40:00.000Z</published>
    <updated>2017-07-16T03:54:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>我相信你已经看过很多关于 JavaScript 的 <code>this</code>  的谈论了，既然你点进来了，不妨继续看下去，看是否能帮你加深对 <code>this</code> 的理解。</p>
<p>最近在看 <a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="external">《You Dont Know JS》</a> 这本书，不得感叹，就算用了 JS 很多年的老前端来看这本书，我觉得还是会有不少的收获。</p>
<p>其中关于 <code>this</code> 的讲解，更是加深了我对 <code>this</code> 的理解，故整理知识点，再加上自身的理解，以自己的语言来描述。<br>对读者来说，算是二手知识，这本书是开源的，可以到本书的 Github 项目地址学习一手的知识。</p>
<p>首先有一句大家都明白的话，我还是要强调一遍：<br><strong>「<code>this</code> 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。」</strong></p>
<p>这句话很重要，这是理解 <code>this</code> 原理的基础。<br>而在讲解 <code>this</code> 之前，先要理解一下作用域的相关概念。</p>
<h1 id="u300C_u8BCD_u6CD5_u4F5C_u7528_u57DF_u300D_u4E0E_u300C_u52A8_u6001_u4F5C_u7528_u57DF_u300D"><a href="#u300C_u8BCD_u6CD5_u4F5C_u7528_u57DF_u300D_u4E0E_u300C_u52A8_u6001_u4F5C_u7528_u57DF_u300D" class="headerlink" title="「词法作用域」与「动态作用域」"></a>「词法作用域」与「动态作用域」</h1><p>通常来说，作用域一共有两种主要的工作模型。</p>
<ul>
<li>词法作用域</li>
<li>动态作用域</li>
</ul>
<p>词法作用域是大多数编程语言所采用的模式，而动态作用域仍有一些编程语言在用，例如 Bash 脚本。<br>而 JavaScript 就是采用的词法作用域，也就是在编程阶段，作用域就已经明确下来了。</p>
<p>思考下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);   <span class="comment">// 输出 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>
<p>因为 JavaScript 所用的是词法作用域，自然 <code>foo()</code> 声明的阶段，就已经确定了变量 <code>a</code> 的作用域了。</p>
<p>倘若，JavaScript 是采用的动态作用域，<code>foo()</code> 中打印的将是 <code>3</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);   <span class="comment">// 输出 3 （不是 2）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>
<p>而 JavaScript 的 <code>this</code> 机制跟动态作用域很相似，是在运行时在被调用的地方动态绑定的。</p>
<h1 id="this__u7684_u56DB_u79CD_u7ED1_u5B9A_u89C4_u5219"><a href="#this__u7684_u56DB_u79CD_u7ED1_u5B9A_u89C4_u5219" class="headerlink" title="this 的四种绑定规则"></a>this 的四种绑定规则</h1><p>在 JavaScript 中，影响 this 指向的绑定规则有四种：</p>
<ul>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>显式绑定</li>
<li>new 绑定</li>
</ul>
<h2 id="u9ED8_u8BA4_u7ED1_u5B9A"><a href="#u9ED8_u8BA4_u7ED1_u5B9A" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>这是最直接的一种方式，就是不加任何的修饰符直接调用函数，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)   <span class="comment">// 输出 a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;  <span class="comment">//  变量声明到全局对象中</span></span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>使用 <code>var</code> 声明的变量 <code>a</code>，被绑定到全局对象中，如果是浏览器，则是在 <code>window</code> 对象。<br><code>foo()</code> 调用时，引用了默认绑定，<code>this</code> 指向了全局对象。</p>
<h2 id="u9690_u5F0F_u7ED1_u5B9A"><a href="#u9690_u5F0F_u7ED1_u5B9A" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>这种情况会发生在调用位置存在「上下文对象」的情况，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.foo();   <span class="comment">// 输出 1</span></span><br><span class="line">obj2.foo();   <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>
<p>当函数调用的时候，拥有上下文对象的时候，<code>this</code> 会被绑定到该上下文对象。<br>正如上面的代码，<br><code>obj1.foo()</code> 被调用时，<code>this</code> 绑定到了 <code>obj1</code>,<br>而 <code>obj2.foo()</code> 被调用时，<code>this</code> 绑定到了 <code>obj2</code>。</p>
<h2 id="u663E_u5F0F_u7ED1_u5B9A"><a href="#u663E_u5F0F_u7ED1_u5B9A" class="headerlink" title="显式绑定"></a>显式绑定</h2><p>这种就是使用 <code>Function.prototype</code> 中的三个方法 <code>call()</code>, <code>apply()</code>, <code>bind()</code> 了。<br>这三个函数，都可以改变函数的 <code>this</code> 指向到指定的对象，<br>不同之处在于，<code>call()</code> 和 <code>apply()</code> 是立即执行函数，并且接受的参数的形式不同：</p>
<ul>
<li><code>call(this, arg1, arg2, ...)</code></li>
<li><code>apply(this, [arg1, arg2, ...])</code></li>
</ul>
<p>而 <code>bind()</code> 则是创建一个新的包装函数，并且返回，而不是立刻执行。</p>
<ul>
<li><code>bind(this, arg1, arg2, ...)</code></li>
</ul>
<p><code>apply()</code> 接收参数的形式，有助于函数嵌套函数的时候，把 <code>arguments</code> 变量传递到下一层函数中。</p>
<p>思考下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);  <span class="comment">// 输出 1</span></span><br><span class="line">  bar.apply(&#123;a: <span class="number">2</span>&#125;, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a + b);  <span class="comment">// 输出 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">foo(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>foo()</code> 内部的 <code>this</code> 遵循默认绑定规则，绑定到全局变量中。<br>而 <code>bar()</code> 在调用的时候，调用了 <code>apply()</code> 函数，把 <code>this</code> 绑定到了一个新的对象中 <code>{a: 2}</code>，而且原封不动的接收 <code>foo()</code> 接收的函数。</p>
<h2 id="new__u7ED1_u5B9A"><a href="#new__u7ED1_u5B9A" class="headerlink" title="new 绑定"></a>new 绑定</h2><p>最后一种，则是使用 <code>new</code> 操作符会产生 <code>this</code> 的绑定。<br>在理解 <code>new</code> 操作符对 <code>this</code> 的影响，首先要理解 <code>new</code> 的原理。<br>在 JavaScript 中，<code>new</code> 操作符并不像其他面向对象的语言一样，而是一种模拟出来的机制。<br>在 JavaScript 中，所有的函数都可以被 <code>new</code> 调用，这时候这个函数一般会被称为「构造函数」，实际上并不存在所谓「构造函数」，更确切的理解应该是对于函数的「构造调用」。</p>
<p>使用 <code>new</code> 来调用函数，会自动执行下面操作：</p>
<ol>
<li>创建一个全新的对象。</li>
<li>这个新对象会被执行 [[Prototype]] 连接。</li>
<li>这个新对象会绑定到函数调用的 this。</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li>
</ol>
<p>所以如果 <code>new</code> 是一个函数的话，会是这样子的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">Constructor, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;   <span class="comment">// 创建一个新对象</span></span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(obj, Constructor.prototype);  <span class="comment">// 连接新对象与函数的原型</span></span><br><span class="line">    <span class="keyword">return</span> Constructor.apply(obj, args) || obj;   <span class="comment">// 执行函数，改变 this 指向新的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">New(Foo, <span class="number">1</span>);  <span class="comment">// Foo &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>
<p>所以，在使用 <code>new</code> 来调用函数时候，我们会构造一个新对象并把它绑定到函数调用中的 <code>this</code> 上。</p>
<h1 id="u4F18_u5148_u7EA7"><a href="#u4F18_u5148_u7EA7" class="headerlink" title="优先级"></a>优先级</h1><p>如果一个位置发生了多条改变 this 的规则，那么优先级是如何的呢？</p>
<p>看几段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式绑定 &gt; 隐式绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.foo();     <span class="comment">// 输出 2</span></span><br><span class="line">obj1.foo.call(&#123;a: <span class="number">1</span>&#125;);      <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>
<p>这说明「显式绑定」的优先级大于「隐式绑定」</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 绑定 &gt; 显式绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = foo.bind(obj1);</span><br><span class="line">bar(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// 输出 &#123;a:2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="keyword">new</span> bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// 输出 &#123;a:2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// 输出 foo &#123; a: 3 &#125;</span></span><br></pre></td></tr></table></figure>
<p>这说明「new 绑定」的优先级大于「显式绑定」<br>而「默认绑定」，毫无疑问是优先级最低的。<br>所以优先级顺序为：</p>
<p><strong>「new 绑定」 &gt; 「显式绑定」 &gt; 「隐式绑定」 &gt; 「默认绑定。」</strong></p>
<h1 id="u6240_u4EE5_uFF0Cthis__u5230_u5E95_u662F_u4EC0_u4E48"><a href="#u6240_u4EE5_uFF0Cthis__u5230_u5E95_u662F_u4EC0_u4E48" class="headerlink" title="所以，this 到底是什么"></a>所以，this 到底是什么</h1><p><code>this</code> 并不是在编写的时候绑定的，而是在运行时绑定的。它的上下文取决于函数调用时的各种条件。<br><code>this</code> 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。<br>当一个函数被调用时，会创建一个「执行上下文」，这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。<code>this</code> 就是这个记录的一个属性，会在函数执行的过程中用到。</p>
<h1 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes" target="_blank" rel="external">《You Dont Know JS》- this &amp; Object Prototypes</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我相信你已经看过很多关于 JavaScript 的 &lt;code&gt;this&lt;/code&gt;  的谈论了，既然你点进来了，不妨继续看下去，看是否能帮你加深对 &lt;code&gt;this&lt;/code&gt; 的理解。&lt;/p&gt;
&lt;p&gt;最近在看 &lt;a href=&quot;https://github.co
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="javascript" scheme="http://huang-jerryc.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>谈谈像素以及微信小程序的 rpx</title>
    <link href="http://huang-jerryc.com/2017/05/21/talk-about-pixel-and-rpx/"/>
    <id>http://huang-jerryc.com/2017/05/21/talk-about-pixel-and-rpx/</id>
    <published>2017-05-21T06:21:25.000Z</published>
    <updated>2020-07-21T08:12:37.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>最近在负责有赞的某个业务的微信小程序开发，这是我第一次着手微信小程序的开发，这个过程中发现微信小程序所定义的一套 WXSS (WeiXin Style Sheets) 中有一个有趣的长度单位 <code>rpx</code>，即 responsive pixel。<br>根据官方的描述：</p>
<blockquote>
<p>rpx（responsive pixel）， 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p>
</blockquote>
<p>平时我们一般会用 <code>em</code> 或者 <code>rem</code> 来做屏幕适配，而在微信小程序中，可以方便的借助 <code>rpx</code> 来完成这项工作。</p>
<p>那么怎么理解 <code>rpx</code>，还有它与 <code>px</code> 之间什么关系？什么是物理像素？<br>为了更好理解 <code>rpx</code>，我打算聊聊下面的一些概念：</p>
<ol>
<li>像素 (Pixel)</li>
<li>PPI (Pixels per inch 每英尺像素)</li>
<li>DPR (Device pixel ratio)</li>
</ol>
<h1 id="u50CF_u7D20"><a href="#u50CF_u7D20" class="headerlink" title="像素"></a>像素</h1><p>像素，英文单词：pixel，是英语单词 「picture」 的简写 「pix」，加上 「element」 的简写 「el」，合成的词汇，表示「图像元素」的意思。<br>一个像素只能表达一个色块，是显示的最小的一个单元。</p>
<p>而在我们写代码的时候，可以把像素分为两种：</p>
<ol>
<li>物理像素 Physical pixels</li>
<li>逻辑像素 Logical pixels</li>
</ol>
<h2 id="u7269_u7406_u50CF_u7D20"><a href="#u7269_u7406_u50CF_u7D20" class="headerlink" title="物理像素"></a>物理像素</h2><p>也被称为设备像素 (Device independent pixels)，即设备在出厂的时候就已经固定了像素。</p>
<p>我们来看一下 iPhone6 (左图) 与 iPhone6 plus (右图) 的官方显示屏的规格说明：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/518488434BEC1074B675EB42A5A57AEF.png" alt="iPhone6 &amp; iPhone6 plus 规格"></p>
<p>iPhone6 是 <code>1334px x 750px</code> 的像素分辨率，意思是当手机竖放的时候，横向有 750 个物理像素，纵向有 1334 个物理像素。</p>
<h2 id="u903B_u8F91_u50CF_u7D20"><a href="#u903B_u8F91_u50CF_u7D20" class="headerlink" title="逻辑像素"></a>逻辑像素</h2><p>在 CSS 中也被称为 CSS 像素 (CSS pixels)，是为 Web 开发者创造的，在 CSS 和 JavaScript 中使用的一个抽象的层，每一个 CSS 声明和几乎所有的 Javascript 属性都使用 CSS 像素。</p>
<p>例如我们平时使用 Chrome 的设备调试工具的时候，iPhone6 是高 <code>667px</code>，宽是 <code>375px</code>，与苹果官方的 <code>1334px x 750px</code>，长宽分别少了 2 倍，那么面积就少了 4 倍。这就是经常说的 Retina 屏幕用四个(物理)像素表示一个(逻辑)像素。</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/9C4CD0061C94690AF81DB8DED8F71252.png" alt="Chrome 下 iPhone6 逻辑像素"></p>
<h1 id="PPI"><a href="#PPI" class="headerlink" title="PPI"></a>PPI</h1><p>Pixels per inch，每英寸像素，也被称为像素密度，意思是一英寸中有多少个物理像素。<br>其中 1英寸 (inch) = 2.54厘米 (cm)。</p>
<p>回顾一下上面的 iPhone6 和 iPhone6 plus 的官方规格说明图，其中有 <code>ppi</code> 这一项，iPhone6 是 <code>326ppi</code>，iphone6 plus 是 <code>401ppi</code>。</p>
<h2 id="PPI__u600E_u4E48_u7B97_u51FA_u6765_u7684_uFF1F"><a href="#PPI__u600E_u4E48_u7B97_u51FA_u6765_u7684_uFF1F" class="headerlink" title="PPI 怎么算出来的？"></a>PPI 怎么算出来的？</h2><p>要计算显示器的每英寸像素值，首先要确定屏幕的尺寸和分辨率。<br>PPI 计算公式：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/855BB6047CE2CA7F9DBBF1791D52C6CC.gif" alt="PPI 计算公式"></p>
<p>其中，</p>
<ul>
<li>dp (device pixel) 为屏幕对角线的分辨率</li>
<li>wp (width pixel) 为屏幕横向分辨率</li>
<li>hp (height piexl) 为屏幕纵向分辨率</li>
<li>di (device inch) 为屏幕对角线的长度(单位为英寸)。</li>
</ul>
<p>以 iPhone6 为例：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/2A67EB1D8C0873E419C676DB430570C2.gif" alt="iPhone6 PPI 计算"></p>
<p>四舍五入那便是 <code>326ppi</code> 了。</p>
<h2 id="u7269_u7406_u50CF_u7D20_u6709_u591A_u5927_uFF1F"><a href="#u7269_u7406_u50CF_u7D20_u6709_u591A_u5927_uFF1F" class="headerlink" title="物理像素有多大？"></a>物理像素有多大？</h2><p>「物理像素」是有特定长度的，这取决于 ppi 值。</p>
<p>那么如何求出一个设备的物理像素的长度？<br>因为绝大多数设备的物理像素都是方形的，我们可以假设当前设备的像素是方形的。<br>那么，</p>
<ul>
<li>iPhone6 中每个像素长度：1inch / 326ppi ≈ 0.003 inch = 0.0762mm</li>
<li>iPhone6 plus 中每个像素长度：1inch / 401ppi ≈ 0.002 inch = 0.0508mm</li>
</ul>
<p>可以看出 iPhone6 plus 的屏幕制作工艺更加精细。<br>因为像素越小，那么单位面积内像素点就越多，显示的效果人眼就越难看出毛刺。<br>用来显示一份图像的像素越多，效果就越接近现实。</p>
<p>和物理像素不同，「逻辑像素」没有特定的物理长度的，只是表示显示设备中最小的显示单元，优秀的显示设备完全可以把显示单元做的更加小，以达到更好的显示效果。</p>
<h1 id="DPR"><a href="#DPR" class="headerlink" title="DPR"></a>DPR</h1><p>Device Pixel Ratio，设备像素比。</p>
<p>在早先的移动设备中，并没有 DPR 的概念。随着技术的发展，移动设备的屏幕像素密度越来越高。<br>从 iPhone4 开始，苹果公司推出了所谓的 Retina 视网膜屏幕。之所以叫做视网膜屏幕，是因为屏幕的 PPI 太高，人的视网膜无法分辨出屏幕上的像素点。<br>iPhone4 的分辨率提高了一倍，但屏幕尺寸却没有变化，这意味着同样大小的屏幕上，像素多了一倍，于是 <code>dpr = 2</code>。</p>
<p>在 Chrome 浏览器可以通过以下代码获取设备的 DPR：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let dpr = window.devicePixelRatio;</span><br></pre></td></tr></table></figure>
<p>而通过下面的代码可以获取设备的逻辑像素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let logicalHeight = screen.height;&#10;let logicalWidth = screen.width;</span><br></pre></td></tr></table></figure>
<p>那么很多人看到这里，就会认为：<code>物理像素 = 逻辑像素 * dpr</code><br>但实际情况并不是这样，<br>留意一下 iPhone6 plus 的物理像素和逻辑像素：</p>
<ul>
<li>物理像素：<code>1080px x 1920px</code></li>
<li>逻辑像素：<code>414px x 736px</code></li>
</ul>
<p>而官方声称 iPhone6 plus 的 <code>dpr = 3</code>，按理应该是：</p>
<ul>
<li><code>414px x 736px</code> → 乘以 3 倍 dpr → <code>1242px x 2208px</code></li>
</ul>
<p>那么 iPhone6 plus 只有 <code>1080px x 1920px</code>，怎么去展示 <code>1241px x 2208px</code> 的分辨率呢？</p>
<p>原来 iPhone6 plus 对逻辑像素做了缩小处理，以适应物理像素，也就是<br><code>1241px x 2208px</code> 除以 <code>115%</code> ，得到 <code>1080px x 1920px</code>。</p>
<p>换句话来说，本来 iPhone6 plus 的 <code>dpr = 2.6</code>，但是通过虚拟技术把物理像素放大 115% ，以达到 <code>dpr = 3</code> 的效果。</p>
<p>所以说是假 3 倍 dpr，其实我们开发和设计的时候也不用管这个，当作它就是 3 倍 dpr 就好了。</p>
<h1 id="u56DE_u5230_rpx"><a href="#u56DE_u5230_rpx" class="headerlink" title="回到 rpx"></a>回到 rpx</h1><p>根据官方给出的 rpx 换算 px 的实例：<br><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/talk-about-pixel-and-rpx/ACED349F80C8D926AB74922C360B2F5A.png" alt="rpx 换算 px"></p>
<p>三款机器的逻辑像素：</p>
<ul>
<li>iPhone5 : <code>320px x 568px</code></li>
<li>iPhone6 : <code>375px x 667px</code></li>
<li>iPhone6 plus : <code>414px x 736px</code></li>
</ul>
<p>rpx 转换成 px 是需要乘以一个系数的：</p>
<ul>
<li><code>px = rpx * n</code></li>
</ul>
<p>其中系数 n，是跟着设备改变的：</p>
<ul>
<li>iPhone5: <code>n = 2.34</code></li>
<li>iPhone6: <code>n = 2</code></li>
<li>iPhone6 plus: <code>n = 1.81</code></li>
</ul>
<p>所以 rpx 只是定义一个绝对值 750 宽度，然后简单的根据不同设备的逻辑像素来进行 rpx 到 px 的换算。</p>
<p>精明的观众可能发现了， rpx 压根就不需要关心 DPR 和 PPI 的概念。<br>呃，其实我就是在理解 rpx 的过程中，拦不住思维的发散，了解了一大堆概念，然后顺道给你们分享一下罢了。</p>
<h1 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.wikiwand.com/zh-sg/%E5%83%8F%E7%B4%A0" target="_blank" rel="external">Wiki - 像素</a><br><a href="https://www.wikiwand.com/zh-sg/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0" target="_blank" rel="external">Wiki - 每英寸像素</a><br><a href="https://www.paintcodeapp.com/news/iphone-6-screens-demystified" target="_blank" rel="external">iPhone 6 Screens Demystified</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在负责有赞的某个业务的微信小程序开发，这是我第一次着手微信小程序的开发，这个过程中发现微信小程序所定
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="前端" scheme="http://huang-jerryc.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2017 第一季度复盘</title>
    <link href="http://huang-jerryc.com/2017/05/04/reconsidering-for-2017-Q1/"/>
    <id>http://huang-jerryc.com/2017/05/04/reconsidering-for-2017-Q1/</id>
    <published>2017-05-03T16:33:02.000Z</published>
    <updated>2018-05-01T16:16:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The_Past"><a href="#The_Past" class="headerlink" title="The Past"></a>The Past</h1><ol>
<li><a href="https://github.com/JerryC8080/Memeye" target="_blank" rel="external">Memeye</a> 终于开源了，到目前为止已经有 153 个 star 了，但是后续没有再维护了，打算等我学完 Vue 以及对前端更加熟练之后，对前端部分进行重构，使得界面更加流畅。</li>
<li>输出文章九篇，其中八篇技术文。</li>
<li>输出了一本小书：「<a href="https://github.com/JerryC8080/understand-tcp-udp" target="_blank" rel="external">理解 TCP 和 UDP</a>」，这是我在复习计算机网络的产物，有幸能拿到 123 star （数字很特别）。</li>
<li>从魅族离职，入职有赞，换了个 Title，从「NodeJS 工程师」到「前端工程师」，这是很符合我个人的发展计划的，以 JS 栈为主的全栈道路。当然，前提需要是一个优秀的软件工程师。</li>
</ol>
<p>可惜的是，2017年的开头没有好好整理今年的目标。<br>记得有句话很深刻：「人生中最适合的时机有两个，一个是十年前，一个是现在」<br>虽然过了三分之一了，但现在计划，还来得及。</p>
<h1 id="The_Next"><a href="#The_Next" class="headerlink" title="The Next"></a>The Next</h1><p>希望到了 2018 年的自己：</p>
<ol>
<li><strong>Target</strong>: 能解决大部分前端业务上的开发<ol>
<li>深入前端，补足前端基础，包括 CSS、HTML5、ReactJS、Vue2，移动端开发</li>
<li>学习设计理论、色彩理论、看更多的优秀设计。</li>
<li>寻找设计领域比较好的读物，给读完。</li>
</ol>
</li>
<li><strong>Target</strong>: 在社区有更加多的影响力<ol>
<li>全年至少产出文章 12 - 20 篇</li>
<li>拥有一个 300 star 的开源项目</li>
<li>影响所在团队，逐渐营造技术氛围</li>
</ol>
</li>
<li><strong>Target</strong>: 持续扎实基础实力<ol>
<li>《鸟哥的Linux私房菜》</li>
<li>《设计模式》</li>
<li>《深入理解计算机操作系统》</li>
<li>《深入浅出 NodeJS》、《NodeJS 硬实战》、《Security Your NodeJS Application》</li>
<li>《高性能MySQL》</li>
<li>《CSS 权威指南》、《CSS 揭秘》</li>
<li>《Redis 设计与实现》、《Redis 实战》</li>
<li>《你不知道的 JavaScript》</li>
</ol>
</li>
<li><strong>Target</strong>: 具有敏捷开发的实践经验<ol>
<li>团队沟通</li>
<li>文档沉淀</li>
<li>影响力输出</li>
<li>代码质量</li>
<li>稳定交付</li>
<li>快速迭代流程</li>
</ol>
</li>
<li><strong>Target</strong>: 拓展自身的技术视野<ol>
<li>学习 Python，感受社区</li>
<li>学习 Go，感受社区</li>
</ol>
</li>
<li><strong>Target</strong>: 技术之外<ol>
<li>《软技能》</li>
<li>《浪潮之巅》一二册</li>
<li>《暗时间》第二次阅读</li>
<li>《如何阅读一本书》</li>
</ol>
</li>
</ol>
<p>共勉。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;The_Past&quot;&gt;&lt;a href=&quot;#The_Past&quot; class=&quot;headerlink&quot; title=&quot;The Past&quot;&gt;&lt;/a&gt;The Past&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/JerryC8080/M
    
    </summary>
    
      <category term="三省吾身" scheme="http://huang-jerryc.com/categories/%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>一款 NodeJS 轻量级内存监控工具</title>
    <link href="http://huang-jerryc.com/2017/03/17/the-memeye/"/>
    <id>http://huang-jerryc.com/2017/03/17/the-memeye/</id>
    <published>2017-03-17T07:17:38.000Z</published>
    <updated>2019-07-17T13:52:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Memeye"><a href="#Memeye" class="headerlink" title="Memeye"></a><a href="https://github.com/JerryC8080/Memeye" target="_blank" rel="external">Memeye</a></h1><p>Github 链接：<a href="https://github.com/JerryC8080/Memeye" target="_blank" rel="external">https://github.com/JerryC8080/Memeye</a></p>
<p>Memeye 是一个轻量级的 NodeJS 进程监控工具，它提供 进程内存、V8 堆空间内存、操作系统内存 三大维度的数据可视化展示。<br>前端部分，借助 <a href="https://github.com/vuejs/vue" target="_blank" rel="external">Vue2</a> 和 <a href="https://github.com/chartjs/Chart.js" target="_blank" rel="external">ChartJS</a> 提供了一个不错的动态展示面板。<br>Memeye 在宿主进程中，只植入了一个简单的数据收集器，其他工作则启动一个子进程，交由子进程来进行。<br>这样做能把 Memeye 的代码对宿主进程的影响降到最低，以确保数据的真实性。    </p>
<h3 id="u7279_u70B9"><a href="#u7279_u70B9" class="headerlink" title="特点"></a>特点</h3><ul>
<li>轻量级</li>
<li>简单</li>
<li>面向开发环境</li>
<li>可视化</li>
</ul>
<p><em>Note: Memeye 暂时只支持单进程，NodeJS 分布式进程还不适用，所以不建议在产品环境使用。</em></p>
<h1 id="u52A8_u673A"><a href="#u52A8_u673A" class="headerlink" title="动机"></a>动机</h1><p>总所周知，NodeJS 对内存是很敏感的。在去年 4 月我用 NodeJS 做的一个营销性的项目，在上线当天 PV 突破了 100W。<br>其中内存就呈现出持续上涨趋势，在排查问题的过程中，想寻找一个轻量级的，只要可视化的呈现内存使用情况的工具，无果。<br>然后就有了这个项目的想法，但当时由于繁忙只做出了一个 Demo 级别的，简单能用就发布了。<br>最近有时间，再次翻出来，重构改版，增加更多维度的数据展示。    </p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><a href="http://jerryc8080.github.io/Memeye/" target="_blank" rel="external">See preview demo</a> (也许需要翻墙)</p>
<h1 id="u517C_u5BB9_u6027"><a href="#u517C_u5BB9_u6027" class="headerlink" title="兼容性"></a>兼容性</h1><ul>
<li>Node v7.x</li>
<li>Node v6.x</li>
</ul>
<h1 id="u5B89_u88C5__26amp_3B__u4F7F_u7528"><a href="#u5B89_u88C5__26amp_3B__u4F7F_u7528" class="headerlink" title="安装 &amp; 使用"></a>安装 &amp; 使用</h1><p>运行下面命令安装 : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install memeye --save-dev</span><br></pre></td></tr></table></figure>
<p>然后在你的代码中引入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const memeye = require(&#39;memeye&#39;);&#10;memeye();</span><br></pre></td></tr></table></figure>
<p>最后打开你的浏览器，输入下面地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:23333  //23333 port by defaul.</span><br></pre></td></tr></table></figure>
<p>就这么简单！</p>
<h1 id="Memeye__u662F_u5982_u4F55_u5DE5_u4F5C_u7684"><a href="#Memeye__u662F_u5982_u4F55_u5DE5_u4F5C_u7684" class="headerlink" title="Memeye 是如何工作的"></a>Memeye 是如何工作的</h1><p>Memeye 有三个核心概念：Collector, Indicators, Dashboard。<br>Collector 运行在宿主进程中（你的NodeJS进程），Indicator 和 Dashboard 运行在子进程中，这样可以尽量减少 Memeye 代码对你的宿主进程的影响。    </p>
<h2 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h2><p>Collector 会监听宿主进程，并且收集数据，然后通过 IPC 通信管道发送数据给子进程，交由子进程处理。    </p>
<h2 id="Indicator"><a href="#Indicator" class="headerlink" title="Indicator"></a>Indicator</h2><p>Indicator 像一个状态机。当它的属性变化的时候，会触发相应事件。所以我们可以用它来处理收集回来的数据。    </p>
<h2 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h2><p>Dashboard 会以子进程的形式唤起。他会创建一个 Indicator 实例，以及启动一个集成 socket.io 的 Http 服务器。<br>然后绑定 Indicator 和进程通信管道，以接收父进程发过来的数据。<br>最后再绑定 Indicator 和 socket.io，这样可以在 Indicator 属性变化的时候发送数据给前端。    </p>
<p>##Collector, Indicator, Dashboard 之间的通信</p>
<p><img src="(https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190717214117.jpg" alt="commication.jpeg"></p>
<h1 id="u9884_u89C8"><a href="#u9884_u89C8" class="headerlink" title="预览"></a>预览</h1><p><img src="https://raw.githubusercontent.com/JerryC8080/figure-bed/master/img/20190717214216.jpeg" alt="预览"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Memeye&quot;&gt;&lt;a href=&quot;#Memeye&quot; class=&quot;headerlink&quot; title=&quot;Memeye&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/JerryC8080/Memeye&quot; target=&quot;_blank&quot; rel=&quot;
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="Javascript" scheme="http://huang-jerryc.com/tags/Javascript/"/>
    
      <category term="Nodejs" scheme="http://huang-jerryc.com/tags/Nodejs/"/>
    
      <category term="SOAP" scheme="http://huang-jerryc.com/tags/SOAP/"/>
    
  </entry>
  
  <entry>
    <title>理解UDP</title>
    <link href="http://huang-jerryc.com/2017/03/02/understand-udp/"/>
    <id>http://huang-jerryc.com/2017/03/02/understand-udp/</id>
    <published>2017-03-02T08:02:25.000Z</published>
    <updated>2020-07-21T08:12:37.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>更好阅读体验：<a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/" target="_blank" rel="external">《理解 TCP 和 UDP》— By Gitbook</a>    </p>
</blockquote>
<h1 id="UDP__u548C_TCP__u7684_u4E0D_u540C"><a href="#UDP__u548C_TCP__u7684_u4E0D_u540C" class="headerlink" title="UDP 和 TCP 的不同"></a>UDP 和 TCP 的不同</h1><p>TCP 在传送数据之前必须先建立连接，数据传送结束后要释放连接。<br>TCP 不提供广播或多播服务，由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。    </p>
<p>而 UDP 在传送数据之前不需要先建立连接。接收方收到 UDP 报文之后，不需要给出任何确认。<br>虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。    </p>
<p>简单来说就是：</p>
<p><strong>UDP：单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序；</strong></p>
<p><strong>TCP：流式，需要建立连接，复杂，可靠 ，有序。</strong></p>
<h1 id="UDP__u6982_u8FF0"><a href="#UDP__u6982_u8FF0" class="headerlink" title="UDP 概述"></a>UDP 概述</h1><p>UDP 全称 User Datagram Protocol, 与 TCP 同是在网络模型中的传输层的协议。</p>
<p><strong>UDP 的主要特点是：</strong></p>
<ol>
<li><strong>无连接的</strong>，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li>
<li><strong>不保证可靠交付</strong>，因此主机不需要为此复杂的连接状态表</li>
<li><strong>面向报文的</strong>，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。</li>
<li><strong>没有阻塞控制</strong>，因此网络出现的拥塞不会使发送方的发送速率降低。</li>
<li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>，也即是提供广播和多播的功能。</li>
<li><strong>首部开销小</strong>，首部只有 8 个字节，分为四部分。</li>
</ol>
<p><strong>UDP 的常用场景：</strong></p>
<ol>
<li>名字转换（DNS）</li>
<li>文件传送（TFTP）</li>
<li>路由选择协议（RIP）</li>
<li>IP 地址配置（BOOTP，DHTP）</li>
<li>网络管理（SNMP）</li>
<li>远程文件服务（NFS）</li>
<li>IP 电话</li>
<li>流式多媒体通信</li>
</ol>
<h1 id="UDP__u62A5_u6587_u7ED3_u6784"><a href="#UDP__u62A5_u6587_u7ED3_u6784" class="headerlink" title="UDP 报文结构"></a>UDP 报文结构</h1><p>UDP 数据报分为数据字段和首部字段。<br>首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/6FCC9F4EDE80F784BD11ED9FA76FA375.png" alt="UDP  数据报结构.png"></p>
<p><strong>首部各字段意义</strong>：</p>
<ol>
<li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要时可全 0.</li>
<li><strong>目的端口</strong>：目的端口号，在终点交付报文时必须要使用到。</li>
<li><strong>长度</strong>：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。</li>
<li><strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。</li>
</ol>
<h1 id="UDP__u5982_u4F55_u8FDB_u884C_u6821_u9A8C_u548C"><a href="#UDP__u5982_u4F55_u8FDB_u884C_u6821_u9A8C_u548C" class="headerlink" title="UDP 如何进行校验和"></a>UDP 如何进行校验和</h1><h2 id="u4F2A_u9996_u90E8"><a href="#u4F2A_u9996_u90E8" class="headerlink" title="伪首部"></a>伪首部</h2><p>UDP 数据报首部中检验和的计算方法比较特殊。<br>在计算检验和时，要在数据报之前增加 12 个字节的伪首部，用来计算校验和。<br>伪首部并不是数据报真正的首部，是为了计算校验和而临时添加在数据报前面的，在真正传输的时候并不会把伪首部一并发送。    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/3D9C291187835C3571A111952201B4FF.png" alt="UDP 数据报结构-伪首部.png"></p>
<p><strong>伪首部个字段意义</strong>：</p>
<ol>
<li>第一字段，源 IP 地址</li>
<li>第二字段，目的 IP 地址</li>
<li>第三字段，字段全 0</li>
<li>第四字段，IP 首部中的协议字段的值，对于 UDP，此字段值为 17</li>
<li>第五字段，UDP 用户数据报的长度</li>
</ol>
<h2 id="u6821_u9A8C_u548C_u8BA1_u7B97_u65B9_u6CD5"><a href="#u6821_u9A8C_u548C_u8BA1_u7B97_u65B9_u6CD5" class="headerlink" title="校验和计算方法"></a>校验和计算方法</h2><p>校验和的计算中，频繁用到了二进制的反码求和运算，运算规则见下：    </p>
<p><strong>二进制反码求和运算</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 + 0 = 0&#10;1 + 0 = 0 + 1 = 1&#10;1 + 1 = 10</span><br></pre></td></tr></table></figure>
<p>其中 10 中的 1 加到了下一列去，如果是最高列的 1 + 1 ，那么得到的 10 留下 0 , 1 移到最低列，与最低位再做一次二进制加法即可。</p>
<p><strong>检验和计算过程</strong></p>
<ol>
<li>把首部的检验和字段设置为全 0 </li>
<li>把伪首部以及数据段看成是许多 16 位的字串接起来。</li>
<li>若数据段不是偶数个字节，则填充一个全 0 字节，但是这个字节不发送。</li>
<li>通过二进制反码运算，计算出 16 位字的和。<ol>
<li>让第一行和第二行做二进制反码运算。  </li>
<li>将第一行和第二行的结果与第三行做二进制反码计算，以此类推。</li>
</ol>
</li>
<li>最后运算结果取反，得到校验和。</li>
<li>把计算出来的校验和值，填入首部校验和字段。</li>
</ol>
<p>接收方收到数据报之后，按照同样的方法计算校验和，如果有差错，则丢弃这个数据报。    </p>
<p>可以看出校验和，既检查了 UDP 用户数据报的源端口号和目的端口号以及数据报的数据部分，又检查了 IP 数据报的源 IP 地址和目的地址。    </p>
<p><strong>一个校验和例子</strong><br>假设一个 UDP 数据报：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/5DADDF7480F81837145468E2ADA6839F.png" alt="UDP 校验和.png"></p>
<p>各字段以二进制表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1001 1001 0001 0011 //&#20266;&#39318;&#37096;&#28304;IP&#22320;&#22336;&#21069;16&#20301;&#65292;&#20540;&#65306;153.19&#10;0000 1000 0110 1000 //&#20266;&#39318;&#37096;&#28304;IP&#22320;&#22336;&#21518;16&#20301;&#65292;&#20540;&#65306;8.104&#10;1010 1011 0000 0011 //&#20266;&#39318;&#37096;&#30446;&#30340;IP&#22320;&#22336;&#21069;16&#20301;&#65292;&#20540;&#65306;171.3&#10;0000 1110 0000 1011 //&#20266;&#39318;&#37096;&#30446;&#30340;IP&#22320;&#22336;&#21518;16&#20301;&#65292;&#20540;&#65306;14.11&#10;0000 0000 0001 0001 //&#20266;&#39318;&#37096;UDP&#21327;&#35758;&#23383;&#27573;&#20195;&#34920;&#21495;&#65292;&#20540;&#65306;17&#10;0000 0000 0000 1111 //&#20266;&#39318;&#37096;UDP&#38271;&#24230;&#23383;&#27573;&#65292;&#20540;&#65306;15&#10;0000 0100 0011 1111 //UDP&#22836;&#37096;&#28304;IP&#22320;&#22336;&#23545;&#24212;&#30340;&#36827;&#31243;&#31471;&#21475;&#21495;&#65292;&#20540;&#65306;1087&#10;0000 0000 0000 1101 //UDP&#22836;&#37096;&#30446;&#30340;IP&#22320;&#22336;&#23545;&#24212;&#30340;&#36827;&#31243;&#31471;&#21475;&#21495;&#65292;&#20540;&#65306;13&#10;0000 0000 0000 1111 //UDP&#22836;&#37096;UDP&#38271;&#24230;&#23383;&#27573;&#65292;&#20540;&#65306;15&#10;0000 0000 0000 0000 //UDP&#22836;&#37096;UDP&#26816;&#39564;&#21644;&#65292;&#20540;&#65306;0&#10;0101 0100 0100 0101 //&#25968;&#25454;&#23383;&#27573;&#10;0101 0011 0101 0100 //&#25968;&#25454;&#23383;&#27573;&#10;0100 1001 0100 1110 //&#25968;&#25454;&#23383;&#27573;&#10;0100 0111 0000 0000 //&#25968;&#25454;&#23383;&#27573;+&#22635;&#20805;0&#23383;&#27573;</span><br></pre></td></tr></table></figure>
<p>按照二进制反码运算求和，结果：<code>10010110 11101101</code><br>结果求反码得出校验和：<code>01101001 00010010</code> </p>
<h1 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h1><p><a href="https://jcchan23.github.io/2016/07/12/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8D%E7%A0%81%E6%B1%82%E5%92%8C%E8%BF%90%E7%AE%97/" target="_blank" rel="external">二进制反码求和运算</a><br><a href="https://book.douban.com/subject/26850616/" target="_blank" rel="external">《后台开发 核心技术与应用实践》</a><br><a href="https://book.douban.com/subject/2970300/" target="_blank" rel="external">《计算机网络》</a>    </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更好阅读体验：&lt;a href=&quot;https://jerryc8080.gitbooks.io/understand-tcp-and-udp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《理解 TCP 和 UDP》— By Gi
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="udp" scheme="http://huang-jerryc.com/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>理解TCP（六）：网络编程接口</title>
    <link href="http://huang-jerryc.com/2017/03/02/understand-tcp-6/"/>
    <id>http://huang-jerryc.com/2017/03/02/understand-tcp-6/</id>
    <published>2017-03-02T08:01:25.000Z</published>
    <updated>2020-07-21T08:12:37.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>更好阅读体验：<a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/" target="_blank" rel="external">《理解 TCP 和 UDP》— By Gitbook</a>    </p>
</blockquote>
<h1 id="u4E00_u5207_u7686_Socket"><a href="#u4E00_u5207_u7686_Socket" class="headerlink" title="一切皆 Socket"></a>一切皆 Socket</h1><p>我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢？<br>socket 起源于 UNIX，而 UNIX/Linux 基本哲学之一就是「一切皆文件」，都可以用「open → write/read → close」模式来操作。<br>socket 其实就是该模式的一个实现，socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作。    </p>
<p>使用 TCP/IP 协议的应用程序通常采用系统提供的编程接口：<strong>UNIX BSD 的套接字接口（Socket Interfaces）</strong><br>以此来实现网络进程之间的通信。<br>就目前而言，几乎所有的应用程序都是采用 socket，所以说现在的网络时代，网络中进程通信是无处不在，<strong>一切皆 socket</strong>    </p>
<h1 id="u5957_u63A5_u5B57_u63A5_u53E3_Socket_Interfaces"><a href="#u5957_u63A5_u5B57_u63A5_u53E3_Socket_Interfaces" class="headerlink" title="套接字接口 Socket Interfaces"></a>套接字接口 Socket Interfaces</h1><p>套接字接口是一组函数，由操作系统提供，用以创建网络应用。<br>大多数现代操作系统都实现了套接字接口，包括所有 Unix 变种，Windows 和 Macintosh 系统。    </p>
<blockquote>
<p><strong>套接字接口的起源</strong><br>套接字接口是加州大学伯克利分校的研究人员在 20 世纪 80 年代早起提出的。<br>伯克利的研究者使得套接字接口适用于任何底层的协议，第一个实现就是针对 TCP/IP 协议，他们把它包括在 Unix 4.2 BSD 的内核里，并且分发给许多学校和实验室。<br>这在因特网的历史成为了一个重大事件。<br>—— 《深入理解计算机系统》</p>
</blockquote>
<p>从 Linux 内核的角度来看，一个套接字就是通信的一个端点。<br>从 Linux 程序的角度来看，套接字是一个有相应描述符的文件。<br>普通文件的打开操作返回一个文件描述字，而 socket() 用于创建一个 socket 描述符，唯一标识一个 socket。<br>这个 socket 描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些操作。    </p>
<p>常用的函数有：</p>
<ul>
<li>socket()</li>
<li>bind()</li>
<li>listen()</li>
<li>connect()</li>
<li>accept()</li>
<li>write()</li>
<li>read()</li>
<li>close()</li>
</ul>
<h1 id="Socket__u7684_u4EA4_u4E92_u6D41_u7A0B"><a href="#Socket__u7684_u4EA4_u4E92_u6D41_u7A0B" class="headerlink" title="Socket 的交互流程"></a>Socket 的交互流程</h1><p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/46872611EB6C0874FE9E4C290E8F3FE9.png" alt="socket 交互过程.png"></p>
<p>图中展示了 TCP 协议的 socket 交互流程，描述如下：</p>
<ol>
<li>服务器根据地址类型、socket 类型、以及协议来创建 socket。</li>
<li>服务器为 socket 绑定 IP 地址和端口号。</li>
<li>服务器 socket 监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的 socket 并没有全部打开。</li>
<li>客户端创建 socket。</li>
<li>客户端打开 socket，根据服务器 IP 地址和端口号试图连接服务器 socket。</li>
<li>服务器 socket 接收到客户端 socket 请求，被动打开，开始接收客户端请求，知道客户端返回连接信息。这时候 socket 进入阻塞状态，阻塞是由于 accept() 方法会一直等到客户端返回连接信息后才返回，然后开始连接下一个客户端的连接请求。</li>
<li>客户端连接成功，向服务器发送连接状态信息。</li>
<li>服务器 accept() 方法返回，连接成功。</li>
<li>服务器和客户端通过网络 I/O 函数进行数据的传输。</li>
<li>客户端关闭 socket。</li>
<li>服务器关闭 socket。</li>
</ol>
<p>这个过程中，服务器和客户端建立连接的部分，就体现了 TCP 三次握手的原理。    </p>
<p>下面详细讲一下 socket 的各函数。    </p>
<h2 id="Socket__u63A5_u53E3"><a href="#Socket__u63A5_u53E3" class="headerlink" title="Socket 接口"></a>Socket 接口</h2><p>socket 是系统提供的接口，而操作系统大多数都是用 C/C++ 开发的，自然函数库也是 C/C++ 代码。    </p>
<h2 id="socket__u51FD_u6570"><a href="#socket__u51FD_u6570" class="headerlink" title="socket 函数"></a>socket 函数</h2><p>该函数会返回一个套接字描述符（socket descriptor），但是该描述符仅是部分打开的，还不能用于读写。<br>如何完成打开套接字的工作，取决于我们是客户端还是服务器。    </p>
<h3 id="u51FD_u6570_u539F_u578B"><a href="#u51FD_u6570_u539F_u578B" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="u53C2_u6570_u8BF4_u660E"><a href="#u53C2_u6570_u8BF4_u660E" class="headerlink" title="参数说明"></a>参数说明</h3><p><strong>domain</strong>:<br>协议域，决定了 socket 的地质类型，在通信中必须采用对应的地址。<br>常用的协议族有：<code>AF_INET</code>（ipv4地址与端口号的组合）、<code>AF_INET6</code>（ipv6地址与端口号的组合）、<code>AF_LOCAL</code>（绝对路径名作为地址）。<br>该值的常量定义在 <code>sys/socket.h</code> 文件中。    </p>
<p><strong>type</strong>:<br>指定 socket 类型。<br>常用的类型有：<code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、<code>SOCK_RAW</code>、<code>SOCK_PACKET</code>、<code>SOCK_SEQPACKET</code>等。<br>其中 <code>SOCK_STREAM</code> 表示提供面向连接的稳定数据传输，即 TCP 协议。<br>该值的常量定义在 <code>sys/socket.h</code> 文件中。    </p>
<p><strong>protocol</strong>:<br>指定协议。<br>常用的协议有：<code>IPPROTO_TCP</code>（TCP协议）、<code>IPPTOTO_UDP</code>（UDP协议）、<code>IPPROTO_SCTP</code>（STCP协议）。<br>当值位 0 时，会自动选择 <code>type</code> 类型对应的默认协议。    </p>
<h2 id="bind__u51FD_u6570"><a href="#bind__u51FD_u6570" class="headerlink" title="bind 函数"></a>bind 函数</h2><p>由服务端调用，把一个地址族中的特定地址和 socket 联系起来。</p>
<h3 id="u51FD_u6570_u539F_u578B-1"><a href="#u51FD_u6570_u539F_u578B-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, socklen_t addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="u53C2_u6570_u8BF4_u660E-1"><a href="#u53C2_u6570_u8BF4_u660E-1" class="headerlink" title="参数说明"></a>参数说明</h3><p><strong>sockfd</strong>:<br>即 socket 描述字，由 socket() 函数创建。    </p>
<p><strong>*addr</strong>：<br>一个 <code>const struct sockaddr</code> 指针，指向要绑定给 <code>sockfd</code> 的协议地址。<br>这个地址结构根据地址创建 socket 时的地址协议族不同而不同，例如 ipv4 对应 <code>sockaddr_in</code>，ipv6 对应 <code>sockaddr_in6</code>.<br>这几个结构体在使用的时候，都可以强制转换成 <code>sockaddr</code>。<br>下面是这几个结构体对应的所在的头文件：</p>
<ol>
<li><code>sockaddr</code>： <code>sys/socket.h</code></li>
<li><code>sockaddr_in</code>： <code>netinet/in.h</code></li>
<li><code>sockaddr_in6</code>： <code>netinet6/in.h</code></li>
</ol>
<blockquote>
<p>_in 后缀意义：互联网络(internet)的缩写，而不是输入(input)的缩写。</p>
</blockquote>
<h2 id="listen__u51FD_u6570"><a href="#listen__u51FD_u6570" class="headerlink" title="listen 函数"></a>listen 函数</h2><p>服务器调用，将 socket 从一个主动套接字转化为一个监听套接字（listening socket）, 该套接字可以接收来自客户端的连接请求。<br>在默认情况下，操作系统内核会认为 socket 函数创建的描述符对应于主动套接字（active socket）。    </p>
<h3 id="u51FD_u6570_u539F_u578B-2"><a href="#u51FD_u6570_u539F_u578B-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="u53C2_u6570_u8BF4_u660E-2"><a href="#u53C2_u6570_u8BF4_u660E-2" class="headerlink" title="参数说明"></a>参数说明</h3><p><strong>sockfd</strong>:<br>即 socket 描述字，由 socket() 函数创建。    </p>
<p><strong>backlog</strong>:<br>指定在请求队列中的最大请求数，进入的连接请求将在队列中等待 accept() 它们。    </p>
<h2 id="connect__u51FD_u6570"><a href="#connect__u51FD_u6570" class="headerlink" title="connect 函数"></a>connect 函数</h2><p>由客户端调用，与目的服务器的套接字建立一个连接。    </p>
<h3 id="u51FD_u6570_u539F_u578B-3"><a href="#u51FD_u6570_u539F_u578B-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> clientfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, socklen_t addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="u53C2_u6570_u8BF4_u660E-3"><a href="#u53C2_u6570_u8BF4_u660E-3" class="headerlink" title="参数说明"></a>参数说明</h3><p><strong>clientfd</strong>:<br>目的服务器的 socket 描述符    </p>
<p><strong>*addr</strong>:<br>一个 <code>const struct sockaddr</code> 指针，包含了目的服务器 IP 和端口。    </p>
<p><strong>addrlen</strong>：<br>协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 <code>sizeof(sockaddr_in)</code>;    </p>
<h2 id="accept__u51FD_u6570"><a href="#accept__u51FD_u6570" class="headerlink" title="accept 函数"></a>accept 函数</h2><p>服务器调用，等待来自客户端的连接请求。<br>当客户端连接，accept 函数会在 <code>addr</code> 中会填充上客户端的套接字地址，并且返回一个已连接描述符（connected descriptor），这个描述符可以用来利用 Unix I/O 函数与客户端通信。    </p>
<h3 id="u51FD_u6570_u539F_u578B-4"><a href="#u51FD_u6570_u539F_u578B-4" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#indclude &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">int</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="u53C2_u6570_u8BF4_u660E-4"><a href="#u53C2_u6570_u8BF4_u660E-4" class="headerlink" title="参数说明"></a>参数说明</h3><p><strong>listenfd</strong>:<br>服务器的 socket 描述字，由 socket() 函数创建。    </p>
<p><strong>*addr</strong>:<br>一个 <code>const struct sockaddr</code> 指针，用来存放提出连接请求客户端的主机的信息</p>
<p><strong>*addrlen</strong>:<br>协议地址的长度，如果是 ipv4 的 TCP 连接，一般为 <code>sizeof(sockaddr_in)</code>。    </p>
<h2 id="close__u51FD_u6570"><a href="#close__u51FD_u6570" class="headerlink" title="close 函数"></a>close 函数</h2><p>在数据传输完成之后，手动关闭连接。    </p>
<h3 id="u51FD_u6570_u539F_u578B-5"><a href="#u51FD_u6570_u539F_u578B-5" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="u53C2_u6570_u8BF4_u660E-5"><a href="#u53C2_u6570_u8BF4_u660E-5" class="headerlink" title="参数说明"></a>参数说明</h3><p><strong>fd</strong>:<br>需要关闭的连接 socket 描述符    </p>
<h2 id="u7F51_u7EDC_I/O__u51FD_u6570"><a href="#u7F51_u7EDC_I/O__u51FD_u6570" class="headerlink" title="网络 I/O 函数"></a>网络 I/O 函数</h2><p>当客户端和服务器建立连接后，可以使用网络 I/O 进行读写操作。<br>网络 I/O 操作有下面几组：</p>
<ol>
<li>read()/write()</li>
<li>recv()/send()</li>
<li>readv()/writev()</li>
<li>recvmsg()/sendmsg()</li>
<li>recvfrom()/sendto()</li>
</ol>
<p>最常用的是 read()/write()<br>他们的原型是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<p>鉴于该文是侧重于描述 socket 的工作原理，就不再详细描述这些函数了。</p>
<h1 id="u5B9E_u73B0_u4E00_u4E2A_u7B80_u5355_TCP__u4EA4_u4E92"><a href="#u5B9E_u73B0_u4E00_u4E2A_u7B80_u5355_TCP__u4EA4_u4E92" class="headerlink" title="实现一个简单 TCP 交互"></a>实现一个简单 TCP 交互</h1><h2 id="u670D_u52A1_u7AEF"><a href="#u670D_u52A1_u7AEF" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket_server.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXLINE <span class="number">4096</span> <span class="comment">// 4 * 1024</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, <span class="comment">// 监听端口的 socket 描述符</span></span><br><span class="line">        connfd;   <span class="comment">// 连接端 socket 描述符</span></span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in servaddr;</span><br><span class="line">    <span class="keyword">char</span> buff[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 socket，并且进行错误处理</span></span><br><span class="line">    <span class="keyword">if</span> ((listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 sockaddr_in 数据结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 socket 和 端口</span></span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"bind socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">10</span>) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"listen socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"====== Waiting for client's request======\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持续接收客户端的连接请求</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)<span class="literal">NULL</span>, <span class="literal">NULL</span>) == -<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"accept socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n = recv(connfd, buff, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        buff[n] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"recv msg from client: %s\n"</span>, buff);</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5BA2_u6237_u7AEF"><a href="#u5BA2_u6237_u7AEF" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket_client.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXLINE <span class="number">4096</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd, n;</span><br><span class="line">    <span class="keyword">char</span> recvline[<span class="number">4096</span>], sendline[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in servaddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: ./client &lt;ipaddress&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 socket 描述符</span></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化目标服务器数据结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">    <span class="comment">// 从参数中读取 IP 地址</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"inet_pton error for %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接目标服务器，并和 sockfd 联系起来。</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"connect error: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"send msg to server: \n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从标准输入流中读取信息</span></span><br><span class="line">    fgets(sendline, <span class="number">4096</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 sockfd，向目标服务器发送信息</span></span><br><span class="line">    <span class="keyword">if</span> (send(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"send msg error: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据传输完毕，关闭 socket 连接</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h1><p>首先创建 <code>makefile</code> 文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">all:server client</span><br><span class="line">server:socket_server.o</span><br><span class="line">	g++ -g -o socket_server socket_server.o</span><br><span class="line">client:socket_client.o</span><br><span class="line">	g++ -g -o socket_client socket_client.o</span><br><span class="line">socket_server.o:socket_server.cpp</span><br><span class="line">	g++ -g -c socket_server.cpp</span><br><span class="line">socket_client.o:socket_client.cpp</span><br><span class="line">	g++ -g -c socket_client.cpp</span><br><span class="line">clean:all</span><br><span class="line">	rm all</span><br></pre></td></tr></table></figure>
<p>然后使用命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure>
<p>会生成两个可执行文件：</p>
<ol>
<li><code>socket_server</code></li>
<li><code>socket_client</code></li>
</ol>
<p>分别打开两个终端，运行：</p>
<ol>
<li><code>./socket_server</code></li>
<li><code>./socket_client 127.0.0.1</code></li>
</ol>
<p>然后在 <code>socket_client</code> 中键入发送内容，可以再 <code>socket_server</code> 接收到同样的信息。</p>
<h1 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h1><p><a href="https://book.douban.com/subject/26850616/" target="_blank" rel="external">《后台开发 核心技术与应用实践》</a><br><a href="https://book.douban.com/subject/2970300/" target="_blank" rel="external">《计算机网络》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更好阅读体验：&lt;a href=&quot;https://jerryc8080.gitbooks.io/understand-tcp-and-udp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《理解 TCP 和 UDP》— By Gi
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="tcp" scheme="http://huang-jerryc.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>理解TCP（五）：可靠性交付的实现</title>
    <link href="http://huang-jerryc.com/2017/03/02/understand-tcp-5/"/>
    <id>http://huang-jerryc.com/2017/03/02/understand-tcp-5/</id>
    <published>2017-03-02T08:00:25.000Z</published>
    <updated>2020-07-21T08:12:37.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>更好阅读体验：<a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/" target="_blank" rel="external">《理解 TCP 和 UDP》— By Gitbook</a>    </p>
</blockquote>
<p>TCP 是一种提供可靠性交付的协议。<br>也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。<br>但是在网络中相连两端之间的介质，是复杂的，并不确保数据的可靠性交付，那么 TCP 是怎么样解决问题的？<br>这就需要了解 TCP 的几种技术：    </p>
<ol>
<li>滑动窗口    </li>
<li>超时重传    </li>
<li>流量控制    </li>
<li>拥塞控制    </li>
</ol>
<p>下面来分别讲一下这几种技术的实现原理。    </p>
<h1 id="u8D85_u65F6_u91CD_u4F20"><a href="#u8D85_u65F6_u91CD_u4F20" class="headerlink" title="超时重传"></a>超时重传</h1><h2 id="u91CD_u4F20_u65F6_u673A"><a href="#u91CD_u4F20_u65F6_u673A" class="headerlink" title="重传时机"></a>重传时机</h2><p>TCP 报文段在传输的过程中，下面的情况都是有可能发生的：</p>
<ol>
<li>数据包中途丢失；</li>
<li>数据包顺利到达，但对方发送的 ACK 报文中途丢失；</li>
<li>数据包顺利到达，但对方异常未响应 ACK 或被对方丢弃；</li>
</ol>
<p>当出现这些异常情况时，TCP 就会超时重传。<br>TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到了，但还没有收到确认，就重传这一报文段，这个就叫做「超时重传」。    </p>
<h2 id="u91CD_u4F20_u7B97_u6CD5"><a href="#u91CD_u4F20_u7B97_u6CD5" class="headerlink" title="重传算法"></a>重传算法</h2><h3 id="u5148_u8BA4_u8BC6_u4E24_u4E2A_u6982_u5FF5"><a href="#u5148_u8BA4_u8BC6_u4E24_u4E2A_u6982_u5FF5" class="headerlink" title="先认识两个概念"></a>先认识两个概念</h3><h4 id="RTO__28_Retransmission_Time-Out__29__u91CD_u4F20_u8D85_u65F6_u65F6_u95F4"><a href="#RTO__28_Retransmission_Time-Out__29__u91CD_u4F20_u8D85_u65F6_u65F6_u95F4" class="headerlink" title="RTO ( Retransmission Time-Out ) 重传超时时间"></a>RTO ( Retransmission Time-Out ) 重传超时时间</h4><p>指发送端发送数据后、重传数据前等待接收方收到该数据 ACK 报文的时间。<br>大白话就是，需要等待多长时间还没收到确认，就重新传一次。    </p>
<p>RTO 的设置对于重传非常重要：    </p>
<ol>
<li>设长了，重发就慢，没有效率，性能差；</li>
<li>设短了，重发得就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ol>
<h4 id="RTT__28_Round_Trip_Time__29__u8FDE_u63A5_u5F80_u8FD4_u65F6_u95F4"><a href="#RTT__28_Round_Trip_Time__29__u8FDE_u63A5_u5F80_u8FD4_u65F6_u95F4" class="headerlink" title="RTT ( Round Trip Time ) 连接往返时间"></a>RTT ( Round Trip Time ) 连接往返时间</h4><p>指发送端从发送 TCP 包开始到接收它的 ACK 报文之间所耗费的时间。<br>而在实际的网络传输中，RTT 的值每次都是随机的，无法事先预预知。<br>TCP 通过测量来获得连接当前 RTT 的一个估计值，并以该 RTT 估计值为基准来设置当前的 RTO。<br>这就引入了一类算法的称呼：自适应重传算法（Adaptive Restransmission Algorithm）<br>这类算法的关键就在于对当前 RTT 的准确估计，以便适时调整 RTO。    </p>
<p>关于自适应重传算法，经历过多次的迭代和修正。<br>从 1981 年的 <a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="external">RFC793</a> 提及的经典算法，到 1987 年 Karn 提出的 Karn/Partridge 算法，再到后来的 1988 年的 Jacobson / Karels 算法。<br>最后的这个算法在被用在今天的 TCP 协议中（Linux的源代码在：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609" target="_blank" rel="external"><code>tcp_rtt_estimator</code></a>）。    </p>
<p>自适应重传算法的发展读者有兴趣可以参考其他资料，在这里我拎一个现在在用的算法出来讲讲，随意感受一下。    </p>
<h3 id="Jacobson_/_Karels__u7B97_u6CD5"><a href="#Jacobson_/_Karels__u7B97_u6CD5" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h3><p>1988年，有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看<a href="https://tools.ietf.org/html/rfc2988" target="_blank" rel="external">RFC6298</a>）。<br>其计算公式：</p>
<blockquote>
<p>SRTT = SRTT + α ( RTT – SRTT )  —— 计算平滑 RTT</p>
</blockquote>
<blockquote>
<p>DevRTT = ( 1-β ) <em> DevRTT + β </em> ( | RTT - SRTT | ) ——计算平滑 RTT 和真实的差距（加权移动平均）</p>
</blockquote>
<blockquote>
<p>RTO= µ <em> SRTT + ∂ </em> DevRTT </p>
</blockquote>
<p>其中：</p>
<ul>
<li><p><code>α</code>、<code>β</code>、<code>μ</code>、<code>∂</code> 是可以调整的参数，在 RFC6298 中给出了对应的参考值，而在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4；</p>
</li>
<li><p>SRTT 是 Smoothed RTT 的意思，是 RTT 的平滑计算值，即根据每次测量的 RTT 和旧的 RTT 进行运算，得出新的 RTT。SRTT 的值，会在每一次测量到 RTT 之后进行更新；</p>
</li>
<li><p>DevRTT 是 Deviation RTT 的意思，根据每次测量的 RTT 和旧的 SRTT 值进行运算，得出新的 DevRTT；</p>
</li>
</ul>
<p>由算法可以知道 RTO 的值会根据每次测量的 RTT 值变化而变化，基本要点是 TCP 监视每个连接的性能，由每一个 TCP 的连接情况推算出合适的 RTO 值，根据不同的网络情况，自动修改 RTO 值，以适应负责的网络变化。</p>
<h1 id="u62E5_u585E_u63A7_u5236"><a href="#u62E5_u585E_u63A7_u5236" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h1 id="u6ED1_u52A8_u7A97_u53E3_Sliding_Window"><a href="#u6ED1_u52A8_u7A97_u53E3_Sliding_Window" class="headerlink" title="滑动窗口 Sliding Window"></a>滑动窗口 Sliding Window</h1><p>滑动窗口协议比较复杂，也是 TCP 协议的精髓所在。    </p>
<p>TCP 头里有一个字段叫 Window，叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。    </p>
<p>滑动窗口分为「接收窗口」和「发送窗口」<br>因为 TCP 协议是全双工的，会话的双方都可以同时接收和发送，那么就需要各自维护一个「发送窗口」和「接收窗口」。    </p>
<h2 id="u53D1_u9001_u7A97_u53E3"><a href="#u53D1_u9001_u7A97_u53E3" class="headerlink" title="发送窗口"></a>发送窗口</h2><p>大小取决于对端通告的接受窗口。<br>只有收到对端对于本端发送窗口内字节的 ACK 确认，才会移动发送窗口的左边界。    </p>
<p>下图是发送窗口的示意图：</p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png" alt="tcps-send-wwindows.png"></p>
<p>对于发送窗口，在缓存内的数据有四种状态：</p>
<ul>
<li>#1 已发送，并得到接收方 ACK 确认；</li>
<li>#2 已发送，但还未收到接收方 ACK；</li>
<li>#3 未发送，但接收方允许发送，接收方还有空间</li>
<li>#4 未发送，且接收方不允许发送，接收方没有空间</li>
</ul>
<p>如果下一刻，收到了接收方对于 32-36 字节序的数据包的 ACK 确认，那么发送方的窗口就会发生「滑动」。<br>并且发送下一个 46-51 字节序的数据包。    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png" alt="tcps-send-wslide.png"></p>
<p>滑动窗口的概念，描述了 TCP 的数据是怎么发送，以及怎么接收的。<br>TCP 的滑动窗口是动态的，我们可以想象成小学常见的一个数学题，一个水池，体积 V，每小时进水量 V1, 出水量 V2。<br>当水池满了就不允许再注入了，如果有个液压系统控制水池大小，那么就可以控制水的注入速率和量了。<br>应用程序可以根据自身的处理能力变化，通过 API 来控制本端 TCP 接收窗口的大小，来进行流量控制。    </p>
<h2 id="u63A5_u6536_u7A97_u53E3"><a href="#u63A5_u6536_u7A97_u53E3" class="headerlink" title="接收窗口"></a>接收窗口</h2><p>大小取决于应用、系统、硬件的限制。    </p>
<p>下图是接收窗口的示意图（找不到图，唯有自己画了）：    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png" alt="tcps-receive-wwindows.png"></p>
<p>相对于发送窗口，接受窗口在缓存内的数据只有三种状态：</p>
<ul>
<li>已接收已确认；</li>
<li>未接收，准备接收；</li>
<li>未接收，并未准备接收；</li>
</ul>
<p>下一刻接收到来自发送端的 32-36 数据包，然后回送 ACK 确认报，并且移动接收窗口。    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png" alt="tcps-receive-wslide.png"></p>
<p>另外接收端相对于发送端还有不同的一点，只有前面所有的段都确认的情况下才会移动左边界，<br>在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认，以此确保对端会对这些数据重传。<br>假如 32-36 字节不是一个报文段的，而是每个字节一个报文段的话，那么就会分成了 5 个报文段。<br>在实际的网络环境中，不能确保是按序收到的，其中会有一些早达到，一些迟到达。    </p>
<p><img src="https://bluesun-1252625244.cos.ap-guangzhou.myqcloud.com/post/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png" alt="tcps-receive-disorder.png"></p>
<p>如图中的 34、35 字节序，先收到了，接收窗口也不会移动。<br>因为有可能 32、33 字节序会出现丢包或者超时，这时就需要发送端重发报文段了。    </p>
<h1 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo.htm" target="_blank" rel="external">The TCP/IP Guide</a><br><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP 的那些事儿（下）</a><br><a href="https://book.douban.com/subject/26850616/" target="_blank" rel="external">《后台开发 核心技术与应用实践》</a><br><a href="https://book.douban.com/subject/2970300/" target="_blank" rel="external">《计算机网络》</a>    </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更好阅读体验：&lt;a href=&quot;https://jerryc8080.gitbooks.io/understand-tcp-and-udp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《理解 TCP 和 UDP》— By Gi
    
    </summary>
    
      <category term="搬砖码农" scheme="http://huang-jerryc.com/categories/%E6%90%AC%E7%A0%96%E7%A0%81%E5%86%9C/"/>
    
    
      <category term="tcp" scheme="http://huang-jerryc.com/tags/tcp/"/>
    
  </entry>
  
</feed>
